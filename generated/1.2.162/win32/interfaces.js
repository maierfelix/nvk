/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY nvk v0.8.0
 */
"use strict";

const {platform} = process;
const nvk = require("./build/Release/addon-" + platform + ".node");

let ENABLE_SHARED_MEMORY_HINTS = !!process.env.npm_config_enable_shared_memory_hints;
if (!ENABLE_SHARED_MEMORY_HINTS) {
  process.argv.map(arg => {
    if (arg.match("enable-shared-memory-hints")) ENABLE_SHARED_MEMORY_HINTS = true;
  });
}

if (typeof BigInt === "undefined") {
  throw new ReferenceError(`BigInt Type is not available on your platform!`);
}

const BI0 = BigInt(0);
const BI4 = BigInt(4);
const BI8 = BigInt(8);
const NULLT = String.fromCharCode(0x0);
const VK_ENUMERATIONS = nvk.$getVulkanEnumerations();

const getAddressFromArrayBuffer = nvk.getAddressFromArrayBuffer;
const getArrayBufferFromAddress = nvk.getArrayBufferFromAddress;

global.ArrayBuffer.prototype.getAddress = function() {
  return getAddressFromArrayBuffer(this);
};

global.ArrayBuffer.fromAddress = function(address, byteLength) {
  return getArrayBufferFromAddress(address, BigInt(byteLength));
};

global.BigInt.prototype.dereference = function() {
  return new BigUint64Array(ArrayBuffer.fromAddress(this, BI8))[0];
};

const textEncoder = new (typeof TextEncoder === "undefined" ? require("util").TextEncoder : TextEncoder);
const textDecoder = new (typeof TextDecoder === "undefined" ? require("util").TextDecoder : TextDecoder);

function getStructFromStack(byteOffset, ctor, cache) {
  if (cache[byteOffset] === void 0) {
    let stackAllocated = new ctor();
    cache[byteOffset] = stackAllocated;
    return stackAllocated;
  }
  let stackAllocated = cache[byteOffset];
  return stackAllocated;
};

function decodeNullTerminatedUTF8String(view) {
  let terminator = view.indexOf(0x0);
  let subview = view.subarray(0, terminator > -1 ? terminator : view.length);
  return textDecoder.decode(subview);
};

function findNullTerminatedUTF8StringLength(addr) {
  let limit = 2 << 12; 
  // read 4 bytes on each iteration
  for (let ii = 0; ii < limit; ii += 4) {
    let chunk = getArrayBufferFromAddress(addr + BigInt(ii), BI4);
    let chunkU8 = new Uint8Array(chunk);
    if (chunkU8[0x0] === 0) return ii + 0x1 + 0x0;
    if (chunkU8[0x1] === 0) return ii + 0x1 + 0x1;
    if (chunkU8[0x2] === 0) return ii + 0x1 + 0x2;
    if (chunkU8[0x3] === 0) return ii + 0x1 + 0x3;
  };
  throw new ReferenceError(`Failed to find UTF8 String length - Memory is either corrupted, misses a NULL terminator or exceeds the Limit of '${limit}' bytes`);
  return -1;
};

function decodeNativeArrayOfObjects(addr, length, ctor) {
  let out = [];
  let byteLength = BigInt(ctor.byteLength);
  for (let ii = 0; ii < length; ++ii) {
    let buffer = getArrayBufferFromAddress(
      addr + BigInt(ii) * byteLength,
      byteLength
    );
    let item = new ctor({
      $memoryBuffer: buffer,
      $memoryOffset: 0
    });
    out.push(item);
  };
  return out;
};

function typeToString(value) {
  return ((value === void 0 || value === null) ? String(value) : value.constructor.name);
};

function ASSERT_IS_STRING(value, name) {
  if (typeof value !== "string") {
    throw new TypeError(`Invalid type for '${name}': Expected 'String' but got '" + typeToString(value) + "'`);
  }
}

function ASSERT_IS_NUMBER(value, name) {
  if (typeof value !== "number") {
    throw new TypeError(`Invalid type for '${name}': Expected 'Number' but got '" + typeToString(value) + "'`);
  }
};

function ASSERT_IS_NUMBER_OR_BIGINT(value, name) {
  if (typeof value !== "bigint" && typeof value !== "number") {
    throw new TypeError(`Invalid type for '${name}': Expected 'BigInt' or 'Number' but got '" + typeToString(value) + "'`);
  }
};

class NativeStringArray {
  constructor(array) {
    this.array = array;
    this.address = BI0;
    let stringBuffers = [];
    let addressView = new BigInt64Array(array.length);
    let addressBuffer = addressView.buffer;
    let addressBufferAddress = getAddressFromArrayBuffer(addressBuffer);
    for (let ii = 0; ii < array.length; ++ii) {
      let strBuffer = textEncoder.encode(array[ii] + NULLT).buffer;
      addressView[ii] = getAddressFromArrayBuffer(strBuffer);
      stringBuffers.push(strBuffer);
    };
    this.address = addressBufferAddress;
    // keep references to prevent deallocation
    this.addressBuffer = addressBuffer;
    this.stringBuffers = stringBuffers;
  }
};

class NativeObjectArray {
  constructor(array) {
    this.array = array;
    this.address = BI0;
    let byteStride = array[0].memoryBuffer.byteLength;
    let objectBuffer = new ArrayBuffer(array.length * byteStride);
    let objectBufferView = new Uint8Array(objectBuffer);
    let objectBufferAddress = getAddressFromArrayBuffer(objectBuffer);
    for (let ii = 0; ii < array.length; ++ii) {
      let byteOffset = ii * byteStride;
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      let dstView = objectBufferView.subarray(byteOffset, byteOffset + byteStride);
      dstView.set(srcView, 0x0);
    };
    this.address = objectBufferAddress;
    // keep reference to prevent deallocation
    this.objectBuffer = objectBuffer;
  }
};

class NativeObjectReferenceArray {
  constructor(array) {
    this.array = array;
    this.address = BI0;
    let addressView = new BigInt64Array(array.length);
    let addressBuffer = addressView.buffer;
    let addressBufferAddress = getAddressFromArrayBuffer(addressBuffer);
    for (let ii = 0; ii < array.length; ++ii) {
      let object = array[ii];
      let objectAddress = object.address;
      addressView[ii] = objectAddress;
    };
    this.address = addressBufferAddress;
    // keep reference to prevent deallocation
    this.addressBuffer = addressBuffer;
  }
};

const STRUCT_RESET_CACHE = {
  "0x0": new Uint8Array(0x0),
};
/** VkInstance **/
function VkInstance(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkInstance' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkInstance.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkInstance"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkInstance.byteLength = 0x8;
/** VkPhysicalDevice **/
function VkPhysicalDevice(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkPhysicalDevice' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkPhysicalDevice.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPhysicalDevice"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPhysicalDevice.byteLength = 0x8;
/** VkDevice **/
function VkDevice(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDevice' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDevice.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDevice"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDevice.byteLength = 0x8;
/** VkQueue **/
function VkQueue(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkQueue' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkQueue.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkQueue"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkQueue.byteLength = 0x8;
/** VkCommandBuffer **/
function VkCommandBuffer(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkCommandBuffer' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkCommandBuffer.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkCommandBuffer"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkCommandBuffer.byteLength = 0x8;
/** VkDeviceMemory **/
function VkDeviceMemory(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDeviceMemory' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDeviceMemory.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDeviceMemory"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDeviceMemory.byteLength = 0x8;
/** VkCommandPool **/
function VkCommandPool(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkCommandPool' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkCommandPool.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkCommandPool"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkCommandPool.byteLength = 0x8;
/** VkBuffer **/
function VkBuffer(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkBuffer' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkBuffer.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkBuffer"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkBuffer.byteLength = 0x8;
/** VkBufferView **/
function VkBufferView(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkBufferView' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkBufferView.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkBufferView"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkBufferView.byteLength = 0x8;
/** VkImage **/
function VkImage(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkImage' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkImage.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkImage"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkImage.byteLength = 0x8;
/** VkImageView **/
function VkImageView(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkImageView' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkImageView.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkImageView"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkImageView.byteLength = 0x8;
/** VkShaderModule **/
function VkShaderModule(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkShaderModule' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkShaderModule.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkShaderModule"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkShaderModule.byteLength = 0x8;
/** VkPipeline **/
function VkPipeline(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkPipeline' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkPipeline.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPipeline"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPipeline.byteLength = 0x8;
/** VkPipelineLayout **/
function VkPipelineLayout(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkPipelineLayout' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkPipelineLayout.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPipelineLayout"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPipelineLayout.byteLength = 0x8;
/** VkSampler **/
function VkSampler(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkSampler' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkSampler.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSampler"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSampler.byteLength = 0x8;
/** VkDescriptorSet **/
function VkDescriptorSet(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDescriptorSet' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDescriptorSet.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorSet"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorSet.byteLength = 0x8;
/** VkDescriptorSetLayout **/
function VkDescriptorSetLayout(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDescriptorSetLayout' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDescriptorSetLayout.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorSetLayout"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorSetLayout.byteLength = 0x8;
/** VkDescriptorPool **/
function VkDescriptorPool(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDescriptorPool' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDescriptorPool.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorPool"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorPool.byteLength = 0x8;
/** VkFence **/
function VkFence(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkFence' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkFence.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkFence"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkFence.byteLength = 0x8;
/** VkSemaphore **/
function VkSemaphore(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkSemaphore' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkSemaphore.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSemaphore"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSemaphore.byteLength = 0x8;
/** VkEvent **/
function VkEvent(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkEvent' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkEvent.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkEvent"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkEvent.byteLength = 0x8;
/** VkQueryPool **/
function VkQueryPool(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkQueryPool' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkQueryPool.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkQueryPool"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkQueryPool.byteLength = 0x8;
/** VkFramebuffer **/
function VkFramebuffer(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkFramebuffer' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkFramebuffer.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkFramebuffer"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkFramebuffer.byteLength = 0x8;
/** VkRenderPass **/
function VkRenderPass(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkRenderPass' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkRenderPass.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkRenderPass"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkRenderPass.byteLength = 0x8;
/** VkPipelineCache **/
function VkPipelineCache(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkPipelineCache' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkPipelineCache.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPipelineCache"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPipelineCache.byteLength = 0x8;
/** VkIndirectCommandsLayoutNV **/
function VkIndirectCommandsLayoutNV(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkIndirectCommandsLayoutNV' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkIndirectCommandsLayoutNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkIndirectCommandsLayoutNV"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkIndirectCommandsLayoutNV.byteLength = 0x8;
/** VkDescriptorUpdateTemplate **/
function VkDescriptorUpdateTemplate(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDescriptorUpdateTemplate' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDescriptorUpdateTemplate.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorUpdateTemplate"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorUpdateTemplate.byteLength = 0x8;
/** VkSamplerYcbcrConversion **/
function VkSamplerYcbcrConversion(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkSamplerYcbcrConversion' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkSamplerYcbcrConversion.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSamplerYcbcrConversion"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSamplerYcbcrConversion.byteLength = 0x8;
/** VkValidationCacheEXT **/
function VkValidationCacheEXT(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkValidationCacheEXT' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkValidationCacheEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkValidationCacheEXT"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkValidationCacheEXT.byteLength = 0x8;
/** VkAccelerationStructureKHR **/
function VkAccelerationStructureKHR(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkAccelerationStructureKHR' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkAccelerationStructureKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkAccelerationStructureKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkAccelerationStructureKHR.byteLength = 0x8;
/** VkAccelerationStructureNV **/
function VkAccelerationStructureNV(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkAccelerationStructureNV' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkAccelerationStructureNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkAccelerationStructureNV"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkAccelerationStructureNV.byteLength = 0x8;
/** VkPerformanceConfigurationINTEL **/
function VkPerformanceConfigurationINTEL(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkPerformanceConfigurationINTEL' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkPerformanceConfigurationINTEL.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPerformanceConfigurationINTEL"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPerformanceConfigurationINTEL.byteLength = 0x8;
/** VkDeferredOperationKHR **/
function VkDeferredOperationKHR(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDeferredOperationKHR' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDeferredOperationKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDeferredOperationKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDeferredOperationKHR.byteLength = 0x8;
/** VkPrivateDataSlotEXT **/
function VkPrivateDataSlotEXT(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkPrivateDataSlotEXT' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkPrivateDataSlotEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPrivateDataSlotEXT"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPrivateDataSlotEXT.byteLength = 0x8;
/** VkDisplayKHR **/
function VkDisplayKHR(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDisplayKHR' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDisplayKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDisplayKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDisplayKHR.byteLength = 0x8;
/** VkDisplayModeKHR **/
function VkDisplayModeKHR(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDisplayModeKHR' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDisplayModeKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDisplayModeKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDisplayModeKHR.byteLength = 0x8;
/** VkSurfaceKHR **/
function VkSurfaceKHR(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkSurfaceKHR' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkSurfaceKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSurfaceKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSurfaceKHR.byteLength = 0x8;
/** VkSwapchainKHR **/
function VkSwapchainKHR(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkSwapchainKHR' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkSwapchainKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSwapchainKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSwapchainKHR.byteLength = 0x8;
/** VkDebugReportCallbackEXT **/
function VkDebugReportCallbackEXT(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDebugReportCallbackEXT' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDebugReportCallbackEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDebugReportCallbackEXT"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDebugReportCallbackEXT.byteLength = 0x8;
/** VkDebugUtilsMessengerEXT **/
function VkDebugUtilsMessengerEXT(opts) {
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.memoryOffset = 0x0;

  if (opts !== void 0) {
    if (opts.$memoryBuffer === void 0) {
      throw new Error("'VkDebugUtilsMessengerEXT' doesn't take any arguments");
    }
    else {
      if (opts.$memoryOffset !== void 0) {
        let addr = getAddressFromArrayBuffer(opts.$memoryBuffer);
        this.memoryBuffer = getArrayBufferFromAddress(addr + BigInt(opts.$memoryOffset), BI8);
        this.memoryOffset = opts.$memoryOffset;
      } else {
        this.memoryBuffer = opts.$memoryBuffer;
      }
    }
  }
  else {
    this.memoryBuffer = new ArrayBuffer(0x8);
  }
  this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
  this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x8);
};

VkDebugUtilsMessengerEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDebugUtilsMessengerEXT"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDebugUtilsMessengerEXT.byteLength = 0x8;
/** VkClearColorValue **/
function VkClearColorValue(opts, byteOffset) {
  if (new.target !== VkClearColorValue) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkClearColorValue, STRUCT_CACHE_VkClearColorValue);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkClearColorValue, STRUCT_CACHE_VkClearColorValue);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkClearColorValue'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._float32 = null;
  this._int32 = null;
  this._uint32 = null;
  
  if (typeof opts === "object") {
    if (opts.float32 !== void 0) this.float32 = opts.float32;
    if (opts.int32 !== void 0) this.int32 = opts.int32;
    if (opts.uint32 !== void 0) this.uint32 = opts.uint32;
    
  }
};

Object.defineProperties(VkClearColorValue.prototype, {
  "float32": {
    get() {
    return this._float32;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._float32 = value;
    } else if (value === null) {
      this._float32 = null;
    } else {
      throw new TypeError("Invalid type for 'VkClearColorValue.float32': Expected 'Array float' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "int32": {
    get() {
    return this._int32;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._int32 = value;
    } else if (value === null) {
      this._int32 = null;
    } else {
      throw new TypeError("Invalid type for 'VkClearColorValue.int32': Expected 'Array int32_t' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "uint32": {
    get() {
    return this._uint32;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._uint32 = value;
    } else if (value === null) {
      this._uint32 = null;
    } else {
      throw new TypeError("Invalid type for 'VkClearColorValue.uint32': Expected 'Array uint32_t' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkClearColorValue.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._float32 = null;
  this._int32 = null;
  this._uint32 = null;
  
  if (typeof opts === "object") {
    if (opts.float32 !== void 0) this.float32 = opts.float32;
    if (opts.int32 !== void 0) this.int32 = opts.int32;
    if (opts.uint32 !== void 0) this.uint32 = opts.uint32;
    
  }
};

VkClearColorValue.prototype.flush = function flush() {
  
  
  if (this._float32 !== null) {
    let array = this._float32;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkClearColorValue.float32'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkClearColorValue.float32[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryView.setFloat32(0x0 + (ii * 4), array[ii], true);
    };
  } else {
    
  }
  
  
  if (this._int32 !== null) {
    let array = this._int32;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkClearColorValue.int32'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkClearColorValue.int32[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryView.setInt32(0x0 + (ii * 4), array[ii], true);
    };
  } else {
    
  }
  
  
  if (this._uint32 !== null) {
    let array = this._uint32;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkClearColorValue.uint32'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkClearColorValue.uint32[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryView.setUint32(0x0 + (ii * 4), array[ii], true);
    };
  } else {
    
  }
  
  return true;
};

VkClearColorValue.prototype.reflect = function reflect(memoryAddress) {
  };

VkClearColorValue.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkClearColorValue();
  if (original.float32 !== null) {
        copy.float32 = [...Array(original.float32.length)].map((v, i) => {
          return original.float32[i];
        });
      }
  if (original.int32 !== null) {
        copy.int32 = [...Array(original.int32.length)].map((v, i) => {
          return original.int32[i];
        });
      }
  if (original.uint32 !== null) {
        copy.uint32 = [...Array(original.uint32.length)].map((v, i) => {
          return original.uint32[i];
        });
      }
  
  return copy;
};

VkClearColorValue.byteLength = 0x0;

VkClearColorValue.memoryLayout = {
  float32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  int32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uint32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkClearValue **/
function VkClearValue(opts, byteOffset) {
  if (new.target !== VkClearValue) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkClearValue, STRUCT_CACHE_VkClearValue);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkClearValue, STRUCT_CACHE_VkClearValue);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkClearValue'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._color = new VkClearColorValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._depthStencil = new VkClearDepthStencilValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.color !== void 0) this.color = opts.color;
    if (opts.depthStencil !== void 0) this.depthStencil = opts.depthStencil;
    
  }
};

Object.defineProperties(VkClearValue.prototype, {
  "color": {
    get() {
    return this._color;
    },
    set(value) {
    if (value !== null && value.constructor === VkClearColorValue) {
      value.flush();
      this._color = value;
      
      
    } else if (value === null) {
      this._color = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearValue.color': Expected 'VkClearColorValue' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "depthStencil": {
    get() {
    return this._depthStencil;
    },
    set(value) {
    if (value !== null && value.constructor === VkClearDepthStencilValue) {
      value.flush();
      this._depthStencil = value;
      
      
    } else if (value === null) {
      this._depthStencil = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearValue.depthStencil': Expected 'VkClearDepthStencilValue' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkClearValue.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._color !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._color.memoryBuffer) this._color = new VkClearColorValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._color.reset();
  }
  if (this._depthStencil !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._depthStencil.memoryBuffer) this._depthStencil = new VkClearDepthStencilValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._depthStencil.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.color !== void 0) this.color = opts.color;
    if (opts.depthStencil !== void 0) this.depthStencil = opts.depthStencil;
    
  }
};

VkClearValue.prototype.flush = function flush() {
  
  
  if (this._color !== null) {
    let color = this._color;
    color.flush();
    if (this.memoryBuffer !== color.memoryBuffer) {
      let srcView = new Uint8Array(color.memoryBuffer, color.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkClearValue.color' isn't used as shared-memory");
    }
  }
  
  
  if (this._depthStencil !== null) {
    let depthStencil = this._depthStencil;
    depthStencil.flush();
    if (this.memoryBuffer !== depthStencil.memoryBuffer) {
      let srcView = new Uint8Array(depthStencil.memoryBuffer, depthStencil.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkClearValue.depthStencil' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkClearValue.prototype.reflect = function reflect(memoryAddress) {
  };

VkClearValue.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkClearValue();
  if (original.color !== null) {
        copy.color = original.color.constructor.createCopyFrom(original.color);
      }
  if (original.depthStencil !== null) {
        copy.depthStencil = original.depthStencil.constructor.createCopyFrom(original.depthStencil);
      }
  
  return copy;
};

VkClearValue.byteLength = 0x0;

VkClearValue.memoryLayout = {
  color: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthStencil: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPerformanceCounterResultKHR **/
function VkPerformanceCounterResultKHR(opts, byteOffset) {
  if (new.target !== VkPerformanceCounterResultKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPerformanceCounterResultKHR, STRUCT_CACHE_VkPerformanceCounterResultKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPerformanceCounterResultKHR, STRUCT_CACHE_VkPerformanceCounterResultKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPerformanceCounterResultKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.int32 !== void 0) this.int32 = opts.int32;
    if (opts.int64 !== void 0) this.int64 = opts.int64;
    if (opts.uint32 !== void 0) this.uint32 = opts.uint32;
    if (opts.uint64 !== void 0) this.uint64 = opts.uint64;
    if (opts.float32 !== void 0) this.float32 = opts.float32;
    if (opts.float64 !== void 0) this.float64 = opts.float64;
    
  }
};

Object.defineProperties(VkPerformanceCounterResultKHR.prototype, {
  "int32": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceCounterResultKHR.int32");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "int64": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkPerformanceCounterResultKHR.int64")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "uint32": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceCounterResultKHR.uint32");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "uint64": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkPerformanceCounterResultKHR.uint64")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "float32": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceCounterResultKHR.float32");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "float64": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkPerformanceCounterResultKHR.float64")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkPerformanceCounterResultKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.int32 !== void 0) this.int32 = opts.int32;
    if (opts.int64 !== void 0) this.int64 = opts.int64;
    if (opts.uint32 !== void 0) this.uint32 = opts.uint32;
    if (opts.uint64 !== void 0) this.uint64 = opts.uint64;
    if (opts.float32 !== void 0) this.float32 = opts.float32;
    if (opts.float64 !== void 0) this.float64 = opts.float64;
    
  }
};

VkPerformanceCounterResultKHR.prototype.flush = function flush() {
  
  return true;
};

VkPerformanceCounterResultKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPerformanceCounterResultKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPerformanceCounterResultKHR();
  copy.int32 = original.int32;
  copy.int64 = original.int64;
  copy.uint32 = original.uint32;
  copy.uint64 = original.uint64;
  copy.float32 = original.float32;
  copy.float64 = original.float64;
  
  return copy;
};

VkPerformanceCounterResultKHR.byteLength = 0x0;

VkPerformanceCounterResultKHR.memoryLayout = {
  int32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  int64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uint32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uint64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  float32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  float64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPerformanceValueDataINTEL **/
function VkPerformanceValueDataINTEL(opts, byteOffset) {
  if (new.target !== VkPerformanceValueDataINTEL) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPerformanceValueDataINTEL, STRUCT_CACHE_VkPerformanceValueDataINTEL);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPerformanceValueDataINTEL, STRUCT_CACHE_VkPerformanceValueDataINTEL);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPerformanceValueDataINTEL'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  this._valueString = null;
  
  if (typeof opts === "object") {
    if (opts.value32 !== void 0) this.value32 = opts.value32;
    if (opts.value64 !== void 0) this.value64 = opts.value64;
    if (opts.valueFloat !== void 0) this.valueFloat = opts.valueFloat;
    if (opts.valueBool !== void 0) this.valueBool = opts.valueBool;
    if (opts.valueString !== void 0) this.valueString = opts.valueString;
    
  }
};

Object.defineProperties(VkPerformanceValueDataINTEL.prototype, {
  "value32": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceValueDataINTEL.value32");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "value64": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkPerformanceValueDataINTEL.value64")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "valueFloat": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceValueDataINTEL.valueFloat");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "valueBool": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "valueString": {
    get() {
    if (this._valueString !== null) {
      let str = textDecoder.decode(this._valueString);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._valueString = buffer;
        return this.valueString;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._valueString = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._valueString), true);
    } else if (value === null) {
      this._valueString = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkPerformanceValueDataINTEL.valueString");
    }
    
    }
    },
  
});

VkPerformanceValueDataINTEL.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  this._valueString = null;
  
  if (typeof opts === "object") {
    if (opts.value32 !== void 0) this.value32 = opts.value32;
    if (opts.value64 !== void 0) this.value64 = opts.value64;
    if (opts.valueFloat !== void 0) this.valueFloat = opts.valueFloat;
    if (opts.valueBool !== void 0) this.valueBool = opts.valueBool;
    if (opts.valueString !== void 0) this.valueString = opts.valueString;
    
  }
};

VkPerformanceValueDataINTEL.prototype.flush = function flush() {
  
  return true;
};

VkPerformanceValueDataINTEL.prototype.reflect = function reflect(memoryAddress) {
  };

VkPerformanceValueDataINTEL.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPerformanceValueDataINTEL();
  copy.value32 = original.value32;
  copy.value64 = original.value64;
  copy.valueFloat = original.valueFloat;
  copy.valueBool = original.valueBool;
  copy.valueString = original.valueString;
  
  return copy;
};

VkPerformanceValueDataINTEL.byteLength = 0x0;

VkPerformanceValueDataINTEL.memoryLayout = {
  value32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  value64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  valueFloat: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  valueBool: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  valueString: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineExecutableStatisticValueKHR **/
function VkPipelineExecutableStatisticValueKHR(opts, byteOffset) {
  if (new.target !== VkPipelineExecutableStatisticValueKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineExecutableStatisticValueKHR, STRUCT_CACHE_VkPipelineExecutableStatisticValueKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineExecutableStatisticValueKHR, STRUCT_CACHE_VkPipelineExecutableStatisticValueKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineExecutableStatisticValueKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPipelineExecutableStatisticValueKHR.prototype, {
  "b32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "i64": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    },
  "u64": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "f64": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPipelineExecutableStatisticValueKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkPipelineExecutableStatisticValueKHR.prototype.flush = function flush() {
  
  return true;
};

VkPipelineExecutableStatisticValueKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPipelineExecutableStatisticValueKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineExecutableStatisticValueKHR();
  copy.b32 = original.b32;
  copy.i64 = original.i64;
  copy.u64 = original.u64;
  copy.f64 = original.f64;
  
  return copy;
};

VkPipelineExecutableStatisticValueKHR.byteLength = 0x0;

VkPipelineExecutableStatisticValueKHR.memoryLayout = {
  b32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  i64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  u64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  f64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceOrHostAddressKHR **/
function VkDeviceOrHostAddressKHR(opts, byteOffset) {
  if (new.target !== VkDeviceOrHostAddressKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceOrHostAddressKHR, STRUCT_CACHE_VkDeviceOrHostAddressKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceOrHostAddressKHR, STRUCT_CACHE_VkDeviceOrHostAddressKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceOrHostAddressKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._hostAddress = null;
  
  if (typeof opts === "object") {
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    if (opts.hostAddress !== void 0) this.hostAddress = opts.hostAddress;
    
  }
};

Object.defineProperties(VkDeviceOrHostAddressKHR.prototype, {
  "deviceAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDeviceOrHostAddressKHR.deviceAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "hostAddress": {
    get() {
    return this._hostAddress;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._hostAddress = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._hostAddress = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceOrHostAddressKHR.hostAddress': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceOrHostAddressKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._hostAddress = null;
  
  if (typeof opts === "object") {
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    if (opts.hostAddress !== void 0) this.hostAddress = opts.hostAddress;
    
  }
};

VkDeviceOrHostAddressKHR.prototype.flush = function flush() {
  
  return true;
};

VkDeviceOrHostAddressKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceOrHostAddressKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceOrHostAddressKHR();
  copy.deviceAddress = original.deviceAddress;
  if (original.hostAddress !== null) {
      let buf = new ArrayBuffer(original.hostAddress.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.hostAddress), 0x0);
      copy.hostAddress = buf;
    }
  
  return copy;
};

VkDeviceOrHostAddressKHR.byteLength = 0x0;

VkDeviceOrHostAddressKHR.memoryLayout = {
  deviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  hostAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceOrHostAddressConstKHR **/
function VkDeviceOrHostAddressConstKHR(opts, byteOffset) {
  if (new.target !== VkDeviceOrHostAddressConstKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceOrHostAddressConstKHR, STRUCT_CACHE_VkDeviceOrHostAddressConstKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceOrHostAddressConstKHR, STRUCT_CACHE_VkDeviceOrHostAddressConstKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceOrHostAddressConstKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._hostAddress = null;
  
  if (typeof opts === "object") {
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    if (opts.hostAddress !== void 0) this.hostAddress = opts.hostAddress;
    
  }
};

Object.defineProperties(VkDeviceOrHostAddressConstKHR.prototype, {
  "deviceAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDeviceOrHostAddressConstKHR.deviceAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "hostAddress": {
    get() {
    return this._hostAddress;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._hostAddress = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._hostAddress = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceOrHostAddressConstKHR.hostAddress': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceOrHostAddressConstKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._hostAddress = null;
  
  if (typeof opts === "object") {
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    if (opts.hostAddress !== void 0) this.hostAddress = opts.hostAddress;
    
  }
};

VkDeviceOrHostAddressConstKHR.prototype.flush = function flush() {
  
  return true;
};

VkDeviceOrHostAddressConstKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceOrHostAddressConstKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceOrHostAddressConstKHR();
  copy.deviceAddress = original.deviceAddress;
  if (original.hostAddress !== null) {
      let buf = new ArrayBuffer(original.hostAddress.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.hostAddress), 0x0);
      copy.hostAddress = buf;
    }
  
  return copy;
};

VkDeviceOrHostAddressConstKHR.byteLength = 0x0;

VkDeviceOrHostAddressConstKHR.memoryLayout = {
  deviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  hostAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureGeometryDataKHR **/
function VkAccelerationStructureGeometryDataKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureGeometryDataKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureGeometryDataKHR, STRUCT_CACHE_VkAccelerationStructureGeometryDataKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureGeometryDataKHR, STRUCT_CACHE_VkAccelerationStructureGeometryDataKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureGeometryDataKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._triangles = new VkAccelerationStructureGeometryTrianglesDataKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._aabbs = new VkAccelerationStructureGeometryAabbsDataKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._instances = new VkAccelerationStructureGeometryInstancesDataKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.triangles !== void 0) this.triangles = opts.triangles;
    if (opts.aabbs !== void 0) this.aabbs = opts.aabbs;
    if (opts.instances !== void 0) this.instances = opts.instances;
    
  }
};

Object.defineProperties(VkAccelerationStructureGeometryDataKHR.prototype, {
  "triangles": {
    get() {
    return this._triangles;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureGeometryTrianglesDataKHR) {
      value.flush();
      this._triangles = value;
      
      
    } else if (value === null) {
      this._triangles = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureGeometryDataKHR.triangles': Expected 'VkAccelerationStructureGeometryTrianglesDataKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "aabbs": {
    get() {
    return this._aabbs;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureGeometryAabbsDataKHR) {
      value.flush();
      this._aabbs = value;
      
      
    } else if (value === null) {
      this._aabbs = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureGeometryDataKHR.aabbs': Expected 'VkAccelerationStructureGeometryAabbsDataKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "instances": {
    get() {
    return this._instances;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureGeometryInstancesDataKHR) {
      value.flush();
      this._instances = value;
      
      
    } else if (value === null) {
      this._instances = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureGeometryDataKHR.instances': Expected 'VkAccelerationStructureGeometryInstancesDataKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAccelerationStructureGeometryDataKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._triangles !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._triangles.memoryBuffer) this._triangles = new VkAccelerationStructureGeometryTrianglesDataKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._triangles.reset();
  }
  if (this._aabbs !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._aabbs.memoryBuffer) this._aabbs = new VkAccelerationStructureGeometryAabbsDataKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._aabbs.reset();
  }
  if (this._instances !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._instances.memoryBuffer) this._instances = new VkAccelerationStructureGeometryInstancesDataKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._instances.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.triangles !== void 0) this.triangles = opts.triangles;
    if (opts.aabbs !== void 0) this.aabbs = opts.aabbs;
    if (opts.instances !== void 0) this.instances = opts.instances;
    
  }
};

VkAccelerationStructureGeometryDataKHR.prototype.flush = function flush() {
  
  
  if (this._triangles !== null) {
    let triangles = this._triangles;
    triangles.flush();
    if (this.memoryBuffer !== triangles.memoryBuffer) {
      let srcView = new Uint8Array(triangles.memoryBuffer, triangles.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureGeometryDataKHR.triangles' isn't used as shared-memory");
    }
  }
  
  
  if (this._aabbs !== null) {
    let aabbs = this._aabbs;
    aabbs.flush();
    if (this.memoryBuffer !== aabbs.memoryBuffer) {
      let srcView = new Uint8Array(aabbs.memoryBuffer, aabbs.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureGeometryDataKHR.aabbs' isn't used as shared-memory");
    }
  }
  
  
  if (this._instances !== null) {
    let instances = this._instances;
    instances.flush();
    if (this.memoryBuffer !== instances.memoryBuffer) {
      let srcView = new Uint8Array(instances.memoryBuffer, instances.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureGeometryDataKHR.instances' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAccelerationStructureGeometryDataKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureGeometryDataKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureGeometryDataKHR();
  if (original.triangles !== null) {
        copy.triangles = original.triangles.constructor.createCopyFrom(original.triangles);
      }
  if (original.aabbs !== null) {
        copy.aabbs = original.aabbs.constructor.createCopyFrom(original.aabbs);
      }
  if (original.instances !== null) {
        copy.instances = original.instances.constructor.createCopyFrom(original.instances);
      }
  
  return copy;
};

VkAccelerationStructureGeometryDataKHR.byteLength = 0x0;

VkAccelerationStructureGeometryDataKHR.memoryLayout = {
  triangles: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  aabbs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  instances: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBaseOutStructure **/
function VkBaseOutStructure(opts, byteOffset) {
  if (new.target !== VkBaseOutStructure) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBaseOutStructure, STRUCT_CACHE_VkBaseOutStructure);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBaseOutStructure, STRUCT_CACHE_VkBaseOutStructure);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBaseOutStructure'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkBaseOutStructure.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBaseOutStructure.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    if (this._pNext === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkBaseOutStructure.byteLength));
      this._pNext = new VkBaseOutStructure({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pNext.memoryAddress, true);
      return this.pNext;
    } else {
      return this._pNext;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkBaseOutStructure) {
      value.flush();
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBaseOutStructure.pNext': Expected 'VkBaseOutStructure' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBaseOutStructure.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkBaseOutStructure.prototype.flush = function flush() {
  
  return true;
};

VkBaseOutStructure.prototype.reflect = function reflect(memoryAddress) {
  };

VkBaseOutStructure.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBaseOutStructure();
  copy.sType = original.sType;
  if (original.pNext !== null) {
        copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
      }
  
  return copy;
};

VkBaseOutStructure.byteLength = 0x0;

VkBaseOutStructure.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBaseInStructure **/
function VkBaseInStructure(opts, byteOffset) {
  if (new.target !== VkBaseInStructure) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBaseInStructure, STRUCT_CACHE_VkBaseInStructure);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBaseInStructure, STRUCT_CACHE_VkBaseInStructure);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBaseInStructure'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkBaseInStructure.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBaseInStructure.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    if (this._pNext === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkBaseInStructure.byteLength));
      this._pNext = new VkBaseInStructure({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pNext.memoryAddress, true);
      return this.pNext;
    } else {
      return this._pNext;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkBaseInStructure) {
      value.flush();
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBaseInStructure.pNext': Expected 'VkBaseInStructure' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBaseInStructure.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkBaseInStructure.prototype.flush = function flush() {
  
  return true;
};

VkBaseInStructure.prototype.reflect = function reflect(memoryAddress) {
  };

VkBaseInStructure.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBaseInStructure();
  copy.sType = original.sType;
  if (original.pNext !== null) {
        copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
      }
  
  return copy;
};

VkBaseInStructure.byteLength = 0x0;

VkBaseInStructure.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkOffset2D **/
function VkOffset2D(opts, byteOffset) {
  if (new.target !== VkOffset2D) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkOffset2D, STRUCT_CACHE_VkOffset2D);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkOffset2D, STRUCT_CACHE_VkOffset2D);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkOffset2D'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    
  }
};

Object.defineProperties(VkOffset2D.prototype, {
  "x": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkOffset2D.x");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "y": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkOffset2D.y");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkOffset2D.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    
  }
};

VkOffset2D.prototype.flush = function flush() {
  
  return true;
};

VkOffset2D.prototype.reflect = function reflect(memoryAddress) {
  };

VkOffset2D.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkOffset2D();
  copy.x = original.x;
  copy.y = original.y;
  
  return copy;
};

VkOffset2D.byteLength = 0x0;

VkOffset2D.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  y: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkOffset3D **/
function VkOffset3D(opts, byteOffset) {
  if (new.target !== VkOffset3D) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkOffset3D, STRUCT_CACHE_VkOffset3D);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkOffset3D, STRUCT_CACHE_VkOffset3D);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkOffset3D'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.z !== void 0) this.z = opts.z;
    
  }
};

Object.defineProperties(VkOffset3D.prototype, {
  "x": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkOffset3D.x");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "y": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkOffset3D.y");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "z": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkOffset3D.z");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkOffset3D.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.z !== void 0) this.z = opts.z;
    
  }
};

VkOffset3D.prototype.flush = function flush() {
  
  return true;
};

VkOffset3D.prototype.reflect = function reflect(memoryAddress) {
  };

VkOffset3D.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkOffset3D();
  copy.x = original.x;
  copy.y = original.y;
  copy.z = original.z;
  
  return copy;
};

VkOffset3D.byteLength = 0x0;

VkOffset3D.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  y: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  z: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExtent2D **/
function VkExtent2D(opts, byteOffset) {
  if (new.target !== VkExtent2D) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExtent2D, STRUCT_CACHE_VkExtent2D);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExtent2D, STRUCT_CACHE_VkExtent2D);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExtent2D'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    
  }
};

Object.defineProperties(VkExtent2D.prototype, {
  "width": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExtent2D.width");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "height": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExtent2D.height");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkExtent2D.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    
  }
};

VkExtent2D.prototype.flush = function flush() {
  
  return true;
};

VkExtent2D.prototype.reflect = function reflect(memoryAddress) {
  };

VkExtent2D.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExtent2D();
  copy.width = original.width;
  copy.height = original.height;
  
  return copy;
};

VkExtent2D.byteLength = 0x0;

VkExtent2D.memoryLayout = {
  width: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  height: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExtent3D **/
function VkExtent3D(opts, byteOffset) {
  if (new.target !== VkExtent3D) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExtent3D, STRUCT_CACHE_VkExtent3D);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExtent3D, STRUCT_CACHE_VkExtent3D);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExtent3D'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.depth !== void 0) this.depth = opts.depth;
    
  }
};

Object.defineProperties(VkExtent3D.prototype, {
  "width": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExtent3D.width");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "height": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExtent3D.height");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "depth": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExtent3D.depth");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkExtent3D.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.depth !== void 0) this.depth = opts.depth;
    
  }
};

VkExtent3D.prototype.flush = function flush() {
  
  return true;
};

VkExtent3D.prototype.reflect = function reflect(memoryAddress) {
  };

VkExtent3D.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExtent3D();
  copy.width = original.width;
  copy.height = original.height;
  copy.depth = original.depth;
  
  return copy;
};

VkExtent3D.byteLength = 0x0;

VkExtent3D.memoryLayout = {
  width: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  height: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkViewport **/
function VkViewport(opts, byteOffset) {
  if (new.target !== VkViewport) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkViewport, STRUCT_CACHE_VkViewport);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkViewport, STRUCT_CACHE_VkViewport);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkViewport'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.minDepth !== void 0) this.minDepth = opts.minDepth;
    if (opts.maxDepth !== void 0) this.maxDepth = opts.maxDepth;
    
  }
};

Object.defineProperties(VkViewport.prototype, {
  "x": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewport.x");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "y": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewport.y");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "width": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewport.width");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "height": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewport.height");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "minDepth": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewport.minDepth");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxDepth": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewport.maxDepth");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkViewport.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.minDepth !== void 0) this.minDepth = opts.minDepth;
    if (opts.maxDepth !== void 0) this.maxDepth = opts.maxDepth;
    
  }
};

VkViewport.prototype.flush = function flush() {
  
  return true;
};

VkViewport.prototype.reflect = function reflect(memoryAddress) {
  };

VkViewport.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkViewport();
  copy.x = original.x;
  copy.y = original.y;
  copy.width = original.width;
  copy.height = original.height;
  copy.minDepth = original.minDepth;
  copy.maxDepth = original.maxDepth;
  
  return copy;
};

VkViewport.byteLength = 0x0;

VkViewport.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  y: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  width: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  height: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minDepth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDepth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRect2D **/
function VkRect2D(opts, byteOffset) {
  if (new.target !== VkRect2D) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRect2D, STRUCT_CACHE_VkRect2D);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRect2D, STRUCT_CACHE_VkRect2D);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRect2D'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._offset = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._extent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

Object.defineProperties(VkRect2D.prototype, {
  "offset": {
    get() {
    return this._offset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset2D) {
      value.flush();
      this._offset = value;
      
      
    } else if (value === null) {
      this._offset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRect2D.offset': Expected 'VkOffset2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRect2D.extent': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRect2D.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._offset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._offset.memoryBuffer) this._offset = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._offset.reset();
  }
  if (this._extent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._extent.memoryBuffer) this._extent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._extent.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

VkRect2D.prototype.flush = function flush() {
  
  
  if (this._offset !== null) {
    let offset = this._offset;
    offset.flush();
    if (this.memoryBuffer !== offset.memoryBuffer) {
      let srcView = new Uint8Array(offset.memoryBuffer, offset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRect2D.offset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer, extent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRect2D.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkRect2D.prototype.reflect = function reflect(memoryAddress) {
  };

VkRect2D.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRect2D();
  if (original.offset !== null) {
        copy.offset = original.offset.constructor.createCopyFrom(original.offset);
      }
  if (original.extent !== null) {
        copy.extent = original.extent.constructor.createCopyFrom(original.extent);
      }
  
  return copy;
};

VkRect2D.byteLength = 0x0;

VkRect2D.memoryLayout = {
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkClearRect **/
function VkClearRect(opts, byteOffset) {
  if (new.target !== VkClearRect) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkClearRect, STRUCT_CACHE_VkClearRect);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkClearRect, STRUCT_CACHE_VkClearRect);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkClearRect'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._rect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  if (typeof opts === "object") {
    if (opts.rect !== void 0) this.rect = opts.rect;
    if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    
  }
};

Object.defineProperties(VkClearRect.prototype, {
  "rect": {
    get() {
    return this._rect;
    },
    set(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._rect = value;
      
      
    } else if (value === null) {
      this._rect = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearRect.rect': Expected 'VkRect2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "baseArrayLayer": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkClearRect.baseArrayLayer");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "layerCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkClearRect.layerCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkClearRect.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._rect !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._rect.memoryBuffer) this._rect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._rect.reset();
  }
  
  
  
  if (typeof opts === "object") {
    if (opts.rect !== void 0) this.rect = opts.rect;
    if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    
  }
};

VkClearRect.prototype.flush = function flush() {
  
  
  if (this._rect !== null) {
    let rect = this._rect;
    rect.flush();
    if (this.memoryBuffer !== rect.memoryBuffer) {
      let srcView = new Uint8Array(rect.memoryBuffer, rect.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkClearRect.rect' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkClearRect.prototype.reflect = function reflect(memoryAddress) {
  };

VkClearRect.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkClearRect();
  if (original.rect !== null) {
        copy.rect = original.rect.constructor.createCopyFrom(original.rect);
      }
  copy.baseArrayLayer = original.baseArrayLayer;
  copy.layerCount = original.layerCount;
  
  return copy;
};

VkClearRect.byteLength = 0x0;

VkClearRect.memoryLayout = {
  rect: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  baseArrayLayer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layerCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkComponentMapping **/
function VkComponentMapping(opts, byteOffset) {
  if (new.target !== VkComponentMapping) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkComponentMapping, STRUCT_CACHE_VkComponentMapping);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkComponentMapping, STRUCT_CACHE_VkComponentMapping);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkComponentMapping'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.r !== void 0) this.r = opts.r;
    if (opts.g !== void 0) this.g = opts.g;
    if (opts.b !== void 0) this.b = opts.b;
    if (opts.a !== void 0) this.a = opts.a;
    
  }
};

Object.defineProperties(VkComponentMapping.prototype, {
  "r": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkComponentMapping.r");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "g": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkComponentMapping.g");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "b": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkComponentMapping.b");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "a": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkComponentMapping.a");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkComponentMapping.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.r !== void 0) this.r = opts.r;
    if (opts.g !== void 0) this.g = opts.g;
    if (opts.b !== void 0) this.b = opts.b;
    if (opts.a !== void 0) this.a = opts.a;
    
  }
};

VkComponentMapping.prototype.flush = function flush() {
  
  return true;
};

VkComponentMapping.prototype.reflect = function reflect(memoryAddress) {
  };

VkComponentMapping.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkComponentMapping();
  copy.r = original.r;
  copy.g = original.g;
  copy.b = original.b;
  copy.a = original.a;
  
  return copy;
};

VkComponentMapping.byteLength = 0x0;

VkComponentMapping.memoryLayout = {
  r: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  g: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  b: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  a: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceProperties **/
function VkPhysicalDeviceProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceProperties, STRUCT_CACHE_VkPhysicalDeviceProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceProperties, STRUCT_CACHE_VkPhysicalDeviceProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  this._pipelineCacheUUID = [...Array(16)].fill(0x0);
  this._limits = new VkPhysicalDeviceLimits({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._sparseProperties = new VkPhysicalDeviceSparseProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPhysicalDeviceProperties.prototype, {
  "apiVersion": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "driverVersion": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "vendorID": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "deviceID": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "deviceType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "deviceName": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "pipelineCacheUUID": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true),
      this.memoryView.getUint8(0x8, true),
      this.memoryView.getUint8(0x9, true),
      this.memoryView.getUint8(0xA, true),
      this.memoryView.getUint8(0xB, true),
      this.memoryView.getUint8(0xC, true),
      this.memoryView.getUint8(0xD, true),
      this.memoryView.getUint8(0xE, true),
      this.memoryView.getUint8(0xF, true)
    ];
    },
    },
  "limits": {
    get() {
    return this._limits;
    },
    },
  "sparseProperties": {
    get() {
    return this._sparseProperties;
    },
    },
  
});

VkPhysicalDeviceProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  if (this._pipelineCacheUUID !== null) this._pipelineCacheUUID.fill(0x0);
      else this._pipelineCacheUUID = [...Array(16)].fill(0x0);
  if (this._limits !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._limits.memoryBuffer) this._limits = new VkPhysicalDeviceLimits({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._limits.reset();
  }
  if (this._sparseProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._sparseProperties.memoryBuffer) this._sparseProperties = new VkPhysicalDeviceSparseProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._sparseProperties.reset();
  }
  
  if (typeof opts === "object") {
    
  }
};

VkPhysicalDeviceProperties.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceProperties();
  copy.apiVersion = original.apiVersion;
  copy.driverVersion = original.driverVersion;
  copy.vendorID = original.vendorID;
  copy.deviceID = original.deviceID;
  copy.deviceType = original.deviceType;
  copy.deviceName = original.deviceName;
  if (original.pipelineCacheUUID !== null) {
        copy.pipelineCacheUUID = [...Array(original.pipelineCacheUUID.length)].map((v, i) => {
          return original.pipelineCacheUUID[i];
        });
      }
  if (original.limits !== null) {
        copy.limits = original.limits.constructor.createCopyFrom(original.limits);
      }
  if (original.sparseProperties !== null) {
        copy.sparseProperties = original.sparseProperties.constructor.createCopyFrom(original.sparseProperties);
      }
  
  return copy;
};

VkPhysicalDeviceProperties.byteLength = 0x0;

VkPhysicalDeviceProperties.memoryLayout = {
  apiVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vendorID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineCacheUUID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  limits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExtensionProperties **/
function VkExtensionProperties(opts, byteOffset) {
  if (new.target !== VkExtensionProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExtensionProperties, STRUCT_CACHE_VkExtensionProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExtensionProperties, STRUCT_CACHE_VkExtensionProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExtensionProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkExtensionProperties.prototype, {
  "extensionName": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "specVersion": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkExtensionProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkExtensionProperties.prototype.flush = function flush() {
  
  return true;
};

VkExtensionProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExtensionProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExtensionProperties();
  copy.extensionName = original.extensionName;
  copy.specVersion = original.specVersion;
  
  return copy;
};

VkExtensionProperties.byteLength = 0x0;

VkExtensionProperties.memoryLayout = {
  extensionName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  specVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkLayerProperties **/
function VkLayerProperties(opts, byteOffset) {
  if (new.target !== VkLayerProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkLayerProperties, STRUCT_CACHE_VkLayerProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkLayerProperties, STRUCT_CACHE_VkLayerProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkLayerProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkLayerProperties.prototype, {
  "layerName": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "specVersion": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "implementationVersion": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "description": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  
});

VkLayerProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkLayerProperties.prototype.flush = function flush() {
  
  return true;
};

VkLayerProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkLayerProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkLayerProperties();
  copy.layerName = original.layerName;
  copy.specVersion = original.specVersion;
  copy.implementationVersion = original.implementationVersion;
  copy.description = original.description;
  
  return copy;
};

VkLayerProperties.byteLength = 0x0;

VkLayerProperties.memoryLayout = {
  layerName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  specVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  implementationVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  description: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkApplicationInfo **/
function VkApplicationInfo(opts, byteOffset) {
  if (new.target !== VkApplicationInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkApplicationInfo, STRUCT_CACHE_VkApplicationInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkApplicationInfo, STRUCT_CACHE_VkApplicationInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkApplicationInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._pApplicationName = null;
  
  this._pEngineName = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pApplicationName !== void 0) this.pApplicationName = opts.pApplicationName;
    if (opts.applicationVersion !== void 0) this.applicationVersion = opts.applicationVersion;
    if (opts.pEngineName !== void 0) this.pEngineName = opts.pEngineName;
    if (opts.engineVersion !== void 0) this.engineVersion = opts.engineVersion;
    if (opts.apiVersion !== void 0) this.apiVersion = opts.apiVersion;
    
  }
};

Object.defineProperties(VkApplicationInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkApplicationInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkApplicationInfo.pNext' isn't allowed to be filled");
    }
    },
  "pApplicationName": {
    get() {
    if (this._pApplicationName !== null) {
      let str = textDecoder.decode(this._pApplicationName);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._pApplicationName = buffer;
        return this.pApplicationName;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pApplicationName = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._pApplicationName), true);
    } else if (value === null) {
      this._pApplicationName = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkApplicationInfo.pApplicationName");
    }
    
    }
    },
  "applicationVersion": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkApplicationInfo.applicationVersion");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pEngineName": {
    get() {
    if (this._pEngineName !== null) {
      let str = textDecoder.decode(this._pEngineName);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._pEngineName = buffer;
        return this.pEngineName;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pEngineName = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._pEngineName), true);
    } else if (value === null) {
      this._pEngineName = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkApplicationInfo.pEngineName");
    }
    
    }
    },
  "engineVersion": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkApplicationInfo.engineVersion");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "apiVersion": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkApplicationInfo.apiVersion");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkApplicationInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._pApplicationName = null;
  
  this._pEngineName = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pApplicationName !== void 0) this.pApplicationName = opts.pApplicationName;
    if (opts.applicationVersion !== void 0) this.applicationVersion = opts.applicationVersion;
    if (opts.pEngineName !== void 0) this.pEngineName = opts.pEngineName;
    if (opts.engineVersion !== void 0) this.engineVersion = opts.engineVersion;
    if (opts.apiVersion !== void 0) this.apiVersion = opts.apiVersion;
    
  }
};

VkApplicationInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkApplicationInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkApplicationInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkApplicationInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pApplicationName = original.pApplicationName;
  copy.applicationVersion = original.applicationVersion;
  copy.pEngineName = original.pEngineName;
  copy.engineVersion = original.engineVersion;
  copy.apiVersion = original.apiVersion;
  
  return copy;
};

VkApplicationInfo.byteLength = 0x0;

VkApplicationInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pApplicationName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  applicationVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pEngineName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  engineVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  apiVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAllocationCallbacks **/
function VkAllocationCallbacks(opts, byteOffset) {
  if (new.target !== VkAllocationCallbacks) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAllocationCallbacks, STRUCT_CACHE_VkAllocationCallbacks);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAllocationCallbacks, STRUCT_CACHE_VkAllocationCallbacks);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAllocationCallbacks'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._pUserData = null;
  this._pfnAllocation = null;this._pfnAllocationCallbackProxy = null;
  this._pfnReallocation = null;this._pfnReallocationCallbackProxy = null;
  this._pfnFree = null;this._pfnFreeCallbackProxy = null;
  this._pfnInternalAllocation = null;this._pfnInternalAllocationCallbackProxy = null;
  this._pfnInternalFree = null;this._pfnInternalFreeCallbackProxy = null;
  
  if (typeof opts === "object") {
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    if (opts.pfnAllocation !== void 0) this.pfnAllocation = opts.pfnAllocation;
    if (opts.pfnReallocation !== void 0) this.pfnReallocation = opts.pfnReallocation;
    if (opts.pfnFree !== void 0) this.pfnFree = opts.pfnFree;
    if (opts.pfnInternalAllocation !== void 0) this.pfnInternalAllocation = opts.pfnInternalAllocation;
    if (opts.pfnInternalFree !== void 0) this.pfnInternalFree = opts.pfnInternalFree;
    
  }
};

Object.defineProperties(VkAllocationCallbacks.prototype, {
  "pUserData": {
    get() {
    return this._pUserData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pUserData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pfnAllocation": {
    get() {
    return this._pfnAllocation;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      let MITM = function() {
        for (let ii = 0; ii < arguments.length; ++ii) {
          let arg = arguments[ii];
          if (arg instanceof Object && arg.constructor.createCopyFrom instanceof Function) {
            let copy = arg.constructor.createCopyFrom(arg);
            arguments[ii] = copy;
          }
        };
        return value.apply(this, arguments);
      }.bind(this);
      this._pfnAllocation = value;
      this._pfnAllocationCallbackProxy = new nvk.$CallbackProxy(MITM, module.exports);
      this.memoryView.setBigInt64(0x0, nvk.$vulkanCallbackFunctionPointers["vkAllocationFunction"], true);
      this.memoryView.setBigInt64(0x0, this._pfnAllocationCallbackProxy.getAddress(), true);
    } else if (value === null) {
      this._pfnAllocation = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pfnAllocation': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pfnReallocation": {
    get() {
    return this._pfnReallocation;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      let MITM = function() {
        for (let ii = 0; ii < arguments.length; ++ii) {
          let arg = arguments[ii];
          if (arg instanceof Object && arg.constructor.createCopyFrom instanceof Function) {
            let copy = arg.constructor.createCopyFrom(arg);
            arguments[ii] = copy;
          }
        };
        return value.apply(this, arguments);
      }.bind(this);
      this._pfnReallocation = value;
      this._pfnReallocationCallbackProxy = new nvk.$CallbackProxy(MITM, module.exports);
      this.memoryView.setBigInt64(0x0, nvk.$vulkanCallbackFunctionPointers["vkReallocationFunction"], true);
      this.memoryView.setBigInt64(0x0, this._pfnReallocationCallbackProxy.getAddress(), true);
    } else if (value === null) {
      this._pfnReallocation = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pfnReallocation': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pfnFree": {
    get() {
    return this._pfnFree;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      let MITM = function() {
        for (let ii = 0; ii < arguments.length; ++ii) {
          let arg = arguments[ii];
          if (arg instanceof Object && arg.constructor.createCopyFrom instanceof Function) {
            let copy = arg.constructor.createCopyFrom(arg);
            arguments[ii] = copy;
          }
        };
        return value.apply(this, arguments);
      }.bind(this);
      this._pfnFree = value;
      this._pfnFreeCallbackProxy = new nvk.$CallbackProxy(MITM, module.exports);
      this.memoryView.setBigInt64(0x0, nvk.$vulkanCallbackFunctionPointers["vkFreeFunction"], true);
      this.memoryView.setBigInt64(0x0, this._pfnFreeCallbackProxy.getAddress(), true);
    } else if (value === null) {
      this._pfnFree = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pfnFree': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pfnInternalAllocation": {
    get() {
    return this._pfnInternalAllocation;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      let MITM = function() {
        for (let ii = 0; ii < arguments.length; ++ii) {
          let arg = arguments[ii];
          if (arg instanceof Object && arg.constructor.createCopyFrom instanceof Function) {
            let copy = arg.constructor.createCopyFrom(arg);
            arguments[ii] = copy;
          }
        };
        return value.apply(this, arguments);
      }.bind(this);
      this._pfnInternalAllocation = value;
      this._pfnInternalAllocationCallbackProxy = new nvk.$CallbackProxy(MITM, module.exports);
      this.memoryView.setBigInt64(0x0, nvk.$vulkanCallbackFunctionPointers["vkInternalAllocationNotification"], true);
      this.memoryView.setBigInt64(0x0, this._pfnInternalAllocationCallbackProxy.getAddress(), true);
    } else if (value === null) {
      this._pfnInternalAllocation = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pfnInternalAllocation': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pfnInternalFree": {
    get() {
    return this._pfnInternalFree;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      let MITM = function() {
        for (let ii = 0; ii < arguments.length; ++ii) {
          let arg = arguments[ii];
          if (arg instanceof Object && arg.constructor.createCopyFrom instanceof Function) {
            let copy = arg.constructor.createCopyFrom(arg);
            arguments[ii] = copy;
          }
        };
        return value.apply(this, arguments);
      }.bind(this);
      this._pfnInternalFree = value;
      this._pfnInternalFreeCallbackProxy = new nvk.$CallbackProxy(MITM, module.exports);
      this.memoryView.setBigInt64(0x0, nvk.$vulkanCallbackFunctionPointers["vkInternalFreeNotification"], true);
      this.memoryView.setBigInt64(0x0, this._pfnInternalFreeCallbackProxy.getAddress(), true);
    } else if (value === null) {
      this._pfnInternalFree = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pfnInternalFree': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAllocationCallbacks.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._pUserData = null;
  this._pfnAllocation = null;
  this._pfnReallocation = null;
  this._pfnFree = null;
  this._pfnInternalAllocation = null;
  this._pfnInternalFree = null;
  
  if (typeof opts === "object") {
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    if (opts.pfnAllocation !== void 0) this.pfnAllocation = opts.pfnAllocation;
    if (opts.pfnReallocation !== void 0) this.pfnReallocation = opts.pfnReallocation;
    if (opts.pfnFree !== void 0) this.pfnFree = opts.pfnFree;
    if (opts.pfnInternalAllocation !== void 0) this.pfnInternalAllocation = opts.pfnInternalAllocation;
    if (opts.pfnInternalFree !== void 0) this.pfnInternalFree = opts.pfnInternalFree;
    
  }
};

VkAllocationCallbacks.prototype.flush = function flush() {
  
  return true;
};

VkAllocationCallbacks.prototype.reflect = function reflect(memoryAddress) {
  };

VkAllocationCallbacks.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAllocationCallbacks();
  if (original.pUserData !== null) {
      let buf = new ArrayBuffer(original.pUserData.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pUserData), 0x0);
      copy.pUserData = buf;
    }
  copy.pfnAllocation = original.pfnAllocation;
  copy.pfnReallocation = original.pfnReallocation;
  copy.pfnFree = original.pfnFree;
  copy.pfnInternalAllocation = original.pfnInternalAllocation;
  copy.pfnInternalFree = original.pfnInternalFree;
  
  return copy;
};

VkAllocationCallbacks.byteLength = 0x0;

VkAllocationCallbacks.memoryLayout = {
  pUserData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pfnAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pfnReallocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pfnFree: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pfnInternalAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pfnInternalFree: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceQueueCreateInfo **/
function VkDeviceQueueCreateInfo(opts, byteOffset) {
  if (new.target !== VkDeviceQueueCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceQueueCreateInfo, STRUCT_CACHE_VkDeviceQueueCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceQueueCreateInfo, STRUCT_CACHE_VkDeviceQueueCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceQueueCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._pQueuePriorities = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    if (opts.queueCount !== void 0) this.queueCount = opts.queueCount;
    if (opts.pQueuePriorities !== void 0) this.pQueuePriorities = opts.pQueuePriorities;
    
  }
};

Object.defineProperties(VkDeviceQueueCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceQueueCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceQueueCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "queueFamilyIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceQueueCreateInfo.queueFamilyIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "queueCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceQueueCreateInfo.queueCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pQueuePriorities": {
    get() {
    return this._pQueuePriorities;
    },
    set(value) {
    if (value !== null && value.constructor === Float32Array) {
      this._pQueuePriorities = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pQueuePriorities = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pQueuePriorities': Expected 'Float32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceQueueCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this._pQueuePriorities = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    if (opts.queueCount !== void 0) this.queueCount = opts.queueCount;
    if (opts.pQueuePriorities !== void 0) this.pQueuePriorities = opts.pQueuePriorities;
    
  }
};

VkDeviceQueueCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceQueueCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceQueueCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceQueueCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.queueFamilyIndex = original.queueFamilyIndex;
  copy.queueCount = original.queueCount;
  if (original.pQueuePriorities !== null) {
        copy.pQueuePriorities = new Float32Array(original.pQueuePriorities);
      }
  
  return copy;
};

VkDeviceQueueCreateInfo.byteLength = 0x0;

VkDeviceQueueCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueFamilyIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pQueuePriorities: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceCreateInfo **/
function VkDeviceCreateInfo(opts, byteOffset) {
  if (new.target !== VkDeviceCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceCreateInfo, STRUCT_CACHE_VkDeviceCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceCreateInfo, STRUCT_CACHE_VkDeviceCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pQueueCreateInfos = null;
  this._pQueueCreateInfosNative = null;
  
  this._ppEnabledLayerNames = null;
  this._ppEnabledLayerNamesNative = null;
  
  this._ppEnabledExtensionNames = null;
  this._ppEnabledExtensionNamesNative = null;
  this._pEnabledFeatures = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueCreateInfoCount !== void 0) this.queueCreateInfoCount = opts.queueCreateInfoCount;
    if (opts.pQueueCreateInfos !== void 0) this.pQueueCreateInfos = opts.pQueueCreateInfos;
    if (opts.enabledLayerCount !== void 0) this.enabledLayerCount = opts.enabledLayerCount;
    if (opts.ppEnabledLayerNames !== void 0) this.ppEnabledLayerNames = opts.ppEnabledLayerNames;
    if (opts.enabledExtensionCount !== void 0) this.enabledExtensionCount = opts.enabledExtensionCount;
    if (opts.ppEnabledExtensionNames !== void 0) this.ppEnabledExtensionNames = opts.ppEnabledExtensionNames;
    if (opts.pEnabledFeatures !== void 0) this.pEnabledFeatures = opts.pEnabledFeatures;
    
  }
};

Object.defineProperties(VkDeviceCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "queueCreateInfoCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceCreateInfo.queueCreateInfoCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pQueueCreateInfos": {
    get() {
    if (this._pQueueCreateInfos === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.queueCreateInfoCount, VkDeviceQueueCreateInfo);
      this._pQueueCreateInfos = array;
      return this.pQueueCreateInfos;
    } else {
      return this._pQueueCreateInfos;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pQueueCreateInfos = value;
    } else if (value === null) {
      this._pQueueCreateInfos = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pQueueCreateInfos': Expected 'Array VkDeviceQueueCreateInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "enabledLayerCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceCreateInfo.enabledLayerCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "ppEnabledLayerNames": {
    get() {
    return this._ppEnabledLayerNames;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledLayerNames = value;
    } else if (value === null) {
      this._ppEnabledLayerNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledLayerNames': Expected 'Array char' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "enabledExtensionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceCreateInfo.enabledExtensionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "ppEnabledExtensionNames": {
    get() {
    return this._ppEnabledExtensionNames;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledExtensionNames = value;
    } else if (value === null) {
      this._ppEnabledExtensionNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledExtensionNames': Expected 'Array char' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pEnabledFeatures": {
    get() {
    if (this._pEnabledFeatures === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPhysicalDeviceFeatures.byteLength));
      this._pEnabledFeatures = new VkPhysicalDeviceFeatures({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pEnabledFeatures.memoryAddress, true);
      return this.pEnabledFeatures;
    } else {
      return this._pEnabledFeatures;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPhysicalDeviceFeatures) {
      value.flush();
      this._pEnabledFeatures = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pEnabledFeatures = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pEnabledFeatures': Expected 'VkPhysicalDeviceFeatures' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pQueueCreateInfos = null;
  this._pQueueCreateInfosNative = null;
  
  this._ppEnabledLayerNames = null;
  this._ppEnabledLayerNamesNative = null;
  
  this._ppEnabledExtensionNames = null;
  this._ppEnabledExtensionNamesNative = null;
  this._pEnabledFeatures = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueCreateInfoCount !== void 0) this.queueCreateInfoCount = opts.queueCreateInfoCount;
    if (opts.pQueueCreateInfos !== void 0) this.pQueueCreateInfos = opts.pQueueCreateInfos;
    if (opts.enabledLayerCount !== void 0) this.enabledLayerCount = opts.enabledLayerCount;
    if (opts.ppEnabledLayerNames !== void 0) this.ppEnabledLayerNames = opts.ppEnabledLayerNames;
    if (opts.enabledExtensionCount !== void 0) this.enabledExtensionCount = opts.enabledExtensionCount;
    if (opts.ppEnabledExtensionNames !== void 0) this.ppEnabledExtensionNames = opts.ppEnabledExtensionNames;
    if (opts.pEnabledFeatures !== void 0) this.pEnabledFeatures = opts.pEnabledFeatures;
    
  }
};

VkDeviceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pQueueCreateInfos !== null) {
    let array = this._pQueueCreateInfos;
    
    if (array.length !== this.queueCreateInfoCount) {
      throw new RangeError("Invalid array length, expected length of 'queueCreateInfoCount' for 'VkDeviceCreateInfo.pQueueCreateInfos'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDeviceQueueCreateInfo)) {
        throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pQueueCreateInfos[" + ii + "]': Expected 'VkDeviceQueueCreateInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pQueueCreateInfosNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pQueueCreateInfosNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._ppEnabledLayerNames !== null) {
    let array = this._ppEnabledLayerNames;
    
    // validate length
    if (array.length !== this.enabledLayerCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledLayerCount' for 'VkDeviceCreateInfo.ppEnabledLayerNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "string") {
        throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledLayerNames[" + ii + "]': Expected 'String' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledLayerNames);
    this._ppEnabledLayerNamesNative = nativeArray;
    this.memoryView.setBigInt64(0x0, nativeArray.address, true);
  } else {
    this.memoryView.setBigInt64(0x0, BI0, true);
  }
  
  
  if (this._ppEnabledExtensionNames !== null) {
    let array = this._ppEnabledExtensionNames;
    
    // validate length
    if (array.length !== this.enabledExtensionCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledExtensionCount' for 'VkDeviceCreateInfo.ppEnabledExtensionNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "string") {
        throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledExtensionNames[" + ii + "]': Expected 'String' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledExtensionNames);
    this._ppEnabledExtensionNamesNative = nativeArray;
    this.memoryView.setBigInt64(0x0, nativeArray.address, true);
  } else {
    this.memoryView.setBigInt64(0x0, BI0, true);
  }
  
  return true;
};

VkDeviceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.queueCreateInfoCount = original.queueCreateInfoCount;
  if (original.pQueueCreateInfos !== null) {
        copy.pQueueCreateInfos = [...Array(original.pQueueCreateInfos.length)].map((v, i) => {
          return original.pQueueCreateInfos[i].constructor.createCopyFrom(original.pQueueCreateInfos[i]);
        });
      }
  copy.enabledLayerCount = original.enabledLayerCount;
  if (original.ppEnabledLayerNames !== null) {
        copy.ppEnabledLayerNames = [...Array(original.ppEnabledLayerNames.length)].map((v, i) => {
          return original.ppEnabledLayerNames[i];
        });
      }
  copy.enabledExtensionCount = original.enabledExtensionCount;
  if (original.ppEnabledExtensionNames !== null) {
        copy.ppEnabledExtensionNames = [...Array(original.ppEnabledExtensionNames.length)].map((v, i) => {
          return original.ppEnabledExtensionNames[i];
        });
      }
  if (original.pEnabledFeatures !== null) {
        copy.pEnabledFeatures = original.pEnabledFeatures.constructor.createCopyFrom(original.pEnabledFeatures);
      }
  
  return copy;
};

VkDeviceCreateInfo.byteLength = 0x0;

VkDeviceCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueCreateInfoCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pQueueCreateInfos: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  enabledLayerCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ppEnabledLayerNames: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  enabledExtensionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ppEnabledExtensionNames: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pEnabledFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkInstanceCreateInfo **/
function VkInstanceCreateInfo(opts, byteOffset) {
  if (new.target !== VkInstanceCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkInstanceCreateInfo, STRUCT_CACHE_VkInstanceCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkInstanceCreateInfo, STRUCT_CACHE_VkInstanceCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkInstanceCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pApplicationInfo = null;
  
  this._ppEnabledLayerNames = null;
  this._ppEnabledLayerNamesNative = null;
  
  this._ppEnabledExtensionNames = null;
  this._ppEnabledExtensionNamesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pApplicationInfo !== void 0) this.pApplicationInfo = opts.pApplicationInfo;
    if (opts.enabledLayerCount !== void 0) this.enabledLayerCount = opts.enabledLayerCount;
    if (opts.ppEnabledLayerNames !== void 0) this.ppEnabledLayerNames = opts.ppEnabledLayerNames;
    if (opts.enabledExtensionCount !== void 0) this.enabledExtensionCount = opts.enabledExtensionCount;
    if (opts.ppEnabledExtensionNames !== void 0) this.ppEnabledExtensionNames = opts.ppEnabledExtensionNames;
    
  }
};

Object.defineProperties(VkInstanceCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInstanceCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInstanceCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pApplicationInfo": {
    get() {
    if (this._pApplicationInfo === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkApplicationInfo.byteLength));
      this._pApplicationInfo = new VkApplicationInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pApplicationInfo.memoryAddress, true);
      return this.pApplicationInfo;
    } else {
      return this._pApplicationInfo;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkApplicationInfo) {
      value.flush();
      this._pApplicationInfo = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pApplicationInfo = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pApplicationInfo': Expected 'VkApplicationInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "enabledLayerCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInstanceCreateInfo.enabledLayerCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "ppEnabledLayerNames": {
    get() {
    return this._ppEnabledLayerNames;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledLayerNames = value;
    } else if (value === null) {
      this._ppEnabledLayerNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledLayerNames': Expected 'Array char' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "enabledExtensionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInstanceCreateInfo.enabledExtensionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "ppEnabledExtensionNames": {
    get() {
    return this._ppEnabledExtensionNames;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledExtensionNames = value;
    } else if (value === null) {
      this._ppEnabledExtensionNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledExtensionNames': Expected 'Array char' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkInstanceCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pApplicationInfo = null;
  
  this._ppEnabledLayerNames = null;
  this._ppEnabledLayerNamesNative = null;
  
  this._ppEnabledExtensionNames = null;
  this._ppEnabledExtensionNamesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pApplicationInfo !== void 0) this.pApplicationInfo = opts.pApplicationInfo;
    if (opts.enabledLayerCount !== void 0) this.enabledLayerCount = opts.enabledLayerCount;
    if (opts.ppEnabledLayerNames !== void 0) this.ppEnabledLayerNames = opts.ppEnabledLayerNames;
    if (opts.enabledExtensionCount !== void 0) this.enabledExtensionCount = opts.enabledExtensionCount;
    if (opts.ppEnabledExtensionNames !== void 0) this.ppEnabledExtensionNames = opts.ppEnabledExtensionNames;
    
  }
};

VkInstanceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._ppEnabledLayerNames !== null) {
    let array = this._ppEnabledLayerNames;
    
    // validate length
    if (array.length !== this.enabledLayerCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledLayerCount' for 'VkInstanceCreateInfo.ppEnabledLayerNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "string") {
        throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledLayerNames[" + ii + "]': Expected 'String' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledLayerNames);
    this._ppEnabledLayerNamesNative = nativeArray;
    this.memoryView.setBigInt64(0x0, nativeArray.address, true);
  } else {
    this.memoryView.setBigInt64(0x0, BI0, true);
  }
  
  
  if (this._ppEnabledExtensionNames !== null) {
    let array = this._ppEnabledExtensionNames;
    
    // validate length
    if (array.length !== this.enabledExtensionCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledExtensionCount' for 'VkInstanceCreateInfo.ppEnabledExtensionNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "string") {
        throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledExtensionNames[" + ii + "]': Expected 'String' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledExtensionNames);
    this._ppEnabledExtensionNamesNative = nativeArray;
    this.memoryView.setBigInt64(0x0, nativeArray.address, true);
  } else {
    this.memoryView.setBigInt64(0x0, BI0, true);
  }
  
  return true;
};

VkInstanceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkInstanceCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkInstanceCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  if (original.pApplicationInfo !== null) {
        copy.pApplicationInfo = original.pApplicationInfo.constructor.createCopyFrom(original.pApplicationInfo);
      }
  copy.enabledLayerCount = original.enabledLayerCount;
  if (original.ppEnabledLayerNames !== null) {
        copy.ppEnabledLayerNames = [...Array(original.ppEnabledLayerNames.length)].map((v, i) => {
          return original.ppEnabledLayerNames[i];
        });
      }
  copy.enabledExtensionCount = original.enabledExtensionCount;
  if (original.ppEnabledExtensionNames !== null) {
        copy.ppEnabledExtensionNames = [...Array(original.ppEnabledExtensionNames.length)].map((v, i) => {
          return original.ppEnabledExtensionNames[i];
        });
      }
  
  return copy;
};

VkInstanceCreateInfo.byteLength = 0x0;

VkInstanceCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pApplicationInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  enabledLayerCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ppEnabledLayerNames: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  enabledExtensionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ppEnabledExtensionNames: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkQueueFamilyProperties **/
function VkQueueFamilyProperties(opts, byteOffset) {
  if (new.target !== VkQueueFamilyProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkQueueFamilyProperties, STRUCT_CACHE_VkQueueFamilyProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkQueueFamilyProperties, STRUCT_CACHE_VkQueueFamilyProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkQueueFamilyProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  this._minImageTransferGranularity = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkQueueFamilyProperties.prototype, {
  "queueFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "queueCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "timestampValidBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "minImageTransferGranularity": {
    get() {
    return this._minImageTransferGranularity;
    },
    },
  
});

VkQueueFamilyProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (this._minImageTransferGranularity !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._minImageTransferGranularity.memoryBuffer) this._minImageTransferGranularity = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._minImageTransferGranularity.reset();
  }
  
  if (typeof opts === "object") {
    
  }
};

VkQueueFamilyProperties.prototype.flush = function flush() {
  
  return true;
};

VkQueueFamilyProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkQueueFamilyProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkQueueFamilyProperties();
  copy.queueFlags = original.queueFlags;
  copy.queueCount = original.queueCount;
  copy.timestampValidBits = original.timestampValidBits;
  if (original.minImageTransferGranularity !== null) {
        copy.minImageTransferGranularity = original.minImageTransferGranularity.constructor.createCopyFrom(original.minImageTransferGranularity);
      }
  
  return copy;
};

VkQueueFamilyProperties.byteLength = 0x0;

VkQueueFamilyProperties.memoryLayout = {
  queueFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  timestampValidBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minImageTransferGranularity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMemoryProperties **/
function VkPhysicalDeviceMemoryProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMemoryProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMemoryProperties, STRUCT_CACHE_VkPhysicalDeviceMemoryProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMemoryProperties, STRUCT_CACHE_VkPhysicalDeviceMemoryProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMemoryProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._memoryTypes = [...Array(32)].map((v, i) => new VkMemoryType({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 + (i * 0x0) }));
  
  this._memoryHeaps = [...Array(16)].map((v, i) => new VkMemoryHeap({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 + (i * 0x0) }));
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPhysicalDeviceMemoryProperties.prototype, {
  "memoryTypeCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "memoryTypes": {
    get() {
    return this._memoryTypes;
    },
    },
  "memoryHeapCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "memoryHeaps": {
    get() {
    return this._memoryHeaps;
    },
    },
  
});

VkPhysicalDeviceMemoryProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  if (this._memoryTypes !== null) {
    let array = this._memoryTypes;
    for (let ii = 0; ii < array.length; ++ii) {
      array[ii].reset();
    };
  }
  
  if (this._memoryHeaps !== null) {
    let array = this._memoryHeaps;
    for (let ii = 0; ii < array.length; ++ii) {
      array[ii].reset();
    };
  }
  
  if (typeof opts === "object") {
    
  }
};

VkPhysicalDeviceMemoryProperties.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceMemoryProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceMemoryProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMemoryProperties();
  copy.memoryTypeCount = original.memoryTypeCount;
  if (original.memoryTypes !== null) {
        copy.memoryTypes = [...Array(original.memoryTypes.length)].map((v, i) => {
          return original.memoryTypes[i].constructor.createCopyFrom(original.memoryTypes[i]);
        });
      }
  copy.memoryHeapCount = original.memoryHeapCount;
  if (original.memoryHeaps !== null) {
        copy.memoryHeaps = [...Array(original.memoryHeaps.length)].map((v, i) => {
          return original.memoryHeaps[i].constructor.createCopyFrom(original.memoryHeaps[i]);
        });
      }
  
  return copy;
};

VkPhysicalDeviceMemoryProperties.byteLength = 0x0;

VkPhysicalDeviceMemoryProperties.memoryLayout = {
  memoryTypeCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryHeapCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryHeaps: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryAllocateInfo **/
function VkMemoryAllocateInfo(opts, byteOffset) {
  if (new.target !== VkMemoryAllocateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryAllocateInfo, STRUCT_CACHE_VkMemoryAllocateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryAllocateInfo, STRUCT_CACHE_VkMemoryAllocateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryAllocateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.allocationSize !== void 0) this.allocationSize = opts.allocationSize;
    if (opts.memoryTypeIndex !== void 0) this.memoryTypeIndex = opts.memoryTypeIndex;
    
  }
};

Object.defineProperties(VkMemoryAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryAllocateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.pNext'");
    }
    
    }
    },
  "allocationSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkMemoryAllocateInfo.allocationSize")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "memoryTypeIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryAllocateInfo.memoryTypeIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkMemoryAllocateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.allocationSize !== void 0) this.allocationSize = opts.allocationSize;
    if (opts.memoryTypeIndex !== void 0) this.memoryTypeIndex = opts.memoryTypeIndex;
    
  }
};

VkMemoryAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryAllocateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryAllocateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.allocationSize = original.allocationSize;
  copy.memoryTypeIndex = original.memoryTypeIndex;
  
  return copy;
};

VkMemoryAllocateInfo.byteLength = 0x0;

VkMemoryAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  allocationSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryTypeIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryRequirements **/
function VkMemoryRequirements(opts, byteOffset) {
  if (new.target !== VkMemoryRequirements) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryRequirements, STRUCT_CACHE_VkMemoryRequirements);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryRequirements, STRUCT_CACHE_VkMemoryRequirements);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryRequirements'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkMemoryRequirements.prototype, {
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "alignment": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "memoryTypeBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkMemoryRequirements.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkMemoryRequirements.prototype.flush = function flush() {
  
  return true;
};

VkMemoryRequirements.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMemoryRequirements.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryRequirements();
  copy.size = original.size;
  copy.alignment = original.alignment;
  copy.memoryTypeBits = original.memoryTypeBits;
  
  return copy;
};

VkMemoryRequirements.byteLength = 0x0;

VkMemoryRequirements.memoryLayout = {
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  alignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryTypeBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseImageFormatProperties **/
function VkSparseImageFormatProperties(opts, byteOffset) {
  if (new.target !== VkSparseImageFormatProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseImageFormatProperties, STRUCT_CACHE_VkSparseImageFormatProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseImageFormatProperties, STRUCT_CACHE_VkSparseImageFormatProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseImageFormatProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._imageGranularity = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkSparseImageFormatProperties.prototype, {
  "aspectMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "imageGranularity": {
    get() {
    return this._imageGranularity;
    },
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkSparseImageFormatProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  if (this._imageGranularity !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageGranularity.memoryBuffer) this._imageGranularity = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageGranularity.reset();
  }
  
  
  if (typeof opts === "object") {
    
  }
};

VkSparseImageFormatProperties.prototype.flush = function flush() {
  
  return true;
};

VkSparseImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSparseImageFormatProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseImageFormatProperties();
  copy.aspectMask = original.aspectMask;
  if (original.imageGranularity !== null) {
        copy.imageGranularity = original.imageGranularity.constructor.createCopyFrom(original.imageGranularity);
      }
  copy.flags = original.flags;
  
  return copy;
};

VkSparseImageFormatProperties.byteLength = 0x0;

VkSparseImageFormatProperties.memoryLayout = {
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageGranularity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseImageMemoryRequirements **/
function VkSparseImageMemoryRequirements(opts, byteOffset) {
  if (new.target !== VkSparseImageMemoryRequirements) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseImageMemoryRequirements, STRUCT_CACHE_VkSparseImageMemoryRequirements);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseImageMemoryRequirements, STRUCT_CACHE_VkSparseImageMemoryRequirements);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseImageMemoryRequirements'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._formatProperties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkSparseImageMemoryRequirements.prototype, {
  "formatProperties": {
    get() {
    return this._formatProperties;
    },
    },
  "imageMipTailFirstLod": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "imageMipTailSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "imageMipTailOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "imageMipTailStride": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkSparseImageMemoryRequirements.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._formatProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._formatProperties.memoryBuffer) this._formatProperties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._formatProperties.reset();
  }
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkSparseImageMemoryRequirements.prototype.flush = function flush() {
  
  return true;
};

VkSparseImageMemoryRequirements.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSparseImageMemoryRequirements.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseImageMemoryRequirements();
  if (original.formatProperties !== null) {
        copy.formatProperties = original.formatProperties.constructor.createCopyFrom(original.formatProperties);
      }
  copy.imageMipTailFirstLod = original.imageMipTailFirstLod;
  copy.imageMipTailSize = original.imageMipTailSize;
  copy.imageMipTailOffset = original.imageMipTailOffset;
  copy.imageMipTailStride = original.imageMipTailStride;
  
  return copy;
};

VkSparseImageMemoryRequirements.byteLength = 0x0;

VkSparseImageMemoryRequirements.memoryLayout = {
  formatProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageMipTailFirstLod: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageMipTailSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageMipTailOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageMipTailStride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryType **/
function VkMemoryType(opts, byteOffset) {
  if (new.target !== VkMemoryType) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryType, STRUCT_CACHE_VkMemoryType);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryType, STRUCT_CACHE_VkMemoryType);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryType'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkMemoryType.prototype, {
  "propertyFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "heapIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkMemoryType.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkMemoryType.prototype.flush = function flush() {
  
  return true;
};

VkMemoryType.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMemoryType.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryType();
  copy.propertyFlags = original.propertyFlags;
  copy.heapIndex = original.heapIndex;
  
  return copy;
};

VkMemoryType.byteLength = 0x0;

VkMemoryType.memoryLayout = {
  propertyFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  heapIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryHeap **/
function VkMemoryHeap(opts, byteOffset) {
  if (new.target !== VkMemoryHeap) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryHeap, STRUCT_CACHE_VkMemoryHeap);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryHeap, STRUCT_CACHE_VkMemoryHeap);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryHeap'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkMemoryHeap.prototype, {
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkMemoryHeap.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkMemoryHeap.prototype.flush = function flush() {
  
  return true;
};

VkMemoryHeap.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMemoryHeap.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryHeap();
  copy.size = original.size;
  copy.flags = original.flags;
  
  return copy;
};

VkMemoryHeap.byteLength = 0x0;

VkMemoryHeap.memoryLayout = {
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMappedMemoryRange **/
function VkMappedMemoryRange(opts, byteOffset) {
  if (new.target !== VkMappedMemoryRange) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMappedMemoryRange, STRUCT_CACHE_VkMappedMemoryRange);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMappedMemoryRange, STRUCT_CACHE_VkMappedMemoryRange);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMappedMemoryRange'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memory = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkMappedMemoryRange.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMappedMemoryRange.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMappedMemoryRange.pNext' isn't allowed to be filled");
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkMappedMemoryRange.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkMappedMemoryRange.offset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkMappedMemoryRange.size")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkMappedMemoryRange.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._memory = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

VkMappedMemoryRange.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMappedMemoryRange.prototype.reflect = function reflect(memoryAddress) {
  };

VkMappedMemoryRange.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMappedMemoryRange();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  copy.offset = original.offset;
  copy.size = original.size;
  
  return copy;
};

VkMappedMemoryRange.byteLength = 0x0;

VkMappedMemoryRange.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFormatProperties **/
function VkFormatProperties(opts, byteOffset) {
  if (new.target !== VkFormatProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFormatProperties, STRUCT_CACHE_VkFormatProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFormatProperties, STRUCT_CACHE_VkFormatProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFormatProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkFormatProperties.prototype, {
  "linearTilingFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "optimalTilingFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "bufferFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkFormatProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkFormatProperties.prototype.flush = function flush() {
  
  return true;
};

VkFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkFormatProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFormatProperties();
  copy.linearTilingFeatures = original.linearTilingFeatures;
  copy.optimalTilingFeatures = original.optimalTilingFeatures;
  copy.bufferFeatures = original.bufferFeatures;
  
  return copy;
};

VkFormatProperties.byteLength = 0x0;

VkFormatProperties.memoryLayout = {
  linearTilingFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  optimalTilingFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageFormatProperties **/
function VkImageFormatProperties(opts, byteOffset) {
  if (new.target !== VkImageFormatProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageFormatProperties, STRUCT_CACHE_VkImageFormatProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageFormatProperties, STRUCT_CACHE_VkImageFormatProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageFormatProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._maxExtent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkImageFormatProperties.prototype, {
  "maxExtent": {
    get() {
    return this._maxExtent;
    },
    },
  "maxMipLevels": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxArrayLayers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "sampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "maxResourceSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkImageFormatProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._maxExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxExtent.memoryBuffer) this._maxExtent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxExtent.reset();
  }
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkImageFormatProperties.prototype.flush = function flush() {
  
  return true;
};

VkImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkImageFormatProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageFormatProperties();
  if (original.maxExtent !== null) {
        copy.maxExtent = original.maxExtent.constructor.createCopyFrom(original.maxExtent);
      }
  copy.maxMipLevels = original.maxMipLevels;
  copy.maxArrayLayers = original.maxArrayLayers;
  copy.sampleCounts = original.sampleCounts;
  copy.maxResourceSize = original.maxResourceSize;
  
  return copy;
};

VkImageFormatProperties.byteLength = 0x0;

VkImageFormatProperties.memoryLayout = {
  maxExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMipLevels: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxArrayLayers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxResourceSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorBufferInfo **/
function VkDescriptorBufferInfo(opts, byteOffset) {
  if (new.target !== VkDescriptorBufferInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorBufferInfo, STRUCT_CACHE_VkDescriptorBufferInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorBufferInfo, STRUCT_CACHE_VkDescriptorBufferInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorBufferInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._buffer = null;
  
  
  
  if (typeof opts === "object") {
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.range !== void 0) this.range = opts.range;
    
  }
};

Object.defineProperties(VkDescriptorBufferInfo.prototype, {
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorBufferInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDescriptorBufferInfo.offset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "range": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDescriptorBufferInfo.range")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkDescriptorBufferInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._buffer = null;
  
  
  
  if (typeof opts === "object") {
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.range !== void 0) this.range = opts.range;
    
  }
};

VkDescriptorBufferInfo.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorBufferInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorBufferInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorBufferInfo();
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  copy.offset = original.offset;
  copy.range = original.range;
  
  return copy;
};

VkDescriptorBufferInfo.byteLength = 0x0;

VkDescriptorBufferInfo.memoryLayout = {
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  range: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorImageInfo **/
function VkDescriptorImageInfo(opts, byteOffset) {
  if (new.target !== VkDescriptorImageInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorImageInfo, STRUCT_CACHE_VkDescriptorImageInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorImageInfo, STRUCT_CACHE_VkDescriptorImageInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorImageInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._sampler = null;
  this._imageView = null;
  
  
  if (typeof opts === "object") {
    if (opts.sampler !== void 0) this.sampler = opts.sampler;
    if (opts.imageView !== void 0) this.imageView = opts.imageView;
    if (opts.imageLayout !== void 0) this.imageLayout = opts.imageLayout;
    
  }
};

Object.defineProperties(VkDescriptorImageInfo.prototype, {
  "sampler": {
    get() {
    return this._sampler;
    },
    set(value) {
    if (value !== null && value.constructor === VkSampler) {
      
      this._sampler = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._sampler = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorImageInfo.sampler': Expected 'VkSampler' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageView": {
    get() {
    return this._imageView;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageView) {
      
      this._imageView = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._imageView = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorImageInfo.imageView': Expected 'VkImageView' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorImageInfo.imageLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkDescriptorImageInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._sampler = null;
  this._imageView = null;
  
  
  if (typeof opts === "object") {
    if (opts.sampler !== void 0) this.sampler = opts.sampler;
    if (opts.imageView !== void 0) this.imageView = opts.imageView;
    if (opts.imageLayout !== void 0) this.imageLayout = opts.imageLayout;
    
  }
};

VkDescriptorImageInfo.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorImageInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorImageInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorImageInfo();
  if (original.sampler !== null) {
        copy.sampler = original.sampler.constructor.createCopyFrom(original.sampler);
      }
  if (original.imageView !== null) {
        copy.imageView = original.imageView.constructor.createCopyFrom(original.imageView);
      }
  copy.imageLayout = original.imageLayout;
  
  return copy;
};

VkDescriptorImageInfo.byteLength = 0x0;

VkDescriptorImageInfo.memoryLayout = {
  sampler: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageView: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkWriteDescriptorSet **/
function VkWriteDescriptorSet(opts, byteOffset) {
  if (new.target !== VkWriteDescriptorSet) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkWriteDescriptorSet, STRUCT_CACHE_VkWriteDescriptorSet);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkWriteDescriptorSet, STRUCT_CACHE_VkWriteDescriptorSet);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkWriteDescriptorSet'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._dstSet = null;
  
  
  
  
  this._pImageInfo = null;
  this._pImageInfoNative = null;
  this._pBufferInfo = null;
  this._pBufferInfoNative = null;
  this._pTexelBufferView = null;
  this._pTexelBufferViewNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dstSet !== void 0) this.dstSet = opts.dstSet;
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.pImageInfo !== void 0) this.pImageInfo = opts.pImageInfo;
    if (opts.pBufferInfo !== void 0) this.pBufferInfo = opts.pBufferInfo;
    if (opts.pTexelBufferView !== void 0) this.pTexelBufferView = opts.pTexelBufferView;
    
  }
};

Object.defineProperties(VkWriteDescriptorSet.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSet.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pNext'");
    }
    
    }
    },
  "dstSet": {
    get() {
    return this._dstSet;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._dstSet = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dstSet = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.dstSet': Expected 'VkDescriptorSet' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstBinding": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSet.dstBinding");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "dstArrayElement": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSet.dstArrayElement");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSet.descriptorCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "descriptorType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSet.descriptorType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pImageInfo": {
    get() {
    if (this._pImageInfo === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.descriptorCount, VkDescriptorImageInfo);
      this._pImageInfo = array;
      return this.pImageInfo;
    } else {
      return this._pImageInfo;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pImageInfo = value;
    } else if (value === null) {
      this._pImageInfo = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pImageInfo': Expected 'Array VkDescriptorImageInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pBufferInfo": {
    get() {
    if (this._pBufferInfo === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.descriptorCount, VkDescriptorBufferInfo);
      this._pBufferInfo = array;
      return this.pBufferInfo;
    } else {
      return this._pBufferInfo;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBufferInfo = value;
    } else if (value === null) {
      this._pBufferInfo = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pBufferInfo': Expected 'Array VkDescriptorBufferInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pTexelBufferView": {
    get() {
    if (this._pTexelBufferView === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.descriptorCount, VkBufferView);
      this._pTexelBufferView = array;
      return this.pTexelBufferView;
    } else {
      return this._pTexelBufferView;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pTexelBufferView = value;
    } else if (value === null) {
      this._pTexelBufferView = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pTexelBufferView': Expected 'Array VkBufferView' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkWriteDescriptorSet.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._dstSet = null;
  
  
  
  
  this._pImageInfo = null;
  this._pImageInfoNative = null;
  this._pBufferInfo = null;
  this._pBufferInfoNative = null;
  this._pTexelBufferView = null;
  this._pTexelBufferViewNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dstSet !== void 0) this.dstSet = opts.dstSet;
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.pImageInfo !== void 0) this.pImageInfo = opts.pImageInfo;
    if (opts.pBufferInfo !== void 0) this.pBufferInfo = opts.pBufferInfo;
    if (opts.pTexelBufferView !== void 0) this.pTexelBufferView = opts.pTexelBufferView;
    
  }
};

VkWriteDescriptorSet.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pImageInfo !== null) {
    let array = this._pImageInfo;
    
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkWriteDescriptorSet.pImageInfo'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorImageInfo)) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pImageInfo[" + ii + "]': Expected 'VkDescriptorImageInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pImageInfoNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pImageInfoNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pBufferInfo !== null) {
    let array = this._pBufferInfo;
    
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkWriteDescriptorSet.pBufferInfo'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorBufferInfo)) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pBufferInfo[" + ii + "]': Expected 'VkDescriptorBufferInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBufferInfoNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pBufferInfoNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pTexelBufferView !== null) {
    let array = this._pTexelBufferView;
    
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkWriteDescriptorSet.pTexelBufferView'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkBufferView)) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pTexelBufferView[" + ii + "]': Expected 'VkBufferView' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pTexelBufferViewNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pTexelBufferViewNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkWriteDescriptorSet.prototype.reflect = function reflect(memoryAddress) {
  };

VkWriteDescriptorSet.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkWriteDescriptorSet();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.dstSet !== null) {
        copy.dstSet = original.dstSet.constructor.createCopyFrom(original.dstSet);
      }
  copy.dstBinding = original.dstBinding;
  copy.dstArrayElement = original.dstArrayElement;
  copy.descriptorCount = original.descriptorCount;
  copy.descriptorType = original.descriptorType;
  if (original.pImageInfo !== null) {
        copy.pImageInfo = [...Array(original.pImageInfo.length)].map((v, i) => {
          return original.pImageInfo[i].constructor.createCopyFrom(original.pImageInfo[i]);
        });
      }
  if (original.pBufferInfo !== null) {
        copy.pBufferInfo = [...Array(original.pBufferInfo.length)].map((v, i) => {
          return original.pBufferInfo[i].constructor.createCopyFrom(original.pBufferInfo[i]);
        });
      }
  if (original.pTexelBufferView !== null) {
        copy.pTexelBufferView = [...Array(original.pTexelBufferView.length)].map((v, i) => {
          return original.pTexelBufferView[i].constructor.createCopyFrom(original.pTexelBufferView[i]);
        });
      }
  
  return copy;
};

VkWriteDescriptorSet.byteLength = 0x0;

VkWriteDescriptorSet.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSet: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstBinding: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstArrayElement: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pImageInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pBufferInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pTexelBufferView: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCopyDescriptorSet **/
function VkCopyDescriptorSet(opts, byteOffset) {
  if (new.target !== VkCopyDescriptorSet) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCopyDescriptorSet, STRUCT_CACHE_VkCopyDescriptorSet);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCopyDescriptorSet, STRUCT_CACHE_VkCopyDescriptorSet);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCopyDescriptorSet'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcSet = null;
  
  
  this._dstSet = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSet !== void 0) this.srcSet = opts.srcSet;
    if (opts.srcBinding !== void 0) this.srcBinding = opts.srcBinding;
    if (opts.srcArrayElement !== void 0) this.srcArrayElement = opts.srcArrayElement;
    if (opts.dstSet !== void 0) this.dstSet = opts.dstSet;
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    
  }
};

Object.defineProperties(VkCopyDescriptorSet.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyDescriptorSet.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCopyDescriptorSet.pNext' isn't allowed to be filled");
    }
    },
  "srcSet": {
    get() {
    return this._srcSet;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._srcSet = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._srcSet = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.srcSet': Expected 'VkDescriptorSet' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcBinding": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyDescriptorSet.srcBinding");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "srcArrayElement": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyDescriptorSet.srcArrayElement");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "dstSet": {
    get() {
    return this._dstSet;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._dstSet = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dstSet = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.dstSet': Expected 'VkDescriptorSet' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstBinding": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyDescriptorSet.dstBinding");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "dstArrayElement": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyDescriptorSet.dstArrayElement");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyDescriptorSet.descriptorCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkCopyDescriptorSet.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._srcSet = null;
  
  
  this._dstSet = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSet !== void 0) this.srcSet = opts.srcSet;
    if (opts.srcBinding !== void 0) this.srcBinding = opts.srcBinding;
    if (opts.srcArrayElement !== void 0) this.srcArrayElement = opts.srcArrayElement;
    if (opts.dstSet !== void 0) this.dstSet = opts.dstSet;
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    
  }
};

VkCopyDescriptorSet.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCopyDescriptorSet.prototype.reflect = function reflect(memoryAddress) {
  };

VkCopyDescriptorSet.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCopyDescriptorSet();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcSet !== null) {
        copy.srcSet = original.srcSet.constructor.createCopyFrom(original.srcSet);
      }
  copy.srcBinding = original.srcBinding;
  copy.srcArrayElement = original.srcArrayElement;
  if (original.dstSet !== null) {
        copy.dstSet = original.dstSet.constructor.createCopyFrom(original.dstSet);
      }
  copy.dstBinding = original.dstBinding;
  copy.dstArrayElement = original.dstArrayElement;
  copy.descriptorCount = original.descriptorCount;
  
  return copy;
};

VkCopyDescriptorSet.byteLength = 0x0;

VkCopyDescriptorSet.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcSet: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcBinding: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcArrayElement: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSet: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstBinding: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstArrayElement: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferCreateInfo **/
function VkBufferCreateInfo(opts, byteOffset) {
  if (new.target !== VkBufferCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferCreateInfo, STRUCT_CACHE_VkBufferCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferCreateInfo, STRUCT_CACHE_VkBufferCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this._pQueueFamilyIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    
  }
};

Object.defineProperties(VkBufferCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBufferCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkBufferCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferCreateInfo.size")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferCreateInfo.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "sharingMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferCreateInfo.sharingMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "queueFamilyIndexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferCreateInfo.queueFamilyIndexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pQueueFamilyIndices": {
    get() {
    return this._pQueueFamilyIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this._pQueueFamilyIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    
  }
};

VkBufferCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.size = original.size;
  copy.usage = original.usage;
  copy.sharingMode = original.sharingMode;
  copy.queueFamilyIndexCount = original.queueFamilyIndexCount;
  if (original.pQueueFamilyIndices !== null) {
        copy.pQueueFamilyIndices = new Uint32Array(original.pQueueFamilyIndices);
      }
  
  return copy;
};

VkBufferCreateInfo.byteLength = 0x0;

VkBufferCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sharingMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueFamilyIndexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pQueueFamilyIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferViewCreateInfo **/
function VkBufferViewCreateInfo(opts, byteOffset) {
  if (new.target !== VkBufferViewCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferViewCreateInfo, STRUCT_CACHE_VkBufferViewCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferViewCreateInfo, STRUCT_CACHE_VkBufferViewCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferViewCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._buffer = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.range !== void 0) this.range = opts.range;
    
  }
};

Object.defineProperties(VkBufferViewCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferViewCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferViewCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferViewCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferViewCreateInfo.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "offset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferViewCreateInfo.offset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "range": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferViewCreateInfo.range")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBufferViewCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._buffer = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.range !== void 0) this.range = opts.range;
    
  }
};

VkBufferViewCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferViewCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferViewCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferViewCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  copy.format = original.format;
  copy.offset = original.offset;
  copy.range = original.range;
  
  return copy;
};

VkBufferViewCreateInfo.byteLength = 0x0;

VkBufferViewCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  range: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageSubresource **/
function VkImageSubresource(opts, byteOffset) {
  if (new.target !== VkImageSubresource) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageSubresource, STRUCT_CACHE_VkImageSubresource);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageSubresource, STRUCT_CACHE_VkImageSubresource);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageSubresource'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.mipLevel !== void 0) this.mipLevel = opts.mipLevel;
    if (opts.arrayLayer !== void 0) this.arrayLayer = opts.arrayLayer;
    
  }
};

Object.defineProperties(VkImageSubresource.prototype, {
  "aspectMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresource.aspectMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "mipLevel": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresource.mipLevel");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "arrayLayer": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresource.arrayLayer");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkImageSubresource.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.mipLevel !== void 0) this.mipLevel = opts.mipLevel;
    if (opts.arrayLayer !== void 0) this.arrayLayer = opts.arrayLayer;
    
  }
};

VkImageSubresource.prototype.flush = function flush() {
  
  return true;
};

VkImageSubresource.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageSubresource.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageSubresource();
  copy.aspectMask = original.aspectMask;
  copy.mipLevel = original.mipLevel;
  copy.arrayLayer = original.arrayLayer;
  
  return copy;
};

VkImageSubresource.byteLength = 0x0;

VkImageSubresource.memoryLayout = {
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mipLevel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  arrayLayer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageSubresourceLayers **/
function VkImageSubresourceLayers(opts, byteOffset) {
  if (new.target !== VkImageSubresourceLayers) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageSubresourceLayers, STRUCT_CACHE_VkImageSubresourceLayers);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageSubresourceLayers, STRUCT_CACHE_VkImageSubresourceLayers);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageSubresourceLayers'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.mipLevel !== void 0) this.mipLevel = opts.mipLevel;
    if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    
  }
};

Object.defineProperties(VkImageSubresourceLayers.prototype, {
  "aspectMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresourceLayers.aspectMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "mipLevel": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresourceLayers.mipLevel");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "baseArrayLayer": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresourceLayers.baseArrayLayer");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "layerCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresourceLayers.layerCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkImageSubresourceLayers.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.mipLevel !== void 0) this.mipLevel = opts.mipLevel;
    if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    
  }
};

VkImageSubresourceLayers.prototype.flush = function flush() {
  
  return true;
};

VkImageSubresourceLayers.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageSubresourceLayers.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageSubresourceLayers();
  copy.aspectMask = original.aspectMask;
  copy.mipLevel = original.mipLevel;
  copy.baseArrayLayer = original.baseArrayLayer;
  copy.layerCount = original.layerCount;
  
  return copy;
};

VkImageSubresourceLayers.byteLength = 0x0;

VkImageSubresourceLayers.memoryLayout = {
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mipLevel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  baseArrayLayer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layerCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageSubresourceRange **/
function VkImageSubresourceRange(opts, byteOffset) {
  if (new.target !== VkImageSubresourceRange) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageSubresourceRange, STRUCT_CACHE_VkImageSubresourceRange);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageSubresourceRange, STRUCT_CACHE_VkImageSubresourceRange);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageSubresourceRange'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.baseMipLevel !== void 0) this.baseMipLevel = opts.baseMipLevel;
    if (opts.levelCount !== void 0) this.levelCount = opts.levelCount;
    if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    
  }
};

Object.defineProperties(VkImageSubresourceRange.prototype, {
  "aspectMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresourceRange.aspectMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "baseMipLevel": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresourceRange.baseMipLevel");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "levelCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresourceRange.levelCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "baseArrayLayer": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresourceRange.baseArrayLayer");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "layerCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSubresourceRange.layerCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkImageSubresourceRange.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.baseMipLevel !== void 0) this.baseMipLevel = opts.baseMipLevel;
    if (opts.levelCount !== void 0) this.levelCount = opts.levelCount;
    if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    
  }
};

VkImageSubresourceRange.prototype.flush = function flush() {
  
  return true;
};

VkImageSubresourceRange.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageSubresourceRange.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageSubresourceRange();
  copy.aspectMask = original.aspectMask;
  copy.baseMipLevel = original.baseMipLevel;
  copy.levelCount = original.levelCount;
  copy.baseArrayLayer = original.baseArrayLayer;
  copy.layerCount = original.layerCount;
  
  return copy;
};

VkImageSubresourceRange.byteLength = 0x0;

VkImageSubresourceRange.memoryLayout = {
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  baseMipLevel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  levelCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  baseArrayLayer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layerCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryBarrier **/
function VkMemoryBarrier(opts, byteOffset) {
  if (new.target !== VkMemoryBarrier) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryBarrier, STRUCT_CACHE_VkMemoryBarrier);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryBarrier, STRUCT_CACHE_VkMemoryBarrier);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryBarrier'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    
  }
};

Object.defineProperties(VkMemoryBarrier.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryBarrier.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryBarrier.pNext' isn't allowed to be filled");
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryBarrier.srcAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryBarrier.dstAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkMemoryBarrier.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    
  }
};

VkMemoryBarrier.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryBarrier.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryBarrier.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryBarrier();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.srcAccessMask = original.srcAccessMask;
  copy.dstAccessMask = original.dstAccessMask;
  
  return copy;
};

VkMemoryBarrier.byteLength = 0x0;

VkMemoryBarrier.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferMemoryBarrier **/
function VkBufferMemoryBarrier(opts, byteOffset) {
  if (new.target !== VkBufferMemoryBarrier) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferMemoryBarrier, STRUCT_CACHE_VkBufferMemoryBarrier);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferMemoryBarrier, STRUCT_CACHE_VkBufferMemoryBarrier);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferMemoryBarrier'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this._buffer = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.srcQueueFamilyIndex !== void 0) this.srcQueueFamilyIndex = opts.srcQueueFamilyIndex;
    if (opts.dstQueueFamilyIndex !== void 0) this.dstQueueFamilyIndex = opts.dstQueueFamilyIndex;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkBufferMemoryBarrier.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferMemoryBarrier.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferMemoryBarrier.pNext' isn't allowed to be filled");
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferMemoryBarrier.srcAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferMemoryBarrier.dstAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "srcQueueFamilyIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferMemoryBarrier.srcQueueFamilyIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "dstQueueFamilyIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferMemoryBarrier.dstQueueFamilyIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferMemoryBarrier.offset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferMemoryBarrier.size")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBufferMemoryBarrier.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._buffer = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.srcQueueFamilyIndex !== void 0) this.srcQueueFamilyIndex = opts.srcQueueFamilyIndex;
    if (opts.dstQueueFamilyIndex !== void 0) this.dstQueueFamilyIndex = opts.dstQueueFamilyIndex;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

VkBufferMemoryBarrier.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferMemoryBarrier.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferMemoryBarrier.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferMemoryBarrier();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.srcAccessMask = original.srcAccessMask;
  copy.dstAccessMask = original.dstAccessMask;
  copy.srcQueueFamilyIndex = original.srcQueueFamilyIndex;
  copy.dstQueueFamilyIndex = original.dstQueueFamilyIndex;
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  copy.offset = original.offset;
  copy.size = original.size;
  
  return copy;
};

VkBufferMemoryBarrier.byteLength = 0x0;

VkBufferMemoryBarrier.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcQueueFamilyIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstQueueFamilyIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageMemoryBarrier **/
function VkImageMemoryBarrier(opts, byteOffset) {
  if (new.target !== VkImageMemoryBarrier) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageMemoryBarrier, STRUCT_CACHE_VkImageMemoryBarrier);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageMemoryBarrier, STRUCT_CACHE_VkImageMemoryBarrier);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageMemoryBarrier'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  this._image = null;
  this._subresourceRange = new VkImageSubresourceRange({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.oldLayout !== void 0) this.oldLayout = opts.oldLayout;
    if (opts.newLayout !== void 0) this.newLayout = opts.newLayout;
    if (opts.srcQueueFamilyIndex !== void 0) this.srcQueueFamilyIndex = opts.srcQueueFamilyIndex;
    if (opts.dstQueueFamilyIndex !== void 0) this.dstQueueFamilyIndex = opts.dstQueueFamilyIndex;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.subresourceRange !== void 0) this.subresourceRange = opts.subresourceRange;
    
  }
};

Object.defineProperties(VkImageMemoryBarrier.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageMemoryBarrier.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageMemoryBarrier.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageMemoryBarrier.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.pNext'");
    }
    
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageMemoryBarrier.srcAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageMemoryBarrier.dstAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "oldLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageMemoryBarrier.oldLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "newLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageMemoryBarrier.newLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "srcQueueFamilyIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageMemoryBarrier.srcQueueFamilyIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "dstQueueFamilyIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageMemoryBarrier.dstQueueFamilyIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "subresourceRange": {
    get() {
    return this._subresourceRange;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceRange) {
      value.flush();
      this._subresourceRange = value;
      
      
    } else if (value === null) {
      this._subresourceRange = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.subresourceRange': Expected 'VkImageSubresourceRange' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageMemoryBarrier.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  this._image = null;
  if (this._subresourceRange !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._subresourceRange.memoryBuffer) this._subresourceRange = new VkImageSubresourceRange({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._subresourceRange.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.oldLayout !== void 0) this.oldLayout = opts.oldLayout;
    if (opts.newLayout !== void 0) this.newLayout = opts.newLayout;
    if (opts.srcQueueFamilyIndex !== void 0) this.srcQueueFamilyIndex = opts.srcQueueFamilyIndex;
    if (opts.dstQueueFamilyIndex !== void 0) this.dstQueueFamilyIndex = opts.dstQueueFamilyIndex;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.subresourceRange !== void 0) this.subresourceRange = opts.subresourceRange;
    
  }
};

VkImageMemoryBarrier.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._subresourceRange !== null) {
    let subresourceRange = this._subresourceRange;
    subresourceRange.flush();
    if (this.memoryBuffer !== subresourceRange.memoryBuffer) {
      let srcView = new Uint8Array(subresourceRange.memoryBuffer, subresourceRange.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageMemoryBarrier.subresourceRange' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageMemoryBarrier.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageMemoryBarrier.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageMemoryBarrier();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.srcAccessMask = original.srcAccessMask;
  copy.dstAccessMask = original.dstAccessMask;
  copy.oldLayout = original.oldLayout;
  copy.newLayout = original.newLayout;
  copy.srcQueueFamilyIndex = original.srcQueueFamilyIndex;
  copy.dstQueueFamilyIndex = original.dstQueueFamilyIndex;
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  if (original.subresourceRange !== null) {
        copy.subresourceRange = original.subresourceRange.constructor.createCopyFrom(original.subresourceRange);
      }
  
  return copy;
};

VkImageMemoryBarrier.byteLength = 0x0;

VkImageMemoryBarrier.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  oldLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  newLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcQueueFamilyIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstQueueFamilyIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subresourceRange: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageCreateInfo **/
function VkImageCreateInfo(opts, byteOffset) {
  if (new.target !== VkImageCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageCreateInfo, STRUCT_CACHE_VkImageCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageCreateInfo, STRUCT_CACHE_VkImageCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  
  
  this._pQueueFamilyIndices = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.imageType !== void 0) this.imageType = opts.imageType;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.extent !== void 0) this.extent = opts.extent;
    if (opts.mipLevels !== void 0) this.mipLevels = opts.mipLevels;
    if (opts.arrayLayers !== void 0) this.arrayLayers = opts.arrayLayers;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    
  }
};

Object.defineProperties(VkImageCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "imageType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.imageType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.extent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "mipLevels": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.mipLevels");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "arrayLayers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.arrayLayers");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "samples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.samples");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "tiling": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.tiling");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "sharingMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.sharingMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "queueFamilyIndexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.queueFamilyIndexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pQueueFamilyIndices": {
    get() {
    return this._pQueueFamilyIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "initialLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCreateInfo.initialLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImageCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  if (this._extent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._extent.memoryBuffer) this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._extent.reset();
  }
  
  
  
  
  
  
  
  this._pQueueFamilyIndices = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.imageType !== void 0) this.imageType = opts.imageType;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.extent !== void 0) this.extent = opts.extent;
    if (opts.mipLevels !== void 0) this.mipLevels = opts.mipLevels;
    if (opts.arrayLayers !== void 0) this.arrayLayers = opts.arrayLayers;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    
  }
};

VkImageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer, extent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCreateInfo.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.imageType = original.imageType;
  copy.format = original.format;
  if (original.extent !== null) {
        copy.extent = original.extent.constructor.createCopyFrom(original.extent);
      }
  copy.mipLevels = original.mipLevels;
  copy.arrayLayers = original.arrayLayers;
  copy.samples = original.samples;
  copy.tiling = original.tiling;
  copy.usage = original.usage;
  copy.sharingMode = original.sharingMode;
  copy.queueFamilyIndexCount = original.queueFamilyIndexCount;
  if (original.pQueueFamilyIndices !== null) {
        copy.pQueueFamilyIndices = new Uint32Array(original.pQueueFamilyIndices);
      }
  copy.initialLayout = original.initialLayout;
  
  return copy;
};

VkImageCreateInfo.byteLength = 0x0;

VkImageCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mipLevels: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  arrayLayers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tiling: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sharingMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueFamilyIndexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pQueueFamilyIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  initialLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubresourceLayout **/
function VkSubresourceLayout(opts, byteOffset) {
  if (new.target !== VkSubresourceLayout) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubresourceLayout, STRUCT_CACHE_VkSubresourceLayout);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubresourceLayout, STRUCT_CACHE_VkSubresourceLayout);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubresourceLayout'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkSubresourceLayout.prototype, {
  "offset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "rowPitch": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "arrayPitch": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "depthPitch": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkSubresourceLayout.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkSubresourceLayout.prototype.flush = function flush() {
  
  return true;
};

VkSubresourceLayout.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSubresourceLayout.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubresourceLayout();
  copy.offset = original.offset;
  copy.size = original.size;
  copy.rowPitch = original.rowPitch;
  copy.arrayPitch = original.arrayPitch;
  copy.depthPitch = original.depthPitch;
  
  return copy;
};

VkSubresourceLayout.byteLength = 0x0;

VkSubresourceLayout.memoryLayout = {
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rowPitch: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  arrayPitch: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthPitch: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageViewCreateInfo **/
function VkImageViewCreateInfo(opts, byteOffset) {
  if (new.target !== VkImageViewCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageViewCreateInfo, STRUCT_CACHE_VkImageViewCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageViewCreateInfo, STRUCT_CACHE_VkImageViewCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageViewCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._image = null;
  
  
  this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._subresourceRange = new VkImageSubresourceRange({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.viewType !== void 0) this.viewType = opts.viewType;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.components !== void 0) this.components = opts.components;
    if (opts.subresourceRange !== void 0) this.subresourceRange = opts.subresourceRange;
    
  }
};

Object.defineProperties(VkImageViewCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageViewCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageViewCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "viewType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewCreateInfo.viewType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewCreateInfo.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "components": {
    get() {
    return this._components;
    },
    set(value) {
    if (value !== null && value.constructor === VkComponentMapping) {
      value.flush();
      this._components = value;
      
      
    } else if (value === null) {
      this._components = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.components': Expected 'VkComponentMapping' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "subresourceRange": {
    get() {
    return this._subresourceRange;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceRange) {
      value.flush();
      this._subresourceRange = value;
      
      
    } else if (value === null) {
      this._subresourceRange = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.subresourceRange': Expected 'VkImageSubresourceRange' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageViewCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._image = null;
  
  
  if (this._components !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._components.memoryBuffer) this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._components.reset();
  }
  if (this._subresourceRange !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._subresourceRange.memoryBuffer) this._subresourceRange = new VkImageSubresourceRange({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._subresourceRange.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.viewType !== void 0) this.viewType = opts.viewType;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.components !== void 0) this.components = opts.components;
    if (opts.subresourceRange !== void 0) this.subresourceRange = opts.subresourceRange;
    
  }
};

VkImageViewCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._components !== null) {
    let components = this._components;
    components.flush();
    if (this.memoryBuffer !== components.memoryBuffer) {
      let srcView = new Uint8Array(components.memoryBuffer, components.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageViewCreateInfo.components' isn't used as shared-memory");
    }
  }
  
  
  if (this._subresourceRange !== null) {
    let subresourceRange = this._subresourceRange;
    subresourceRange.flush();
    if (this.memoryBuffer !== subresourceRange.memoryBuffer) {
      let srcView = new Uint8Array(subresourceRange.memoryBuffer, subresourceRange.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageViewCreateInfo.subresourceRange' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageViewCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageViewCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageViewCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  copy.viewType = original.viewType;
  copy.format = original.format;
  if (original.components !== null) {
        copy.components = original.components.constructor.createCopyFrom(original.components);
      }
  if (original.subresourceRange !== null) {
        copy.subresourceRange = original.subresourceRange.constructor.createCopyFrom(original.subresourceRange);
      }
  
  return copy;
};

VkImageViewCreateInfo.byteLength = 0x0;

VkImageViewCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  components: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subresourceRange: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferCopy **/
function VkBufferCopy(opts, byteOffset) {
  if (new.target !== VkBufferCopy) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferCopy, STRUCT_CACHE_VkBufferCopy);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferCopy, STRUCT_CACHE_VkBufferCopy);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferCopy'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkBufferCopy.prototype, {
  "srcOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferCopy.srcOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "dstOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferCopy.dstOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferCopy.size")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBufferCopy.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

VkBufferCopy.prototype.flush = function flush() {
  
  return true;
};

VkBufferCopy.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferCopy.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferCopy();
  copy.srcOffset = original.srcOffset;
  copy.dstOffset = original.dstOffset;
  copy.size = original.size;
  
  return copy;
};

VkBufferCopy.byteLength = 0x0;

VkBufferCopy.memoryLayout = {
  srcOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseMemoryBind **/
function VkSparseMemoryBind(opts, byteOffset) {
  if (new.target !== VkSparseMemoryBind) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseMemoryBind, STRUCT_CACHE_VkSparseMemoryBind);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseMemoryBind, STRUCT_CACHE_VkSparseMemoryBind);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseMemoryBind'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  this._memory = null;
  
  
  
  if (typeof opts === "object") {
    if (opts.resourceOffset !== void 0) this.resourceOffset = opts.resourceOffset;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkSparseMemoryBind.prototype, {
  "resourceOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkSparseMemoryBind.resourceOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkSparseMemoryBind.size")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkSparseMemoryBind.memoryOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSparseMemoryBind.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSparseMemoryBind.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  this._memory = null;
  
  
  
  if (typeof opts === "object") {
    if (opts.resourceOffset !== void 0) this.resourceOffset = opts.resourceOffset;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkSparseMemoryBind.prototype.flush = function flush() {
  
  return true;
};

VkSparseMemoryBind.prototype.reflect = function reflect(memoryAddress) {
  };

VkSparseMemoryBind.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseMemoryBind();
  copy.resourceOffset = original.resourceOffset;
  copy.size = original.size;
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  copy.memoryOffset = original.memoryOffset;
  copy.flags = original.flags;
  
  return copy;
};

VkSparseMemoryBind.byteLength = 0x0;

VkSparseMemoryBind.memoryLayout = {
  resourceOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseImageMemoryBind **/
function VkSparseImageMemoryBind(opts, byteOffset) {
  if (new.target !== VkSparseImageMemoryBind) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseImageMemoryBind, STRUCT_CACHE_VkSparseImageMemoryBind);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseImageMemoryBind, STRUCT_CACHE_VkSparseImageMemoryBind);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseImageMemoryBind'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._subresource = new VkImageSubresource({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._offset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._memory = null;
  
  
  
  if (typeof opts === "object") {
    if (opts.subresource !== void 0) this.subresource = opts.subresource;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkSparseImageMemoryBind.prototype, {
  "subresource": {
    get() {
    return this._subresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresource) {
      value.flush();
      this._subresource = value;
      
      
    } else if (value === null) {
      this._subresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.subresource': Expected 'VkImageSubresource' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this._offset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._offset = value;
      
      
    } else if (value === null) {
      this._offset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.offset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.extent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkSparseImageMemoryBind.memoryOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSparseImageMemoryBind.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSparseImageMemoryBind.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._subresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._subresource.memoryBuffer) this._subresource = new VkImageSubresource({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._subresource.reset();
  }
  if (this._offset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._offset.memoryBuffer) this._offset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._offset.reset();
  }
  if (this._extent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._extent.memoryBuffer) this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._extent.reset();
  }
  this._memory = null;
  
  
  
  if (typeof opts === "object") {
    if (opts.subresource !== void 0) this.subresource = opts.subresource;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkSparseImageMemoryBind.prototype.flush = function flush() {
  
  
  if (this._subresource !== null) {
    let subresource = this._subresource;
    subresource.flush();
    if (this.memoryBuffer !== subresource.memoryBuffer) {
      let srcView = new Uint8Array(subresource.memoryBuffer, subresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSparseImageMemoryBind.subresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._offset !== null) {
    let offset = this._offset;
    offset.flush();
    if (this.memoryBuffer !== offset.memoryBuffer) {
      let srcView = new Uint8Array(offset.memoryBuffer, offset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSparseImageMemoryBind.offset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer, extent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSparseImageMemoryBind.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSparseImageMemoryBind.prototype.reflect = function reflect(memoryAddress) {
  };

VkSparseImageMemoryBind.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseImageMemoryBind();
  if (original.subresource !== null) {
        copy.subresource = original.subresource.constructor.createCopyFrom(original.subresource);
      }
  if (original.offset !== null) {
        copy.offset = original.offset.constructor.createCopyFrom(original.offset);
      }
  if (original.extent !== null) {
        copy.extent = original.extent.constructor.createCopyFrom(original.extent);
      }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  copy.memoryOffset = original.memoryOffset;
  copy.flags = original.flags;
  
  return copy;
};

VkSparseImageMemoryBind.byteLength = 0x0;

VkSparseImageMemoryBind.memoryLayout = {
  subresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseBufferMemoryBindInfo **/
function VkSparseBufferMemoryBindInfo(opts, byteOffset) {
  if (new.target !== VkSparseBufferMemoryBindInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseBufferMemoryBindInfo, STRUCT_CACHE_VkSparseBufferMemoryBindInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseBufferMemoryBindInfo, STRUCT_CACHE_VkSparseBufferMemoryBindInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseBufferMemoryBindInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._buffer = null;
  
  this._pBinds = null;
  this._pBindsNative = null;
  
  if (typeof opts === "object") {
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
    if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
    
  }
};

Object.defineProperties(VkSparseBufferMemoryBindInfo.prototype, {
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "bindCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSparseBufferMemoryBindInfo.bindCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pBinds": {
    get() {
    if (this._pBinds === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.bindCount, VkSparseMemoryBind);
      this._pBinds = array;
      return this.pBinds;
    } else {
      return this._pBinds;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBinds = value;
    } else if (value === null) {
      this._pBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.pBinds': Expected 'Array VkSparseMemoryBind' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkSparseBufferMemoryBindInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._buffer = null;
  
  this._pBinds = null;
  this._pBindsNative = null;
  
  if (typeof opts === "object") {
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
    if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
    
  }
};

VkSparseBufferMemoryBindInfo.prototype.flush = function flush() {
  
  
  if (this._pBinds !== null) {
    let array = this._pBinds;
    
    if (array.length !== this.bindCount) {
      throw new RangeError("Invalid array length, expected length of 'bindCount' for 'VkSparseBufferMemoryBindInfo.pBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseMemoryBind)) {
        throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.pBinds[" + ii + "]': Expected 'VkSparseMemoryBind' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBindsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pBindsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSparseBufferMemoryBindInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSparseBufferMemoryBindInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseBufferMemoryBindInfo();
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  copy.bindCount = original.bindCount;
  if (original.pBinds !== null) {
        copy.pBinds = [...Array(original.pBinds.length)].map((v, i) => {
          return original.pBinds[i].constructor.createCopyFrom(original.pBinds[i]);
        });
      }
  
  return copy;
};

VkSparseBufferMemoryBindInfo.byteLength = 0x0;

VkSparseBufferMemoryBindInfo.memoryLayout = {
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bindCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pBinds: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseImageOpaqueMemoryBindInfo **/
function VkSparseImageOpaqueMemoryBindInfo(opts, byteOffset) {
  if (new.target !== VkSparseImageOpaqueMemoryBindInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseImageOpaqueMemoryBindInfo, STRUCT_CACHE_VkSparseImageOpaqueMemoryBindInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseImageOpaqueMemoryBindInfo, STRUCT_CACHE_VkSparseImageOpaqueMemoryBindInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseImageOpaqueMemoryBindInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._image = null;
  
  this._pBinds = null;
  this._pBindsNative = null;
  
  if (typeof opts === "object") {
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
    if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
    
  }
};

Object.defineProperties(VkSparseImageOpaqueMemoryBindInfo.prototype, {
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "bindCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSparseImageOpaqueMemoryBindInfo.bindCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pBinds": {
    get() {
    if (this._pBinds === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.bindCount, VkSparseMemoryBind);
      this._pBinds = array;
      return this.pBinds;
    } else {
      return this._pBinds;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBinds = value;
    } else if (value === null) {
      this._pBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.pBinds': Expected 'Array VkSparseMemoryBind' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkSparseImageOpaqueMemoryBindInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._image = null;
  
  this._pBinds = null;
  this._pBindsNative = null;
  
  if (typeof opts === "object") {
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
    if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
    
  }
};

VkSparseImageOpaqueMemoryBindInfo.prototype.flush = function flush() {
  
  
  if (this._pBinds !== null) {
    let array = this._pBinds;
    
    if (array.length !== this.bindCount) {
      throw new RangeError("Invalid array length, expected length of 'bindCount' for 'VkSparseImageOpaqueMemoryBindInfo.pBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseMemoryBind)) {
        throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.pBinds[" + ii + "]': Expected 'VkSparseMemoryBind' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBindsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pBindsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSparseImageOpaqueMemoryBindInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSparseImageOpaqueMemoryBindInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseImageOpaqueMemoryBindInfo();
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  copy.bindCount = original.bindCount;
  if (original.pBinds !== null) {
        copy.pBinds = [...Array(original.pBinds.length)].map((v, i) => {
          return original.pBinds[i].constructor.createCopyFrom(original.pBinds[i]);
        });
      }
  
  return copy;
};

VkSparseImageOpaqueMemoryBindInfo.byteLength = 0x0;

VkSparseImageOpaqueMemoryBindInfo.memoryLayout = {
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bindCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pBinds: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseImageMemoryBindInfo **/
function VkSparseImageMemoryBindInfo(opts, byteOffset) {
  if (new.target !== VkSparseImageMemoryBindInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseImageMemoryBindInfo, STRUCT_CACHE_VkSparseImageMemoryBindInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseImageMemoryBindInfo, STRUCT_CACHE_VkSparseImageMemoryBindInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseImageMemoryBindInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._image = null;
  
  this._pBinds = null;
  this._pBindsNative = null;
  
  if (typeof opts === "object") {
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
    if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
    
  }
};

Object.defineProperties(VkSparseImageMemoryBindInfo.prototype, {
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "bindCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSparseImageMemoryBindInfo.bindCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pBinds": {
    get() {
    if (this._pBinds === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.bindCount, VkSparseImageMemoryBind);
      this._pBinds = array;
      return this.pBinds;
    } else {
      return this._pBinds;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBinds = value;
    } else if (value === null) {
      this._pBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.pBinds': Expected 'Array VkSparseImageMemoryBind' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkSparseImageMemoryBindInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._image = null;
  
  this._pBinds = null;
  this._pBindsNative = null;
  
  if (typeof opts === "object") {
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
    if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
    
  }
};

VkSparseImageMemoryBindInfo.prototype.flush = function flush() {
  
  
  if (this._pBinds !== null) {
    let array = this._pBinds;
    
    if (array.length !== this.bindCount) {
      throw new RangeError("Invalid array length, expected length of 'bindCount' for 'VkSparseImageMemoryBindInfo.pBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseImageMemoryBind)) {
        throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.pBinds[" + ii + "]': Expected 'VkSparseImageMemoryBind' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBindsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pBindsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSparseImageMemoryBindInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSparseImageMemoryBindInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseImageMemoryBindInfo();
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  copy.bindCount = original.bindCount;
  if (original.pBinds !== null) {
        copy.pBinds = [...Array(original.pBinds.length)].map((v, i) => {
          return original.pBinds[i].constructor.createCopyFrom(original.pBinds[i]);
        });
      }
  
  return copy;
};

VkSparseImageMemoryBindInfo.byteLength = 0x0;

VkSparseImageMemoryBindInfo.memoryLayout = {
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bindCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pBinds: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindSparseInfo **/
function VkBindSparseInfo(opts, byteOffset) {
  if (new.target !== VkBindSparseInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindSparseInfo, STRUCT_CACHE_VkBindSparseInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindSparseInfo, STRUCT_CACHE_VkBindSparseInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindSparseInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
  this._pWaitSemaphoresNative = null;
  
  this._pBufferBinds = null;
  this._pBufferBindsNative = null;
  
  this._pImageOpaqueBinds = null;
  this._pImageOpaqueBindsNative = null;
  
  this._pImageBinds = null;
  this._pImageBindsNative = null;
  
  this._pSignalSemaphores = null;
  this._pSignalSemaphoresNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
    if (opts.bufferBindCount !== void 0) this.bufferBindCount = opts.bufferBindCount;
    if (opts.pBufferBinds !== void 0) this.pBufferBinds = opts.pBufferBinds;
    if (opts.imageOpaqueBindCount !== void 0) this.imageOpaqueBindCount = opts.imageOpaqueBindCount;
    if (opts.pImageOpaqueBinds !== void 0) this.pImageOpaqueBinds = opts.pImageOpaqueBinds;
    if (opts.imageBindCount !== void 0) this.imageBindCount = opts.imageBindCount;
    if (opts.pImageBinds !== void 0) this.pImageBinds = opts.pImageBinds;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphores !== void 0) this.pSignalSemaphores = opts.pSignalSemaphores;
    
  }
};

Object.defineProperties(VkBindSparseInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindSparseInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindSparseInfo.pNext'");
      switch (sType) {
          
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindSparseInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pNext'");
    }
    
    }
    },
  "waitSemaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindSparseInfo.waitSemaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pWaitSemaphores": {
    get() {
    if (this._pWaitSemaphores === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.waitSemaphoreCount, VkSemaphore);
      this._pWaitSemaphores = array;
      return this.pWaitSemaphores;
    } else {
      return this._pWaitSemaphores;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pWaitSemaphores = value;
    } else if (value === null) {
      this._pWaitSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pWaitSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "bufferBindCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindSparseInfo.bufferBindCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pBufferBinds": {
    get() {
    if (this._pBufferBinds === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.bufferBindCount, VkSparseBufferMemoryBindInfo);
      this._pBufferBinds = array;
      return this.pBufferBinds;
    } else {
      return this._pBufferBinds;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBufferBinds = value;
    } else if (value === null) {
      this._pBufferBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pBufferBinds': Expected 'Array VkSparseBufferMemoryBindInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "imageOpaqueBindCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindSparseInfo.imageOpaqueBindCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pImageOpaqueBinds": {
    get() {
    if (this._pImageOpaqueBinds === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.imageOpaqueBindCount, VkSparseImageOpaqueMemoryBindInfo);
      this._pImageOpaqueBinds = array;
      return this.pImageOpaqueBinds;
    } else {
      return this._pImageOpaqueBinds;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pImageOpaqueBinds = value;
    } else if (value === null) {
      this._pImageOpaqueBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageOpaqueBinds': Expected 'Array VkSparseImageOpaqueMemoryBindInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "imageBindCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindSparseInfo.imageBindCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pImageBinds": {
    get() {
    if (this._pImageBinds === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.imageBindCount, VkSparseImageMemoryBindInfo);
      this._pImageBinds = array;
      return this.pImageBinds;
    } else {
      return this._pImageBinds;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pImageBinds = value;
    } else if (value === null) {
      this._pImageBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageBinds': Expected 'Array VkSparseImageMemoryBindInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "signalSemaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindSparseInfo.signalSemaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSignalSemaphores": {
    get() {
    if (this._pSignalSemaphores === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.signalSemaphoreCount, VkSemaphore);
      this._pSignalSemaphores = array;
      return this.pSignalSemaphores;
    } else {
      return this._pSignalSemaphores;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSignalSemaphores = value;
    } else if (value === null) {
      this._pSignalSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pSignalSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkBindSparseInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
  this._pWaitSemaphoresNative = null;
  
  this._pBufferBinds = null;
  this._pBufferBindsNative = null;
  
  this._pImageOpaqueBinds = null;
  this._pImageOpaqueBindsNative = null;
  
  this._pImageBinds = null;
  this._pImageBindsNative = null;
  
  this._pSignalSemaphores = null;
  this._pSignalSemaphoresNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
    if (opts.bufferBindCount !== void 0) this.bufferBindCount = opts.bufferBindCount;
    if (opts.pBufferBinds !== void 0) this.pBufferBinds = opts.pBufferBinds;
    if (opts.imageOpaqueBindCount !== void 0) this.imageOpaqueBindCount = opts.imageOpaqueBindCount;
    if (opts.pImageOpaqueBinds !== void 0) this.pImageOpaqueBinds = opts.pImageOpaqueBinds;
    if (opts.imageBindCount !== void 0) this.imageBindCount = opts.imageBindCount;
    if (opts.pImageBinds !== void 0) this.pImageBinds = opts.pImageBinds;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphores !== void 0) this.pSignalSemaphores = opts.pSignalSemaphores;
    
  }
};

VkBindSparseInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pWaitSemaphores !== null) {
    let array = this._pWaitSemaphores;
    
    if (array.length !== this.waitSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'waitSemaphoreCount' for 'VkBindSparseInfo.pWaitSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pWaitSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pWaitSemaphoresNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pWaitSemaphoresNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pBufferBinds !== null) {
    let array = this._pBufferBinds;
    
    if (array.length !== this.bufferBindCount) {
      throw new RangeError("Invalid array length, expected length of 'bufferBindCount' for 'VkBindSparseInfo.pBufferBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseBufferMemoryBindInfo)) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pBufferBinds[" + ii + "]': Expected 'VkSparseBufferMemoryBindInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBufferBindsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pBufferBindsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pImageOpaqueBinds !== null) {
    let array = this._pImageOpaqueBinds;
    
    if (array.length !== this.imageOpaqueBindCount) {
      throw new RangeError("Invalid array length, expected length of 'imageOpaqueBindCount' for 'VkBindSparseInfo.pImageOpaqueBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseImageOpaqueMemoryBindInfo)) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageOpaqueBinds[" + ii + "]': Expected 'VkSparseImageOpaqueMemoryBindInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pImageOpaqueBindsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pImageOpaqueBindsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pImageBinds !== null) {
    let array = this._pImageBinds;
    
    if (array.length !== this.imageBindCount) {
      throw new RangeError("Invalid array length, expected length of 'imageBindCount' for 'VkBindSparseInfo.pImageBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSparseImageMemoryBindInfo)) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageBinds[" + ii + "]': Expected 'VkSparseImageMemoryBindInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pImageBindsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pImageBindsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pSignalSemaphores !== null) {
    let array = this._pSignalSemaphores;
    
    if (array.length !== this.signalSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'signalSemaphoreCount' for 'VkBindSparseInfo.pSignalSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pSignalSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSignalSemaphoresNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSignalSemaphoresNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkBindSparseInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindSparseInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindSparseInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.waitSemaphoreCount = original.waitSemaphoreCount;
  if (original.pWaitSemaphores !== null) {
        copy.pWaitSemaphores = [...Array(original.pWaitSemaphores.length)].map((v, i) => {
          return original.pWaitSemaphores[i].constructor.createCopyFrom(original.pWaitSemaphores[i]);
        });
      }
  copy.bufferBindCount = original.bufferBindCount;
  if (original.pBufferBinds !== null) {
        copy.pBufferBinds = [...Array(original.pBufferBinds.length)].map((v, i) => {
          return original.pBufferBinds[i].constructor.createCopyFrom(original.pBufferBinds[i]);
        });
      }
  copy.imageOpaqueBindCount = original.imageOpaqueBindCount;
  if (original.pImageOpaqueBinds !== null) {
        copy.pImageOpaqueBinds = [...Array(original.pImageOpaqueBinds.length)].map((v, i) => {
          return original.pImageOpaqueBinds[i].constructor.createCopyFrom(original.pImageOpaqueBinds[i]);
        });
      }
  copy.imageBindCount = original.imageBindCount;
  if (original.pImageBinds !== null) {
        copy.pImageBinds = [...Array(original.pImageBinds.length)].map((v, i) => {
          return original.pImageBinds[i].constructor.createCopyFrom(original.pImageBinds[i]);
        });
      }
  copy.signalSemaphoreCount = original.signalSemaphoreCount;
  if (original.pSignalSemaphores !== null) {
        copy.pSignalSemaphores = [...Array(original.pSignalSemaphores.length)].map((v, i) => {
          return original.pSignalSemaphores[i].constructor.createCopyFrom(original.pSignalSemaphores[i]);
        });
      }
  
  return copy;
};

VkBindSparseInfo.byteLength = 0x0;

VkBindSparseInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  waitSemaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pWaitSemaphores: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferBindCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pBufferBinds: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageOpaqueBindCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pImageOpaqueBinds: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageBindCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pImageBinds: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  signalSemaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSignalSemaphores: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageCopy **/
function VkImageCopy(opts, byteOffset) {
  if (new.target !== VkImageCopy) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageCopy, STRUCT_CACHE_VkImageCopy);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageCopy, STRUCT_CACHE_VkImageCopy);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageCopy'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

Object.defineProperties(VkImageCopy.prototype, {
  "srcSubresource": {
    get() {
    return this._srcSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcOffset": {
    get() {
    return this._srcOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._srcOffset = value;
      
      
    } else if (value === null) {
      this._srcOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.srcOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstSubresource": {
    get() {
    return this._dstSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstOffset": {
    get() {
    return this._dstOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._dstOffset = value;
      
      
    } else if (value === null) {
      this._dstOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.dstOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.extent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageCopy.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._srcSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcSubresource.memoryBuffer) this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcSubresource.reset();
  }
  if (this._srcOffset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcOffset.memoryBuffer) this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcOffset.reset();
  }
  if (this._dstSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstSubresource.memoryBuffer) this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstSubresource.reset();
  }
  if (this._dstOffset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstOffset.memoryBuffer) this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstOffset.reset();
  }
  if (this._extent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._extent.memoryBuffer) this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._extent.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

VkImageCopy.prototype.flush = function flush() {
  
  
  if (this._srcSubresource !== null) {
    let srcSubresource = this._srcSubresource;
    srcSubresource.flush();
    if (this.memoryBuffer !== srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(srcSubresource.memoryBuffer, srcSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy.srcSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._srcOffset !== null) {
    let srcOffset = this._srcOffset;
    srcOffset.flush();
    if (this.memoryBuffer !== srcOffset.memoryBuffer) {
      let srcView = new Uint8Array(srcOffset.memoryBuffer, srcOffset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy.srcOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstSubresource !== null) {
    let dstSubresource = this._dstSubresource;
    dstSubresource.flush();
    if (this.memoryBuffer !== dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(dstSubresource.memoryBuffer, dstSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy.dstSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstOffset !== null) {
    let dstOffset = this._dstOffset;
    dstOffset.flush();
    if (this.memoryBuffer !== dstOffset.memoryBuffer) {
      let srcView = new Uint8Array(dstOffset.memoryBuffer, dstOffset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy.dstOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer, extent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageCopy.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageCopy.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageCopy();
  if (original.srcSubresource !== null) {
        copy.srcSubresource = original.srcSubresource.constructor.createCopyFrom(original.srcSubresource);
      }
  if (original.srcOffset !== null) {
        copy.srcOffset = original.srcOffset.constructor.createCopyFrom(original.srcOffset);
      }
  if (original.dstSubresource !== null) {
        copy.dstSubresource = original.dstSubresource.constructor.createCopyFrom(original.dstSubresource);
      }
  if (original.dstOffset !== null) {
        copy.dstOffset = original.dstOffset.constructor.createCopyFrom(original.dstOffset);
      }
  if (original.extent !== null) {
        copy.extent = original.extent.constructor.createCopyFrom(original.extent);
      }
  
  return copy;
};

VkImageCopy.byteLength = 0x0;

VkImageCopy.memoryLayout = {
  srcSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageBlit **/
function VkImageBlit(opts, byteOffset) {
  if (new.target !== VkImageBlit) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageBlit, STRUCT_CACHE_VkImageBlit);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageBlit, STRUCT_CACHE_VkImageBlit);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageBlit'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._srcOffsets = [...Array(2)].map((v, i) => new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 + (i * 0x0) }));
  this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstOffsets = [...Array(2)].map((v, i) => new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 + (i * 0x0) }));
  
  if (typeof opts === "object") {
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffsets !== void 0) this.srcOffsets = opts.srcOffsets;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffsets !== void 0) this.dstOffsets = opts.dstOffsets;
    
  }
};

Object.defineProperties(VkImageBlit.prototype, {
  "srcSubresource": {
    get() {
    return this._srcSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcOffsets": {
    get() {
    return this._srcOffsets;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._srcOffsets = value;
    } else if (value === null) {
      this._srcOffsets = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.srcOffsets': Expected 'Array VkOffset3D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "dstSubresource": {
    get() {
    return this._dstSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstOffsets": {
    get() {
    return this._dstOffsets;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._dstOffsets = value;
    } else if (value === null) {
      this._dstOffsets = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.dstOffsets': Expected 'Array VkOffset3D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkImageBlit.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._srcSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcSubresource.memoryBuffer) this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcSubresource.reset();
  }
  if (this._srcOffsets !== null) {
    let array = this._srcOffsets;
    for (let ii = 0; ii < array.length; ++ii) {
      array[ii].reset();
    };
  }
  if (this._dstSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstSubresource.memoryBuffer) this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstSubresource.reset();
  }
  if (this._dstOffsets !== null) {
    let array = this._dstOffsets;
    for (let ii = 0; ii < array.length; ++ii) {
      array[ii].reset();
    };
  }
  
  if (typeof opts === "object") {
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffsets !== void 0) this.srcOffsets = opts.srcOffsets;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffsets !== void 0) this.dstOffsets = opts.dstOffsets;
    
  }
};

VkImageBlit.prototype.flush = function flush() {
  
  
  if (this._srcSubresource !== null) {
    let srcSubresource = this._srcSubresource;
    srcSubresource.flush();
    if (this.memoryBuffer !== srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(srcSubresource.memoryBuffer, srcSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageBlit.srcSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._srcOffsets !== null) {
    let array = this._srcOffsets;
    
    if (array.length !== 2) {
      throw new RangeError("Invalid array length, expected length of '2' for 'VkImageBlit.srcOffsets'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkOffset3D)) {
        throw new TypeError("Invalid type for 'VkImageBlit.srcOffsets[" + ii + "]': Expected 'VkOffset3D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let dstView = new Uint8Array(this.memoryBuffer);
    let byteOffset = 0x0;
    for (let ii = 0; ii < array.length; ++ii) {
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      dstView.set(srcView, byteOffset);
      byteOffset += VkOffset3D.byteLength;
    };
  }
  
  
  if (this._dstSubresource !== null) {
    let dstSubresource = this._dstSubresource;
    dstSubresource.flush();
    if (this.memoryBuffer !== dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(dstSubresource.memoryBuffer, dstSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageBlit.dstSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstOffsets !== null) {
    let array = this._dstOffsets;
    
    if (array.length !== 2) {
      throw new RangeError("Invalid array length, expected length of '2' for 'VkImageBlit.dstOffsets'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkOffset3D)) {
        throw new TypeError("Invalid type for 'VkImageBlit.dstOffsets[" + ii + "]': Expected 'VkOffset3D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let dstView = new Uint8Array(this.memoryBuffer);
    let byteOffset = 0x0;
    for (let ii = 0; ii < array.length; ++ii) {
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      dstView.set(srcView, byteOffset);
      byteOffset += VkOffset3D.byteLength;
    };
  }
  
  return true;
};

VkImageBlit.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageBlit.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageBlit();
  if (original.srcSubresource !== null) {
        copy.srcSubresource = original.srcSubresource.constructor.createCopyFrom(original.srcSubresource);
      }
  if (original.srcOffsets !== null) {
        copy.srcOffsets = [...Array(original.srcOffsets.length)].map((v, i) => {
          return original.srcOffsets[i].constructor.createCopyFrom(original.srcOffsets[i]);
        });
      }
  if (original.dstSubresource !== null) {
        copy.dstSubresource = original.dstSubresource.constructor.createCopyFrom(original.dstSubresource);
      }
  if (original.dstOffsets !== null) {
        copy.dstOffsets = [...Array(original.dstOffsets.length)].map((v, i) => {
          return original.dstOffsets[i].constructor.createCopyFrom(original.dstOffsets[i]);
        });
      }
  
  return copy;
};

VkImageBlit.byteLength = 0x0;

VkImageBlit.memoryLayout = {
  srcSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcOffsets: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstOffsets: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferImageCopy **/
function VkBufferImageCopy(opts, byteOffset) {
  if (new.target !== VkBufferImageCopy) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferImageCopy, STRUCT_CACHE_VkBufferImageCopy);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferImageCopy, STRUCT_CACHE_VkBufferImageCopy);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferImageCopy'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  this._imageSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._imageOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._imageExtent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.bufferOffset !== void 0) this.bufferOffset = opts.bufferOffset;
    if (opts.bufferRowLength !== void 0) this.bufferRowLength = opts.bufferRowLength;
    if (opts.bufferImageHeight !== void 0) this.bufferImageHeight = opts.bufferImageHeight;
    if (opts.imageSubresource !== void 0) this.imageSubresource = opts.imageSubresource;
    if (opts.imageOffset !== void 0) this.imageOffset = opts.imageOffset;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    
  }
};

Object.defineProperties(VkBufferImageCopy.prototype, {
  "bufferOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferImageCopy.bufferOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "bufferRowLength": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferImageCopy.bufferRowLength");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "bufferImageHeight": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferImageCopy.bufferImageHeight");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "imageSubresource": {
    get() {
    return this._imageSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._imageSubresource = value;
      
      
    } else if (value === null) {
      this._imageSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.imageSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageOffset": {
    get() {
    return this._imageOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._imageOffset = value;
      
      
    } else if (value === null) {
      this._imageOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.imageOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageExtent": {
    get() {
    return this._imageExtent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._imageExtent = value;
      
      
    } else if (value === null) {
      this._imageExtent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.imageExtent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferImageCopy.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (this._imageSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageSubresource.memoryBuffer) this._imageSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageSubresource.reset();
  }
  if (this._imageOffset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageOffset.memoryBuffer) this._imageOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageOffset.reset();
  }
  if (this._imageExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageExtent.memoryBuffer) this._imageExtent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageExtent.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.bufferOffset !== void 0) this.bufferOffset = opts.bufferOffset;
    if (opts.bufferRowLength !== void 0) this.bufferRowLength = opts.bufferRowLength;
    if (opts.bufferImageHeight !== void 0) this.bufferImageHeight = opts.bufferImageHeight;
    if (opts.imageSubresource !== void 0) this.imageSubresource = opts.imageSubresource;
    if (opts.imageOffset !== void 0) this.imageOffset = opts.imageOffset;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    
  }
};

VkBufferImageCopy.prototype.flush = function flush() {
  
  
  if (this._imageSubresource !== null) {
    let imageSubresource = this._imageSubresource;
    imageSubresource.flush();
    if (this.memoryBuffer !== imageSubresource.memoryBuffer) {
      let srcView = new Uint8Array(imageSubresource.memoryBuffer, imageSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkBufferImageCopy.imageSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._imageOffset !== null) {
    let imageOffset = this._imageOffset;
    imageOffset.flush();
    if (this.memoryBuffer !== imageOffset.memoryBuffer) {
      let srcView = new Uint8Array(imageOffset.memoryBuffer, imageOffset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkBufferImageCopy.imageOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._imageExtent !== null) {
    let imageExtent = this._imageExtent;
    imageExtent.flush();
    if (this.memoryBuffer !== imageExtent.memoryBuffer) {
      let srcView = new Uint8Array(imageExtent.memoryBuffer, imageExtent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkBufferImageCopy.imageExtent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkBufferImageCopy.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferImageCopy.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferImageCopy();
  copy.bufferOffset = original.bufferOffset;
  copy.bufferRowLength = original.bufferRowLength;
  copy.bufferImageHeight = original.bufferImageHeight;
  if (original.imageSubresource !== null) {
        copy.imageSubresource = original.imageSubresource.constructor.createCopyFrom(original.imageSubresource);
      }
  if (original.imageOffset !== null) {
        copy.imageOffset = original.imageOffset.constructor.createCopyFrom(original.imageOffset);
      }
  if (original.imageExtent !== null) {
        copy.imageExtent = original.imageExtent.constructor.createCopyFrom(original.imageExtent);
      }
  
  return copy;
};

VkBufferImageCopy.byteLength = 0x0;

VkBufferImageCopy.memoryLayout = {
  bufferOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferRowLength: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferImageHeight: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageResolve **/
function VkImageResolve(opts, byteOffset) {
  if (new.target !== VkImageResolve) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageResolve, STRUCT_CACHE_VkImageResolve);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageResolve, STRUCT_CACHE_VkImageResolve);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageResolve'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

Object.defineProperties(VkImageResolve.prototype, {
  "srcSubresource": {
    get() {
    return this._srcSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcOffset": {
    get() {
    return this._srcOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._srcOffset = value;
      
      
    } else if (value === null) {
      this._srcOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.srcOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstSubresource": {
    get() {
    return this._dstSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstOffset": {
    get() {
    return this._dstOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._dstOffset = value;
      
      
    } else if (value === null) {
      this._dstOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.dstOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.extent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageResolve.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._srcSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcSubresource.memoryBuffer) this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcSubresource.reset();
  }
  if (this._srcOffset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcOffset.memoryBuffer) this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcOffset.reset();
  }
  if (this._dstSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstSubresource.memoryBuffer) this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstSubresource.reset();
  }
  if (this._dstOffset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstOffset.memoryBuffer) this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstOffset.reset();
  }
  if (this._extent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._extent.memoryBuffer) this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._extent.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

VkImageResolve.prototype.flush = function flush() {
  
  
  if (this._srcSubresource !== null) {
    let srcSubresource = this._srcSubresource;
    srcSubresource.flush();
    if (this.memoryBuffer !== srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(srcSubresource.memoryBuffer, srcSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve.srcSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._srcOffset !== null) {
    let srcOffset = this._srcOffset;
    srcOffset.flush();
    if (this.memoryBuffer !== srcOffset.memoryBuffer) {
      let srcView = new Uint8Array(srcOffset.memoryBuffer, srcOffset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve.srcOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstSubresource !== null) {
    let dstSubresource = this._dstSubresource;
    dstSubresource.flush();
    if (this.memoryBuffer !== dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(dstSubresource.memoryBuffer, dstSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve.dstSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstOffset !== null) {
    let dstOffset = this._dstOffset;
    dstOffset.flush();
    if (this.memoryBuffer !== dstOffset.memoryBuffer) {
      let srcView = new Uint8Array(dstOffset.memoryBuffer, dstOffset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve.dstOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer, extent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageResolve.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageResolve.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageResolve();
  if (original.srcSubresource !== null) {
        copy.srcSubresource = original.srcSubresource.constructor.createCopyFrom(original.srcSubresource);
      }
  if (original.srcOffset !== null) {
        copy.srcOffset = original.srcOffset.constructor.createCopyFrom(original.srcOffset);
      }
  if (original.dstSubresource !== null) {
        copy.dstSubresource = original.dstSubresource.constructor.createCopyFrom(original.dstSubresource);
      }
  if (original.dstOffset !== null) {
        copy.dstOffset = original.dstOffset.constructor.createCopyFrom(original.dstOffset);
      }
  if (original.extent !== null) {
        copy.extent = original.extent.constructor.createCopyFrom(original.extent);
      }
  
  return copy;
};

VkImageResolve.byteLength = 0x0;

VkImageResolve.memoryLayout = {
  srcSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkShaderModuleCreateInfo **/
function VkShaderModuleCreateInfo(opts, byteOffset) {
  if (new.target !== VkShaderModuleCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkShaderModuleCreateInfo, STRUCT_CACHE_VkShaderModuleCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkShaderModuleCreateInfo, STRUCT_CACHE_VkShaderModuleCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkShaderModuleCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pCode = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.codeSize !== void 0) this.codeSize = opts.codeSize;
    if (opts.pCode !== void 0) this.pCode = opts.pCode;
    
  }
};

Object.defineProperties(VkShaderModuleCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkShaderModuleCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkShaderModuleCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "codeSize": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkShaderModuleCreateInfo.codeSize")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "pCode": {
    get() {
    return this._pCode;
    },
    set(value) {
    if (value !== null && value.constructor === Uint8Array) {
      this._pCode = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pCode = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pCode': Expected 'Uint8Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkShaderModuleCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pCode = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.codeSize !== void 0) this.codeSize = opts.codeSize;
    if (opts.pCode !== void 0) this.pCode = opts.pCode;
    
  }
};

VkShaderModuleCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkShaderModuleCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkShaderModuleCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkShaderModuleCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.codeSize = original.codeSize;
  if (original.pCode !== null) {
        copy.pCode = new Uint8Array(original.pCode);
      }
  
  return copy;
};

VkShaderModuleCreateInfo.byteLength = 0x0;

VkShaderModuleCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  codeSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetLayoutBinding **/
function VkDescriptorSetLayoutBinding(opts, byteOffset) {
  if (new.target !== VkDescriptorSetLayoutBinding) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetLayoutBinding, STRUCT_CACHE_VkDescriptorSetLayoutBinding);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetLayoutBinding, STRUCT_CACHE_VkDescriptorSetLayoutBinding);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetLayoutBinding'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  this._pImmutableSamplers = null;
  this._pImmutableSamplersNative = null;
  
  if (typeof opts === "object") {
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.stageFlags !== void 0) this.stageFlags = opts.stageFlags;
    if (opts.pImmutableSamplers !== void 0) this.pImmutableSamplers = opts.pImmutableSamplers;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutBinding.prototype, {
  "binding": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutBinding.binding");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "descriptorType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutBinding.descriptorType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutBinding.descriptorCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "stageFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutBinding.stageFlags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pImmutableSamplers": {
    get() {
    if (this._pImmutableSamplers === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.descriptorCount, VkSampler);
      this._pImmutableSamplers = array;
      return this.pImmutableSamplers;
    } else {
      return this._pImmutableSamplers;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pImmutableSamplers = value;
    } else if (value === null) {
      this._pImmutableSamplers = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.pImmutableSamplers': Expected 'Array VkSampler' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDescriptorSetLayoutBinding.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  this._pImmutableSamplers = null;
  this._pImmutableSamplersNative = null;
  
  if (typeof opts === "object") {
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.stageFlags !== void 0) this.stageFlags = opts.stageFlags;
    if (opts.pImmutableSamplers !== void 0) this.pImmutableSamplers = opts.pImmutableSamplers;
    
  }
};

VkDescriptorSetLayoutBinding.prototype.flush = function flush() {
  
  
  if (this._pImmutableSamplers !== null) {
    let array = this._pImmutableSamplers;
    
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkDescriptorSetLayoutBinding.pImmutableSamplers'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSampler)) {
        throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.pImmutableSamplers[" + ii + "]': Expected 'VkSampler' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pImmutableSamplersNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pImmutableSamplersNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDescriptorSetLayoutBinding.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorSetLayoutBinding.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetLayoutBinding();
  copy.binding = original.binding;
  copy.descriptorType = original.descriptorType;
  copy.descriptorCount = original.descriptorCount;
  copy.stageFlags = original.stageFlags;
  if (original.pImmutableSamplers !== null) {
        copy.pImmutableSamplers = [...Array(original.pImmutableSamplers.length)].map((v, i) => {
          return original.pImmutableSamplers[i].constructor.createCopyFrom(original.pImmutableSamplers[i]);
        });
      }
  
  return copy;
};

VkDescriptorSetLayoutBinding.byteLength = 0x0;

VkDescriptorSetLayoutBinding.memoryLayout = {
  binding: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stageFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pImmutableSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetLayoutCreateInfo **/
function VkDescriptorSetLayoutCreateInfo(opts, byteOffset) {
  if (new.target !== VkDescriptorSetLayoutCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetLayoutCreateInfo, STRUCT_CACHE_VkDescriptorSetLayoutCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetLayoutCreateInfo, STRUCT_CACHE_VkDescriptorSetLayoutCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetLayoutCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pBindings = null;
  this._pBindingsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.bindingCount !== void 0) this.bindingCount = opts.bindingCount;
    if (opts.pBindings !== void 0) this.pBindings = opts.pBindings;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "bindingCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutCreateInfo.bindingCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pBindings": {
    get() {
    if (this._pBindings === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.bindingCount, VkDescriptorSetLayoutBinding);
      this._pBindings = array;
      return this.pBindings;
    } else {
      return this._pBindings;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pBindings = value;
    } else if (value === null) {
      this._pBindings = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pBindings': Expected 'Array VkDescriptorSetLayoutBinding' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDescriptorSetLayoutCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pBindings = null;
  this._pBindingsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.bindingCount !== void 0) this.bindingCount = opts.bindingCount;
    if (opts.pBindings !== void 0) this.pBindings = opts.pBindings;
    
  }
};

VkDescriptorSetLayoutCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pBindings !== null) {
    let array = this._pBindings;
    
    if (array.length !== this.bindingCount) {
      throw new RangeError("Invalid array length, expected length of 'bindingCount' for 'VkDescriptorSetLayoutCreateInfo.pBindings'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorSetLayoutBinding)) {
        throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pBindings[" + ii + "]': Expected 'VkDescriptorSetLayoutBinding' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pBindingsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pBindingsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDescriptorSetLayoutCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorSetLayoutCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetLayoutCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.bindingCount = original.bindingCount;
  if (original.pBindings !== null) {
        copy.pBindings = [...Array(original.pBindings.length)].map((v, i) => {
          return original.pBindings[i].constructor.createCopyFrom(original.pBindings[i]);
        });
      }
  
  return copy;
};

VkDescriptorSetLayoutCreateInfo.byteLength = 0x0;

VkDescriptorSetLayoutCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bindingCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pBindings: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorPoolSize **/
function VkDescriptorPoolSize(opts, byteOffset) {
  if (new.target !== VkDescriptorPoolSize) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorPoolSize, STRUCT_CACHE_VkDescriptorPoolSize);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorPoolSize, STRUCT_CACHE_VkDescriptorPoolSize);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorPoolSize'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    
  }
};

Object.defineProperties(VkDescriptorPoolSize.prototype, {
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorPoolSize.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorPoolSize.descriptorCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDescriptorPoolSize.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    
  }
};

VkDescriptorPoolSize.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorPoolSize.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorPoolSize.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorPoolSize();
  copy.type = original.type;
  copy.descriptorCount = original.descriptorCount;
  
  return copy;
};

VkDescriptorPoolSize.byteLength = 0x0;

VkDescriptorPoolSize.memoryLayout = {
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorPoolCreateInfo **/
function VkDescriptorPoolCreateInfo(opts, byteOffset) {
  if (new.target !== VkDescriptorPoolCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorPoolCreateInfo, STRUCT_CACHE_VkDescriptorPoolCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorPoolCreateInfo, STRUCT_CACHE_VkDescriptorPoolCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorPoolCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._pPoolSizes = null;
  this._pPoolSizesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.maxSets !== void 0) this.maxSets = opts.maxSets;
    if (opts.poolSizeCount !== void 0) this.poolSizeCount = opts.poolSizeCount;
    if (opts.pPoolSizes !== void 0) this.pPoolSizes = opts.pPoolSizes;
    
  }
};

Object.defineProperties(VkDescriptorPoolCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorPoolCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorPoolCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "maxSets": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorPoolCreateInfo.maxSets");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "poolSizeCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorPoolCreateInfo.poolSizeCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPoolSizes": {
    get() {
    if (this._pPoolSizes === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.poolSizeCount, VkDescriptorPoolSize);
      this._pPoolSizes = array;
      return this.pPoolSizes;
    } else {
      return this._pPoolSizes;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPoolSizes = value;
    } else if (value === null) {
      this._pPoolSizes = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pPoolSizes': Expected 'Array VkDescriptorPoolSize' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDescriptorPoolCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this._pPoolSizes = null;
  this._pPoolSizesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.maxSets !== void 0) this.maxSets = opts.maxSets;
    if (opts.poolSizeCount !== void 0) this.poolSizeCount = opts.poolSizeCount;
    if (opts.pPoolSizes !== void 0) this.pPoolSizes = opts.pPoolSizes;
    
  }
};

VkDescriptorPoolCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPoolSizes !== null) {
    let array = this._pPoolSizes;
    
    if (array.length !== this.poolSizeCount) {
      throw new RangeError("Invalid array length, expected length of 'poolSizeCount' for 'VkDescriptorPoolCreateInfo.pPoolSizes'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorPoolSize)) {
        throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pPoolSizes[" + ii + "]': Expected 'VkDescriptorPoolSize' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPoolSizesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pPoolSizesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDescriptorPoolCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorPoolCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorPoolCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.maxSets = original.maxSets;
  copy.poolSizeCount = original.poolSizeCount;
  if (original.pPoolSizes !== null) {
        copy.pPoolSizes = [...Array(original.pPoolSizes.length)].map((v, i) => {
          return original.pPoolSizes[i].constructor.createCopyFrom(original.pPoolSizes[i]);
        });
      }
  
  return copy;
};

VkDescriptorPoolCreateInfo.byteLength = 0x0;

VkDescriptorPoolCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSets: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  poolSizeCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPoolSizes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetAllocateInfo **/
function VkDescriptorSetAllocateInfo(opts, byteOffset) {
  if (new.target !== VkDescriptorSetAllocateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetAllocateInfo, STRUCT_CACHE_VkDescriptorSetAllocateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetAllocateInfo, STRUCT_CACHE_VkDescriptorSetAllocateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetAllocateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._descriptorPool = null;
  
  this._pSetLayouts = null;
  this._pSetLayoutsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.descriptorPool !== void 0) this.descriptorPool = opts.descriptorPool;
    if (opts.descriptorSetCount !== void 0) this.descriptorSetCount = opts.descriptorSetCount;
    if (opts.pSetLayouts !== void 0) this.pSetLayouts = opts.pSetLayouts;
    
  }
};

Object.defineProperties(VkDescriptorSetAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetAllocateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pNext'");
    }
    
    }
    },
  "descriptorPool": {
    get() {
    return this._descriptorPool;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorPool) {
      
      this._descriptorPool = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._descriptorPool = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.descriptorPool': Expected 'VkDescriptorPool' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "descriptorSetCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetAllocateInfo.descriptorSetCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSetLayouts": {
    get() {
    if (this._pSetLayouts === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.descriptorSetCount, VkDescriptorSetLayout);
      this._pSetLayouts = array;
      return this.pSetLayouts;
    } else {
      return this._pSetLayouts;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSetLayouts = value;
    } else if (value === null) {
      this._pSetLayouts = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pSetLayouts': Expected 'Array VkDescriptorSetLayout' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDescriptorSetAllocateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._descriptorPool = null;
  
  this._pSetLayouts = null;
  this._pSetLayoutsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.descriptorPool !== void 0) this.descriptorPool = opts.descriptorPool;
    if (opts.descriptorSetCount !== void 0) this.descriptorSetCount = opts.descriptorSetCount;
    if (opts.pSetLayouts !== void 0) this.pSetLayouts = opts.pSetLayouts;
    
  }
};

VkDescriptorSetAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSetLayouts !== null) {
    let array = this._pSetLayouts;
    
    if (array.length !== this.descriptorSetCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorSetCount' for 'VkDescriptorSetAllocateInfo.pSetLayouts'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorSetLayout)) {
        throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pSetLayouts[" + ii + "]': Expected 'VkDescriptorSetLayout' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSetLayoutsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSetLayoutsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDescriptorSetAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorSetAllocateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetAllocateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.descriptorPool !== null) {
        copy.descriptorPool = original.descriptorPool.constructor.createCopyFrom(original.descriptorPool);
      }
  copy.descriptorSetCount = original.descriptorSetCount;
  if (original.pSetLayouts !== null) {
        copy.pSetLayouts = [...Array(original.pSetLayouts.length)].map((v, i) => {
          return original.pSetLayouts[i].constructor.createCopyFrom(original.pSetLayouts[i]);
        });
      }
  
  return copy;
};

VkDescriptorSetAllocateInfo.byteLength = 0x0;

VkDescriptorSetAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorPool: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorSetCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSetLayouts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSpecializationMapEntry **/
function VkSpecializationMapEntry(opts, byteOffset) {
  if (new.target !== VkSpecializationMapEntry) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSpecializationMapEntry, STRUCT_CACHE_VkSpecializationMapEntry);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSpecializationMapEntry, STRUCT_CACHE_VkSpecializationMapEntry);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSpecializationMapEntry'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.constantID !== void 0) this.constantID = opts.constantID;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkSpecializationMapEntry.prototype, {
  "constantID": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSpecializationMapEntry.constantID");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "offset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSpecializationMapEntry.offset");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkSpecializationMapEntry.size")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  
});

VkSpecializationMapEntry.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.constantID !== void 0) this.constantID = opts.constantID;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

VkSpecializationMapEntry.prototype.flush = function flush() {
  
  return true;
};

VkSpecializationMapEntry.prototype.reflect = function reflect(memoryAddress) {
  };

VkSpecializationMapEntry.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSpecializationMapEntry();
  copy.constantID = original.constantID;
  copy.offset = original.offset;
  copy.size = original.size;
  
  return copy;
};

VkSpecializationMapEntry.byteLength = 0x0;

VkSpecializationMapEntry.memoryLayout = {
  constantID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSpecializationInfo **/
function VkSpecializationInfo(opts, byteOffset) {
  if (new.target !== VkSpecializationInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSpecializationInfo, STRUCT_CACHE_VkSpecializationInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSpecializationInfo, STRUCT_CACHE_VkSpecializationInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSpecializationInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pMapEntries = null;
  this._pMapEntriesNative = null;
  
  this._pData = null;
  
  if (typeof opts === "object") {
    if (opts.mapEntryCount !== void 0) this.mapEntryCount = opts.mapEntryCount;
    if (opts.pMapEntries !== void 0) this.pMapEntries = opts.pMapEntries;
    if (opts.dataSize !== void 0) this.dataSize = opts.dataSize;
    if (opts.pData !== void 0) this.pData = opts.pData;
    
  }
};

Object.defineProperties(VkSpecializationInfo.prototype, {
  "mapEntryCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSpecializationInfo.mapEntryCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pMapEntries": {
    get() {
    if (this._pMapEntries === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.mapEntryCount, VkSpecializationMapEntry);
      this._pMapEntries = array;
      return this.pMapEntries;
    } else {
      return this._pMapEntries;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pMapEntries = value;
    } else if (value === null) {
      this._pMapEntries = null;
    } else {
      throw new TypeError("Invalid type for 'VkSpecializationInfo.pMapEntries': Expected 'Array VkSpecializationMapEntry' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "dataSize": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkSpecializationInfo.dataSize")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "pData": {
    get() {
    return this._pData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSpecializationInfo.pData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSpecializationInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pMapEntries = null;
  this._pMapEntriesNative = null;
  
  this._pData = null;
  
  if (typeof opts === "object") {
    if (opts.mapEntryCount !== void 0) this.mapEntryCount = opts.mapEntryCount;
    if (opts.pMapEntries !== void 0) this.pMapEntries = opts.pMapEntries;
    if (opts.dataSize !== void 0) this.dataSize = opts.dataSize;
    if (opts.pData !== void 0) this.pData = opts.pData;
    
  }
};

VkSpecializationInfo.prototype.flush = function flush() {
  
  
  if (this._pMapEntries !== null) {
    let array = this._pMapEntries;
    
    if (array.length !== this.mapEntryCount) {
      throw new RangeError("Invalid array length, expected length of 'mapEntryCount' for 'VkSpecializationInfo.pMapEntries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSpecializationMapEntry)) {
        throw new TypeError("Invalid type for 'VkSpecializationInfo.pMapEntries[" + ii + "]': Expected 'VkSpecializationMapEntry' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pMapEntriesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pMapEntriesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSpecializationInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSpecializationInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSpecializationInfo();
  copy.mapEntryCount = original.mapEntryCount;
  if (original.pMapEntries !== null) {
        copy.pMapEntries = [...Array(original.pMapEntries.length)].map((v, i) => {
          return original.pMapEntries[i].constructor.createCopyFrom(original.pMapEntries[i]);
        });
      }
  copy.dataSize = original.dataSize;
  if (original.pData !== null) {
      let buf = new ArrayBuffer(original.pData.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pData), 0x0);
      copy.pData = buf;
    }
  
  return copy;
};

VkSpecializationInfo.byteLength = 0x0;

VkSpecializationInfo.memoryLayout = {
  mapEntryCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pMapEntries: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dataSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineShaderStageCreateInfo **/
function VkPipelineShaderStageCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineShaderStageCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineShaderStageCreateInfo, STRUCT_CACHE_VkPipelineShaderStageCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineShaderStageCreateInfo, STRUCT_CACHE_VkPipelineShaderStageCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineShaderStageCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._module = null;
  this._pName = null;
  this._pSpecializationInfo = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stage !== void 0) this.stage = opts.stage;
    if (opts.module !== void 0) this.module = opts.module;
    if (opts.pName !== void 0) this.pName = opts.pName;
    if (opts.pSpecializationInfo !== void 0) this.pSpecializationInfo = opts.pSpecializationInfo;
    
  }
};

Object.defineProperties(VkPipelineShaderStageCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineShaderStageCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineShaderStageCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineShaderStageCreateInfo.stage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "module": {
    get() {
    return this._module;
    },
    set(value) {
    if (value !== null && value.constructor === VkShaderModule) {
      
      this._module = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._module = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.module': Expected 'VkShaderModule' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pName": {
    get() {
    if (this._pName !== null) {
      let str = textDecoder.decode(this._pName);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._pName = buffer;
        return this.pName;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pName = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._pName), true);
    } else if (value === null) {
      this._pName = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkPipelineShaderStageCreateInfo.pName");
    }
    
    }
    },
  "pSpecializationInfo": {
    get() {
    if (this._pSpecializationInfo === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkSpecializationInfo.byteLength));
      this._pSpecializationInfo = new VkSpecializationInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pSpecializationInfo.memoryAddress, true);
      return this.pSpecializationInfo;
    } else {
      return this._pSpecializationInfo;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkSpecializationInfo) {
      value.flush();
      this._pSpecializationInfo = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pSpecializationInfo = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.pSpecializationInfo': Expected 'VkSpecializationInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineShaderStageCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._module = null;
  this._pName = null;
  this._pSpecializationInfo = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stage !== void 0) this.stage = opts.stage;
    if (opts.module !== void 0) this.module = opts.module;
    if (opts.pName !== void 0) this.pName = opts.pName;
    if (opts.pSpecializationInfo !== void 0) this.pSpecializationInfo = opts.pSpecializationInfo;
    
  }
};

VkPipelineShaderStageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineShaderStageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineShaderStageCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineShaderStageCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.stage = original.stage;
  if (original.module !== null) {
        copy.module = original.module.constructor.createCopyFrom(original.module);
      }
  copy.pName = original.pName;
  if (original.pSpecializationInfo !== null) {
        copy.pSpecializationInfo = original.pSpecializationInfo.constructor.createCopyFrom(original.pSpecializationInfo);
      }
  
  return copy;
};

VkPipelineShaderStageCreateInfo.byteLength = 0x0;

VkPipelineShaderStageCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  module: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSpecializationInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkComputePipelineCreateInfo **/
function VkComputePipelineCreateInfo(opts, byteOffset) {
  if (new.target !== VkComputePipelineCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkComputePipelineCreateInfo, STRUCT_CACHE_VkComputePipelineCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkComputePipelineCreateInfo, STRUCT_CACHE_VkComputePipelineCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkComputePipelineCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._stage = new VkPipelineShaderStageCreateInfo({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._layout = null;
  this._basePipelineHandle = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stage !== void 0) this.stage = opts.stage;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

Object.defineProperties(VkComputePipelineCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkComputePipelineCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkComputePipelineCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stage": {
    get() {
    return this._stage;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineShaderStageCreateInfo) {
      value.flush();
      this._stage = value;
      
      
    } else if (value === null) {
      this._stage = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.stage': Expected 'VkPipelineShaderStageCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "layout": {
    get() {
    return this._layout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._layout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._layout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.layout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineHandle": {
    get() {
    return this._basePipelineHandle;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._basePipelineHandle = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._basePipelineHandle = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.basePipelineHandle': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineIndex": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkComputePipelineCreateInfo.basePipelineIndex");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkComputePipelineCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._stage !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._stage.memoryBuffer) this._stage = new VkPipelineShaderStageCreateInfo({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._stage.reset();
  }
  this._layout = null;
  this._basePipelineHandle = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stage !== void 0) this.stage = opts.stage;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

VkComputePipelineCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._stage !== null) {
    let stage = this._stage;
    stage.flush();
    if (this.memoryBuffer !== stage.memoryBuffer) {
      let srcView = new Uint8Array(stage.memoryBuffer, stage.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkComputePipelineCreateInfo.stage' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkComputePipelineCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkComputePipelineCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkComputePipelineCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  if (original.stage !== null) {
        copy.stage = original.stage.constructor.createCopyFrom(original.stage);
      }
  if (original.layout !== null) {
        copy.layout = original.layout.constructor.createCopyFrom(original.layout);
      }
  if (original.basePipelineHandle !== null) {
        copy.basePipelineHandle = original.basePipelineHandle.constructor.createCopyFrom(original.basePipelineHandle);
      }
  copy.basePipelineIndex = original.basePipelineIndex;
  
  return copy;
};

VkComputePipelineCreateInfo.byteLength = 0x0;

VkComputePipelineCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  basePipelineHandle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  basePipelineIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkVertexInputBindingDescription **/
function VkVertexInputBindingDescription(opts, byteOffset) {
  if (new.target !== VkVertexInputBindingDescription) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkVertexInputBindingDescription, STRUCT_CACHE_VkVertexInputBindingDescription);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkVertexInputBindingDescription, STRUCT_CACHE_VkVertexInputBindingDescription);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkVertexInputBindingDescription'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.stride !== void 0) this.stride = opts.stride;
    if (opts.inputRate !== void 0) this.inputRate = opts.inputRate;
    
  }
};

Object.defineProperties(VkVertexInputBindingDescription.prototype, {
  "binding": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkVertexInputBindingDescription.binding");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "stride": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkVertexInputBindingDescription.stride");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "inputRate": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkVertexInputBindingDescription.inputRate");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkVertexInputBindingDescription.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.stride !== void 0) this.stride = opts.stride;
    if (opts.inputRate !== void 0) this.inputRate = opts.inputRate;
    
  }
};

VkVertexInputBindingDescription.prototype.flush = function flush() {
  
  return true;
};

VkVertexInputBindingDescription.prototype.reflect = function reflect(memoryAddress) {
  };

VkVertexInputBindingDescription.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkVertexInputBindingDescription();
  copy.binding = original.binding;
  copy.stride = original.stride;
  copy.inputRate = original.inputRate;
  
  return copy;
};

VkVertexInputBindingDescription.byteLength = 0x0;

VkVertexInputBindingDescription.memoryLayout = {
  binding: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  inputRate: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkVertexInputAttributeDescription **/
function VkVertexInputAttributeDescription(opts, byteOffset) {
  if (new.target !== VkVertexInputAttributeDescription) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkVertexInputAttributeDescription, STRUCT_CACHE_VkVertexInputAttributeDescription);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkVertexInputAttributeDescription, STRUCT_CACHE_VkVertexInputAttributeDescription);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkVertexInputAttributeDescription'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.location !== void 0) this.location = opts.location;
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.offset !== void 0) this.offset = opts.offset;
    
  }
};

Object.defineProperties(VkVertexInputAttributeDescription.prototype, {
  "location": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkVertexInputAttributeDescription.location");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "binding": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkVertexInputAttributeDescription.binding");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkVertexInputAttributeDescription.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "offset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkVertexInputAttributeDescription.offset");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkVertexInputAttributeDescription.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.location !== void 0) this.location = opts.location;
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.offset !== void 0) this.offset = opts.offset;
    
  }
};

VkVertexInputAttributeDescription.prototype.flush = function flush() {
  
  return true;
};

VkVertexInputAttributeDescription.prototype.reflect = function reflect(memoryAddress) {
  };

VkVertexInputAttributeDescription.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkVertexInputAttributeDescription();
  copy.location = original.location;
  copy.binding = original.binding;
  copy.format = original.format;
  copy.offset = original.offset;
  
  return copy;
};

VkVertexInputAttributeDescription.byteLength = 0x0;

VkVertexInputAttributeDescription.memoryLayout = {
  location: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  binding: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineVertexInputStateCreateInfo **/
function VkPipelineVertexInputStateCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineVertexInputStateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineVertexInputStateCreateInfo, STRUCT_CACHE_VkPipelineVertexInputStateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineVertexInputStateCreateInfo, STRUCT_CACHE_VkPipelineVertexInputStateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineVertexInputStateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pVertexBindingDescriptions = null;
  this._pVertexBindingDescriptionsNative = null;
  
  this._pVertexAttributeDescriptions = null;
  this._pVertexAttributeDescriptionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.vertexBindingDescriptionCount !== void 0) this.vertexBindingDescriptionCount = opts.vertexBindingDescriptionCount;
    if (opts.pVertexBindingDescriptions !== void 0) this.pVertexBindingDescriptions = opts.pVertexBindingDescriptions;
    if (opts.vertexAttributeDescriptionCount !== void 0) this.vertexAttributeDescriptionCount = opts.vertexAttributeDescriptionCount;
    if (opts.pVertexAttributeDescriptions !== void 0) this.pVertexAttributeDescriptions = opts.pVertexAttributeDescriptions;
    
  }
};

Object.defineProperties(VkPipelineVertexInputStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineVertexInputStateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineVertexInputStateCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "vertexBindingDescriptionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineVertexInputStateCreateInfo.vertexBindingDescriptionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pVertexBindingDescriptions": {
    get() {
    if (this._pVertexBindingDescriptions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.vertexBindingDescriptionCount, VkVertexInputBindingDescription);
      this._pVertexBindingDescriptions = array;
      return this.pVertexBindingDescriptions;
    } else {
      return this._pVertexBindingDescriptions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pVertexBindingDescriptions = value;
    } else if (value === null) {
      this._pVertexBindingDescriptions = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions': Expected 'Array VkVertexInputBindingDescription' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "vertexAttributeDescriptionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineVertexInputStateCreateInfo.vertexAttributeDescriptionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pVertexAttributeDescriptions": {
    get() {
    if (this._pVertexAttributeDescriptions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.vertexAttributeDescriptionCount, VkVertexInputAttributeDescription);
      this._pVertexAttributeDescriptions = array;
      return this.pVertexAttributeDescriptions;
    } else {
      return this._pVertexAttributeDescriptions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pVertexAttributeDescriptions = value;
    } else if (value === null) {
      this._pVertexAttributeDescriptions = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions': Expected 'Array VkVertexInputAttributeDescription' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineVertexInputStateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pVertexBindingDescriptions = null;
  this._pVertexBindingDescriptionsNative = null;
  
  this._pVertexAttributeDescriptions = null;
  this._pVertexAttributeDescriptionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.vertexBindingDescriptionCount !== void 0) this.vertexBindingDescriptionCount = opts.vertexBindingDescriptionCount;
    if (opts.pVertexBindingDescriptions !== void 0) this.pVertexBindingDescriptions = opts.pVertexBindingDescriptions;
    if (opts.vertexAttributeDescriptionCount !== void 0) this.vertexAttributeDescriptionCount = opts.vertexAttributeDescriptionCount;
    if (opts.pVertexAttributeDescriptions !== void 0) this.pVertexAttributeDescriptions = opts.pVertexAttributeDescriptions;
    
  }
};

VkPipelineVertexInputStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pVertexBindingDescriptions !== null) {
    let array = this._pVertexBindingDescriptions;
    
    if (array.length !== this.vertexBindingDescriptionCount) {
      throw new RangeError("Invalid array length, expected length of 'vertexBindingDescriptionCount' for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkVertexInputBindingDescription)) {
        throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions[" + ii + "]': Expected 'VkVertexInputBindingDescription' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pVertexBindingDescriptionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pVertexBindingDescriptionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pVertexAttributeDescriptions !== null) {
    let array = this._pVertexAttributeDescriptions;
    
    if (array.length !== this.vertexAttributeDescriptionCount) {
      throw new RangeError("Invalid array length, expected length of 'vertexAttributeDescriptionCount' for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkVertexInputAttributeDescription)) {
        throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions[" + ii + "]': Expected 'VkVertexInputAttributeDescription' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pVertexAttributeDescriptionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pVertexAttributeDescriptionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineVertexInputStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineVertexInputStateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineVertexInputStateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.vertexBindingDescriptionCount = original.vertexBindingDescriptionCount;
  if (original.pVertexBindingDescriptions !== null) {
        copy.pVertexBindingDescriptions = [...Array(original.pVertexBindingDescriptions.length)].map((v, i) => {
          return original.pVertexBindingDescriptions[i].constructor.createCopyFrom(original.pVertexBindingDescriptions[i]);
        });
      }
  copy.vertexAttributeDescriptionCount = original.vertexAttributeDescriptionCount;
  if (original.pVertexAttributeDescriptions !== null) {
        copy.pVertexAttributeDescriptions = [...Array(original.pVertexAttributeDescriptions.length)].map((v, i) => {
          return original.pVertexAttributeDescriptions[i].constructor.createCopyFrom(original.pVertexAttributeDescriptions[i]);
        });
      }
  
  return copy;
};

VkPipelineVertexInputStateCreateInfo.byteLength = 0x0;

VkPipelineVertexInputStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexBindingDescriptionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pVertexBindingDescriptions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexAttributeDescriptionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pVertexAttributeDescriptions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineInputAssemblyStateCreateInfo **/
function VkPipelineInputAssemblyStateCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineInputAssemblyStateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineInputAssemblyStateCreateInfo, STRUCT_CACHE_VkPipelineInputAssemblyStateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineInputAssemblyStateCreateInfo, STRUCT_CACHE_VkPipelineInputAssemblyStateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineInputAssemblyStateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.topology !== void 0) this.topology = opts.topology;
    if (opts.primitiveRestartEnable !== void 0) this.primitiveRestartEnable = opts.primitiveRestartEnable;
    
  }
};

Object.defineProperties(VkPipelineInputAssemblyStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineInputAssemblyStateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineInputAssemblyStateCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineInputAssemblyStateCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "topology": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineInputAssemblyStateCreateInfo.topology");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "primitiveRestartEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPipelineInputAssemblyStateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.topology !== void 0) this.topology = opts.topology;
    if (opts.primitiveRestartEnable !== void 0) this.primitiveRestartEnable = opts.primitiveRestartEnable;
    
  }
};

VkPipelineInputAssemblyStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineInputAssemblyStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineInputAssemblyStateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineInputAssemblyStateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.topology = original.topology;
  copy.primitiveRestartEnable = original.primitiveRestartEnable;
  
  return copy;
};

VkPipelineInputAssemblyStateCreateInfo.byteLength = 0x0;

VkPipelineInputAssemblyStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  topology: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  primitiveRestartEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineTessellationStateCreateInfo **/
function VkPipelineTessellationStateCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineTessellationStateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineTessellationStateCreateInfo, STRUCT_CACHE_VkPipelineTessellationStateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineTessellationStateCreateInfo, STRUCT_CACHE_VkPipelineTessellationStateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineTessellationStateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.patchControlPoints !== void 0) this.patchControlPoints = opts.patchControlPoints;
    
  }
};

Object.defineProperties(VkPipelineTessellationStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineTessellationStateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineTessellationStateCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "patchControlPoints": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineTessellationStateCreateInfo.patchControlPoints");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkPipelineTessellationStateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.patchControlPoints !== void 0) this.patchControlPoints = opts.patchControlPoints;
    
  }
};

VkPipelineTessellationStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineTessellationStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineTessellationStateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineTessellationStateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.patchControlPoints = original.patchControlPoints;
  
  return copy;
};

VkPipelineTessellationStateCreateInfo.byteLength = 0x0;

VkPipelineTessellationStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  patchControlPoints: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineViewportStateCreateInfo **/
function VkPipelineViewportStateCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineViewportStateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineViewportStateCreateInfo, STRUCT_CACHE_VkPipelineViewportStateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineViewportStateCreateInfo, STRUCT_CACHE_VkPipelineViewportStateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineViewportStateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pViewports = null;
  this._pViewportsNative = null;
  
  this._pScissors = null;
  this._pScissorsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pViewports !== void 0) this.pViewports = opts.pViewports;
    if (opts.scissorCount !== void 0) this.scissorCount = opts.scissorCount;
    if (opts.pScissors !== void 0) this.pScissors = opts.pScissors;
    
  }
};

Object.defineProperties(VkPipelineViewportStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportStateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportStateCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "viewportCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportStateCreateInfo.viewportCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewports": {
    get() {
    if (this._pViewports === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.viewportCount, VkViewport);
      this._pViewports = array;
      return this.pViewports;
    } else {
      return this._pViewports;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pViewports = value;
    } else if (value === null) {
      this._pViewports = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pViewports': Expected 'Array VkViewport' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "scissorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportStateCreateInfo.scissorCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pScissors": {
    get() {
    if (this._pScissors === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.scissorCount, VkRect2D);
      this._pScissors = array;
      return this.pScissors;
    } else {
      return this._pScissors;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pScissors = value;
    } else if (value === null) {
      this._pScissors = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pScissors': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportStateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pViewports = null;
  this._pViewportsNative = null;
  
  this._pScissors = null;
  this._pScissorsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pViewports !== void 0) this.pViewports = opts.pViewports;
    if (opts.scissorCount !== void 0) this.scissorCount = opts.scissorCount;
    if (opts.pScissors !== void 0) this.pScissors = opts.pScissors;
    
  }
};

VkPipelineViewportStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pViewports !== null) {
    let array = this._pViewports;
    
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportStateCreateInfo.pViewports'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkViewport)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pViewports[" + ii + "]': Expected 'VkViewport' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pViewportsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pViewportsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pScissors !== null) {
    let array = this._pScissors;
    
    if (array.length !== this.scissorCount) {
      throw new RangeError("Invalid array length, expected length of 'scissorCount' for 'VkPipelineViewportStateCreateInfo.pScissors'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pScissors[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pScissorsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pScissorsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineViewportStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineViewportStateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineViewportStateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.viewportCount = original.viewportCount;
  if (original.pViewports !== null) {
        copy.pViewports = [...Array(original.pViewports.length)].map((v, i) => {
          return original.pViewports[i].constructor.createCopyFrom(original.pViewports[i]);
        });
      }
  copy.scissorCount = original.scissorCount;
  if (original.pScissors !== null) {
        copy.pScissors = [...Array(original.pScissors.length)].map((v, i) => {
          return original.pScissors[i].constructor.createCopyFrom(original.pScissors[i]);
        });
      }
  
  return copy;
};

VkPipelineViewportStateCreateInfo.byteLength = 0x0;

VkPipelineViewportStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewportCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewports: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  scissorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pScissors: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineRasterizationStateCreateInfo **/
function VkPipelineRasterizationStateCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineRasterizationStateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineRasterizationStateCreateInfo, STRUCT_CACHE_VkPipelineRasterizationStateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineRasterizationStateCreateInfo, STRUCT_CACHE_VkPipelineRasterizationStateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineRasterizationStateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.depthClampEnable !== void 0) this.depthClampEnable = opts.depthClampEnable;
    if (opts.rasterizerDiscardEnable !== void 0) this.rasterizerDiscardEnable = opts.rasterizerDiscardEnable;
    if (opts.polygonMode !== void 0) this.polygonMode = opts.polygonMode;
    if (opts.cullMode !== void 0) this.cullMode = opts.cullMode;
    if (opts.frontFace !== void 0) this.frontFace = opts.frontFace;
    if (opts.depthBiasEnable !== void 0) this.depthBiasEnable = opts.depthBiasEnable;
    if (opts.depthBiasConstantFactor !== void 0) this.depthBiasConstantFactor = opts.depthBiasConstantFactor;
    if (opts.depthBiasClamp !== void 0) this.depthBiasClamp = opts.depthBiasClamp;
    if (opts.depthBiasSlopeFactor !== void 0) this.depthBiasSlopeFactor = opts.depthBiasSlopeFactor;
    if (opts.lineWidth !== void 0) this.lineWidth = opts.lineWidth;
    
  }
};

Object.defineProperties(VkPipelineRasterizationStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "depthClampEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "rasterizerDiscardEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "polygonMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateCreateInfo.polygonMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "cullMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateCreateInfo.cullMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "frontFace": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateCreateInfo.frontFace");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "depthBiasEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "depthBiasConstantFactor": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateCreateInfo.depthBiasConstantFactor");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "depthBiasClamp": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateCreateInfo.depthBiasClamp");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "depthBiasSlopeFactor": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateCreateInfo.depthBiasSlopeFactor");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "lineWidth": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateCreateInfo.lineWidth");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkPipelineRasterizationStateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.depthClampEnable !== void 0) this.depthClampEnable = opts.depthClampEnable;
    if (opts.rasterizerDiscardEnable !== void 0) this.rasterizerDiscardEnable = opts.rasterizerDiscardEnable;
    if (opts.polygonMode !== void 0) this.polygonMode = opts.polygonMode;
    if (opts.cullMode !== void 0) this.cullMode = opts.cullMode;
    if (opts.frontFace !== void 0) this.frontFace = opts.frontFace;
    if (opts.depthBiasEnable !== void 0) this.depthBiasEnable = opts.depthBiasEnable;
    if (opts.depthBiasConstantFactor !== void 0) this.depthBiasConstantFactor = opts.depthBiasConstantFactor;
    if (opts.depthBiasClamp !== void 0) this.depthBiasClamp = opts.depthBiasClamp;
    if (opts.depthBiasSlopeFactor !== void 0) this.depthBiasSlopeFactor = opts.depthBiasSlopeFactor;
    if (opts.lineWidth !== void 0) this.lineWidth = opts.lineWidth;
    
  }
};

VkPipelineRasterizationStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineRasterizationStateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineRasterizationStateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.depthClampEnable = original.depthClampEnable;
  copy.rasterizerDiscardEnable = original.rasterizerDiscardEnable;
  copy.polygonMode = original.polygonMode;
  copy.cullMode = original.cullMode;
  copy.frontFace = original.frontFace;
  copy.depthBiasEnable = original.depthBiasEnable;
  copy.depthBiasConstantFactor = original.depthBiasConstantFactor;
  copy.depthBiasClamp = original.depthBiasClamp;
  copy.depthBiasSlopeFactor = original.depthBiasSlopeFactor;
  copy.lineWidth = original.lineWidth;
  
  return copy;
};

VkPipelineRasterizationStateCreateInfo.byteLength = 0x0;

VkPipelineRasterizationStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthClampEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rasterizerDiscardEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  polygonMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  cullMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  frontFace: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthBiasEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthBiasConstantFactor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthBiasClamp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthBiasSlopeFactor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  lineWidth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineMultisampleStateCreateInfo **/
function VkPipelineMultisampleStateCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineMultisampleStateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineMultisampleStateCreateInfo, STRUCT_CACHE_VkPipelineMultisampleStateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineMultisampleStateCreateInfo, STRUCT_CACHE_VkPipelineMultisampleStateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineMultisampleStateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this._pSampleMask = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.rasterizationSamples !== void 0) this.rasterizationSamples = opts.rasterizationSamples;
    if (opts.sampleShadingEnable !== void 0) this.sampleShadingEnable = opts.sampleShadingEnable;
    if (opts.minSampleShading !== void 0) this.minSampleShading = opts.minSampleShading;
    if (opts.pSampleMask !== void 0) this.pSampleMask = opts.pSampleMask;
    if (opts.alphaToCoverageEnable !== void 0) this.alphaToCoverageEnable = opts.alphaToCoverageEnable;
    if (opts.alphaToOneEnable !== void 0) this.alphaToOneEnable = opts.alphaToOneEnable;
    
  }
};

Object.defineProperties(VkPipelineMultisampleStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineMultisampleStateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineMultisampleStateCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "rasterizationSamples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineMultisampleStateCreateInfo.rasterizationSamples");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "sampleShadingEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "minSampleShading": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineMultisampleStateCreateInfo.minSampleShading");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "pSampleMask": {
    get() {
    return this._pSampleMask;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pSampleMask = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pSampleMask = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pSampleMask': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "alphaToCoverageEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "alphaToOneEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPipelineMultisampleStateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pSampleMask = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.rasterizationSamples !== void 0) this.rasterizationSamples = opts.rasterizationSamples;
    if (opts.sampleShadingEnable !== void 0) this.sampleShadingEnable = opts.sampleShadingEnable;
    if (opts.minSampleShading !== void 0) this.minSampleShading = opts.minSampleShading;
    if (opts.pSampleMask !== void 0) this.pSampleMask = opts.pSampleMask;
    if (opts.alphaToCoverageEnable !== void 0) this.alphaToCoverageEnable = opts.alphaToCoverageEnable;
    if (opts.alphaToOneEnable !== void 0) this.alphaToOneEnable = opts.alphaToOneEnable;
    
  }
};

VkPipelineMultisampleStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineMultisampleStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineMultisampleStateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineMultisampleStateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.rasterizationSamples = original.rasterizationSamples;
  copy.sampleShadingEnable = original.sampleShadingEnable;
  copy.minSampleShading = original.minSampleShading;
  if (original.pSampleMask !== null) {
        copy.pSampleMask = new Uint32Array(original.pSampleMask);
      }
  copy.alphaToCoverageEnable = original.alphaToCoverageEnable;
  copy.alphaToOneEnable = original.alphaToOneEnable;
  
  return copy;
};

VkPipelineMultisampleStateCreateInfo.byteLength = 0x0;

VkPipelineMultisampleStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rasterizationSamples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleShadingEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minSampleShading: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSampleMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  alphaToCoverageEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  alphaToOneEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineColorBlendAttachmentState **/
function VkPipelineColorBlendAttachmentState(opts, byteOffset) {
  if (new.target !== VkPipelineColorBlendAttachmentState) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineColorBlendAttachmentState, STRUCT_CACHE_VkPipelineColorBlendAttachmentState);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineColorBlendAttachmentState, STRUCT_CACHE_VkPipelineColorBlendAttachmentState);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineColorBlendAttachmentState'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.blendEnable !== void 0) this.blendEnable = opts.blendEnable;
    if (opts.srcColorBlendFactor !== void 0) this.srcColorBlendFactor = opts.srcColorBlendFactor;
    if (opts.dstColorBlendFactor !== void 0) this.dstColorBlendFactor = opts.dstColorBlendFactor;
    if (opts.colorBlendOp !== void 0) this.colorBlendOp = opts.colorBlendOp;
    if (opts.srcAlphaBlendFactor !== void 0) this.srcAlphaBlendFactor = opts.srcAlphaBlendFactor;
    if (opts.dstAlphaBlendFactor !== void 0) this.dstAlphaBlendFactor = opts.dstAlphaBlendFactor;
    if (opts.alphaBlendOp !== void 0) this.alphaBlendOp = opts.alphaBlendOp;
    if (opts.colorWriteMask !== void 0) this.colorWriteMask = opts.colorWriteMask;
    
  }
};

Object.defineProperties(VkPipelineColorBlendAttachmentState.prototype, {
  "blendEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "srcColorBlendFactor": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendAttachmentState.srcColorBlendFactor");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstColorBlendFactor": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendAttachmentState.dstColorBlendFactor");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "colorBlendOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendAttachmentState.colorBlendOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "srcAlphaBlendFactor": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendAttachmentState.srcAlphaBlendFactor");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstAlphaBlendFactor": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendAttachmentState.dstAlphaBlendFactor");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "alphaBlendOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendAttachmentState.alphaBlendOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "colorWriteMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendAttachmentState.colorWriteMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPipelineColorBlendAttachmentState.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.blendEnable !== void 0) this.blendEnable = opts.blendEnable;
    if (opts.srcColorBlendFactor !== void 0) this.srcColorBlendFactor = opts.srcColorBlendFactor;
    if (opts.dstColorBlendFactor !== void 0) this.dstColorBlendFactor = opts.dstColorBlendFactor;
    if (opts.colorBlendOp !== void 0) this.colorBlendOp = opts.colorBlendOp;
    if (opts.srcAlphaBlendFactor !== void 0) this.srcAlphaBlendFactor = opts.srcAlphaBlendFactor;
    if (opts.dstAlphaBlendFactor !== void 0) this.dstAlphaBlendFactor = opts.dstAlphaBlendFactor;
    if (opts.alphaBlendOp !== void 0) this.alphaBlendOp = opts.alphaBlendOp;
    if (opts.colorWriteMask !== void 0) this.colorWriteMask = opts.colorWriteMask;
    
  }
};

VkPipelineColorBlendAttachmentState.prototype.flush = function flush() {
  
  return true;
};

VkPipelineColorBlendAttachmentState.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineColorBlendAttachmentState.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineColorBlendAttachmentState();
  copy.blendEnable = original.blendEnable;
  copy.srcColorBlendFactor = original.srcColorBlendFactor;
  copy.dstColorBlendFactor = original.dstColorBlendFactor;
  copy.colorBlendOp = original.colorBlendOp;
  copy.srcAlphaBlendFactor = original.srcAlphaBlendFactor;
  copy.dstAlphaBlendFactor = original.dstAlphaBlendFactor;
  copy.alphaBlendOp = original.alphaBlendOp;
  copy.colorWriteMask = original.colorWriteMask;
  
  return copy;
};

VkPipelineColorBlendAttachmentState.byteLength = 0x0;

VkPipelineColorBlendAttachmentState.memoryLayout = {
  blendEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcColorBlendFactor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstColorBlendFactor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  colorBlendOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcAlphaBlendFactor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstAlphaBlendFactor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  alphaBlendOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  colorWriteMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineColorBlendStateCreateInfo **/
function VkPipelineColorBlendStateCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineColorBlendStateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineColorBlendStateCreateInfo, STRUCT_CACHE_VkPipelineColorBlendStateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineColorBlendStateCreateInfo, STRUCT_CACHE_VkPipelineColorBlendStateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineColorBlendStateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  this._blendConstants = [...Array(4)].fill(0x0);
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.logicOpEnable !== void 0) this.logicOpEnable = opts.logicOpEnable;
    if (opts.logicOp !== void 0) this.logicOp = opts.logicOp;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.blendConstants !== void 0) this.blendConstants = opts.blendConstants;
    
  }
};

Object.defineProperties(VkPipelineColorBlendStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendStateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendStateCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "logicOpEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "logicOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendStateCreateInfo.logicOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendStateCreateInfo.attachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAttachments": {
    get() {
    if (this._pAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.attachmentCount, VkPipelineColorBlendAttachmentState);
      this._pAttachments = array;
      return this.pAttachments;
    } else {
      return this._pAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pAttachments': Expected 'Array VkPipelineColorBlendAttachmentState' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "blendConstants": {
    get() {
    return this._blendConstants;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._blendConstants = value;
    } else if (value === null) {
      this._blendConstants = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.blendConstants': Expected 'Array float' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineColorBlendStateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  if (this._blendConstants !== null) this._blendConstants.fill(0x0);
      else this._blendConstants = [...Array(4)].fill(0x0);
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.logicOpEnable !== void 0) this.logicOpEnable = opts.logicOpEnable;
    if (opts.logicOp !== void 0) this.logicOp = opts.logicOp;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.blendConstants !== void 0) this.blendConstants = opts.blendConstants;
    
  }
};

VkPipelineColorBlendStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkPipelineColorBlendStateCreateInfo.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipelineColorBlendAttachmentState)) {
        throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pAttachments[" + ii + "]': Expected 'VkPipelineColorBlendAttachmentState' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._blendConstants !== null) {
    let array = this._blendConstants;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkPipelineColorBlendStateCreateInfo.blendConstants'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.blendConstants[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryView.setFloat32(0x0 + (ii * 4), array[ii], true);
    };
  } else {
    this.memoryView.setFloat32(0x0, 0x0, true);
  }
  
  return true;
};

VkPipelineColorBlendStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineColorBlendStateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineColorBlendStateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.logicOpEnable = original.logicOpEnable;
  copy.logicOp = original.logicOp;
  copy.attachmentCount = original.attachmentCount;
  if (original.pAttachments !== null) {
        copy.pAttachments = [...Array(original.pAttachments.length)].map((v, i) => {
          return original.pAttachments[i].constructor.createCopyFrom(original.pAttachments[i]);
        });
      }
  if (original.blendConstants !== null) {
        copy.blendConstants = [...Array(original.blendConstants.length)].map((v, i) => {
          return original.blendConstants[i];
        });
      }
  
  return copy;
};

VkPipelineColorBlendStateCreateInfo.byteLength = 0x0;

VkPipelineColorBlendStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  logicOpEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  logicOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  blendConstants: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineDynamicStateCreateInfo **/
function VkPipelineDynamicStateCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineDynamicStateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineDynamicStateCreateInfo, STRUCT_CACHE_VkPipelineDynamicStateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineDynamicStateCreateInfo, STRUCT_CACHE_VkPipelineDynamicStateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineDynamicStateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pDynamicStates = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.dynamicStateCount !== void 0) this.dynamicStateCount = opts.dynamicStateCount;
    if (opts.pDynamicStates !== void 0) this.pDynamicStates = opts.pDynamicStates;
    
  }
};

Object.defineProperties(VkPipelineDynamicStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDynamicStateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineDynamicStateCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDynamicStateCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dynamicStateCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDynamicStateCreateInfo.dynamicStateCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDynamicStates": {
    get() {
    return this._pDynamicStates;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pDynamicStates = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDynamicStates = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDynamicStateCreateInfo.pDynamicStates': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineDynamicStateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pDynamicStates = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.dynamicStateCount !== void 0) this.dynamicStateCount = opts.dynamicStateCount;
    if (opts.pDynamicStates !== void 0) this.pDynamicStates = opts.pDynamicStates;
    
  }
};

VkPipelineDynamicStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineDynamicStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineDynamicStateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineDynamicStateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.dynamicStateCount = original.dynamicStateCount;
  if (original.pDynamicStates !== null) {
        copy.pDynamicStates = new Int32Array(original.pDynamicStates);
      }
  
  return copy;
};

VkPipelineDynamicStateCreateInfo.byteLength = 0x0;

VkPipelineDynamicStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dynamicStateCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDynamicStates: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkStencilOpState **/
function VkStencilOpState(opts, byteOffset) {
  if (new.target !== VkStencilOpState) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkStencilOpState, STRUCT_CACHE_VkStencilOpState);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkStencilOpState, STRUCT_CACHE_VkStencilOpState);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkStencilOpState'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.failOp !== void 0) this.failOp = opts.failOp;
    if (opts.passOp !== void 0) this.passOp = opts.passOp;
    if (opts.depthFailOp !== void 0) this.depthFailOp = opts.depthFailOp;
    if (opts.compareOp !== void 0) this.compareOp = opts.compareOp;
    if (opts.compareMask !== void 0) this.compareMask = opts.compareMask;
    if (opts.writeMask !== void 0) this.writeMask = opts.writeMask;
    if (opts.reference !== void 0) this.reference = opts.reference;
    
  }
};

Object.defineProperties(VkStencilOpState.prototype, {
  "failOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkStencilOpState.failOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "passOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkStencilOpState.passOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "depthFailOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkStencilOpState.depthFailOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "compareOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkStencilOpState.compareOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "compareMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkStencilOpState.compareMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "writeMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkStencilOpState.writeMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "reference": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkStencilOpState.reference");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkStencilOpState.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.failOp !== void 0) this.failOp = opts.failOp;
    if (opts.passOp !== void 0) this.passOp = opts.passOp;
    if (opts.depthFailOp !== void 0) this.depthFailOp = opts.depthFailOp;
    if (opts.compareOp !== void 0) this.compareOp = opts.compareOp;
    if (opts.compareMask !== void 0) this.compareMask = opts.compareMask;
    if (opts.writeMask !== void 0) this.writeMask = opts.writeMask;
    if (opts.reference !== void 0) this.reference = opts.reference;
    
  }
};

VkStencilOpState.prototype.flush = function flush() {
  
  return true;
};

VkStencilOpState.prototype.reflect = function reflect(memoryAddress) {
  };

VkStencilOpState.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkStencilOpState();
  copy.failOp = original.failOp;
  copy.passOp = original.passOp;
  copy.depthFailOp = original.depthFailOp;
  copy.compareOp = original.compareOp;
  copy.compareMask = original.compareMask;
  copy.writeMask = original.writeMask;
  copy.reference = original.reference;
  
  return copy;
};

VkStencilOpState.byteLength = 0x0;

VkStencilOpState.memoryLayout = {
  failOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  passOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthFailOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compareOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compareMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  writeMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  reference: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineDepthStencilStateCreateInfo **/
function VkPipelineDepthStencilStateCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineDepthStencilStateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineDepthStencilStateCreateInfo, STRUCT_CACHE_VkPipelineDepthStencilStateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineDepthStencilStateCreateInfo, STRUCT_CACHE_VkPipelineDepthStencilStateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineDepthStencilStateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  this._front = new VkStencilOpState({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._back = new VkStencilOpState({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.depthTestEnable !== void 0) this.depthTestEnable = opts.depthTestEnable;
    if (opts.depthWriteEnable !== void 0) this.depthWriteEnable = opts.depthWriteEnable;
    if (opts.depthCompareOp !== void 0) this.depthCompareOp = opts.depthCompareOp;
    if (opts.depthBoundsTestEnable !== void 0) this.depthBoundsTestEnable = opts.depthBoundsTestEnable;
    if (opts.stencilTestEnable !== void 0) this.stencilTestEnable = opts.stencilTestEnable;
    if (opts.front !== void 0) this.front = opts.front;
    if (opts.back !== void 0) this.back = opts.back;
    if (opts.minDepthBounds !== void 0) this.minDepthBounds = opts.minDepthBounds;
    if (opts.maxDepthBounds !== void 0) this.maxDepthBounds = opts.maxDepthBounds;
    
  }
};

Object.defineProperties(VkPipelineDepthStencilStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDepthStencilStateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineDepthStencilStateCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDepthStencilStateCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "depthTestEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "depthWriteEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "depthCompareOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDepthStencilStateCreateInfo.depthCompareOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "depthBoundsTestEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "stencilTestEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "front": {
    get() {
    return this._front;
    },
    set(value) {
    if (value !== null && value.constructor === VkStencilOpState) {
      value.flush();
      this._front = value;
      
      
    } else if (value === null) {
      this._front = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.front': Expected 'VkStencilOpState' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "back": {
    get() {
    return this._back;
    },
    set(value) {
    if (value !== null && value.constructor === VkStencilOpState) {
      value.flush();
      this._back = value;
      
      
    } else if (value === null) {
      this._back = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.back': Expected 'VkStencilOpState' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "minDepthBounds": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDepthStencilStateCreateInfo.minDepthBounds");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxDepthBounds": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDepthStencilStateCreateInfo.maxDepthBounds");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkPipelineDepthStencilStateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  if (this._front !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._front.memoryBuffer) this._front = new VkStencilOpState({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._front.reset();
  }
  if (this._back !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._back.memoryBuffer) this._back = new VkStencilOpState({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._back.reset();
  }
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.depthTestEnable !== void 0) this.depthTestEnable = opts.depthTestEnable;
    if (opts.depthWriteEnable !== void 0) this.depthWriteEnable = opts.depthWriteEnable;
    if (opts.depthCompareOp !== void 0) this.depthCompareOp = opts.depthCompareOp;
    if (opts.depthBoundsTestEnable !== void 0) this.depthBoundsTestEnable = opts.depthBoundsTestEnable;
    if (opts.stencilTestEnable !== void 0) this.stencilTestEnable = opts.stencilTestEnable;
    if (opts.front !== void 0) this.front = opts.front;
    if (opts.back !== void 0) this.back = opts.back;
    if (opts.minDepthBounds !== void 0) this.minDepthBounds = opts.minDepthBounds;
    if (opts.maxDepthBounds !== void 0) this.maxDepthBounds = opts.maxDepthBounds;
    
  }
};

VkPipelineDepthStencilStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._front !== null) {
    let front = this._front;
    front.flush();
    if (this.memoryBuffer !== front.memoryBuffer) {
      let srcView = new Uint8Array(front.memoryBuffer, front.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPipelineDepthStencilStateCreateInfo.front' isn't used as shared-memory");
    }
  }
  
  
  if (this._back !== null) {
    let back = this._back;
    back.flush();
    if (this.memoryBuffer !== back.memoryBuffer) {
      let srcView = new Uint8Array(back.memoryBuffer, back.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPipelineDepthStencilStateCreateInfo.back' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkPipelineDepthStencilStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineDepthStencilStateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineDepthStencilStateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.depthTestEnable = original.depthTestEnable;
  copy.depthWriteEnable = original.depthWriteEnable;
  copy.depthCompareOp = original.depthCompareOp;
  copy.depthBoundsTestEnable = original.depthBoundsTestEnable;
  copy.stencilTestEnable = original.stencilTestEnable;
  if (original.front !== null) {
        copy.front = original.front.constructor.createCopyFrom(original.front);
      }
  if (original.back !== null) {
        copy.back = original.back.constructor.createCopyFrom(original.back);
      }
  copy.minDepthBounds = original.minDepthBounds;
  copy.maxDepthBounds = original.maxDepthBounds;
  
  return copy;
};

VkPipelineDepthStencilStateCreateInfo.byteLength = 0x0;

VkPipelineDepthStencilStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthTestEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthWriteEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthCompareOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthBoundsTestEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilTestEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  front: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  back: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minDepthBounds: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDepthBounds: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkGraphicsPipelineCreateInfo **/
function VkGraphicsPipelineCreateInfo(opts, byteOffset) {
  if (new.target !== VkGraphicsPipelineCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkGraphicsPipelineCreateInfo, STRUCT_CACHE_VkGraphicsPipelineCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkGraphicsPipelineCreateInfo, STRUCT_CACHE_VkGraphicsPipelineCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkGraphicsPipelineCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pStages = null;
  this._pStagesNative = null;
  this._pVertexInputState = null;
  this._pInputAssemblyState = null;
  this._pTessellationState = null;
  this._pViewportState = null;
  this._pRasterizationState = null;
  this._pMultisampleState = null;
  this._pDepthStencilState = null;
  this._pColorBlendState = null;
  this._pDynamicState = null;
  this._layout = null;
  this._renderPass = null;
  
  this._basePipelineHandle = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
    if (opts.pStages !== void 0) this.pStages = opts.pStages;
    if (opts.pVertexInputState !== void 0) this.pVertexInputState = opts.pVertexInputState;
    if (opts.pInputAssemblyState !== void 0) this.pInputAssemblyState = opts.pInputAssemblyState;
    if (opts.pTessellationState !== void 0) this.pTessellationState = opts.pTessellationState;
    if (opts.pViewportState !== void 0) this.pViewportState = opts.pViewportState;
    if (opts.pRasterizationState !== void 0) this.pRasterizationState = opts.pRasterizationState;
    if (opts.pMultisampleState !== void 0) this.pMultisampleState = opts.pMultisampleState;
    if (opts.pDepthStencilState !== void 0) this.pDepthStencilState = opts.pDepthStencilState;
    if (opts.pColorBlendState !== void 0) this.pColorBlendState = opts.pColorBlendState;
    if (opts.pDynamicState !== void 0) this.pDynamicState = opts.pDynamicState;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

Object.defineProperties(VkGraphicsPipelineCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGraphicsPipelineCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGraphicsPipelineCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stageCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGraphicsPipelineCreateInfo.stageCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pStages": {
    get() {
    if (this._pStages === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.stageCount, VkPipelineShaderStageCreateInfo);
      this._pStages = array;
      return this.pStages;
    } else {
      return this._pStages;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pStages = value;
    } else if (value === null) {
      this._pStages = null;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pStages': Expected 'Array VkPipelineShaderStageCreateInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pVertexInputState": {
    get() {
    if (this._pVertexInputState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineVertexInputStateCreateInfo.byteLength));
      this._pVertexInputState = new VkPipelineVertexInputStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pVertexInputState.memoryAddress, true);
      return this.pVertexInputState;
    } else {
      return this._pVertexInputState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineVertexInputStateCreateInfo) {
      value.flush();
      this._pVertexInputState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pVertexInputState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pVertexInputState': Expected 'VkPipelineVertexInputStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pInputAssemblyState": {
    get() {
    if (this._pInputAssemblyState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineInputAssemblyStateCreateInfo.byteLength));
      this._pInputAssemblyState = new VkPipelineInputAssemblyStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pInputAssemblyState.memoryAddress, true);
      return this.pInputAssemblyState;
    } else {
      return this._pInputAssemblyState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineInputAssemblyStateCreateInfo) {
      value.flush();
      this._pInputAssemblyState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pInputAssemblyState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pInputAssemblyState': Expected 'VkPipelineInputAssemblyStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pTessellationState": {
    get() {
    if (this._pTessellationState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineTessellationStateCreateInfo.byteLength));
      this._pTessellationState = new VkPipelineTessellationStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pTessellationState.memoryAddress, true);
      return this.pTessellationState;
    } else {
      return this._pTessellationState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineTessellationStateCreateInfo) {
      value.flush();
      this._pTessellationState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pTessellationState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pTessellationState': Expected 'VkPipelineTessellationStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pViewportState": {
    get() {
    if (this._pViewportState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineViewportStateCreateInfo.byteLength));
      this._pViewportState = new VkPipelineViewportStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pViewportState.memoryAddress, true);
      return this.pViewportState;
    } else {
      return this._pViewportState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineViewportStateCreateInfo) {
      value.flush();
      this._pViewportState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pViewportState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pViewportState': Expected 'VkPipelineViewportStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pRasterizationState": {
    get() {
    if (this._pRasterizationState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineRasterizationStateCreateInfo.byteLength));
      this._pRasterizationState = new VkPipelineRasterizationStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pRasterizationState.memoryAddress, true);
      return this.pRasterizationState;
    } else {
      return this._pRasterizationState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineRasterizationStateCreateInfo) {
      value.flush();
      this._pRasterizationState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pRasterizationState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pRasterizationState': Expected 'VkPipelineRasterizationStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pMultisampleState": {
    get() {
    if (this._pMultisampleState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineMultisampleStateCreateInfo.byteLength));
      this._pMultisampleState = new VkPipelineMultisampleStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pMultisampleState.memoryAddress, true);
      return this.pMultisampleState;
    } else {
      return this._pMultisampleState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineMultisampleStateCreateInfo) {
      value.flush();
      this._pMultisampleState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pMultisampleState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pMultisampleState': Expected 'VkPipelineMultisampleStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pDepthStencilState": {
    get() {
    if (this._pDepthStencilState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineDepthStencilStateCreateInfo.byteLength));
      this._pDepthStencilState = new VkPipelineDepthStencilStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pDepthStencilState.memoryAddress, true);
      return this.pDepthStencilState;
    } else {
      return this._pDepthStencilState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineDepthStencilStateCreateInfo) {
      value.flush();
      this._pDepthStencilState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pDepthStencilState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pDepthStencilState': Expected 'VkPipelineDepthStencilStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pColorBlendState": {
    get() {
    if (this._pColorBlendState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineColorBlendStateCreateInfo.byteLength));
      this._pColorBlendState = new VkPipelineColorBlendStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pColorBlendState.memoryAddress, true);
      return this.pColorBlendState;
    } else {
      return this._pColorBlendState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineColorBlendStateCreateInfo) {
      value.flush();
      this._pColorBlendState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pColorBlendState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pColorBlendState': Expected 'VkPipelineColorBlendStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pDynamicState": {
    get() {
    if (this._pDynamicState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineDynamicStateCreateInfo.byteLength));
      this._pDynamicState = new VkPipelineDynamicStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pDynamicState.memoryAddress, true);
      return this.pDynamicState;
    } else {
      return this._pDynamicState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineDynamicStateCreateInfo) {
      value.flush();
      this._pDynamicState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pDynamicState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pDynamicState': Expected 'VkPipelineDynamicStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "layout": {
    get() {
    return this._layout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._layout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._layout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.layout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "renderPass": {
    get() {
    return this._renderPass;
    },
    set(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._renderPass = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.renderPass': Expected 'VkRenderPass' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "subpass": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGraphicsPipelineCreateInfo.subpass");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "basePipelineHandle": {
    get() {
    return this._basePipelineHandle;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._basePipelineHandle = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._basePipelineHandle = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.basePipelineHandle': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineIndex": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGraphicsPipelineCreateInfo.basePipelineIndex");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkGraphicsPipelineCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pStages = null;
  this._pStagesNative = null;
  this._pVertexInputState = null;
  this._pInputAssemblyState = null;
  this._pTessellationState = null;
  this._pViewportState = null;
  this._pRasterizationState = null;
  this._pMultisampleState = null;
  this._pDepthStencilState = null;
  this._pColorBlendState = null;
  this._pDynamicState = null;
  this._layout = null;
  this._renderPass = null;
  
  this._basePipelineHandle = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
    if (opts.pStages !== void 0) this.pStages = opts.pStages;
    if (opts.pVertexInputState !== void 0) this.pVertexInputState = opts.pVertexInputState;
    if (opts.pInputAssemblyState !== void 0) this.pInputAssemblyState = opts.pInputAssemblyState;
    if (opts.pTessellationState !== void 0) this.pTessellationState = opts.pTessellationState;
    if (opts.pViewportState !== void 0) this.pViewportState = opts.pViewportState;
    if (opts.pRasterizationState !== void 0) this.pRasterizationState = opts.pRasterizationState;
    if (opts.pMultisampleState !== void 0) this.pMultisampleState = opts.pMultisampleState;
    if (opts.pDepthStencilState !== void 0) this.pDepthStencilState = opts.pDepthStencilState;
    if (opts.pColorBlendState !== void 0) this.pColorBlendState = opts.pColorBlendState;
    if (opts.pDynamicState !== void 0) this.pDynamicState = opts.pDynamicState;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

VkGraphicsPipelineCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pStages !== null) {
    let array = this._pStages;
    
    if (array.length !== this.stageCount) {
      throw new RangeError("Invalid array length, expected length of 'stageCount' for 'VkGraphicsPipelineCreateInfo.pStages'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipelineShaderStageCreateInfo)) {
        throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pStages[" + ii + "]': Expected 'VkPipelineShaderStageCreateInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pStagesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pStagesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkGraphicsPipelineCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkGraphicsPipelineCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkGraphicsPipelineCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.stageCount = original.stageCount;
  if (original.pStages !== null) {
        copy.pStages = [...Array(original.pStages.length)].map((v, i) => {
          return original.pStages[i].constructor.createCopyFrom(original.pStages[i]);
        });
      }
  if (original.pVertexInputState !== null) {
        copy.pVertexInputState = original.pVertexInputState.constructor.createCopyFrom(original.pVertexInputState);
      }
  if (original.pInputAssemblyState !== null) {
        copy.pInputAssemblyState = original.pInputAssemblyState.constructor.createCopyFrom(original.pInputAssemblyState);
      }
  if (original.pTessellationState !== null) {
        copy.pTessellationState = original.pTessellationState.constructor.createCopyFrom(original.pTessellationState);
      }
  if (original.pViewportState !== null) {
        copy.pViewportState = original.pViewportState.constructor.createCopyFrom(original.pViewportState);
      }
  if (original.pRasterizationState !== null) {
        copy.pRasterizationState = original.pRasterizationState.constructor.createCopyFrom(original.pRasterizationState);
      }
  if (original.pMultisampleState !== null) {
        copy.pMultisampleState = original.pMultisampleState.constructor.createCopyFrom(original.pMultisampleState);
      }
  if (original.pDepthStencilState !== null) {
        copy.pDepthStencilState = original.pDepthStencilState.constructor.createCopyFrom(original.pDepthStencilState);
      }
  if (original.pColorBlendState !== null) {
        copy.pColorBlendState = original.pColorBlendState.constructor.createCopyFrom(original.pColorBlendState);
      }
  if (original.pDynamicState !== null) {
        copy.pDynamicState = original.pDynamicState.constructor.createCopyFrom(original.pDynamicState);
      }
  if (original.layout !== null) {
        copy.layout = original.layout.constructor.createCopyFrom(original.layout);
      }
  if (original.renderPass !== null) {
        copy.renderPass = original.renderPass.constructor.createCopyFrom(original.renderPass);
      }
  copy.subpass = original.subpass;
  if (original.basePipelineHandle !== null) {
        copy.basePipelineHandle = original.basePipelineHandle.constructor.createCopyFrom(original.basePipelineHandle);
      }
  copy.basePipelineIndex = original.basePipelineIndex;
  
  return copy;
};

VkGraphicsPipelineCreateInfo.byteLength = 0x0;

VkGraphicsPipelineCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stageCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pStages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pVertexInputState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pInputAssemblyState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pTessellationState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewportState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pRasterizationState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pMultisampleState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDepthStencilState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pColorBlendState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDynamicState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  renderPass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subpass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  basePipelineHandle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  basePipelineIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineCacheCreateInfo **/
function VkPipelineCacheCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineCacheCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineCacheCreateInfo, STRUCT_CACHE_VkPipelineCacheCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineCacheCreateInfo, STRUCT_CACHE_VkPipelineCacheCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineCacheCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pInitialData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.initialDataSize !== void 0) this.initialDataSize = opts.initialDataSize;
    if (opts.pInitialData !== void 0) this.pInitialData = opts.pInitialData;
    
  }
};

Object.defineProperties(VkPipelineCacheCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCacheCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCacheCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCacheCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "initialDataSize": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkPipelineCacheCreateInfo.initialDataSize")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "pInitialData": {
    get() {
    return this._pInitialData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pInitialData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pInitialData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineCacheCreateInfo.pInitialData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineCacheCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pInitialData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.initialDataSize !== void 0) this.initialDataSize = opts.initialDataSize;
    if (opts.pInitialData !== void 0) this.pInitialData = opts.pInitialData;
    
  }
};

VkPipelineCacheCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCacheCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineCacheCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineCacheCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.initialDataSize = original.initialDataSize;
  if (original.pInitialData !== null) {
      let buf = new ArrayBuffer(original.pInitialData.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pInitialData), 0x0);
      copy.pInitialData = buf;
    }
  
  return copy;
};

VkPipelineCacheCreateInfo.byteLength = 0x0;

VkPipelineCacheCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  initialDataSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pInitialData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPushConstantRange **/
function VkPushConstantRange(opts, byteOffset) {
  if (new.target !== VkPushConstantRange) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPushConstantRange, STRUCT_CACHE_VkPushConstantRange);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPushConstantRange, STRUCT_CACHE_VkPushConstantRange);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPushConstantRange'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.stageFlags !== void 0) this.stageFlags = opts.stageFlags;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkPushConstantRange.prototype, {
  "stageFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPushConstantRange.stageFlags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "offset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPushConstantRange.offset");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPushConstantRange.size");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkPushConstantRange.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.stageFlags !== void 0) this.stageFlags = opts.stageFlags;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

VkPushConstantRange.prototype.flush = function flush() {
  
  return true;
};

VkPushConstantRange.prototype.reflect = function reflect(memoryAddress) {
  };

VkPushConstantRange.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPushConstantRange();
  copy.stageFlags = original.stageFlags;
  copy.offset = original.offset;
  copy.size = original.size;
  
  return copy;
};

VkPushConstantRange.byteLength = 0x0;

VkPushConstantRange.memoryLayout = {
  stageFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineLayoutCreateInfo **/
function VkPipelineLayoutCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineLayoutCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineLayoutCreateInfo, STRUCT_CACHE_VkPipelineLayoutCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineLayoutCreateInfo, STRUCT_CACHE_VkPipelineLayoutCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineLayoutCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pSetLayouts = null;
  this._pSetLayoutsNative = null;
  
  this._pPushConstantRanges = null;
  this._pPushConstantRangesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.setLayoutCount !== void 0) this.setLayoutCount = opts.setLayoutCount;
    if (opts.pSetLayouts !== void 0) this.pSetLayouts = opts.pSetLayouts;
    if (opts.pushConstantRangeCount !== void 0) this.pushConstantRangeCount = opts.pushConstantRangeCount;
    if (opts.pPushConstantRanges !== void 0) this.pPushConstantRanges = opts.pPushConstantRanges;
    
  }
};

Object.defineProperties(VkPipelineLayoutCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineLayoutCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineLayoutCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineLayoutCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "setLayoutCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineLayoutCreateInfo.setLayoutCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSetLayouts": {
    get() {
    if (this._pSetLayouts === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.setLayoutCount, VkDescriptorSetLayout);
      this._pSetLayouts = array;
      return this.pSetLayouts;
    } else {
      return this._pSetLayouts;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSetLayouts = value;
    } else if (value === null) {
      this._pSetLayouts = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pSetLayouts': Expected 'Array VkDescriptorSetLayout' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pushConstantRangeCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineLayoutCreateInfo.pushConstantRangeCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPushConstantRanges": {
    get() {
    if (this._pPushConstantRanges === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.pushConstantRangeCount, VkPushConstantRange);
      this._pPushConstantRanges = array;
      return this.pPushConstantRanges;
    } else {
      return this._pPushConstantRanges;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPushConstantRanges = value;
    } else if (value === null) {
      this._pPushConstantRanges = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pPushConstantRanges': Expected 'Array VkPushConstantRange' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineLayoutCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pSetLayouts = null;
  this._pSetLayoutsNative = null;
  
  this._pPushConstantRanges = null;
  this._pPushConstantRangesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.setLayoutCount !== void 0) this.setLayoutCount = opts.setLayoutCount;
    if (opts.pSetLayouts !== void 0) this.pSetLayouts = opts.pSetLayouts;
    if (opts.pushConstantRangeCount !== void 0) this.pushConstantRangeCount = opts.pushConstantRangeCount;
    if (opts.pPushConstantRanges !== void 0) this.pPushConstantRanges = opts.pPushConstantRanges;
    
  }
};

VkPipelineLayoutCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSetLayouts !== null) {
    let array = this._pSetLayouts;
    
    if (array.length !== this.setLayoutCount) {
      throw new RangeError("Invalid array length, expected length of 'setLayoutCount' for 'VkPipelineLayoutCreateInfo.pSetLayouts'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorSetLayout)) {
        throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pSetLayouts[" + ii + "]': Expected 'VkDescriptorSetLayout' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSetLayoutsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSetLayoutsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pPushConstantRanges !== null) {
    let array = this._pPushConstantRanges;
    
    if (array.length !== this.pushConstantRangeCount) {
      throw new RangeError("Invalid array length, expected length of 'pushConstantRangeCount' for 'VkPipelineLayoutCreateInfo.pPushConstantRanges'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPushConstantRange)) {
        throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pPushConstantRanges[" + ii + "]': Expected 'VkPushConstantRange' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPushConstantRangesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pPushConstantRangesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineLayoutCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineLayoutCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineLayoutCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.setLayoutCount = original.setLayoutCount;
  if (original.pSetLayouts !== null) {
        copy.pSetLayouts = [...Array(original.pSetLayouts.length)].map((v, i) => {
          return original.pSetLayouts[i].constructor.createCopyFrom(original.pSetLayouts[i]);
        });
      }
  copy.pushConstantRangeCount = original.pushConstantRangeCount;
  if (original.pPushConstantRanges !== null) {
        copy.pPushConstantRanges = [...Array(original.pPushConstantRanges.length)].map((v, i) => {
          return original.pPushConstantRanges[i].constructor.createCopyFrom(original.pPushConstantRanges[i]);
        });
      }
  
  return copy;
};

VkPipelineLayoutCreateInfo.byteLength = 0x0;

VkPipelineLayoutCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  setLayoutCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSetLayouts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pushConstantRangeCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPushConstantRanges: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSamplerCreateInfo **/
function VkSamplerCreateInfo(opts, byteOffset) {
  if (new.target !== VkSamplerCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSamplerCreateInfo, STRUCT_CACHE_VkSamplerCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSamplerCreateInfo, STRUCT_CACHE_VkSamplerCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSamplerCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.magFilter !== void 0) this.magFilter = opts.magFilter;
    if (opts.minFilter !== void 0) this.minFilter = opts.minFilter;
    if (opts.mipmapMode !== void 0) this.mipmapMode = opts.mipmapMode;
    if (opts.addressModeU !== void 0) this.addressModeU = opts.addressModeU;
    if (opts.addressModeV !== void 0) this.addressModeV = opts.addressModeV;
    if (opts.addressModeW !== void 0) this.addressModeW = opts.addressModeW;
    if (opts.mipLodBias !== void 0) this.mipLodBias = opts.mipLodBias;
    if (opts.anisotropyEnable !== void 0) this.anisotropyEnable = opts.anisotropyEnable;
    if (opts.maxAnisotropy !== void 0) this.maxAnisotropy = opts.maxAnisotropy;
    if (opts.compareEnable !== void 0) this.compareEnable = opts.compareEnable;
    if (opts.compareOp !== void 0) this.compareOp = opts.compareOp;
    if (opts.minLod !== void 0) this.minLod = opts.minLod;
    if (opts.maxLod !== void 0) this.maxLod = opts.maxLod;
    if (opts.borderColor !== void 0) this.borderColor = opts.borderColor;
    if (opts.unnormalizedCoordinates !== void 0) this.unnormalizedCoordinates = opts.unnormalizedCoordinates;
    
  }
};

Object.defineProperties(VkSamplerCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSamplerCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkSamplerCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "magFilter": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.magFilter");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "minFilter": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.minFilter");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "mipmapMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.mipmapMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "addressModeU": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.addressModeU");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "addressModeV": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.addressModeV");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "addressModeW": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.addressModeW");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "mipLodBias": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.mipLodBias");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "anisotropyEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "maxAnisotropy": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.maxAnisotropy");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "compareEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "compareOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.compareOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "minLod": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.minLod");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxLod": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.maxLod");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "borderColor": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCreateInfo.borderColor");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "unnormalizedCoordinates": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkSamplerCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.magFilter !== void 0) this.magFilter = opts.magFilter;
    if (opts.minFilter !== void 0) this.minFilter = opts.minFilter;
    if (opts.mipmapMode !== void 0) this.mipmapMode = opts.mipmapMode;
    if (opts.addressModeU !== void 0) this.addressModeU = opts.addressModeU;
    if (opts.addressModeV !== void 0) this.addressModeV = opts.addressModeV;
    if (opts.addressModeW !== void 0) this.addressModeW = opts.addressModeW;
    if (opts.mipLodBias !== void 0) this.mipLodBias = opts.mipLodBias;
    if (opts.anisotropyEnable !== void 0) this.anisotropyEnable = opts.anisotropyEnable;
    if (opts.maxAnisotropy !== void 0) this.maxAnisotropy = opts.maxAnisotropy;
    if (opts.compareEnable !== void 0) this.compareEnable = opts.compareEnable;
    if (opts.compareOp !== void 0) this.compareOp = opts.compareOp;
    if (opts.minLod !== void 0) this.minLod = opts.minLod;
    if (opts.maxLod !== void 0) this.maxLod = opts.maxLod;
    if (opts.borderColor !== void 0) this.borderColor = opts.borderColor;
    if (opts.unnormalizedCoordinates !== void 0) this.unnormalizedCoordinates = opts.unnormalizedCoordinates;
    
  }
};

VkSamplerCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSamplerCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSamplerCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.magFilter = original.magFilter;
  copy.minFilter = original.minFilter;
  copy.mipmapMode = original.mipmapMode;
  copy.addressModeU = original.addressModeU;
  copy.addressModeV = original.addressModeV;
  copy.addressModeW = original.addressModeW;
  copy.mipLodBias = original.mipLodBias;
  copy.anisotropyEnable = original.anisotropyEnable;
  copy.maxAnisotropy = original.maxAnisotropy;
  copy.compareEnable = original.compareEnable;
  copy.compareOp = original.compareOp;
  copy.minLod = original.minLod;
  copy.maxLod = original.maxLod;
  copy.borderColor = original.borderColor;
  copy.unnormalizedCoordinates = original.unnormalizedCoordinates;
  
  return copy;
};

VkSamplerCreateInfo.byteLength = 0x0;

VkSamplerCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  magFilter: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minFilter: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mipmapMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  addressModeU: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  addressModeV: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  addressModeW: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mipLodBias: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  anisotropyEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxAnisotropy: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compareEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compareOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minLod: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxLod: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  borderColor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  unnormalizedCoordinates: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCommandPoolCreateInfo **/
function VkCommandPoolCreateInfo(opts, byteOffset) {
  if (new.target !== VkCommandPoolCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCommandPoolCreateInfo, STRUCT_CACHE_VkCommandPoolCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCommandPoolCreateInfo, STRUCT_CACHE_VkCommandPoolCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCommandPoolCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    
  }
};

Object.defineProperties(VkCommandPoolCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandPoolCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCommandPoolCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandPoolCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "queueFamilyIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandPoolCreateInfo.queueFamilyIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkCommandPoolCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    
  }
};

VkCommandPoolCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandPoolCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkCommandPoolCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCommandPoolCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.queueFamilyIndex = original.queueFamilyIndex;
  
  return copy;
};

VkCommandPoolCreateInfo.byteLength = 0x0;

VkCommandPoolCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueFamilyIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCommandBufferAllocateInfo **/
function VkCommandBufferAllocateInfo(opts, byteOffset) {
  if (new.target !== VkCommandBufferAllocateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCommandBufferAllocateInfo, STRUCT_CACHE_VkCommandBufferAllocateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCommandBufferAllocateInfo, STRUCT_CACHE_VkCommandBufferAllocateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCommandBufferAllocateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._commandPool = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.commandPool !== void 0) this.commandPool = opts.commandPool;
    if (opts.level !== void 0) this.level = opts.level;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    
  }
};

Object.defineProperties(VkCommandBufferAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferAllocateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCommandBufferAllocateInfo.pNext' isn't allowed to be filled");
    }
    },
  "commandPool": {
    get() {
    return this._commandPool;
    },
    set(value) {
    if (value !== null && value.constructor === VkCommandPool) {
      
      this._commandPool = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._commandPool = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferAllocateInfo.commandPool': Expected 'VkCommandPool' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "level": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferAllocateInfo.level");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "commandBufferCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferAllocateInfo.commandBufferCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkCommandBufferAllocateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._commandPool = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.commandPool !== void 0) this.commandPool = opts.commandPool;
    if (opts.level !== void 0) this.level = opts.level;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    
  }
};

VkCommandBufferAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkCommandBufferAllocateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCommandBufferAllocateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.commandPool !== null) {
        copy.commandPool = original.commandPool.constructor.createCopyFrom(original.commandPool);
      }
  copy.level = original.level;
  copy.commandBufferCount = original.commandBufferCount;
  
  return copy;
};

VkCommandBufferAllocateInfo.byteLength = 0x0;

VkCommandBufferAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  commandPool: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  level: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  commandBufferCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCommandBufferInheritanceInfo **/
function VkCommandBufferInheritanceInfo(opts, byteOffset) {
  if (new.target !== VkCommandBufferInheritanceInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCommandBufferInheritanceInfo, STRUCT_CACHE_VkCommandBufferInheritanceInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCommandBufferInheritanceInfo, STRUCT_CACHE_VkCommandBufferInheritanceInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCommandBufferInheritanceInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._renderPass = null;
  
  this._framebuffer = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.framebuffer !== void 0) this.framebuffer = opts.framebuffer;
    if (opts.occlusionQueryEnable !== void 0) this.occlusionQueryEnable = opts.occlusionQueryEnable;
    if (opts.queryFlags !== void 0) this.queryFlags = opts.queryFlags;
    if (opts.pipelineStatistics !== void 0) this.pipelineStatistics = opts.pipelineStatistics;
    
  }
};

Object.defineProperties(VkCommandBufferInheritanceInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferInheritanceInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pNext'");
      switch (sType) {
          
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pNext'");
    }
    
    }
    },
  "renderPass": {
    get() {
    return this._renderPass;
    },
    set(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._renderPass = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.renderPass': Expected 'VkRenderPass' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "subpass": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferInheritanceInfo.subpass");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "framebuffer": {
    get() {
    return this._framebuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkFramebuffer) {
      
      this._framebuffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._framebuffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.framebuffer': Expected 'VkFramebuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "occlusionQueryEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "queryFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferInheritanceInfo.queryFlags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pipelineStatistics": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferInheritanceInfo.pipelineStatistics");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkCommandBufferInheritanceInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._renderPass = null;
  
  this._framebuffer = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.framebuffer !== void 0) this.framebuffer = opts.framebuffer;
    if (opts.occlusionQueryEnable !== void 0) this.occlusionQueryEnable = opts.occlusionQueryEnable;
    if (opts.queryFlags !== void 0) this.queryFlags = opts.queryFlags;
    if (opts.pipelineStatistics !== void 0) this.pipelineStatistics = opts.pipelineStatistics;
    
  }
};

VkCommandBufferInheritanceInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferInheritanceInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkCommandBufferInheritanceInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCommandBufferInheritanceInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.renderPass !== null) {
        copy.renderPass = original.renderPass.constructor.createCopyFrom(original.renderPass);
      }
  copy.subpass = original.subpass;
  if (original.framebuffer !== null) {
        copy.framebuffer = original.framebuffer.constructor.createCopyFrom(original.framebuffer);
      }
  copy.occlusionQueryEnable = original.occlusionQueryEnable;
  copy.queryFlags = original.queryFlags;
  copy.pipelineStatistics = original.pipelineStatistics;
  
  return copy;
};

VkCommandBufferInheritanceInfo.byteLength = 0x0;

VkCommandBufferInheritanceInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  renderPass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subpass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  framebuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  occlusionQueryEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queryFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineStatistics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCommandBufferBeginInfo **/
function VkCommandBufferBeginInfo(opts, byteOffset) {
  if (new.target !== VkCommandBufferBeginInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCommandBufferBeginInfo, STRUCT_CACHE_VkCommandBufferBeginInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCommandBufferBeginInfo, STRUCT_CACHE_VkCommandBufferBeginInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCommandBufferBeginInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pInheritanceInfo = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pInheritanceInfo !== void 0) this.pInheritanceInfo = opts.pInheritanceInfo;
    
  }
};

Object.defineProperties(VkCommandBufferBeginInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferBeginInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferBeginInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pInheritanceInfo": {
    get() {
    if (this._pInheritanceInfo === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkCommandBufferInheritanceInfo.byteLength));
      this._pInheritanceInfo = new VkCommandBufferInheritanceInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pInheritanceInfo.memoryAddress, true);
      return this.pInheritanceInfo;
    } else {
      return this._pInheritanceInfo;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkCommandBufferInheritanceInfo) {
      value.flush();
      this._pInheritanceInfo = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pInheritanceInfo = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pInheritanceInfo': Expected 'VkCommandBufferInheritanceInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkCommandBufferBeginInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pInheritanceInfo = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pInheritanceInfo !== void 0) this.pInheritanceInfo = opts.pInheritanceInfo;
    
  }
};

VkCommandBufferBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkCommandBufferBeginInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCommandBufferBeginInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  if (original.pInheritanceInfo !== null) {
        copy.pInheritanceInfo = original.pInheritanceInfo.constructor.createCopyFrom(original.pInheritanceInfo);
      }
  
  return copy;
};

VkCommandBufferBeginInfo.byteLength = 0x0;

VkCommandBufferBeginInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pInheritanceInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassBeginInfo **/
function VkRenderPassBeginInfo(opts, byteOffset) {
  if (new.target !== VkRenderPassBeginInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassBeginInfo, STRUCT_CACHE_VkRenderPassBeginInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassBeginInfo, STRUCT_CACHE_VkRenderPassBeginInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassBeginInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._renderPass = null;
  this._framebuffer = null;
  this._renderArea = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  this._pClearValues = null;
  this._pClearValuesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.framebuffer !== void 0) this.framebuffer = opts.framebuffer;
    if (opts.renderArea !== void 0) this.renderArea = opts.renderArea;
    if (opts.clearValueCount !== void 0) this.clearValueCount = opts.clearValueCount;
    if (opts.pClearValues !== void 0) this.pClearValues = opts.pClearValues;
    
  }
};

Object.defineProperties(VkRenderPassBeginInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassBeginInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pNext'");
    }
    
    }
    },
  "renderPass": {
    get() {
    return this._renderPass;
    },
    set(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._renderPass = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.renderPass': Expected 'VkRenderPass' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "framebuffer": {
    get() {
    return this._framebuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkFramebuffer) {
      
      this._framebuffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._framebuffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.framebuffer': Expected 'VkFramebuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "renderArea": {
    get() {
    return this._renderArea;
    },
    set(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._renderArea = value;
      
      
    } else if (value === null) {
      this._renderArea = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.renderArea': Expected 'VkRect2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "clearValueCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassBeginInfo.clearValueCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pClearValues": {
    get() {
    if (this._pClearValues === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.clearValueCount, VkClearValue);
      this._pClearValues = array;
      return this.pClearValues;
    } else {
      return this._pClearValues;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pClearValues = value;
    } else if (value === null) {
      this._pClearValues = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pClearValues': Expected 'Array VkClearValue' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassBeginInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._renderPass = null;
  this._framebuffer = null;
  if (this._renderArea !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._renderArea.memoryBuffer) this._renderArea = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._renderArea.reset();
  }
  
  this._pClearValues = null;
  this._pClearValuesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.framebuffer !== void 0) this.framebuffer = opts.framebuffer;
    if (opts.renderArea !== void 0) this.renderArea = opts.renderArea;
    if (opts.clearValueCount !== void 0) this.clearValueCount = opts.clearValueCount;
    if (opts.pClearValues !== void 0) this.pClearValues = opts.pClearValues;
    
  }
};

VkRenderPassBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._renderArea !== null) {
    let renderArea = this._renderArea;
    renderArea.flush();
    if (this.memoryBuffer !== renderArea.memoryBuffer) {
      let srcView = new Uint8Array(renderArea.memoryBuffer, renderArea.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRenderPassBeginInfo.renderArea' isn't used as shared-memory");
    }
  }
  
  
  if (this._pClearValues !== null) {
    let array = this._pClearValues;
    
    if (array.length !== this.clearValueCount) {
      throw new RangeError("Invalid array length, expected length of 'clearValueCount' for 'VkRenderPassBeginInfo.pClearValues'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkClearValue)) {
        throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pClearValues[" + ii + "]': Expected 'VkClearValue' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pClearValuesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pClearValuesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRenderPassBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassBeginInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassBeginInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.renderPass !== null) {
        copy.renderPass = original.renderPass.constructor.createCopyFrom(original.renderPass);
      }
  if (original.framebuffer !== null) {
        copy.framebuffer = original.framebuffer.constructor.createCopyFrom(original.framebuffer);
      }
  if (original.renderArea !== null) {
        copy.renderArea = original.renderArea.constructor.createCopyFrom(original.renderArea);
      }
  copy.clearValueCount = original.clearValueCount;
  if (original.pClearValues !== null) {
        copy.pClearValues = [...Array(original.pClearValues.length)].map((v, i) => {
          return original.pClearValues[i].constructor.createCopyFrom(original.pClearValues[i]);
        });
      }
  
  return copy;
};

VkRenderPassBeginInfo.byteLength = 0x0;

VkRenderPassBeginInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  renderPass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  framebuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  renderArea: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  clearValueCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pClearValues: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkClearDepthStencilValue **/
function VkClearDepthStencilValue(opts, byteOffset) {
  if (new.target !== VkClearDepthStencilValue) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkClearDepthStencilValue, STRUCT_CACHE_VkClearDepthStencilValue);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkClearDepthStencilValue, STRUCT_CACHE_VkClearDepthStencilValue);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkClearDepthStencilValue'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.depth !== void 0) this.depth = opts.depth;
    if (opts.stencil !== void 0) this.stencil = opts.stencil;
    
  }
};

Object.defineProperties(VkClearDepthStencilValue.prototype, {
  "depth": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkClearDepthStencilValue.depth");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "stencil": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkClearDepthStencilValue.stencil");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkClearDepthStencilValue.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.depth !== void 0) this.depth = opts.depth;
    if (opts.stencil !== void 0) this.stencil = opts.stencil;
    
  }
};

VkClearDepthStencilValue.prototype.flush = function flush() {
  
  return true;
};

VkClearDepthStencilValue.prototype.reflect = function reflect(memoryAddress) {
  };

VkClearDepthStencilValue.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkClearDepthStencilValue();
  copy.depth = original.depth;
  copy.stencil = original.stencil;
  
  return copy;
};

VkClearDepthStencilValue.byteLength = 0x0;

VkClearDepthStencilValue.memoryLayout = {
  depth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencil: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkClearAttachment **/
function VkClearAttachment(opts, byteOffset) {
  if (new.target !== VkClearAttachment) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkClearAttachment, STRUCT_CACHE_VkClearAttachment);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkClearAttachment, STRUCT_CACHE_VkClearAttachment);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkClearAttachment'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  this._clearValue = new VkClearValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.colorAttachment !== void 0) this.colorAttachment = opts.colorAttachment;
    if (opts.clearValue !== void 0) this.clearValue = opts.clearValue;
    
  }
};

Object.defineProperties(VkClearAttachment.prototype, {
  "aspectMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkClearAttachment.aspectMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "colorAttachment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkClearAttachment.colorAttachment");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "clearValue": {
    get() {
    return this._clearValue;
    },
    set(value) {
    if (value !== null && value.constructor === VkClearValue) {
      value.flush();
      this._clearValue = value;
      
      
    } else if (value === null) {
      this._clearValue = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearAttachment.clearValue': Expected 'VkClearValue' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkClearAttachment.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  if (this._clearValue !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._clearValue.memoryBuffer) this._clearValue = new VkClearValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._clearValue.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    if (opts.colorAttachment !== void 0) this.colorAttachment = opts.colorAttachment;
    if (opts.clearValue !== void 0) this.clearValue = opts.clearValue;
    
  }
};

VkClearAttachment.prototype.flush = function flush() {
  
  
  if (this._clearValue !== null) {
    let clearValue = this._clearValue;
    clearValue.flush();
    if (this.memoryBuffer !== clearValue.memoryBuffer) {
      let srcView = new Uint8Array(clearValue.memoryBuffer, clearValue.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkClearAttachment.clearValue' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkClearAttachment.prototype.reflect = function reflect(memoryAddress) {
  };

VkClearAttachment.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkClearAttachment();
  copy.aspectMask = original.aspectMask;
  copy.colorAttachment = original.colorAttachment;
  if (original.clearValue !== null) {
        copy.clearValue = original.clearValue.constructor.createCopyFrom(original.clearValue);
      }
  
  return copy;
};

VkClearAttachment.byteLength = 0x0;

VkClearAttachment.memoryLayout = {
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  colorAttachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  clearValue: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentDescription **/
function VkAttachmentDescription(opts, byteOffset) {
  if (new.target !== VkAttachmentDescription) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentDescription, STRUCT_CACHE_VkAttachmentDescription);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentDescription, STRUCT_CACHE_VkAttachmentDescription);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentDescription'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.loadOp !== void 0) this.loadOp = opts.loadOp;
    if (opts.storeOp !== void 0) this.storeOp = opts.storeOp;
    if (opts.stencilLoadOp !== void 0) this.stencilLoadOp = opts.stencilLoadOp;
    if (opts.stencilStoreOp !== void 0) this.stencilStoreOp = opts.stencilStoreOp;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    if (opts.finalLayout !== void 0) this.finalLayout = opts.finalLayout;
    
  }
};

Object.defineProperties(VkAttachmentDescription.prototype, {
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "samples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription.samples");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "loadOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription.loadOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "storeOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription.storeOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stencilLoadOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription.stencilLoadOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stencilStoreOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription.stencilStoreOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "initialLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription.initialLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "finalLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription.finalLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAttachmentDescription.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.loadOp !== void 0) this.loadOp = opts.loadOp;
    if (opts.storeOp !== void 0) this.storeOp = opts.storeOp;
    if (opts.stencilLoadOp !== void 0) this.stencilLoadOp = opts.stencilLoadOp;
    if (opts.stencilStoreOp !== void 0) this.stencilStoreOp = opts.stencilStoreOp;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    if (opts.finalLayout !== void 0) this.finalLayout = opts.finalLayout;
    
  }
};

VkAttachmentDescription.prototype.flush = function flush() {
  
  return true;
};

VkAttachmentDescription.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentDescription.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentDescription();
  copy.flags = original.flags;
  copy.format = original.format;
  copy.samples = original.samples;
  copy.loadOp = original.loadOp;
  copy.storeOp = original.storeOp;
  copy.stencilLoadOp = original.stencilLoadOp;
  copy.stencilStoreOp = original.stencilStoreOp;
  copy.initialLayout = original.initialLayout;
  copy.finalLayout = original.finalLayout;
  
  return copy;
};

VkAttachmentDescription.byteLength = 0x0;

VkAttachmentDescription.memoryLayout = {
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  loadOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storeOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilLoadOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilStoreOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  initialLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  finalLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentReference **/
function VkAttachmentReference(opts, byteOffset) {
  if (new.target !== VkAttachmentReference) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentReference, STRUCT_CACHE_VkAttachmentReference);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentReference, STRUCT_CACHE_VkAttachmentReference);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentReference'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.attachment !== void 0) this.attachment = opts.attachment;
    if (opts.layout !== void 0) this.layout = opts.layout;
    
  }
};

Object.defineProperties(VkAttachmentReference.prototype, {
  "attachment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReference.attachment");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "layout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReference.layout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAttachmentReference.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.attachment !== void 0) this.attachment = opts.attachment;
    if (opts.layout !== void 0) this.layout = opts.layout;
    
  }
};

VkAttachmentReference.prototype.flush = function flush() {
  
  return true;
};

VkAttachmentReference.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentReference.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentReference();
  copy.attachment = original.attachment;
  copy.layout = original.layout;
  
  return copy;
};

VkAttachmentReference.byteLength = 0x0;

VkAttachmentReference.memoryLayout = {
  attachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassDescription **/
function VkSubpassDescription(opts, byteOffset) {
  if (new.target !== VkSubpassDescription) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassDescription, STRUCT_CACHE_VkSubpassDescription);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassDescription, STRUCT_CACHE_VkSubpassDescription);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassDescription'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  this._pInputAttachments = null;
  this._pInputAttachmentsNative = null;
  
  this._pColorAttachments = null;
  this._pColorAttachmentsNative = null;
  this._pResolveAttachments = null;
  this._pResolveAttachmentsNative = null;
  this._pDepthStencilAttachment = null;
  
  this._pPreserveAttachments = null;
  
  if (typeof opts === "object") {
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.inputAttachmentCount !== void 0) this.inputAttachmentCount = opts.inputAttachmentCount;
    if (opts.pInputAttachments !== void 0) this.pInputAttachments = opts.pInputAttachments;
    if (opts.colorAttachmentCount !== void 0) this.colorAttachmentCount = opts.colorAttachmentCount;
    if (opts.pColorAttachments !== void 0) this.pColorAttachments = opts.pColorAttachments;
    if (opts.pResolveAttachments !== void 0) this.pResolveAttachments = opts.pResolveAttachments;
    if (opts.pDepthStencilAttachment !== void 0) this.pDepthStencilAttachment = opts.pDepthStencilAttachment;
    if (opts.preserveAttachmentCount !== void 0) this.preserveAttachmentCount = opts.preserveAttachmentCount;
    if (opts.pPreserveAttachments !== void 0) this.pPreserveAttachments = opts.pPreserveAttachments;
    
  }
};

Object.defineProperties(VkSubpassDescription.prototype, {
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription.pipelineBindPoint");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "inputAttachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription.inputAttachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pInputAttachments": {
    get() {
    if (this._pInputAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.inputAttachmentCount, VkAttachmentReference);
      this._pInputAttachments = array;
      return this.pInputAttachments;
    } else {
      return this._pInputAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pInputAttachments = value;
    } else if (value === null) {
      this._pInputAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pInputAttachments': Expected 'Array VkAttachmentReference' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "colorAttachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription.colorAttachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pColorAttachments": {
    get() {
    if (this._pColorAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.colorAttachmentCount, VkAttachmentReference);
      this._pColorAttachments = array;
      return this.pColorAttachments;
    } else {
      return this._pColorAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pColorAttachments = value;
    } else if (value === null) {
      this._pColorAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pColorAttachments': Expected 'Array VkAttachmentReference' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pResolveAttachments": {
    get() {
    if (this._pResolveAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.colorAttachmentCount, VkAttachmentReference);
      this._pResolveAttachments = array;
      return this.pResolveAttachments;
    } else {
      return this._pResolveAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pResolveAttachments = value;
    } else if (value === null) {
      this._pResolveAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pResolveAttachments': Expected 'Array VkAttachmentReference' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pDepthStencilAttachment": {
    get() {
    if (this._pDepthStencilAttachment === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkAttachmentReference.byteLength));
      this._pDepthStencilAttachment = new VkAttachmentReference({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pDepthStencilAttachment.memoryAddress, true);
      return this.pDepthStencilAttachment;
    } else {
      return this._pDepthStencilAttachment;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference) {
      value.flush();
      this._pDepthStencilAttachment = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pDepthStencilAttachment = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pDepthStencilAttachment': Expected 'VkAttachmentReference' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "preserveAttachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription.preserveAttachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPreserveAttachments": {
    get() {
    return this._pPreserveAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pPreserveAttachments = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pPreserveAttachments = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pPreserveAttachments': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSubpassDescription.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  this._pInputAttachments = null;
  this._pInputAttachmentsNative = null;
  
  this._pColorAttachments = null;
  this._pColorAttachmentsNative = null;
  this._pResolveAttachments = null;
  this._pResolveAttachmentsNative = null;
  this._pDepthStencilAttachment = null;
  
  this._pPreserveAttachments = null;
  
  if (typeof opts === "object") {
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.inputAttachmentCount !== void 0) this.inputAttachmentCount = opts.inputAttachmentCount;
    if (opts.pInputAttachments !== void 0) this.pInputAttachments = opts.pInputAttachments;
    if (opts.colorAttachmentCount !== void 0) this.colorAttachmentCount = opts.colorAttachmentCount;
    if (opts.pColorAttachments !== void 0) this.pColorAttachments = opts.pColorAttachments;
    if (opts.pResolveAttachments !== void 0) this.pResolveAttachments = opts.pResolveAttachments;
    if (opts.pDepthStencilAttachment !== void 0) this.pDepthStencilAttachment = opts.pDepthStencilAttachment;
    if (opts.preserveAttachmentCount !== void 0) this.preserveAttachmentCount = opts.preserveAttachmentCount;
    if (opts.pPreserveAttachments !== void 0) this.pPreserveAttachments = opts.pPreserveAttachments;
    
  }
};

VkSubpassDescription.prototype.flush = function flush() {
  
  
  if (this._pInputAttachments !== null) {
    let array = this._pInputAttachments;
    
    if (array.length !== this.inputAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'inputAttachmentCount' for 'VkSubpassDescription.pInputAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription.pInputAttachments[" + ii + "]': Expected 'VkAttachmentReference' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pInputAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pInputAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pColorAttachments !== null) {
    let array = this._pColorAttachments;
    
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription.pColorAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription.pColorAttachments[" + ii + "]': Expected 'VkAttachmentReference' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pColorAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pColorAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pResolveAttachments !== null) {
    let array = this._pResolveAttachments;
    
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription.pResolveAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription.pResolveAttachments[" + ii + "]': Expected 'VkAttachmentReference' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pResolveAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pResolveAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSubpassDescription.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassDescription.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassDescription();
  copy.flags = original.flags;
  copy.pipelineBindPoint = original.pipelineBindPoint;
  copy.inputAttachmentCount = original.inputAttachmentCount;
  if (original.pInputAttachments !== null) {
        copy.pInputAttachments = [...Array(original.pInputAttachments.length)].map((v, i) => {
          return original.pInputAttachments[i].constructor.createCopyFrom(original.pInputAttachments[i]);
        });
      }
  copy.colorAttachmentCount = original.colorAttachmentCount;
  if (original.pColorAttachments !== null) {
        copy.pColorAttachments = [...Array(original.pColorAttachments.length)].map((v, i) => {
          return original.pColorAttachments[i].constructor.createCopyFrom(original.pColorAttachments[i]);
        });
      }
  if (original.pResolveAttachments !== null) {
        copy.pResolveAttachments = [...Array(original.pResolveAttachments.length)].map((v, i) => {
          return original.pResolveAttachments[i].constructor.createCopyFrom(original.pResolveAttachments[i]);
        });
      }
  if (original.pDepthStencilAttachment !== null) {
        copy.pDepthStencilAttachment = original.pDepthStencilAttachment.constructor.createCopyFrom(original.pDepthStencilAttachment);
      }
  copy.preserveAttachmentCount = original.preserveAttachmentCount;
  if (original.pPreserveAttachments !== null) {
        copy.pPreserveAttachments = new Uint32Array(original.pPreserveAttachments);
      }
  
  return copy;
};

VkSubpassDescription.byteLength = 0x0;

VkSubpassDescription.memoryLayout = {
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineBindPoint: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  inputAttachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  colorAttachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pColorAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pResolveAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDepthStencilAttachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  preserveAttachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPreserveAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassDependency **/
function VkSubpassDependency(opts, byteOffset) {
  if (new.target !== VkSubpassDependency) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassDependency, STRUCT_CACHE_VkSubpassDependency);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassDependency, STRUCT_CACHE_VkSubpassDependency);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassDependency'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.srcSubpass !== void 0) this.srcSubpass = opts.srcSubpass;
    if (opts.dstSubpass !== void 0) this.dstSubpass = opts.dstSubpass;
    if (opts.srcStageMask !== void 0) this.srcStageMask = opts.srcStageMask;
    if (opts.dstStageMask !== void 0) this.dstStageMask = opts.dstStageMask;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.dependencyFlags !== void 0) this.dependencyFlags = opts.dependencyFlags;
    
  }
};

Object.defineProperties(VkSubpassDependency.prototype, {
  "srcSubpass": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency.srcSubpass");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "dstSubpass": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency.dstSubpass");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "srcStageMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency.srcStageMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstStageMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency.dstStageMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency.srcAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency.dstAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dependencyFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency.dependencyFlags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSubpassDependency.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.srcSubpass !== void 0) this.srcSubpass = opts.srcSubpass;
    if (opts.dstSubpass !== void 0) this.dstSubpass = opts.dstSubpass;
    if (opts.srcStageMask !== void 0) this.srcStageMask = opts.srcStageMask;
    if (opts.dstStageMask !== void 0) this.dstStageMask = opts.dstStageMask;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.dependencyFlags !== void 0) this.dependencyFlags = opts.dependencyFlags;
    
  }
};

VkSubpassDependency.prototype.flush = function flush() {
  
  return true;
};

VkSubpassDependency.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassDependency.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassDependency();
  copy.srcSubpass = original.srcSubpass;
  copy.dstSubpass = original.dstSubpass;
  copy.srcStageMask = original.srcStageMask;
  copy.dstStageMask = original.dstStageMask;
  copy.srcAccessMask = original.srcAccessMask;
  copy.dstAccessMask = original.dstAccessMask;
  copy.dependencyFlags = original.dependencyFlags;
  
  return copy;
};

VkSubpassDependency.byteLength = 0x0;

VkSubpassDependency.memoryLayout = {
  srcSubpass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSubpass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcStageMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstStageMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dependencyFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassCreateInfo **/
function VkRenderPassCreateInfo(opts, byteOffset) {
  if (new.target !== VkRenderPassCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassCreateInfo, STRUCT_CACHE_VkRenderPassCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassCreateInfo, STRUCT_CACHE_VkRenderPassCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  
  this._pSubpasses = null;
  this._pSubpassesNative = null;
  
  this._pDependencies = null;
  this._pDependenciesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pSubpasses !== void 0) this.pSubpasses = opts.pSubpasses;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pDependencies !== void 0) this.pDependencies = opts.pDependencies;
    
  }
};

Object.defineProperties(VkRenderPassCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo.attachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAttachments": {
    get() {
    if (this._pAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.attachmentCount, VkAttachmentDescription);
      this._pAttachments = array;
      return this.pAttachments;
    } else {
      return this._pAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pAttachments': Expected 'Array VkAttachmentDescription' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "subpassCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo.subpassCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSubpasses": {
    get() {
    if (this._pSubpasses === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.subpassCount, VkSubpassDescription);
      this._pSubpasses = array;
      return this.pSubpasses;
    } else {
      return this._pSubpasses;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSubpasses = value;
    } else if (value === null) {
      this._pSubpasses = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pSubpasses': Expected 'Array VkSubpassDescription' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "dependencyCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo.dependencyCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDependencies": {
    get() {
    if (this._pDependencies === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.dependencyCount, VkSubpassDependency);
      this._pDependencies = array;
      return this.pDependencies;
    } else {
      return this._pDependencies;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDependencies = value;
    } else if (value === null) {
      this._pDependencies = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pDependencies': Expected 'Array VkSubpassDependency' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  
  this._pSubpasses = null;
  this._pSubpassesNative = null;
  
  this._pDependencies = null;
  this._pDependenciesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pSubpasses !== void 0) this.pSubpasses = opts.pSubpasses;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pDependencies !== void 0) this.pDependencies = opts.pDependencies;
    
  }
};

VkRenderPassCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkRenderPassCreateInfo.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentDescription)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pAttachments[" + ii + "]': Expected 'VkAttachmentDescription' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pSubpasses !== null) {
    let array = this._pSubpasses;
    
    if (array.length !== this.subpassCount) {
      throw new RangeError("Invalid array length, expected length of 'subpassCount' for 'VkRenderPassCreateInfo.pSubpasses'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassDescription)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pSubpasses[" + ii + "]': Expected 'VkSubpassDescription' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSubpassesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSubpassesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pDependencies !== null) {
    let array = this._pDependencies;
    
    if (array.length !== this.dependencyCount) {
      throw new RangeError("Invalid array length, expected length of 'dependencyCount' for 'VkRenderPassCreateInfo.pDependencies'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassDependency)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pDependencies[" + ii + "]': Expected 'VkSubpassDependency' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDependenciesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pDependenciesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRenderPassCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.attachmentCount = original.attachmentCount;
  if (original.pAttachments !== null) {
        copy.pAttachments = [...Array(original.pAttachments.length)].map((v, i) => {
          return original.pAttachments[i].constructor.createCopyFrom(original.pAttachments[i]);
        });
      }
  copy.subpassCount = original.subpassCount;
  if (original.pSubpasses !== null) {
        copy.pSubpasses = [...Array(original.pSubpasses.length)].map((v, i) => {
          return original.pSubpasses[i].constructor.createCopyFrom(original.pSubpasses[i]);
        });
      }
  copy.dependencyCount = original.dependencyCount;
  if (original.pDependencies !== null) {
        copy.pDependencies = [...Array(original.pDependencies.length)].map((v, i) => {
          return original.pDependencies[i].constructor.createCopyFrom(original.pDependencies[i]);
        });
      }
  
  return copy;
};

VkRenderPassCreateInfo.byteLength = 0x0;

VkRenderPassCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subpassCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSubpasses: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dependencyCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDependencies: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkEventCreateInfo **/
function VkEventCreateInfo(opts, byteOffset) {
  if (new.target !== VkEventCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkEventCreateInfo, STRUCT_CACHE_VkEventCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkEventCreateInfo, STRUCT_CACHE_VkEventCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkEventCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkEventCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkEventCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkEventCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkEventCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkEventCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkEventCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkEventCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkEventCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkEventCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  
  return copy;
};

VkEventCreateInfo.byteLength = 0x0;

VkEventCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFenceCreateInfo **/
function VkFenceCreateInfo(opts, byteOffset) {
  if (new.target !== VkFenceCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFenceCreateInfo, STRUCT_CACHE_VkFenceCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFenceCreateInfo, STRUCT_CACHE_VkFenceCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFenceCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkFenceCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFenceCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFenceCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkFenceCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkFenceCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFenceCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkFenceCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkFenceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFenceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkFenceCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFenceCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  
  return copy;
};

VkFenceCreateInfo.byteLength = 0x0;

VkFenceCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFeatures **/
function VkPhysicalDeviceFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFeatures, STRUCT_CACHE_VkPhysicalDeviceFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFeatures, STRUCT_CACHE_VkPhysicalDeviceFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.robustBufferAccess !== void 0) this.robustBufferAccess = opts.robustBufferAccess;
    if (opts.fullDrawIndexUint32 !== void 0) this.fullDrawIndexUint32 = opts.fullDrawIndexUint32;
    if (opts.imageCubeArray !== void 0) this.imageCubeArray = opts.imageCubeArray;
    if (opts.independentBlend !== void 0) this.independentBlend = opts.independentBlend;
    if (opts.geometryShader !== void 0) this.geometryShader = opts.geometryShader;
    if (opts.tessellationShader !== void 0) this.tessellationShader = opts.tessellationShader;
    if (opts.sampleRateShading !== void 0) this.sampleRateShading = opts.sampleRateShading;
    if (opts.dualSrcBlend !== void 0) this.dualSrcBlend = opts.dualSrcBlend;
    if (opts.logicOp !== void 0) this.logicOp = opts.logicOp;
    if (opts.multiDrawIndirect !== void 0) this.multiDrawIndirect = opts.multiDrawIndirect;
    if (opts.drawIndirectFirstInstance !== void 0) this.drawIndirectFirstInstance = opts.drawIndirectFirstInstance;
    if (opts.depthClamp !== void 0) this.depthClamp = opts.depthClamp;
    if (opts.depthBiasClamp !== void 0) this.depthBiasClamp = opts.depthBiasClamp;
    if (opts.fillModeNonSolid !== void 0) this.fillModeNonSolid = opts.fillModeNonSolid;
    if (opts.depthBounds !== void 0) this.depthBounds = opts.depthBounds;
    if (opts.wideLines !== void 0) this.wideLines = opts.wideLines;
    if (opts.largePoints !== void 0) this.largePoints = opts.largePoints;
    if (opts.alphaToOne !== void 0) this.alphaToOne = opts.alphaToOne;
    if (opts.multiViewport !== void 0) this.multiViewport = opts.multiViewport;
    if (opts.samplerAnisotropy !== void 0) this.samplerAnisotropy = opts.samplerAnisotropy;
    if (opts.textureCompressionETC2 !== void 0) this.textureCompressionETC2 = opts.textureCompressionETC2;
    if (opts.textureCompressionASTC_LDR !== void 0) this.textureCompressionASTC_LDR = opts.textureCompressionASTC_LDR;
    if (opts.textureCompressionBC !== void 0) this.textureCompressionBC = opts.textureCompressionBC;
    if (opts.occlusionQueryPrecise !== void 0) this.occlusionQueryPrecise = opts.occlusionQueryPrecise;
    if (opts.pipelineStatisticsQuery !== void 0) this.pipelineStatisticsQuery = opts.pipelineStatisticsQuery;
    if (opts.vertexPipelineStoresAndAtomics !== void 0) this.vertexPipelineStoresAndAtomics = opts.vertexPipelineStoresAndAtomics;
    if (opts.fragmentStoresAndAtomics !== void 0) this.fragmentStoresAndAtomics = opts.fragmentStoresAndAtomics;
    if (opts.shaderTessellationAndGeometryPointSize !== void 0) this.shaderTessellationAndGeometryPointSize = opts.shaderTessellationAndGeometryPointSize;
    if (opts.shaderImageGatherExtended !== void 0) this.shaderImageGatherExtended = opts.shaderImageGatherExtended;
    if (opts.shaderStorageImageExtendedFormats !== void 0) this.shaderStorageImageExtendedFormats = opts.shaderStorageImageExtendedFormats;
    if (opts.shaderStorageImageMultisample !== void 0) this.shaderStorageImageMultisample = opts.shaderStorageImageMultisample;
    if (opts.shaderStorageImageReadWithoutFormat !== void 0) this.shaderStorageImageReadWithoutFormat = opts.shaderStorageImageReadWithoutFormat;
    if (opts.shaderStorageImageWriteWithoutFormat !== void 0) this.shaderStorageImageWriteWithoutFormat = opts.shaderStorageImageWriteWithoutFormat;
    if (opts.shaderUniformBufferArrayDynamicIndexing !== void 0) this.shaderUniformBufferArrayDynamicIndexing = opts.shaderUniformBufferArrayDynamicIndexing;
    if (opts.shaderSampledImageArrayDynamicIndexing !== void 0) this.shaderSampledImageArrayDynamicIndexing = opts.shaderSampledImageArrayDynamicIndexing;
    if (opts.shaderStorageBufferArrayDynamicIndexing !== void 0) this.shaderStorageBufferArrayDynamicIndexing = opts.shaderStorageBufferArrayDynamicIndexing;
    if (opts.shaderStorageImageArrayDynamicIndexing !== void 0) this.shaderStorageImageArrayDynamicIndexing = opts.shaderStorageImageArrayDynamicIndexing;
    if (opts.shaderClipDistance !== void 0) this.shaderClipDistance = opts.shaderClipDistance;
    if (opts.shaderCullDistance !== void 0) this.shaderCullDistance = opts.shaderCullDistance;
    if (opts.shaderFloat64 !== void 0) this.shaderFloat64 = opts.shaderFloat64;
    if (opts.shaderInt64 !== void 0) this.shaderInt64 = opts.shaderInt64;
    if (opts.shaderInt16 !== void 0) this.shaderInt16 = opts.shaderInt16;
    if (opts.shaderResourceResidency !== void 0) this.shaderResourceResidency = opts.shaderResourceResidency;
    if (opts.shaderResourceMinLod !== void 0) this.shaderResourceMinLod = opts.shaderResourceMinLod;
    if (opts.sparseBinding !== void 0) this.sparseBinding = opts.sparseBinding;
    if (opts.sparseResidencyBuffer !== void 0) this.sparseResidencyBuffer = opts.sparseResidencyBuffer;
    if (opts.sparseResidencyImage2D !== void 0) this.sparseResidencyImage2D = opts.sparseResidencyImage2D;
    if (opts.sparseResidencyImage3D !== void 0) this.sparseResidencyImage3D = opts.sparseResidencyImage3D;
    if (opts.sparseResidency2Samples !== void 0) this.sparseResidency2Samples = opts.sparseResidency2Samples;
    if (opts.sparseResidency4Samples !== void 0) this.sparseResidency4Samples = opts.sparseResidency4Samples;
    if (opts.sparseResidency8Samples !== void 0) this.sparseResidency8Samples = opts.sparseResidency8Samples;
    if (opts.sparseResidency16Samples !== void 0) this.sparseResidency16Samples = opts.sparseResidency16Samples;
    if (opts.sparseResidencyAliased !== void 0) this.sparseResidencyAliased = opts.sparseResidencyAliased;
    if (opts.variableMultisampleRate !== void 0) this.variableMultisampleRate = opts.variableMultisampleRate;
    if (opts.inheritedQueries !== void 0) this.inheritedQueries = opts.inheritedQueries;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFeatures.prototype, {
  "robustBufferAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "fullDrawIndexUint32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "imageCubeArray": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "independentBlend": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "geometryShader": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "tessellationShader": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sampleRateShading": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "dualSrcBlend": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "logicOp": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "multiDrawIndirect": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "drawIndirectFirstInstance": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "depthClamp": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "depthBiasClamp": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "fillModeNonSolid": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "depthBounds": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "wideLines": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "largePoints": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "alphaToOne": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "multiViewport": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "samplerAnisotropy": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "textureCompressionETC2": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "textureCompressionASTC_LDR": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "textureCompressionBC": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "occlusionQueryPrecise": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "pipelineStatisticsQuery": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "vertexPipelineStoresAndAtomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "fragmentStoresAndAtomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderTessellationAndGeometryPointSize": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderImageGatherExtended": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageImageExtendedFormats": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageImageMultisample": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageImageReadWithoutFormat": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageImageWriteWithoutFormat": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderUniformBufferArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSampledImageArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageBufferArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageImageArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderClipDistance": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderCullDistance": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderInt64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderInt16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderResourceResidency": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderResourceMinLod": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseBinding": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseResidencyBuffer": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseResidencyImage2D": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseResidencyImage3D": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseResidency2Samples": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseResidency4Samples": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseResidency8Samples": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseResidency16Samples": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseResidencyAliased": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "variableMultisampleRate": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "inheritedQueries": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.robustBufferAccess !== void 0) this.robustBufferAccess = opts.robustBufferAccess;
    if (opts.fullDrawIndexUint32 !== void 0) this.fullDrawIndexUint32 = opts.fullDrawIndexUint32;
    if (opts.imageCubeArray !== void 0) this.imageCubeArray = opts.imageCubeArray;
    if (opts.independentBlend !== void 0) this.independentBlend = opts.independentBlend;
    if (opts.geometryShader !== void 0) this.geometryShader = opts.geometryShader;
    if (opts.tessellationShader !== void 0) this.tessellationShader = opts.tessellationShader;
    if (opts.sampleRateShading !== void 0) this.sampleRateShading = opts.sampleRateShading;
    if (opts.dualSrcBlend !== void 0) this.dualSrcBlend = opts.dualSrcBlend;
    if (opts.logicOp !== void 0) this.logicOp = opts.logicOp;
    if (opts.multiDrawIndirect !== void 0) this.multiDrawIndirect = opts.multiDrawIndirect;
    if (opts.drawIndirectFirstInstance !== void 0) this.drawIndirectFirstInstance = opts.drawIndirectFirstInstance;
    if (opts.depthClamp !== void 0) this.depthClamp = opts.depthClamp;
    if (opts.depthBiasClamp !== void 0) this.depthBiasClamp = opts.depthBiasClamp;
    if (opts.fillModeNonSolid !== void 0) this.fillModeNonSolid = opts.fillModeNonSolid;
    if (opts.depthBounds !== void 0) this.depthBounds = opts.depthBounds;
    if (opts.wideLines !== void 0) this.wideLines = opts.wideLines;
    if (opts.largePoints !== void 0) this.largePoints = opts.largePoints;
    if (opts.alphaToOne !== void 0) this.alphaToOne = opts.alphaToOne;
    if (opts.multiViewport !== void 0) this.multiViewport = opts.multiViewport;
    if (opts.samplerAnisotropy !== void 0) this.samplerAnisotropy = opts.samplerAnisotropy;
    if (opts.textureCompressionETC2 !== void 0) this.textureCompressionETC2 = opts.textureCompressionETC2;
    if (opts.textureCompressionASTC_LDR !== void 0) this.textureCompressionASTC_LDR = opts.textureCompressionASTC_LDR;
    if (opts.textureCompressionBC !== void 0) this.textureCompressionBC = opts.textureCompressionBC;
    if (opts.occlusionQueryPrecise !== void 0) this.occlusionQueryPrecise = opts.occlusionQueryPrecise;
    if (opts.pipelineStatisticsQuery !== void 0) this.pipelineStatisticsQuery = opts.pipelineStatisticsQuery;
    if (opts.vertexPipelineStoresAndAtomics !== void 0) this.vertexPipelineStoresAndAtomics = opts.vertexPipelineStoresAndAtomics;
    if (opts.fragmentStoresAndAtomics !== void 0) this.fragmentStoresAndAtomics = opts.fragmentStoresAndAtomics;
    if (opts.shaderTessellationAndGeometryPointSize !== void 0) this.shaderTessellationAndGeometryPointSize = opts.shaderTessellationAndGeometryPointSize;
    if (opts.shaderImageGatherExtended !== void 0) this.shaderImageGatherExtended = opts.shaderImageGatherExtended;
    if (opts.shaderStorageImageExtendedFormats !== void 0) this.shaderStorageImageExtendedFormats = opts.shaderStorageImageExtendedFormats;
    if (opts.shaderStorageImageMultisample !== void 0) this.shaderStorageImageMultisample = opts.shaderStorageImageMultisample;
    if (opts.shaderStorageImageReadWithoutFormat !== void 0) this.shaderStorageImageReadWithoutFormat = opts.shaderStorageImageReadWithoutFormat;
    if (opts.shaderStorageImageWriteWithoutFormat !== void 0) this.shaderStorageImageWriteWithoutFormat = opts.shaderStorageImageWriteWithoutFormat;
    if (opts.shaderUniformBufferArrayDynamicIndexing !== void 0) this.shaderUniformBufferArrayDynamicIndexing = opts.shaderUniformBufferArrayDynamicIndexing;
    if (opts.shaderSampledImageArrayDynamicIndexing !== void 0) this.shaderSampledImageArrayDynamicIndexing = opts.shaderSampledImageArrayDynamicIndexing;
    if (opts.shaderStorageBufferArrayDynamicIndexing !== void 0) this.shaderStorageBufferArrayDynamicIndexing = opts.shaderStorageBufferArrayDynamicIndexing;
    if (opts.shaderStorageImageArrayDynamicIndexing !== void 0) this.shaderStorageImageArrayDynamicIndexing = opts.shaderStorageImageArrayDynamicIndexing;
    if (opts.shaderClipDistance !== void 0) this.shaderClipDistance = opts.shaderClipDistance;
    if (opts.shaderCullDistance !== void 0) this.shaderCullDistance = opts.shaderCullDistance;
    if (opts.shaderFloat64 !== void 0) this.shaderFloat64 = opts.shaderFloat64;
    if (opts.shaderInt64 !== void 0) this.shaderInt64 = opts.shaderInt64;
    if (opts.shaderInt16 !== void 0) this.shaderInt16 = opts.shaderInt16;
    if (opts.shaderResourceResidency !== void 0) this.shaderResourceResidency = opts.shaderResourceResidency;
    if (opts.shaderResourceMinLod !== void 0) this.shaderResourceMinLod = opts.shaderResourceMinLod;
    if (opts.sparseBinding !== void 0) this.sparseBinding = opts.sparseBinding;
    if (opts.sparseResidencyBuffer !== void 0) this.sparseResidencyBuffer = opts.sparseResidencyBuffer;
    if (opts.sparseResidencyImage2D !== void 0) this.sparseResidencyImage2D = opts.sparseResidencyImage2D;
    if (opts.sparseResidencyImage3D !== void 0) this.sparseResidencyImage3D = opts.sparseResidencyImage3D;
    if (opts.sparseResidency2Samples !== void 0) this.sparseResidency2Samples = opts.sparseResidency2Samples;
    if (opts.sparseResidency4Samples !== void 0) this.sparseResidency4Samples = opts.sparseResidency4Samples;
    if (opts.sparseResidency8Samples !== void 0) this.sparseResidency8Samples = opts.sparseResidency8Samples;
    if (opts.sparseResidency16Samples !== void 0) this.sparseResidency16Samples = opts.sparseResidency16Samples;
    if (opts.sparseResidencyAliased !== void 0) this.sparseResidencyAliased = opts.sparseResidencyAliased;
    if (opts.variableMultisampleRate !== void 0) this.variableMultisampleRate = opts.variableMultisampleRate;
    if (opts.inheritedQueries !== void 0) this.inheritedQueries = opts.inheritedQueries;
    
  }
};

VkPhysicalDeviceFeatures.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFeatures();
  copy.robustBufferAccess = original.robustBufferAccess;
  copy.fullDrawIndexUint32 = original.fullDrawIndexUint32;
  copy.imageCubeArray = original.imageCubeArray;
  copy.independentBlend = original.independentBlend;
  copy.geometryShader = original.geometryShader;
  copy.tessellationShader = original.tessellationShader;
  copy.sampleRateShading = original.sampleRateShading;
  copy.dualSrcBlend = original.dualSrcBlend;
  copy.logicOp = original.logicOp;
  copy.multiDrawIndirect = original.multiDrawIndirect;
  copy.drawIndirectFirstInstance = original.drawIndirectFirstInstance;
  copy.depthClamp = original.depthClamp;
  copy.depthBiasClamp = original.depthBiasClamp;
  copy.fillModeNonSolid = original.fillModeNonSolid;
  copy.depthBounds = original.depthBounds;
  copy.wideLines = original.wideLines;
  copy.largePoints = original.largePoints;
  copy.alphaToOne = original.alphaToOne;
  copy.multiViewport = original.multiViewport;
  copy.samplerAnisotropy = original.samplerAnisotropy;
  copy.textureCompressionETC2 = original.textureCompressionETC2;
  copy.textureCompressionASTC_LDR = original.textureCompressionASTC_LDR;
  copy.textureCompressionBC = original.textureCompressionBC;
  copy.occlusionQueryPrecise = original.occlusionQueryPrecise;
  copy.pipelineStatisticsQuery = original.pipelineStatisticsQuery;
  copy.vertexPipelineStoresAndAtomics = original.vertexPipelineStoresAndAtomics;
  copy.fragmentStoresAndAtomics = original.fragmentStoresAndAtomics;
  copy.shaderTessellationAndGeometryPointSize = original.shaderTessellationAndGeometryPointSize;
  copy.shaderImageGatherExtended = original.shaderImageGatherExtended;
  copy.shaderStorageImageExtendedFormats = original.shaderStorageImageExtendedFormats;
  copy.shaderStorageImageMultisample = original.shaderStorageImageMultisample;
  copy.shaderStorageImageReadWithoutFormat = original.shaderStorageImageReadWithoutFormat;
  copy.shaderStorageImageWriteWithoutFormat = original.shaderStorageImageWriteWithoutFormat;
  copy.shaderUniformBufferArrayDynamicIndexing = original.shaderUniformBufferArrayDynamicIndexing;
  copy.shaderSampledImageArrayDynamicIndexing = original.shaderSampledImageArrayDynamicIndexing;
  copy.shaderStorageBufferArrayDynamicIndexing = original.shaderStorageBufferArrayDynamicIndexing;
  copy.shaderStorageImageArrayDynamicIndexing = original.shaderStorageImageArrayDynamicIndexing;
  copy.shaderClipDistance = original.shaderClipDistance;
  copy.shaderCullDistance = original.shaderCullDistance;
  copy.shaderFloat64 = original.shaderFloat64;
  copy.shaderInt64 = original.shaderInt64;
  copy.shaderInt16 = original.shaderInt16;
  copy.shaderResourceResidency = original.shaderResourceResidency;
  copy.shaderResourceMinLod = original.shaderResourceMinLod;
  copy.sparseBinding = original.sparseBinding;
  copy.sparseResidencyBuffer = original.sparseResidencyBuffer;
  copy.sparseResidencyImage2D = original.sparseResidencyImage2D;
  copy.sparseResidencyImage3D = original.sparseResidencyImage3D;
  copy.sparseResidency2Samples = original.sparseResidency2Samples;
  copy.sparseResidency4Samples = original.sparseResidency4Samples;
  copy.sparseResidency8Samples = original.sparseResidency8Samples;
  copy.sparseResidency16Samples = original.sparseResidency16Samples;
  copy.sparseResidencyAliased = original.sparseResidencyAliased;
  copy.variableMultisampleRate = original.variableMultisampleRate;
  copy.inheritedQueries = original.inheritedQueries;
  
  return copy;
};

VkPhysicalDeviceFeatures.byteLength = 0x0;

VkPhysicalDeviceFeatures.memoryLayout = {
  robustBufferAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fullDrawIndexUint32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageCubeArray: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  independentBlend: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  geometryShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tessellationShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleRateShading: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dualSrcBlend: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  logicOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiDrawIndirect: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  drawIndirectFirstInstance: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthClamp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthBiasClamp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fillModeNonSolid: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthBounds: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  wideLines: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  largePoints: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  alphaToOne: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiViewport: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samplerAnisotropy: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  textureCompressionETC2: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  textureCompressionASTC_LDR: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  textureCompressionBC: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  occlusionQueryPrecise: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineStatisticsQuery: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexPipelineStoresAndAtomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentStoresAndAtomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderTessellationAndGeometryPointSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderImageGatherExtended: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageExtendedFormats: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageMultisample: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageReadWithoutFormat: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageWriteWithoutFormat: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformBufferArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSampledImageArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageBufferArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderClipDistance: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderCullDistance: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInt64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInt16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderResourceResidency: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderResourceMinLod: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseBinding: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseResidencyBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseResidencyImage2D: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseResidencyImage3D: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseResidency2Samples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseResidency4Samples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseResidency8Samples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseResidency16Samples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseResidencyAliased: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variableMultisampleRate: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  inheritedQueries: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSparseProperties **/
function VkPhysicalDeviceSparseProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSparseProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSparseProperties, STRUCT_CACHE_VkPhysicalDeviceSparseProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSparseProperties, STRUCT_CACHE_VkPhysicalDeviceSparseProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSparseProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPhysicalDeviceSparseProperties.prototype, {
  "residencyStandard2DBlockShape": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "residencyStandard2DMultisampleBlockShape": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "residencyStandard3DBlockShape": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "residencyAlignedMipSize": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "residencyNonResidentStrict": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceSparseProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkPhysicalDeviceSparseProperties.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceSparseProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceSparseProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSparseProperties();
  copy.residencyStandard2DBlockShape = original.residencyStandard2DBlockShape;
  copy.residencyStandard2DMultisampleBlockShape = original.residencyStandard2DMultisampleBlockShape;
  copy.residencyStandard3DBlockShape = original.residencyStandard3DBlockShape;
  copy.residencyAlignedMipSize = original.residencyAlignedMipSize;
  copy.residencyNonResidentStrict = original.residencyNonResidentStrict;
  
  return copy;
};

VkPhysicalDeviceSparseProperties.byteLength = 0x0;

VkPhysicalDeviceSparseProperties.memoryLayout = {
  residencyStandard2DBlockShape: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  residencyStandard2DMultisampleBlockShape: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  residencyStandard3DBlockShape: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  residencyAlignedMipSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  residencyNonResidentStrict: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceLimits **/
function VkPhysicalDeviceLimits(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceLimits) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceLimits, STRUCT_CACHE_VkPhysicalDeviceLimits);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceLimits, STRUCT_CACHE_VkPhysicalDeviceLimits);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceLimits'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this._maxComputeWorkGroupCount = [...Array(3)].fill(0x0);
  
  this._maxComputeWorkGroupSize = [...Array(3)].fill(0x0);
  
  
  
  
  
  
  
  
  this._maxViewportDimensions = [...Array(2)].fill(0x0);
  this._viewportBoundsRange = [...Array(2)].fill(0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this._pointSizeRange = [...Array(2)].fill(0x0);
  this._lineWidthRange = [...Array(2)].fill(0x0);
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPhysicalDeviceLimits.prototype, {
  "maxImageDimension1D": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxImageDimension2D": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxImageDimension3D": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxImageDimensionCube": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxImageArrayLayers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTexelBufferElements": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxUniformBufferRange": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxStorageBufferRange": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPushConstantsSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMemoryAllocationCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxSamplerAllocationCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "bufferImageGranularity": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "sparseAddressSpaceSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "maxBoundDescriptorSets": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorSamplers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUniformBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorStorageBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorSampledImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorStorageImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorInputAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageResources": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetSamplers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUniformBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUniformBuffersDynamic": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetStorageBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetStorageBuffersDynamic": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetSampledImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetStorageImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetInputAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxVertexInputAttributes": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxVertexInputBindings": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxVertexInputAttributeOffset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxVertexInputBindingStride": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxVertexOutputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTessellationGenerationLevel": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTessellationPatchSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTessellationControlPerVertexInputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTessellationControlPerVertexOutputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTessellationControlPerPatchOutputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTessellationControlTotalOutputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTessellationEvaluationInputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTessellationEvaluationOutputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxGeometryShaderInvocations": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxGeometryInputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxGeometryOutputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxGeometryOutputVertices": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxGeometryTotalOutputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxFragmentInputComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxFragmentOutputAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxFragmentDualSrcAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxFragmentCombinedOutputResources": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxComputeSharedMemorySize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxComputeWorkGroupCount": {
    get() {
    return [
      this.memoryView.getUint32(0x0, true),
      this.memoryView.getUint32(0x4, true),
      this.memoryView.getUint32(0x8, true)
    ];
    },
    },
  "maxComputeWorkGroupInvocations": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxComputeWorkGroupSize": {
    get() {
    return [
      this.memoryView.getUint32(0x0, true),
      this.memoryView.getUint32(0x4, true),
      this.memoryView.getUint32(0x8, true)
    ];
    },
    },
  "subPixelPrecisionBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "subTexelPrecisionBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "mipmapPrecisionBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDrawIndexedIndexValue": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDrawIndirectCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxSamplerLodBias": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    },
  "maxSamplerAnisotropy": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    },
  "maxViewports": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxViewportDimensions": {
    get() {
    return [
      this.memoryView.getUint32(0x0, true),
      this.memoryView.getUint32(0x4, true)
    ];
    },
    },
  "viewportBoundsRange": {
    get() {
    return [
      this.memoryView.getFloat32(0x0, true),
      this.memoryView.getFloat32(0x4, true)
    ];
    },
    },
  "viewportSubPixelBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "minMemoryMapAlignment": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    },
  "minTexelBufferOffsetAlignment": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "minUniformBufferOffsetAlignment": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "minStorageBufferOffsetAlignment": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "minTexelOffset": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "maxTexelOffset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "minTexelGatherOffset": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "maxTexelGatherOffset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "minInterpolationOffset": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    },
  "maxInterpolationOffset": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    },
  "subPixelInterpolationOffsetBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxFramebufferWidth": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxFramebufferHeight": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxFramebufferLayers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "framebufferColorSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "framebufferDepthSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "framebufferStencilSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "framebufferNoAttachmentsSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "maxColorAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "sampledImageColorSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "sampledImageIntegerSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "sampledImageDepthSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "sampledImageStencilSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "storageImageSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "maxSampleMaskWords": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "timestampComputeAndGraphics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "timestampPeriod": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    },
  "maxClipDistances": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxCullDistances": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxCombinedClipAndCullDistances": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "discreteQueuePriorities": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "pointSizeRange": {
    get() {
    return [
      this.memoryView.getFloat32(0x0, true),
      this.memoryView.getFloat32(0x4, true)
    ];
    },
    },
  "lineWidthRange": {
    get() {
    return [
      this.memoryView.getFloat32(0x0, true),
      this.memoryView.getFloat32(0x4, true)
    ];
    },
    },
  "pointSizeGranularity": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    },
  "lineWidthGranularity": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    },
  "strictLines": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "standardSampleLocations": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "optimalBufferCopyOffsetAlignment": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "optimalBufferCopyRowPitchAlignment": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "nonCoherentAtomSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPhysicalDeviceLimits.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  if (this._maxComputeWorkGroupCount !== null) this._maxComputeWorkGroupCount.fill(0x0);
      else this._maxComputeWorkGroupCount = [...Array(3)].fill(0x0);
  
  if (this._maxComputeWorkGroupSize !== null) this._maxComputeWorkGroupSize.fill(0x0);
      else this._maxComputeWorkGroupSize = [...Array(3)].fill(0x0);
  
  
  
  
  
  
  
  
  if (this._maxViewportDimensions !== null) this._maxViewportDimensions.fill(0x0);
      else this._maxViewportDimensions = [...Array(2)].fill(0x0);
  if (this._viewportBoundsRange !== null) this._viewportBoundsRange.fill(0x0);
      else this._viewportBoundsRange = [...Array(2)].fill(0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  if (this._pointSizeRange !== null) this._pointSizeRange.fill(0x0);
      else this._pointSizeRange = [...Array(2)].fill(0x0);
  if (this._lineWidthRange !== null) this._lineWidthRange.fill(0x0);
      else this._lineWidthRange = [...Array(2)].fill(0x0);
  
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkPhysicalDeviceLimits.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceLimits.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceLimits.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceLimits();
  copy.maxImageDimension1D = original.maxImageDimension1D;
  copy.maxImageDimension2D = original.maxImageDimension2D;
  copy.maxImageDimension3D = original.maxImageDimension3D;
  copy.maxImageDimensionCube = original.maxImageDimensionCube;
  copy.maxImageArrayLayers = original.maxImageArrayLayers;
  copy.maxTexelBufferElements = original.maxTexelBufferElements;
  copy.maxUniformBufferRange = original.maxUniformBufferRange;
  copy.maxStorageBufferRange = original.maxStorageBufferRange;
  copy.maxPushConstantsSize = original.maxPushConstantsSize;
  copy.maxMemoryAllocationCount = original.maxMemoryAllocationCount;
  copy.maxSamplerAllocationCount = original.maxSamplerAllocationCount;
  copy.bufferImageGranularity = original.bufferImageGranularity;
  copy.sparseAddressSpaceSize = original.sparseAddressSpaceSize;
  copy.maxBoundDescriptorSets = original.maxBoundDescriptorSets;
  copy.maxPerStageDescriptorSamplers = original.maxPerStageDescriptorSamplers;
  copy.maxPerStageDescriptorUniformBuffers = original.maxPerStageDescriptorUniformBuffers;
  copy.maxPerStageDescriptorStorageBuffers = original.maxPerStageDescriptorStorageBuffers;
  copy.maxPerStageDescriptorSampledImages = original.maxPerStageDescriptorSampledImages;
  copy.maxPerStageDescriptorStorageImages = original.maxPerStageDescriptorStorageImages;
  copy.maxPerStageDescriptorInputAttachments = original.maxPerStageDescriptorInputAttachments;
  copy.maxPerStageResources = original.maxPerStageResources;
  copy.maxDescriptorSetSamplers = original.maxDescriptorSetSamplers;
  copy.maxDescriptorSetUniformBuffers = original.maxDescriptorSetUniformBuffers;
  copy.maxDescriptorSetUniformBuffersDynamic = original.maxDescriptorSetUniformBuffersDynamic;
  copy.maxDescriptorSetStorageBuffers = original.maxDescriptorSetStorageBuffers;
  copy.maxDescriptorSetStorageBuffersDynamic = original.maxDescriptorSetStorageBuffersDynamic;
  copy.maxDescriptorSetSampledImages = original.maxDescriptorSetSampledImages;
  copy.maxDescriptorSetStorageImages = original.maxDescriptorSetStorageImages;
  copy.maxDescriptorSetInputAttachments = original.maxDescriptorSetInputAttachments;
  copy.maxVertexInputAttributes = original.maxVertexInputAttributes;
  copy.maxVertexInputBindings = original.maxVertexInputBindings;
  copy.maxVertexInputAttributeOffset = original.maxVertexInputAttributeOffset;
  copy.maxVertexInputBindingStride = original.maxVertexInputBindingStride;
  copy.maxVertexOutputComponents = original.maxVertexOutputComponents;
  copy.maxTessellationGenerationLevel = original.maxTessellationGenerationLevel;
  copy.maxTessellationPatchSize = original.maxTessellationPatchSize;
  copy.maxTessellationControlPerVertexInputComponents = original.maxTessellationControlPerVertexInputComponents;
  copy.maxTessellationControlPerVertexOutputComponents = original.maxTessellationControlPerVertexOutputComponents;
  copy.maxTessellationControlPerPatchOutputComponents = original.maxTessellationControlPerPatchOutputComponents;
  copy.maxTessellationControlTotalOutputComponents = original.maxTessellationControlTotalOutputComponents;
  copy.maxTessellationEvaluationInputComponents = original.maxTessellationEvaluationInputComponents;
  copy.maxTessellationEvaluationOutputComponents = original.maxTessellationEvaluationOutputComponents;
  copy.maxGeometryShaderInvocations = original.maxGeometryShaderInvocations;
  copy.maxGeometryInputComponents = original.maxGeometryInputComponents;
  copy.maxGeometryOutputComponents = original.maxGeometryOutputComponents;
  copy.maxGeometryOutputVertices = original.maxGeometryOutputVertices;
  copy.maxGeometryTotalOutputComponents = original.maxGeometryTotalOutputComponents;
  copy.maxFragmentInputComponents = original.maxFragmentInputComponents;
  copy.maxFragmentOutputAttachments = original.maxFragmentOutputAttachments;
  copy.maxFragmentDualSrcAttachments = original.maxFragmentDualSrcAttachments;
  copy.maxFragmentCombinedOutputResources = original.maxFragmentCombinedOutputResources;
  copy.maxComputeSharedMemorySize = original.maxComputeSharedMemorySize;
  if (original.maxComputeWorkGroupCount !== null) {
        copy.maxComputeWorkGroupCount = [...Array(original.maxComputeWorkGroupCount.length)].map((v, i) => {
          return original.maxComputeWorkGroupCount[i];
        });
      }
  copy.maxComputeWorkGroupInvocations = original.maxComputeWorkGroupInvocations;
  if (original.maxComputeWorkGroupSize !== null) {
        copy.maxComputeWorkGroupSize = [...Array(original.maxComputeWorkGroupSize.length)].map((v, i) => {
          return original.maxComputeWorkGroupSize[i];
        });
      }
  copy.subPixelPrecisionBits = original.subPixelPrecisionBits;
  copy.subTexelPrecisionBits = original.subTexelPrecisionBits;
  copy.mipmapPrecisionBits = original.mipmapPrecisionBits;
  copy.maxDrawIndexedIndexValue = original.maxDrawIndexedIndexValue;
  copy.maxDrawIndirectCount = original.maxDrawIndirectCount;
  copy.maxSamplerLodBias = original.maxSamplerLodBias;
  copy.maxSamplerAnisotropy = original.maxSamplerAnisotropy;
  copy.maxViewports = original.maxViewports;
  if (original.maxViewportDimensions !== null) {
        copy.maxViewportDimensions = [...Array(original.maxViewportDimensions.length)].map((v, i) => {
          return original.maxViewportDimensions[i];
        });
      }
  if (original.viewportBoundsRange !== null) {
        copy.viewportBoundsRange = [...Array(original.viewportBoundsRange.length)].map((v, i) => {
          return original.viewportBoundsRange[i];
        });
      }
  copy.viewportSubPixelBits = original.viewportSubPixelBits;
  copy.minMemoryMapAlignment = original.minMemoryMapAlignment;
  copy.minTexelBufferOffsetAlignment = original.minTexelBufferOffsetAlignment;
  copy.minUniformBufferOffsetAlignment = original.minUniformBufferOffsetAlignment;
  copy.minStorageBufferOffsetAlignment = original.minStorageBufferOffsetAlignment;
  copy.minTexelOffset = original.minTexelOffset;
  copy.maxTexelOffset = original.maxTexelOffset;
  copy.minTexelGatherOffset = original.minTexelGatherOffset;
  copy.maxTexelGatherOffset = original.maxTexelGatherOffset;
  copy.minInterpolationOffset = original.minInterpolationOffset;
  copy.maxInterpolationOffset = original.maxInterpolationOffset;
  copy.subPixelInterpolationOffsetBits = original.subPixelInterpolationOffsetBits;
  copy.maxFramebufferWidth = original.maxFramebufferWidth;
  copy.maxFramebufferHeight = original.maxFramebufferHeight;
  copy.maxFramebufferLayers = original.maxFramebufferLayers;
  copy.framebufferColorSampleCounts = original.framebufferColorSampleCounts;
  copy.framebufferDepthSampleCounts = original.framebufferDepthSampleCounts;
  copy.framebufferStencilSampleCounts = original.framebufferStencilSampleCounts;
  copy.framebufferNoAttachmentsSampleCounts = original.framebufferNoAttachmentsSampleCounts;
  copy.maxColorAttachments = original.maxColorAttachments;
  copy.sampledImageColorSampleCounts = original.sampledImageColorSampleCounts;
  copy.sampledImageIntegerSampleCounts = original.sampledImageIntegerSampleCounts;
  copy.sampledImageDepthSampleCounts = original.sampledImageDepthSampleCounts;
  copy.sampledImageStencilSampleCounts = original.sampledImageStencilSampleCounts;
  copy.storageImageSampleCounts = original.storageImageSampleCounts;
  copy.maxSampleMaskWords = original.maxSampleMaskWords;
  copy.timestampComputeAndGraphics = original.timestampComputeAndGraphics;
  copy.timestampPeriod = original.timestampPeriod;
  copy.maxClipDistances = original.maxClipDistances;
  copy.maxCullDistances = original.maxCullDistances;
  copy.maxCombinedClipAndCullDistances = original.maxCombinedClipAndCullDistances;
  copy.discreteQueuePriorities = original.discreteQueuePriorities;
  if (original.pointSizeRange !== null) {
        copy.pointSizeRange = [...Array(original.pointSizeRange.length)].map((v, i) => {
          return original.pointSizeRange[i];
        });
      }
  if (original.lineWidthRange !== null) {
        copy.lineWidthRange = [...Array(original.lineWidthRange.length)].map((v, i) => {
          return original.lineWidthRange[i];
        });
      }
  copy.pointSizeGranularity = original.pointSizeGranularity;
  copy.lineWidthGranularity = original.lineWidthGranularity;
  copy.strictLines = original.strictLines;
  copy.standardSampleLocations = original.standardSampleLocations;
  copy.optimalBufferCopyOffsetAlignment = original.optimalBufferCopyOffsetAlignment;
  copy.optimalBufferCopyRowPitchAlignment = original.optimalBufferCopyRowPitchAlignment;
  copy.nonCoherentAtomSize = original.nonCoherentAtomSize;
  
  return copy;
};

VkPhysicalDeviceLimits.byteLength = 0x0;

VkPhysicalDeviceLimits.memoryLayout = {
  maxImageDimension1D: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxImageDimension2D: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxImageDimension3D: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxImageDimensionCube: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxImageArrayLayers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTexelBufferElements: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxUniformBufferRange: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxStorageBufferRange: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPushConstantsSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMemoryAllocationCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSamplerAllocationCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferImageGranularity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseAddressSpaceSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxBoundDescriptorSets: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUniformBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorStorageBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorSampledImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorStorageImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageResources: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUniformBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUniformBuffersDynamic: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetStorageBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetStorageBuffersDynamic: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetSampledImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetStorageImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxVertexInputAttributes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxVertexInputBindings: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxVertexInputAttributeOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxVertexInputBindingStride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxVertexOutputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTessellationGenerationLevel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTessellationPatchSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTessellationControlPerVertexInputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTessellationControlPerVertexOutputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTessellationControlPerPatchOutputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTessellationControlTotalOutputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTessellationEvaluationInputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTessellationEvaluationOutputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxGeometryShaderInvocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxGeometryInputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxGeometryOutputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxGeometryOutputVertices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxGeometryTotalOutputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentInputComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentOutputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentDualSrcAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentCombinedOutputResources: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxComputeSharedMemorySize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxComputeWorkGroupCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxComputeWorkGroupInvocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxComputeWorkGroupSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subPixelPrecisionBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subTexelPrecisionBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mipmapPrecisionBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDrawIndexedIndexValue: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDrawIndirectCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSamplerLodBias: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSamplerAnisotropy: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxViewports: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxViewportDimensions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewportBoundsRange: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewportSubPixelBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minMemoryMapAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minTexelBufferOffsetAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minUniformBufferOffsetAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minStorageBufferOffsetAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minTexelOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTexelOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minTexelGatherOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTexelGatherOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minInterpolationOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxInterpolationOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subPixelInterpolationOffsetBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFramebufferWidth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFramebufferHeight: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFramebufferLayers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  framebufferColorSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  framebufferDepthSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  framebufferStencilSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  framebufferNoAttachmentsSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxColorAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampledImageColorSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampledImageIntegerSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampledImageDepthSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampledImageStencilSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageImageSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSampleMaskWords: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  timestampComputeAndGraphics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  timestampPeriod: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxClipDistances: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxCullDistances: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxCombinedClipAndCullDistances: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  discreteQueuePriorities: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pointSizeRange: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  lineWidthRange: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pointSizeGranularity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  lineWidthGranularity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  strictLines: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  standardSampleLocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  optimalBufferCopyOffsetAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  optimalBufferCopyRowPitchAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  nonCoherentAtomSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSemaphoreCreateInfo **/
function VkSemaphoreCreateInfo(opts, byteOffset) {
  if (new.target !== VkSemaphoreCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSemaphoreCreateInfo, STRUCT_CACHE_VkSemaphoreCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSemaphoreCreateInfo, STRUCT_CACHE_VkSemaphoreCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSemaphoreCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkSemaphoreCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSemaphoreCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkSemaphoreCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSemaphoreCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSemaphoreCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  
  return copy;
};

VkSemaphoreCreateInfo.byteLength = 0x0;

VkSemaphoreCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkQueryPoolCreateInfo **/
function VkQueryPoolCreateInfo(opts, byteOffset) {
  if (new.target !== VkQueryPoolCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkQueryPoolCreateInfo, STRUCT_CACHE_VkQueryPoolCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkQueryPoolCreateInfo, STRUCT_CACHE_VkQueryPoolCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkQueryPoolCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queryType !== void 0) this.queryType = opts.queryType;
    if (opts.queryCount !== void 0) this.queryCount = opts.queryCount;
    if (opts.pipelineStatistics !== void 0) this.pipelineStatistics = opts.pipelineStatistics;
    
  }
};

Object.defineProperties(VkQueryPoolCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.pNext'");
      switch (sType) {
          
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "queryType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolCreateInfo.queryType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "queryCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolCreateInfo.queryCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pipelineStatistics": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolCreateInfo.pipelineStatistics");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkQueryPoolCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queryType !== void 0) this.queryType = opts.queryType;
    if (opts.queryCount !== void 0) this.queryCount = opts.queryCount;
    if (opts.pipelineStatistics !== void 0) this.pipelineStatistics = opts.pipelineStatistics;
    
  }
};

VkQueryPoolCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueryPoolCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkQueryPoolCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkQueryPoolCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.queryType = original.queryType;
  copy.queryCount = original.queryCount;
  copy.pipelineStatistics = original.pipelineStatistics;
  
  return copy;
};

VkQueryPoolCreateInfo.byteLength = 0x0;

VkQueryPoolCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queryType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queryCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineStatistics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFramebufferCreateInfo **/
function VkFramebufferCreateInfo(opts, byteOffset) {
  if (new.target !== VkFramebufferCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFramebufferCreateInfo, STRUCT_CACHE_VkFramebufferCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFramebufferCreateInfo, STRUCT_CACHE_VkFramebufferCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFramebufferCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._renderPass = null;
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.layers !== void 0) this.layers = opts.layers;
    
  }
};

Object.defineProperties(VkFramebufferCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "renderPass": {
    get() {
    return this._renderPass;
    },
    set(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._renderPass = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.renderPass': Expected 'VkRenderPass' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferCreateInfo.attachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAttachments": {
    get() {
    if (this._pAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.attachmentCount, VkImageView);
      this._pAttachments = array;
      return this.pAttachments;
    } else {
      return this._pAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pAttachments': Expected 'Array VkImageView' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "width": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferCreateInfo.width");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "height": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferCreateInfo.height");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "layers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferCreateInfo.layers");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkFramebufferCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._renderPass = null;
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.layers !== void 0) this.layers = opts.layers;
    
  }
};

VkFramebufferCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkFramebufferCreateInfo.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkImageView)) {
        throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pAttachments[" + ii + "]': Expected 'VkImageView' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkFramebufferCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkFramebufferCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFramebufferCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  if (original.renderPass !== null) {
        copy.renderPass = original.renderPass.constructor.createCopyFrom(original.renderPass);
      }
  copy.attachmentCount = original.attachmentCount;
  if (original.pAttachments !== null) {
        copy.pAttachments = [...Array(original.pAttachments.length)].map((v, i) => {
          return original.pAttachments[i].constructor.createCopyFrom(original.pAttachments[i]);
        });
      }
  copy.width = original.width;
  copy.height = original.height;
  copy.layers = original.layers;
  
  return copy;
};

VkFramebufferCreateInfo.byteLength = 0x0;

VkFramebufferCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  renderPass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  width: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  height: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDrawIndirectCommand **/
function VkDrawIndirectCommand(opts, byteOffset) {
  if (new.target !== VkDrawIndirectCommand) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDrawIndirectCommand, STRUCT_CACHE_VkDrawIndirectCommand);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDrawIndirectCommand, STRUCT_CACHE_VkDrawIndirectCommand);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDrawIndirectCommand'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.vertexCount !== void 0) this.vertexCount = opts.vertexCount;
    if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
    if (opts.firstVertex !== void 0) this.firstVertex = opts.firstVertex;
    if (opts.firstInstance !== void 0) this.firstInstance = opts.firstInstance;
    
  }
};

Object.defineProperties(VkDrawIndirectCommand.prototype, {
  "vertexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawIndirectCommand.vertexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "instanceCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawIndirectCommand.instanceCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "firstVertex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawIndirectCommand.firstVertex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "firstInstance": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawIndirectCommand.firstInstance");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDrawIndirectCommand.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.vertexCount !== void 0) this.vertexCount = opts.vertexCount;
    if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
    if (opts.firstVertex !== void 0) this.firstVertex = opts.firstVertex;
    if (opts.firstInstance !== void 0) this.firstInstance = opts.firstInstance;
    
  }
};

VkDrawIndirectCommand.prototype.flush = function flush() {
  
  return true;
};

VkDrawIndirectCommand.prototype.reflect = function reflect(memoryAddress) {
  };

VkDrawIndirectCommand.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDrawIndirectCommand();
  copy.vertexCount = original.vertexCount;
  copy.instanceCount = original.instanceCount;
  copy.firstVertex = original.firstVertex;
  copy.firstInstance = original.firstInstance;
  
  return copy;
};

VkDrawIndirectCommand.byteLength = 0x0;

VkDrawIndirectCommand.memoryLayout = {
  vertexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  instanceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  firstVertex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  firstInstance: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDrawIndexedIndirectCommand **/
function VkDrawIndexedIndirectCommand(opts, byteOffset) {
  if (new.target !== VkDrawIndexedIndirectCommand) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDrawIndexedIndirectCommand, STRUCT_CACHE_VkDrawIndexedIndirectCommand);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDrawIndexedIndirectCommand, STRUCT_CACHE_VkDrawIndexedIndirectCommand);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDrawIndexedIndirectCommand'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.indexCount !== void 0) this.indexCount = opts.indexCount;
    if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
    if (opts.firstIndex !== void 0) this.firstIndex = opts.firstIndex;
    if (opts.vertexOffset !== void 0) this.vertexOffset = opts.vertexOffset;
    if (opts.firstInstance !== void 0) this.firstInstance = opts.firstInstance;
    
  }
};

Object.defineProperties(VkDrawIndexedIndirectCommand.prototype, {
  "indexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawIndexedIndirectCommand.indexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "instanceCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawIndexedIndirectCommand.instanceCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "firstIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawIndexedIndirectCommand.firstIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "vertexOffset": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawIndexedIndirectCommand.vertexOffset");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "firstInstance": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawIndexedIndirectCommand.firstInstance");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDrawIndexedIndirectCommand.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.indexCount !== void 0) this.indexCount = opts.indexCount;
    if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
    if (opts.firstIndex !== void 0) this.firstIndex = opts.firstIndex;
    if (opts.vertexOffset !== void 0) this.vertexOffset = opts.vertexOffset;
    if (opts.firstInstance !== void 0) this.firstInstance = opts.firstInstance;
    
  }
};

VkDrawIndexedIndirectCommand.prototype.flush = function flush() {
  
  return true;
};

VkDrawIndexedIndirectCommand.prototype.reflect = function reflect(memoryAddress) {
  };

VkDrawIndexedIndirectCommand.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDrawIndexedIndirectCommand();
  copy.indexCount = original.indexCount;
  copy.instanceCount = original.instanceCount;
  copy.firstIndex = original.firstIndex;
  copy.vertexOffset = original.vertexOffset;
  copy.firstInstance = original.firstInstance;
  
  return copy;
};

VkDrawIndexedIndirectCommand.byteLength = 0x0;

VkDrawIndexedIndirectCommand.memoryLayout = {
  indexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  instanceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  firstIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  firstInstance: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDispatchIndirectCommand **/
function VkDispatchIndirectCommand(opts, byteOffset) {
  if (new.target !== VkDispatchIndirectCommand) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDispatchIndirectCommand, STRUCT_CACHE_VkDispatchIndirectCommand);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDispatchIndirectCommand, STRUCT_CACHE_VkDispatchIndirectCommand);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDispatchIndirectCommand'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.z !== void 0) this.z = opts.z;
    
  }
};

Object.defineProperties(VkDispatchIndirectCommand.prototype, {
  "x": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDispatchIndirectCommand.x");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "y": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDispatchIndirectCommand.y");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "z": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDispatchIndirectCommand.z");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDispatchIndirectCommand.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.z !== void 0) this.z = opts.z;
    
  }
};

VkDispatchIndirectCommand.prototype.flush = function flush() {
  
  return true;
};

VkDispatchIndirectCommand.prototype.reflect = function reflect(memoryAddress) {
  };

VkDispatchIndirectCommand.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDispatchIndirectCommand();
  copy.x = original.x;
  copy.y = original.y;
  copy.z = original.z;
  
  return copy;
};

VkDispatchIndirectCommand.byteLength = 0x0;

VkDispatchIndirectCommand.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  y: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  z: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubmitInfo **/
function VkSubmitInfo(opts, byteOffset) {
  if (new.target !== VkSubmitInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubmitInfo, STRUCT_CACHE_VkSubmitInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubmitInfo, STRUCT_CACHE_VkSubmitInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubmitInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
  this._pWaitSemaphoresNative = null;
  this._pWaitDstStageMask = null;
  
  this._pCommandBuffers = null;
  this._pCommandBuffersNative = null;
  
  this._pSignalSemaphores = null;
  this._pSignalSemaphoresNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
    if (opts.pWaitDstStageMask !== void 0) this.pWaitDstStageMask = opts.pWaitDstStageMask;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    if (opts.pCommandBuffers !== void 0) this.pCommandBuffers = opts.pCommandBuffers;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphores !== void 0) this.pSignalSemaphores = opts.pSignalSemaphores;
    
  }
};

Object.defineProperties(VkSubmitInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubmitInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSubmitInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkSubmitInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pNext'");
    }
    
    }
    },
  "waitSemaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubmitInfo.waitSemaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pWaitSemaphores": {
    get() {
    if (this._pWaitSemaphores === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.waitSemaphoreCount, VkSemaphore);
      this._pWaitSemaphores = array;
      return this.pWaitSemaphores;
    } else {
      return this._pWaitSemaphores;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pWaitSemaphores = value;
    } else if (value === null) {
      this._pWaitSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pWaitSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pWaitDstStageMask": {
    get() {
    return this._pWaitDstStageMask;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pWaitDstStageMask = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pWaitDstStageMask = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pWaitDstStageMask': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "commandBufferCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubmitInfo.commandBufferCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCommandBuffers": {
    get() {
    if (this._pCommandBuffers === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.commandBufferCount, VkCommandBuffer);
      this._pCommandBuffers = array;
      return this.pCommandBuffers;
    } else {
      return this._pCommandBuffers;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pCommandBuffers = value;
    } else if (value === null) {
      this._pCommandBuffers = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pCommandBuffers': Expected 'Array VkCommandBuffer' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "signalSemaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubmitInfo.signalSemaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSignalSemaphores": {
    get() {
    if (this._pSignalSemaphores === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.signalSemaphoreCount, VkSemaphore);
      this._pSignalSemaphores = array;
      return this.pSignalSemaphores;
    } else {
      return this._pSignalSemaphores;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSignalSemaphores = value;
    } else if (value === null) {
      this._pSignalSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pSignalSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkSubmitInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
  this._pWaitSemaphoresNative = null;
  this._pWaitDstStageMask = null;
  
  this._pCommandBuffers = null;
  this._pCommandBuffersNative = null;
  
  this._pSignalSemaphores = null;
  this._pSignalSemaphoresNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
    if (opts.pWaitDstStageMask !== void 0) this.pWaitDstStageMask = opts.pWaitDstStageMask;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    if (opts.pCommandBuffers !== void 0) this.pCommandBuffers = opts.pCommandBuffers;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphores !== void 0) this.pSignalSemaphores = opts.pSignalSemaphores;
    
  }
};

VkSubmitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pWaitSemaphores !== null) {
    let array = this._pWaitSemaphores;
    
    if (array.length !== this.waitSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'waitSemaphoreCount' for 'VkSubmitInfo.pWaitSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkSubmitInfo.pWaitSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pWaitSemaphoresNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pWaitSemaphoresNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pCommandBuffers !== null) {
    let array = this._pCommandBuffers;
    
    if (array.length !== this.commandBufferCount) {
      throw new RangeError("Invalid array length, expected length of 'commandBufferCount' for 'VkSubmitInfo.pCommandBuffers'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkCommandBuffer)) {
        throw new TypeError("Invalid type for 'VkSubmitInfo.pCommandBuffers[" + ii + "]': Expected 'VkCommandBuffer' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pCommandBuffersNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pCommandBuffersNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pSignalSemaphores !== null) {
    let array = this._pSignalSemaphores;
    
    if (array.length !== this.signalSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'signalSemaphoreCount' for 'VkSubmitInfo.pSignalSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkSubmitInfo.pSignalSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSignalSemaphoresNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSignalSemaphoresNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSubmitInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubmitInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubmitInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.waitSemaphoreCount = original.waitSemaphoreCount;
  if (original.pWaitSemaphores !== null) {
        copy.pWaitSemaphores = [...Array(original.pWaitSemaphores.length)].map((v, i) => {
          return original.pWaitSemaphores[i].constructor.createCopyFrom(original.pWaitSemaphores[i]);
        });
      }
  if (original.pWaitDstStageMask !== null) {
        copy.pWaitDstStageMask = new Int32Array(original.pWaitDstStageMask);
      }
  copy.commandBufferCount = original.commandBufferCount;
  if (original.pCommandBuffers !== null) {
        copy.pCommandBuffers = [...Array(original.pCommandBuffers.length)].map((v, i) => {
          return original.pCommandBuffers[i].constructor.createCopyFrom(original.pCommandBuffers[i]);
        });
      }
  copy.signalSemaphoreCount = original.signalSemaphoreCount;
  if (original.pSignalSemaphores !== null) {
        copy.pSignalSemaphores = [...Array(original.pSignalSemaphores.length)].map((v, i) => {
          return original.pSignalSemaphores[i].constructor.createCopyFrom(original.pSignalSemaphores[i]);
        });
      }
  
  return copy;
};

VkSubmitInfo.byteLength = 0x0;

VkSubmitInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  waitSemaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pWaitSemaphores: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pWaitDstStageMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  commandBufferCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCommandBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  signalSemaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSignalSemaphores: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayPropertiesKHR **/
function VkDisplayPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkDisplayPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayPropertiesKHR, STRUCT_CACHE_VkDisplayPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayPropertiesKHR, STRUCT_CACHE_VkDisplayPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._display = null;
  this._displayName = null;
  this._physicalDimensions = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._physicalResolution = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkDisplayPropertiesKHR.prototype, {
  "display": {
    get() {
    return this._display;
    },
    },
  "displayName": {
    get() {
    if (this._displayName !== null) {
      let str = textDecoder.decode(this._displayName);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._displayName = buffer;
        return this.displayName;
      }
      return null;
    }
    },
    },
  "physicalDimensions": {
    get() {
    return this._physicalDimensions;
    },
    },
  "physicalResolution": {
    get() {
    return this._physicalResolution;
    },
    },
  "supportedTransforms": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "planeReorderPossible": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "persistentContent": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkDisplayPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._display = null;
  this._displayName = null;
  if (this._physicalDimensions !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._physicalDimensions.memoryBuffer) this._physicalDimensions = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._physicalDimensions.reset();
  }
  if (this._physicalResolution !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._physicalResolution.memoryBuffer) this._physicalResolution = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._physicalResolution.reset();
  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkDisplayPropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDisplayPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayPropertiesKHR();
  if (original.display !== null) {
        copy.display = original.display.constructor.createCopyFrom(original.display);
      }
  copy.displayName = original.displayName;
  if (original.physicalDimensions !== null) {
        copy.physicalDimensions = original.physicalDimensions.constructor.createCopyFrom(original.physicalDimensions);
      }
  if (original.physicalResolution !== null) {
        copy.physicalResolution = original.physicalResolution.constructor.createCopyFrom(original.physicalResolution);
      }
  copy.supportedTransforms = original.supportedTransforms;
  copy.planeReorderPossible = original.planeReorderPossible;
  copy.persistentContent = original.persistentContent;
  
  return copy;
};

VkDisplayPropertiesKHR.byteLength = 0x0;

VkDisplayPropertiesKHR.memoryLayout = {
  display: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  displayName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  physicalDimensions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  physicalResolution: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedTransforms: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  planeReorderPossible: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  persistentContent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayPlanePropertiesKHR **/
function VkDisplayPlanePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkDisplayPlanePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayPlanePropertiesKHR, STRUCT_CACHE_VkDisplayPlanePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayPlanePropertiesKHR, STRUCT_CACHE_VkDisplayPlanePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayPlanePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._currentDisplay = null;
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkDisplayPlanePropertiesKHR.prototype, {
  "currentDisplay": {
    get() {
    return this._currentDisplay;
    },
    },
  "currentStackIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkDisplayPlanePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._currentDisplay = null;
  
  
  if (typeof opts === "object") {
    
  }
};

VkDisplayPlanePropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayPlanePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDisplayPlanePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayPlanePropertiesKHR();
  if (original.currentDisplay !== null) {
        copy.currentDisplay = original.currentDisplay.constructor.createCopyFrom(original.currentDisplay);
      }
  copy.currentStackIndex = original.currentStackIndex;
  
  return copy;
};

VkDisplayPlanePropertiesKHR.byteLength = 0x0;

VkDisplayPlanePropertiesKHR.memoryLayout = {
  currentDisplay: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  currentStackIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayModeParametersKHR **/
function VkDisplayModeParametersKHR(opts, byteOffset) {
  if (new.target !== VkDisplayModeParametersKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayModeParametersKHR, STRUCT_CACHE_VkDisplayModeParametersKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayModeParametersKHR, STRUCT_CACHE_VkDisplayModeParametersKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayModeParametersKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._visibleRegion = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  if (typeof opts === "object") {
    if (opts.visibleRegion !== void 0) this.visibleRegion = opts.visibleRegion;
    if (opts.refreshRate !== void 0) this.refreshRate = opts.refreshRate;
    
  }
};

Object.defineProperties(VkDisplayModeParametersKHR.prototype, {
  "visibleRegion": {
    get() {
    return this._visibleRegion;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._visibleRegion = value;
      
      
    } else if (value === null) {
      this._visibleRegion = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayModeParametersKHR.visibleRegion': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "refreshRate": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayModeParametersKHR.refreshRate");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDisplayModeParametersKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._visibleRegion !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._visibleRegion.memoryBuffer) this._visibleRegion = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._visibleRegion.reset();
  }
  
  
  if (typeof opts === "object") {
    if (opts.visibleRegion !== void 0) this.visibleRegion = opts.visibleRegion;
    if (opts.refreshRate !== void 0) this.refreshRate = opts.refreshRate;
    
  }
};

VkDisplayModeParametersKHR.prototype.flush = function flush() {
  
  
  if (this._visibleRegion !== null) {
    let visibleRegion = this._visibleRegion;
    visibleRegion.flush();
    if (this.memoryBuffer !== visibleRegion.memoryBuffer) {
      let srcView = new Uint8Array(visibleRegion.memoryBuffer, visibleRegion.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkDisplayModeParametersKHR.visibleRegion' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkDisplayModeParametersKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDisplayModeParametersKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayModeParametersKHR();
  if (original.visibleRegion !== null) {
        copy.visibleRegion = original.visibleRegion.constructor.createCopyFrom(original.visibleRegion);
      }
  copy.refreshRate = original.refreshRate;
  
  return copy;
};

VkDisplayModeParametersKHR.byteLength = 0x0;

VkDisplayModeParametersKHR.memoryLayout = {
  visibleRegion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  refreshRate: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayModePropertiesKHR **/
function VkDisplayModePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkDisplayModePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayModePropertiesKHR, STRUCT_CACHE_VkDisplayModePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayModePropertiesKHR, STRUCT_CACHE_VkDisplayModePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayModePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._displayMode = null;
  this._parameters = new VkDisplayModeParametersKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkDisplayModePropertiesKHR.prototype, {
  "displayMode": {
    get() {
    return this._displayMode;
    },
    },
  "parameters": {
    get() {
    return this._parameters;
    },
    },
  
});

VkDisplayModePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._displayMode = null;
  if (this._parameters !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._parameters.memoryBuffer) this._parameters = new VkDisplayModeParametersKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._parameters.reset();
  }
  
  if (typeof opts === "object") {
    
  }
};

VkDisplayModePropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayModePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDisplayModePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayModePropertiesKHR();
  if (original.displayMode !== null) {
        copy.displayMode = original.displayMode.constructor.createCopyFrom(original.displayMode);
      }
  if (original.parameters !== null) {
        copy.parameters = original.parameters.constructor.createCopyFrom(original.parameters);
      }
  
  return copy;
};

VkDisplayModePropertiesKHR.byteLength = 0x0;

VkDisplayModePropertiesKHR.memoryLayout = {
  displayMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  parameters: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayModeCreateInfoKHR **/
function VkDisplayModeCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkDisplayModeCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayModeCreateInfoKHR, STRUCT_CACHE_VkDisplayModeCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayModeCreateInfoKHR, STRUCT_CACHE_VkDisplayModeCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayModeCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._parameters = new VkDisplayModeParametersKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.parameters !== void 0) this.parameters = opts.parameters;
    
  }
};

Object.defineProperties(VkDisplayModeCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayModeCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayModeCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayModeCreateInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "parameters": {
    get() {
    return this._parameters;
    },
    set(value) {
    if (value !== null && value.constructor === VkDisplayModeParametersKHR) {
      value.flush();
      this._parameters = value;
      
      
    } else if (value === null) {
      this._parameters = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayModeCreateInfoKHR.parameters': Expected 'VkDisplayModeParametersKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDisplayModeCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._parameters !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._parameters.memoryBuffer) this._parameters = new VkDisplayModeParametersKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._parameters.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.parameters !== void 0) this.parameters = opts.parameters;
    
  }
};

VkDisplayModeCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._parameters !== null) {
    let parameters = this._parameters;
    parameters.flush();
    if (this.memoryBuffer !== parameters.memoryBuffer) {
      let srcView = new Uint8Array(parameters.memoryBuffer, parameters.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkDisplayModeCreateInfoKHR.parameters' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkDisplayModeCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDisplayModeCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayModeCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  if (original.parameters !== null) {
        copy.parameters = original.parameters.constructor.createCopyFrom(original.parameters);
      }
  
  return copy;
};

VkDisplayModeCreateInfoKHR.byteLength = 0x0;

VkDisplayModeCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  parameters: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayPlaneCapabilitiesKHR **/
function VkDisplayPlaneCapabilitiesKHR(opts, byteOffset) {
  if (new.target !== VkDisplayPlaneCapabilitiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayPlaneCapabilitiesKHR, STRUCT_CACHE_VkDisplayPlaneCapabilitiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayPlaneCapabilitiesKHR, STRUCT_CACHE_VkDisplayPlaneCapabilitiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayPlaneCapabilitiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._minSrcPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._maxSrcPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._minSrcExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._maxSrcExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._minDstPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._maxDstPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._minDstExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._maxDstExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkDisplayPlaneCapabilitiesKHR.prototype, {
  "supportedAlpha": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "minSrcPosition": {
    get() {
    return this._minSrcPosition;
    },
    },
  "maxSrcPosition": {
    get() {
    return this._maxSrcPosition;
    },
    },
  "minSrcExtent": {
    get() {
    return this._minSrcExtent;
    },
    },
  "maxSrcExtent": {
    get() {
    return this._maxSrcExtent;
    },
    },
  "minDstPosition": {
    get() {
    return this._minDstPosition;
    },
    },
  "maxDstPosition": {
    get() {
    return this._maxDstPosition;
    },
    },
  "minDstExtent": {
    get() {
    return this._minDstExtent;
    },
    },
  "maxDstExtent": {
    get() {
    return this._maxDstExtent;
    },
    },
  
});

VkDisplayPlaneCapabilitiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  if (this._minSrcPosition !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._minSrcPosition.memoryBuffer) this._minSrcPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._minSrcPosition.reset();
  }
  if (this._maxSrcPosition !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxSrcPosition.memoryBuffer) this._maxSrcPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxSrcPosition.reset();
  }
  if (this._minSrcExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._minSrcExtent.memoryBuffer) this._minSrcExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._minSrcExtent.reset();
  }
  if (this._maxSrcExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxSrcExtent.memoryBuffer) this._maxSrcExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxSrcExtent.reset();
  }
  if (this._minDstPosition !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._minDstPosition.memoryBuffer) this._minDstPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._minDstPosition.reset();
  }
  if (this._maxDstPosition !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxDstPosition.memoryBuffer) this._maxDstPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxDstPosition.reset();
  }
  if (this._minDstExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._minDstExtent.memoryBuffer) this._minDstExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._minDstExtent.reset();
  }
  if (this._maxDstExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxDstExtent.memoryBuffer) this._maxDstExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxDstExtent.reset();
  }
  
  if (typeof opts === "object") {
    
  }
};

VkDisplayPlaneCapabilitiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayPlaneCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDisplayPlaneCapabilitiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayPlaneCapabilitiesKHR();
  copy.supportedAlpha = original.supportedAlpha;
  if (original.minSrcPosition !== null) {
        copy.minSrcPosition = original.minSrcPosition.constructor.createCopyFrom(original.minSrcPosition);
      }
  if (original.maxSrcPosition !== null) {
        copy.maxSrcPosition = original.maxSrcPosition.constructor.createCopyFrom(original.maxSrcPosition);
      }
  if (original.minSrcExtent !== null) {
        copy.minSrcExtent = original.minSrcExtent.constructor.createCopyFrom(original.minSrcExtent);
      }
  if (original.maxSrcExtent !== null) {
        copy.maxSrcExtent = original.maxSrcExtent.constructor.createCopyFrom(original.maxSrcExtent);
      }
  if (original.minDstPosition !== null) {
        copy.minDstPosition = original.minDstPosition.constructor.createCopyFrom(original.minDstPosition);
      }
  if (original.maxDstPosition !== null) {
        copy.maxDstPosition = original.maxDstPosition.constructor.createCopyFrom(original.maxDstPosition);
      }
  if (original.minDstExtent !== null) {
        copy.minDstExtent = original.minDstExtent.constructor.createCopyFrom(original.minDstExtent);
      }
  if (original.maxDstExtent !== null) {
        copy.maxDstExtent = original.maxDstExtent.constructor.createCopyFrom(original.maxDstExtent);
      }
  
  return copy;
};

VkDisplayPlaneCapabilitiesKHR.byteLength = 0x0;

VkDisplayPlaneCapabilitiesKHR.memoryLayout = {
  supportedAlpha: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minSrcPosition: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSrcPosition: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minSrcExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSrcExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minDstPosition: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDstPosition: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minDstExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDstExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplaySurfaceCreateInfoKHR **/
function VkDisplaySurfaceCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkDisplaySurfaceCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplaySurfaceCreateInfoKHR, STRUCT_CACHE_VkDisplaySurfaceCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplaySurfaceCreateInfoKHR, STRUCT_CACHE_VkDisplaySurfaceCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplaySurfaceCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._displayMode = null;
  
  
  
  
  
  this._imageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.displayMode !== void 0) this.displayMode = opts.displayMode;
    if (opts.planeIndex !== void 0) this.planeIndex = opts.planeIndex;
    if (opts.planeStackIndex !== void 0) this.planeStackIndex = opts.planeStackIndex;
    if (opts.transform !== void 0) this.transform = opts.transform;
    if (opts.globalAlpha !== void 0) this.globalAlpha = opts.globalAlpha;
    if (opts.alphaMode !== void 0) this.alphaMode = opts.alphaMode;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    
  }
};

Object.defineProperties(VkDisplaySurfaceCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplaySurfaceCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplaySurfaceCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplaySurfaceCreateInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "displayMode": {
    get() {
    return this._displayMode;
    },
    set(value) {
    if (value !== null && value.constructor === VkDisplayModeKHR) {
      
      this._displayMode = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._displayMode = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.displayMode': Expected 'VkDisplayModeKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "planeIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplaySurfaceCreateInfoKHR.planeIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "planeStackIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplaySurfaceCreateInfoKHR.planeStackIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "transform": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplaySurfaceCreateInfoKHR.transform");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "globalAlpha": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplaySurfaceCreateInfoKHR.globalAlpha");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "alphaMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplaySurfaceCreateInfoKHR.alphaMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "imageExtent": {
    get() {
    return this._imageExtent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._imageExtent = value;
      
      
    } else if (value === null) {
      this._imageExtent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.imageExtent': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDisplaySurfaceCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._displayMode = null;
  
  
  
  
  
  if (this._imageExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageExtent.memoryBuffer) this._imageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageExtent.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.displayMode !== void 0) this.displayMode = opts.displayMode;
    if (opts.planeIndex !== void 0) this.planeIndex = opts.planeIndex;
    if (opts.planeStackIndex !== void 0) this.planeStackIndex = opts.planeStackIndex;
    if (opts.transform !== void 0) this.transform = opts.transform;
    if (opts.globalAlpha !== void 0) this.globalAlpha = opts.globalAlpha;
    if (opts.alphaMode !== void 0) this.alphaMode = opts.alphaMode;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    
  }
};

VkDisplaySurfaceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._imageExtent !== null) {
    let imageExtent = this._imageExtent;
    imageExtent.flush();
    if (this.memoryBuffer !== imageExtent.memoryBuffer) {
      let srcView = new Uint8Array(imageExtent.memoryBuffer, imageExtent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkDisplaySurfaceCreateInfoKHR.imageExtent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkDisplaySurfaceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDisplaySurfaceCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplaySurfaceCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  if (original.displayMode !== null) {
        copy.displayMode = original.displayMode.constructor.createCopyFrom(original.displayMode);
      }
  copy.planeIndex = original.planeIndex;
  copy.planeStackIndex = original.planeStackIndex;
  copy.transform = original.transform;
  copy.globalAlpha = original.globalAlpha;
  copy.alphaMode = original.alphaMode;
  if (original.imageExtent !== null) {
        copy.imageExtent = original.imageExtent.constructor.createCopyFrom(original.imageExtent);
      }
  
  return copy;
};

VkDisplaySurfaceCreateInfoKHR.byteLength = 0x0;

VkDisplaySurfaceCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  displayMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  planeIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  planeStackIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transform: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  globalAlpha: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  alphaMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayPresentInfoKHR **/
function VkDisplayPresentInfoKHR(opts, byteOffset) {
  if (new.target !== VkDisplayPresentInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayPresentInfoKHR, STRUCT_CACHE_VkDisplayPresentInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayPresentInfoKHR, STRUCT_CACHE_VkDisplayPresentInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayPresentInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcRect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstRect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcRect !== void 0) this.srcRect = opts.srcRect;
    if (opts.dstRect !== void 0) this.dstRect = opts.dstRect;
    if (opts.persistent !== void 0) this.persistent = opts.persistent;
    
  }
};

Object.defineProperties(VkDisplayPresentInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayPresentInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayPresentInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "srcRect": {
    get() {
    return this._srcRect;
    },
    set(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._srcRect = value;
      
      
    } else if (value === null) {
      this._srcRect = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayPresentInfoKHR.srcRect': Expected 'VkRect2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstRect": {
    get() {
    return this._dstRect;
    },
    set(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._dstRect = value;
      
      
    } else if (value === null) {
      this._dstRect = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayPresentInfoKHR.dstRect': Expected 'VkRect2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "persistent": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkDisplayPresentInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._srcRect !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcRect.memoryBuffer) this._srcRect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcRect.reset();
  }
  if (this._dstRect !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstRect.memoryBuffer) this._dstRect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstRect.reset();
  }
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcRect !== void 0) this.srcRect = opts.srcRect;
    if (opts.dstRect !== void 0) this.dstRect = opts.dstRect;
    if (opts.persistent !== void 0) this.persistent = opts.persistent;
    
  }
};

VkDisplayPresentInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._srcRect !== null) {
    let srcRect = this._srcRect;
    srcRect.flush();
    if (this.memoryBuffer !== srcRect.memoryBuffer) {
      let srcView = new Uint8Array(srcRect.memoryBuffer, srcRect.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkDisplayPresentInfoKHR.srcRect' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstRect !== null) {
    let dstRect = this._dstRect;
    dstRect.flush();
    if (this.memoryBuffer !== dstRect.memoryBuffer) {
      let srcView = new Uint8Array(dstRect.memoryBuffer, dstRect.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkDisplayPresentInfoKHR.dstRect' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkDisplayPresentInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDisplayPresentInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayPresentInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcRect !== null) {
        copy.srcRect = original.srcRect.constructor.createCopyFrom(original.srcRect);
      }
  if (original.dstRect !== null) {
        copy.dstRect = original.dstRect.constructor.createCopyFrom(original.dstRect);
      }
  copy.persistent = original.persistent;
  
  return copy;
};

VkDisplayPresentInfoKHR.byteLength = 0x0;

VkDisplayPresentInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcRect: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstRect: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  persistent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSurfaceCapabilitiesKHR **/
function VkSurfaceCapabilitiesKHR(opts, byteOffset) {
  if (new.target !== VkSurfaceCapabilitiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSurfaceCapabilitiesKHR, STRUCT_CACHE_VkSurfaceCapabilitiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSurfaceCapabilitiesKHR, STRUCT_CACHE_VkSurfaceCapabilitiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSurfaceCapabilitiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  this._currentExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._minImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._maxImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkSurfaceCapabilitiesKHR.prototype, {
  "minImageCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxImageCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "currentExtent": {
    get() {
    return this._currentExtent;
    },
    },
  "minImageExtent": {
    get() {
    return this._minImageExtent;
    },
    },
  "maxImageExtent": {
    get() {
    return this._maxImageExtent;
    },
    },
  "maxImageArrayLayers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "supportedTransforms": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "currentTransform": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "supportedCompositeAlpha": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "supportedUsageFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkSurfaceCapabilitiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  if (this._currentExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._currentExtent.memoryBuffer) this._currentExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._currentExtent.reset();
  }
  if (this._minImageExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._minImageExtent.memoryBuffer) this._minImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._minImageExtent.reset();
  }
  if (this._maxImageExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxImageExtent.memoryBuffer) this._maxImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxImageExtent.reset();
  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkSurfaceCapabilitiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkSurfaceCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSurfaceCapabilitiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSurfaceCapabilitiesKHR();
  copy.minImageCount = original.minImageCount;
  copy.maxImageCount = original.maxImageCount;
  if (original.currentExtent !== null) {
        copy.currentExtent = original.currentExtent.constructor.createCopyFrom(original.currentExtent);
      }
  if (original.minImageExtent !== null) {
        copy.minImageExtent = original.minImageExtent.constructor.createCopyFrom(original.minImageExtent);
      }
  if (original.maxImageExtent !== null) {
        copy.maxImageExtent = original.maxImageExtent.constructor.createCopyFrom(original.maxImageExtent);
      }
  copy.maxImageArrayLayers = original.maxImageArrayLayers;
  copy.supportedTransforms = original.supportedTransforms;
  copy.currentTransform = original.currentTransform;
  copy.supportedCompositeAlpha = original.supportedCompositeAlpha;
  copy.supportedUsageFlags = original.supportedUsageFlags;
  
  return copy;
};

VkSurfaceCapabilitiesKHR.byteLength = 0x0;

VkSurfaceCapabilitiesKHR.memoryLayout = {
  minImageCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxImageCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  currentExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minImageExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxImageExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxImageArrayLayers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedTransforms: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  currentTransform: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedCompositeAlpha: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedUsageFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkWin32SurfaceCreateInfoKHR **/
function VkWin32SurfaceCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkWin32SurfaceCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkWin32SurfaceCreateInfoKHR, STRUCT_CACHE_VkWin32SurfaceCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkWin32SurfaceCreateInfoKHR, STRUCT_CACHE_VkWin32SurfaceCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkWin32SurfaceCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.hinstance !== void 0) this.hinstance = opts.hinstance;
    if (opts.hwnd !== void 0) this.hwnd = opts.hwnd;
    
  }
};

Object.defineProperties(VkWin32SurfaceCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWin32SurfaceCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWin32SurfaceCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWin32SurfaceCreateInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "hinstance": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkWin32SurfaceCreateInfoKHR.hinstance")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "hwnd": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkWin32SurfaceCreateInfoKHR.hwnd")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  
});

VkWin32SurfaceCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.hinstance !== void 0) this.hinstance = opts.hinstance;
    if (opts.hwnd !== void 0) this.hwnd = opts.hwnd;
    
  }
};

VkWin32SurfaceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkWin32SurfaceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkWin32SurfaceCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkWin32SurfaceCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.hinstance = original.hinstance;
  copy.hwnd = original.hwnd;
  
  return copy;
};

VkWin32SurfaceCreateInfoKHR.byteLength = 0x0;

VkWin32SurfaceCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  hinstance: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  hwnd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSurfaceFormatKHR **/
function VkSurfaceFormatKHR(opts, byteOffset) {
  if (new.target !== VkSurfaceFormatKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSurfaceFormatKHR, STRUCT_CACHE_VkSurfaceFormatKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSurfaceFormatKHR, STRUCT_CACHE_VkSurfaceFormatKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSurfaceFormatKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkSurfaceFormatKHR.prototype, {
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "colorSpace": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkSurfaceFormatKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkSurfaceFormatKHR.prototype.flush = function flush() {
  
  return true;
};

VkSurfaceFormatKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSurfaceFormatKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSurfaceFormatKHR();
  copy.format = original.format;
  copy.colorSpace = original.colorSpace;
  
  return copy;
};

VkSurfaceFormatKHR.byteLength = 0x0;

VkSurfaceFormatKHR.memoryLayout = {
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  colorSpace: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSwapchainCreateInfoKHR **/
function VkSwapchainCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkSwapchainCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSwapchainCreateInfoKHR, STRUCT_CACHE_VkSwapchainCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSwapchainCreateInfoKHR, STRUCT_CACHE_VkSwapchainCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSwapchainCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._surface = null;
  
  
  
  this._imageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  this._pQueueFamilyIndices = null;
  
  
  
  
  this._oldSwapchain = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.surface !== void 0) this.surface = opts.surface;
    if (opts.minImageCount !== void 0) this.minImageCount = opts.minImageCount;
    if (opts.imageFormat !== void 0) this.imageFormat = opts.imageFormat;
    if (opts.imageColorSpace !== void 0) this.imageColorSpace = opts.imageColorSpace;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    if (opts.imageArrayLayers !== void 0) this.imageArrayLayers = opts.imageArrayLayers;
    if (opts.imageUsage !== void 0) this.imageUsage = opts.imageUsage;
    if (opts.imageSharingMode !== void 0) this.imageSharingMode = opts.imageSharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    if (opts.preTransform !== void 0) this.preTransform = opts.preTransform;
    if (opts.compositeAlpha !== void 0) this.compositeAlpha = opts.compositeAlpha;
    if (opts.presentMode !== void 0) this.presentMode = opts.presentMode;
    if (opts.clipped !== void 0) this.clipped = opts.clipped;
    if (opts.oldSwapchain !== void 0) this.oldSwapchain = opts.oldSwapchain;
    
  }
};

Object.defineProperties(VkSwapchainCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "surface": {
    get() {
    return this._surface;
    },
    set(value) {
    if (value !== null && value.constructor === VkSurfaceKHR) {
      
      this._surface = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._surface = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.surface': Expected 'VkSurfaceKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "minImageCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.minImageCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "imageFormat": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.imageFormat");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "imageColorSpace": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.imageColorSpace");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "imageExtent": {
    get() {
    return this._imageExtent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._imageExtent = value;
      
      
    } else if (value === null) {
      this._imageExtent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageExtent': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageArrayLayers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.imageArrayLayers");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "imageUsage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.imageUsage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "imageSharingMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.imageSharingMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "queueFamilyIndexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.queueFamilyIndexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pQueueFamilyIndices": {
    get() {
    return this._pQueueFamilyIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "preTransform": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.preTransform");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "compositeAlpha": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.compositeAlpha");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "presentMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCreateInfoKHR.presentMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "clipped": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "oldSwapchain": {
    get() {
    return this._oldSwapchain;
    },
    set(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._oldSwapchain = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._oldSwapchain = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.oldSwapchain': Expected 'VkSwapchainKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSwapchainCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._surface = null;
  
  
  
  if (this._imageExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageExtent.memoryBuffer) this._imageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageExtent.reset();
  }
  
  
  
  
  this._pQueueFamilyIndices = null;
  
  
  
  
  this._oldSwapchain = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.surface !== void 0) this.surface = opts.surface;
    if (opts.minImageCount !== void 0) this.minImageCount = opts.minImageCount;
    if (opts.imageFormat !== void 0) this.imageFormat = opts.imageFormat;
    if (opts.imageColorSpace !== void 0) this.imageColorSpace = opts.imageColorSpace;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    if (opts.imageArrayLayers !== void 0) this.imageArrayLayers = opts.imageArrayLayers;
    if (opts.imageUsage !== void 0) this.imageUsage = opts.imageUsage;
    if (opts.imageSharingMode !== void 0) this.imageSharingMode = opts.imageSharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    if (opts.preTransform !== void 0) this.preTransform = opts.preTransform;
    if (opts.compositeAlpha !== void 0) this.compositeAlpha = opts.compositeAlpha;
    if (opts.presentMode !== void 0) this.presentMode = opts.presentMode;
    if (opts.clipped !== void 0) this.clipped = opts.clipped;
    if (opts.oldSwapchain !== void 0) this.oldSwapchain = opts.oldSwapchain;
    
  }
};

VkSwapchainCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._imageExtent !== null) {
    let imageExtent = this._imageExtent;
    imageExtent.flush();
    if (this.memoryBuffer !== imageExtent.memoryBuffer) {
      let srcView = new Uint8Array(imageExtent.memoryBuffer, imageExtent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSwapchainCreateInfoKHR.imageExtent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSwapchainCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSwapchainCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSwapchainCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  if (original.surface !== null) {
        copy.surface = original.surface.constructor.createCopyFrom(original.surface);
      }
  copy.minImageCount = original.minImageCount;
  copy.imageFormat = original.imageFormat;
  copy.imageColorSpace = original.imageColorSpace;
  if (original.imageExtent !== null) {
        copy.imageExtent = original.imageExtent.constructor.createCopyFrom(original.imageExtent);
      }
  copy.imageArrayLayers = original.imageArrayLayers;
  copy.imageUsage = original.imageUsage;
  copy.imageSharingMode = original.imageSharingMode;
  copy.queueFamilyIndexCount = original.queueFamilyIndexCount;
  if (original.pQueueFamilyIndices !== null) {
        copy.pQueueFamilyIndices = new Uint32Array(original.pQueueFamilyIndices);
      }
  copy.preTransform = original.preTransform;
  copy.compositeAlpha = original.compositeAlpha;
  copy.presentMode = original.presentMode;
  copy.clipped = original.clipped;
  if (original.oldSwapchain !== null) {
        copy.oldSwapchain = original.oldSwapchain.constructor.createCopyFrom(original.oldSwapchain);
      }
  
  return copy;
};

VkSwapchainCreateInfoKHR.byteLength = 0x0;

VkSwapchainCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  surface: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minImageCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageFormat: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageColorSpace: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageArrayLayers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageUsage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageSharingMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueFamilyIndexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pQueueFamilyIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  preTransform: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compositeAlpha: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  presentMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  clipped: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  oldSwapchain: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPresentInfoKHR **/
function VkPresentInfoKHR(opts, byteOffset) {
  if (new.target !== VkPresentInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPresentInfoKHR, STRUCT_CACHE_VkPresentInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPresentInfoKHR, STRUCT_CACHE_VkPresentInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPresentInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
  this._pWaitSemaphoresNative = null;
  
  this._pSwapchains = null;
  this._pSwapchainsNative = null;
  this._pImageIndices = null;
  this._pResults = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pSwapchains !== void 0) this.pSwapchains = opts.pSwapchains;
    if (opts.pImageIndices !== void 0) this.pImageIndices = opts.pImageIndices;
    if (opts.pResults !== void 0) this.pResults = opts.pResults;
    
  }
};

Object.defineProperties(VkPresentInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPresentInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPresentInfoKHR.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPresentInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pNext'");
    }
    
    }
    },
  "waitSemaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPresentInfoKHR.waitSemaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pWaitSemaphores": {
    get() {
    if (this._pWaitSemaphores === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.waitSemaphoreCount, VkSemaphore);
      this._pWaitSemaphores = array;
      return this.pWaitSemaphores;
    } else {
      return this._pWaitSemaphores;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pWaitSemaphores = value;
    } else if (value === null) {
      this._pWaitSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pWaitSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "swapchainCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPresentInfoKHR.swapchainCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSwapchains": {
    get() {
    if (this._pSwapchains === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.swapchainCount, VkSwapchainKHR);
      this._pSwapchains = array;
      return this.pSwapchains;
    } else {
      return this._pSwapchains;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSwapchains = value;
    } else if (value === null) {
      this._pSwapchains = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pSwapchains': Expected 'Array VkSwapchainKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pImageIndices": {
    get() {
    return this._pImageIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pImageIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pImageIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pImageIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pResults": {
    get() {
    return this._pResults;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pResults = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pResults = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pResults': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPresentInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphores = null;
  this._pWaitSemaphoresNative = null;
  
  this._pSwapchains = null;
  this._pSwapchainsNative = null;
  this._pImageIndices = null;
  this._pResults = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pSwapchains !== void 0) this.pSwapchains = opts.pSwapchains;
    if (opts.pImageIndices !== void 0) this.pImageIndices = opts.pImageIndices;
    if (opts.pResults !== void 0) this.pResults = opts.pResults;
    
  }
};

VkPresentInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pWaitSemaphores !== null) {
    let array = this._pWaitSemaphores;
    
    if (array.length !== this.waitSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'waitSemaphoreCount' for 'VkPresentInfoKHR.pWaitSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkPresentInfoKHR.pWaitSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pWaitSemaphoresNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pWaitSemaphoresNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pSwapchains !== null) {
    let array = this._pSwapchains;
    
    if (array.length !== this.swapchainCount) {
      throw new RangeError("Invalid array length, expected length of 'swapchainCount' for 'VkPresentInfoKHR.pSwapchains'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSwapchainKHR)) {
        throw new TypeError("Invalid type for 'VkPresentInfoKHR.pSwapchains[" + ii + "]': Expected 'VkSwapchainKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSwapchainsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSwapchainsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPresentInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPresentInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPresentInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.waitSemaphoreCount = original.waitSemaphoreCount;
  if (original.pWaitSemaphores !== null) {
        copy.pWaitSemaphores = [...Array(original.pWaitSemaphores.length)].map((v, i) => {
          return original.pWaitSemaphores[i].constructor.createCopyFrom(original.pWaitSemaphores[i]);
        });
      }
  copy.swapchainCount = original.swapchainCount;
  if (original.pSwapchains !== null) {
        copy.pSwapchains = [...Array(original.pSwapchains.length)].map((v, i) => {
          return original.pSwapchains[i].constructor.createCopyFrom(original.pSwapchains[i]);
        });
      }
  if (original.pImageIndices !== null) {
        copy.pImageIndices = new Uint32Array(original.pImageIndices);
      }
  if (original.pResults !== null) {
        copy.pResults = new Int32Array(original.pResults);
      }
  
  return copy;
};

VkPresentInfoKHR.byteLength = 0x0;

VkPresentInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  waitSemaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pWaitSemaphores: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  swapchainCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSwapchains: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pImageIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pResults: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDebugReportCallbackCreateInfoEXT **/
function VkDebugReportCallbackCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkDebugReportCallbackCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDebugReportCallbackCreateInfoEXT, STRUCT_CACHE_VkDebugReportCallbackCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDebugReportCallbackCreateInfoEXT, STRUCT_CACHE_VkDebugReportCallbackCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDebugReportCallbackCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pfnCallback = null;this._pfnCallbackCallbackProxy = null;
  this._pUserData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pfnCallback !== void 0) this.pfnCallback = opts.pfnCallback;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

Object.defineProperties(VkDebugReportCallbackCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugReportCallbackCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugReportCallbackCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugReportCallbackCreateInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pfnCallback": {
    get() {
    return this._pfnCallback;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      let MITM = function() {
        for (let ii = 0; ii < arguments.length; ++ii) {
          let arg = arguments[ii];
          if (arg instanceof Object && arg.constructor.createCopyFrom instanceof Function) {
            let copy = arg.constructor.createCopyFrom(arg);
            arguments[ii] = copy;
          }
        };
        return value.apply(this, arguments);
      }.bind(this);
      this._pfnCallback = value;
      this._pfnCallbackCallbackProxy = new nvk.$CallbackProxy(MITM, module.exports);
      this.memoryView.setBigInt64(0x0, nvk.$vulkanCallbackFunctionPointers["vkDebugReportCallbackEXT"], true);
      this.memoryView.setBigInt64(0x0, this._pfnCallbackCallbackProxy.getAddress(), true);
    } else if (value === null) {
      this._pfnCallback = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDebugReportCallbackCreateInfoEXT.pfnCallback': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pUserData": {
    get() {
    return this._pUserData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDebugReportCallbackCreateInfoEXT.pUserData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugReportCallbackCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pfnCallback = null;
  this._pUserData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pfnCallback !== void 0) this.pfnCallback = opts.pfnCallback;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

VkDebugReportCallbackCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugReportCallbackCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDebugReportCallbackCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDebugReportCallbackCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.pfnCallback = original.pfnCallback;
  if (original.pUserData !== null) {
      let buf = new ArrayBuffer(original.pUserData.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pUserData), 0x0);
      copy.pUserData = buf;
    }
  
  return copy;
};

VkDebugReportCallbackCreateInfoEXT.byteLength = 0x0;

VkDebugReportCallbackCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pfnCallback: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pUserData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkValidationFlagsEXT **/
function VkValidationFlagsEXT(opts, byteOffset) {
  if (new.target !== VkValidationFlagsEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkValidationFlagsEXT, STRUCT_CACHE_VkValidationFlagsEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkValidationFlagsEXT, STRUCT_CACHE_VkValidationFlagsEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkValidationFlagsEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pDisabledValidationChecks = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.disabledValidationCheckCount !== void 0) this.disabledValidationCheckCount = opts.disabledValidationCheckCount;
    if (opts.pDisabledValidationChecks !== void 0) this.pDisabledValidationChecks = opts.pDisabledValidationChecks;
    
  }
};

Object.defineProperties(VkValidationFlagsEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkValidationFlagsEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkValidationFlagsEXT.pNext' isn't allowed to be filled");
    }
    },
  "disabledValidationCheckCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkValidationFlagsEXT.disabledValidationCheckCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDisabledValidationChecks": {
    get() {
    return this._pDisabledValidationChecks;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pDisabledValidationChecks = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDisabledValidationChecks = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkValidationFlagsEXT.pDisabledValidationChecks': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkValidationFlagsEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pDisabledValidationChecks = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.disabledValidationCheckCount !== void 0) this.disabledValidationCheckCount = opts.disabledValidationCheckCount;
    if (opts.pDisabledValidationChecks !== void 0) this.pDisabledValidationChecks = opts.pDisabledValidationChecks;
    
  }
};

VkValidationFlagsEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkValidationFlagsEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkValidationFlagsEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkValidationFlagsEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.disabledValidationCheckCount = original.disabledValidationCheckCount;
  if (original.pDisabledValidationChecks !== null) {
        copy.pDisabledValidationChecks = new Int32Array(original.pDisabledValidationChecks);
      }
  
  return copy;
};

VkValidationFlagsEXT.byteLength = 0x0;

VkValidationFlagsEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  disabledValidationCheckCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDisabledValidationChecks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkValidationFeaturesEXT **/
function VkValidationFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkValidationFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkValidationFeaturesEXT, STRUCT_CACHE_VkValidationFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkValidationFeaturesEXT, STRUCT_CACHE_VkValidationFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkValidationFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pEnabledValidationFeatures = null;
  
  this._pDisabledValidationFeatures = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.enabledValidationFeatureCount !== void 0) this.enabledValidationFeatureCount = opts.enabledValidationFeatureCount;
    if (opts.pEnabledValidationFeatures !== void 0) this.pEnabledValidationFeatures = opts.pEnabledValidationFeatures;
    if (opts.disabledValidationFeatureCount !== void 0) this.disabledValidationFeatureCount = opts.disabledValidationFeatureCount;
    if (opts.pDisabledValidationFeatures !== void 0) this.pDisabledValidationFeatures = opts.pDisabledValidationFeatures;
    
  }
};

Object.defineProperties(VkValidationFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkValidationFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkValidationFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "enabledValidationFeatureCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkValidationFeaturesEXT.enabledValidationFeatureCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pEnabledValidationFeatures": {
    get() {
    return this._pEnabledValidationFeatures;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pEnabledValidationFeatures = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pEnabledValidationFeatures = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.pEnabledValidationFeatures': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "disabledValidationFeatureCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkValidationFeaturesEXT.disabledValidationFeatureCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDisabledValidationFeatures": {
    get() {
    return this._pDisabledValidationFeatures;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pDisabledValidationFeatures = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDisabledValidationFeatures = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.pDisabledValidationFeatures': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkValidationFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pEnabledValidationFeatures = null;
  
  this._pDisabledValidationFeatures = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.enabledValidationFeatureCount !== void 0) this.enabledValidationFeatureCount = opts.enabledValidationFeatureCount;
    if (opts.pEnabledValidationFeatures !== void 0) this.pEnabledValidationFeatures = opts.pEnabledValidationFeatures;
    if (opts.disabledValidationFeatureCount !== void 0) this.disabledValidationFeatureCount = opts.disabledValidationFeatureCount;
    if (opts.pDisabledValidationFeatures !== void 0) this.pDisabledValidationFeatures = opts.pDisabledValidationFeatures;
    
  }
};

VkValidationFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkValidationFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkValidationFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkValidationFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.enabledValidationFeatureCount = original.enabledValidationFeatureCount;
  if (original.pEnabledValidationFeatures !== null) {
        copy.pEnabledValidationFeatures = new Int32Array(original.pEnabledValidationFeatures);
      }
  copy.disabledValidationFeatureCount = original.disabledValidationFeatureCount;
  if (original.pDisabledValidationFeatures !== null) {
        copy.pDisabledValidationFeatures = new Int32Array(original.pDisabledValidationFeatures);
      }
  
  return copy;
};

VkValidationFeaturesEXT.byteLength = 0x0;

VkValidationFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  enabledValidationFeatureCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pEnabledValidationFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  disabledValidationFeatureCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDisabledValidationFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineRasterizationStateRasterizationOrderAMD **/
function VkPipelineRasterizationStateRasterizationOrderAMD(opts, byteOffset) {
  if (new.target !== VkPipelineRasterizationStateRasterizationOrderAMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineRasterizationStateRasterizationOrderAMD, STRUCT_CACHE_VkPipelineRasterizationStateRasterizationOrderAMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineRasterizationStateRasterizationOrderAMD, STRUCT_CACHE_VkPipelineRasterizationStateRasterizationOrderAMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineRasterizationStateRasterizationOrderAMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.rasterizationOrder !== void 0) this.rasterizationOrder = opts.rasterizationOrder;
    
  }
};

Object.defineProperties(VkPipelineRasterizationStateRasterizationOrderAMD.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateRasterizationOrderAMD.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRasterizationStateRasterizationOrderAMD.pNext' isn't allowed to be filled");
    }
    },
  "rasterizationOrder": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateRasterizationOrderAMD.rasterizationOrder");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPipelineRasterizationStateRasterizationOrderAMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.rasterizationOrder !== void 0) this.rasterizationOrder = opts.rasterizationOrder;
    
  }
};

VkPipelineRasterizationStateRasterizationOrderAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationStateRasterizationOrderAMD.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineRasterizationStateRasterizationOrderAMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineRasterizationStateRasterizationOrderAMD();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.rasterizationOrder = original.rasterizationOrder;
  
  return copy;
};

VkPipelineRasterizationStateRasterizationOrderAMD.byteLength = 0x0;

VkPipelineRasterizationStateRasterizationOrderAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rasterizationOrder: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDebugMarkerObjectNameInfoEXT **/
function VkDebugMarkerObjectNameInfoEXT(opts, byteOffset) {
  if (new.target !== VkDebugMarkerObjectNameInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDebugMarkerObjectNameInfoEXT, STRUCT_CACHE_VkDebugMarkerObjectNameInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDebugMarkerObjectNameInfoEXT, STRUCT_CACHE_VkDebugMarkerObjectNameInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDebugMarkerObjectNameInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pObjectName = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.object !== void 0) this.object = opts.object;
    if (opts.pObjectName !== void 0) this.pObjectName = opts.pObjectName;
    
  }
};

Object.defineProperties(VkDebugMarkerObjectNameInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugMarkerObjectNameInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugMarkerObjectNameInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "objectType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugMarkerObjectNameInfoEXT.objectType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "object": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDebugMarkerObjectNameInfoEXT.object")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "pObjectName": {
    get() {
    if (this._pObjectName !== null) {
      let str = textDecoder.decode(this._pObjectName);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._pObjectName = buffer;
        return this.pObjectName;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pObjectName = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._pObjectName), true);
    } else if (value === null) {
      this._pObjectName = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkDebugMarkerObjectNameInfoEXT.pObjectName");
    }
    
    }
    },
  
});

VkDebugMarkerObjectNameInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pObjectName = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.object !== void 0) this.object = opts.object;
    if (opts.pObjectName !== void 0) this.pObjectName = opts.pObjectName;
    
  }
};

VkDebugMarkerObjectNameInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugMarkerObjectNameInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDebugMarkerObjectNameInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDebugMarkerObjectNameInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.objectType = original.objectType;
  copy.object = original.object;
  copy.pObjectName = original.pObjectName;
  
  return copy;
};

VkDebugMarkerObjectNameInfoEXT.byteLength = 0x0;

VkDebugMarkerObjectNameInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  objectType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  object: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pObjectName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDebugMarkerObjectTagInfoEXT **/
function VkDebugMarkerObjectTagInfoEXT(opts, byteOffset) {
  if (new.target !== VkDebugMarkerObjectTagInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDebugMarkerObjectTagInfoEXT, STRUCT_CACHE_VkDebugMarkerObjectTagInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDebugMarkerObjectTagInfoEXT, STRUCT_CACHE_VkDebugMarkerObjectTagInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDebugMarkerObjectTagInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this._pTag = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.object !== void 0) this.object = opts.object;
    if (opts.tagName !== void 0) this.tagName = opts.tagName;
    if (opts.tagSize !== void 0) this.tagSize = opts.tagSize;
    if (opts.pTag !== void 0) this.pTag = opts.pTag;
    
  }
};

Object.defineProperties(VkDebugMarkerObjectTagInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugMarkerObjectTagInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugMarkerObjectTagInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "objectType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugMarkerObjectTagInfoEXT.objectType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "object": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDebugMarkerObjectTagInfoEXT.object")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "tagName": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDebugMarkerObjectTagInfoEXT.tagName")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "tagSize": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDebugMarkerObjectTagInfoEXT.tagSize")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "pTag": {
    get() {
    return this._pTag;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pTag = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pTag = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.pTag': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugMarkerObjectTagInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pTag = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.object !== void 0) this.object = opts.object;
    if (opts.tagName !== void 0) this.tagName = opts.tagName;
    if (opts.tagSize !== void 0) this.tagSize = opts.tagSize;
    if (opts.pTag !== void 0) this.pTag = opts.pTag;
    
  }
};

VkDebugMarkerObjectTagInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugMarkerObjectTagInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDebugMarkerObjectTagInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDebugMarkerObjectTagInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.objectType = original.objectType;
  copy.object = original.object;
  copy.tagName = original.tagName;
  copy.tagSize = original.tagSize;
  if (original.pTag !== null) {
      let buf = new ArrayBuffer(original.pTag.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pTag), 0x0);
      copy.pTag = buf;
    }
  
  return copy;
};

VkDebugMarkerObjectTagInfoEXT.byteLength = 0x0;

VkDebugMarkerObjectTagInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  objectType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  object: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tagName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tagSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pTag: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDebugMarkerMarkerInfoEXT **/
function VkDebugMarkerMarkerInfoEXT(opts, byteOffset) {
  if (new.target !== VkDebugMarkerMarkerInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDebugMarkerMarkerInfoEXT, STRUCT_CACHE_VkDebugMarkerMarkerInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDebugMarkerMarkerInfoEXT, STRUCT_CACHE_VkDebugMarkerMarkerInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDebugMarkerMarkerInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._pMarkerName = null;
  this._color = [...Array(4)].fill(0x0);
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pMarkerName !== void 0) this.pMarkerName = opts.pMarkerName;
    if (opts.color !== void 0) this.color = opts.color;
    
  }
};

Object.defineProperties(VkDebugMarkerMarkerInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugMarkerMarkerInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugMarkerMarkerInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "pMarkerName": {
    get() {
    if (this._pMarkerName !== null) {
      let str = textDecoder.decode(this._pMarkerName);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._pMarkerName = buffer;
        return this.pMarkerName;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pMarkerName = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._pMarkerName), true);
    } else if (value === null) {
      this._pMarkerName = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkDebugMarkerMarkerInfoEXT.pMarkerName");
    }
    
    }
    },
  "color": {
    get() {
    return this._color;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._color = value;
    } else if (value === null) {
      this._color = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugMarkerMarkerInfoEXT.color': Expected 'Array float' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugMarkerMarkerInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._pMarkerName = null;
  if (this._color !== null) this._color.fill(0x0);
      else this._color = [...Array(4)].fill(0x0);
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pMarkerName !== void 0) this.pMarkerName = opts.pMarkerName;
    if (opts.color !== void 0) this.color = opts.color;
    
  }
};

VkDebugMarkerMarkerInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._color !== null) {
    let array = this._color;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkDebugMarkerMarkerInfoEXT.color'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkDebugMarkerMarkerInfoEXT.color[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryView.setFloat32(0x0 + (ii * 4), array[ii], true);
    };
  } else {
    this.memoryView.setFloat32(0x0, 0x0, true);
  }
  
  return true;
};

VkDebugMarkerMarkerInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDebugMarkerMarkerInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDebugMarkerMarkerInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pMarkerName = original.pMarkerName;
  if (original.color !== null) {
        copy.color = [...Array(original.color.length)].map((v, i) => {
          return original.color[i];
        });
      }
  
  return copy;
};

VkDebugMarkerMarkerInfoEXT.byteLength = 0x0;

VkDebugMarkerMarkerInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pMarkerName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  color: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDedicatedAllocationImageCreateInfoNV **/
function VkDedicatedAllocationImageCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkDedicatedAllocationImageCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDedicatedAllocationImageCreateInfoNV, STRUCT_CACHE_VkDedicatedAllocationImageCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDedicatedAllocationImageCreateInfoNV, STRUCT_CACHE_VkDedicatedAllocationImageCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDedicatedAllocationImageCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dedicatedAllocation !== void 0) this.dedicatedAllocation = opts.dedicatedAllocation;
    
  }
};

Object.defineProperties(VkDedicatedAllocationImageCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDedicatedAllocationImageCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDedicatedAllocationImageCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "dedicatedAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkDedicatedAllocationImageCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dedicatedAllocation !== void 0) this.dedicatedAllocation = opts.dedicatedAllocation;
    
  }
};

VkDedicatedAllocationImageCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDedicatedAllocationImageCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkDedicatedAllocationImageCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDedicatedAllocationImageCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.dedicatedAllocation = original.dedicatedAllocation;
  
  return copy;
};

VkDedicatedAllocationImageCreateInfoNV.byteLength = 0x0;

VkDedicatedAllocationImageCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dedicatedAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDedicatedAllocationBufferCreateInfoNV **/
function VkDedicatedAllocationBufferCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkDedicatedAllocationBufferCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDedicatedAllocationBufferCreateInfoNV, STRUCT_CACHE_VkDedicatedAllocationBufferCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDedicatedAllocationBufferCreateInfoNV, STRUCT_CACHE_VkDedicatedAllocationBufferCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDedicatedAllocationBufferCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dedicatedAllocation !== void 0) this.dedicatedAllocation = opts.dedicatedAllocation;
    
  }
};

Object.defineProperties(VkDedicatedAllocationBufferCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDedicatedAllocationBufferCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDedicatedAllocationBufferCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "dedicatedAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkDedicatedAllocationBufferCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dedicatedAllocation !== void 0) this.dedicatedAllocation = opts.dedicatedAllocation;
    
  }
};

VkDedicatedAllocationBufferCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDedicatedAllocationBufferCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkDedicatedAllocationBufferCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDedicatedAllocationBufferCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.dedicatedAllocation = original.dedicatedAllocation;
  
  return copy;
};

VkDedicatedAllocationBufferCreateInfoNV.byteLength = 0x0;

VkDedicatedAllocationBufferCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dedicatedAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDedicatedAllocationMemoryAllocateInfoNV **/
function VkDedicatedAllocationMemoryAllocateInfoNV(opts, byteOffset) {
  if (new.target !== VkDedicatedAllocationMemoryAllocateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDedicatedAllocationMemoryAllocateInfoNV, STRUCT_CACHE_VkDedicatedAllocationMemoryAllocateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDedicatedAllocationMemoryAllocateInfoNV, STRUCT_CACHE_VkDedicatedAllocationMemoryAllocateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDedicatedAllocationMemoryAllocateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkDedicatedAllocationMemoryAllocateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDedicatedAllocationMemoryAllocateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDedicatedAllocationMemoryAllocateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationMemoryAllocateInfoNV.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationMemoryAllocateInfoNV.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDedicatedAllocationMemoryAllocateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

VkDedicatedAllocationMemoryAllocateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDedicatedAllocationMemoryAllocateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkDedicatedAllocationMemoryAllocateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDedicatedAllocationMemoryAllocateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  
  return copy;
};

VkDedicatedAllocationMemoryAllocateInfoNV.byteLength = 0x0;

VkDedicatedAllocationMemoryAllocateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalImageFormatPropertiesNV **/
function VkExternalImageFormatPropertiesNV(opts, byteOffset) {
  if (new.target !== VkExternalImageFormatPropertiesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalImageFormatPropertiesNV, STRUCT_CACHE_VkExternalImageFormatPropertiesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalImageFormatPropertiesNV, STRUCT_CACHE_VkExternalImageFormatPropertiesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalImageFormatPropertiesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkExternalImageFormatPropertiesNV.prototype, {
  "imageFormatProperties": {
    get() {
    return this._imageFormatProperties;
    },
    },
  "externalMemoryFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkExternalImageFormatPropertiesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._imageFormatProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageFormatProperties.memoryBuffer) this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageFormatProperties.reset();
  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkExternalImageFormatPropertiesNV.prototype.flush = function flush() {
  
  return true;
};

VkExternalImageFormatPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalImageFormatPropertiesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalImageFormatPropertiesNV();
  if (original.imageFormatProperties !== null) {
        copy.imageFormatProperties = original.imageFormatProperties.constructor.createCopyFrom(original.imageFormatProperties);
      }
  copy.externalMemoryFeatures = original.externalMemoryFeatures;
  copy.exportFromImportedHandleTypes = original.exportFromImportedHandleTypes;
  copy.compatibleHandleTypes = original.compatibleHandleTypes;
  
  return copy;
};

VkExternalImageFormatPropertiesNV.byteLength = 0x0;

VkExternalImageFormatPropertiesNV.memoryLayout = {
  imageFormatProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  externalMemoryFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compatibleHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalMemoryImageCreateInfoNV **/
function VkExternalMemoryImageCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkExternalMemoryImageCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalMemoryImageCreateInfoNV, STRUCT_CACHE_VkExternalMemoryImageCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalMemoryImageCreateInfoNV, STRUCT_CACHE_VkExternalMemoryImageCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalMemoryImageCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExternalMemoryImageCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalMemoryImageCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalMemoryImageCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalMemoryImageCreateInfoNV.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExternalMemoryImageCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExternalMemoryImageCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryImageCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkExternalMemoryImageCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalMemoryImageCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExternalMemoryImageCreateInfoNV.byteLength = 0x0;

VkExternalMemoryImageCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportMemoryAllocateInfoNV **/
function VkExportMemoryAllocateInfoNV(opts, byteOffset) {
  if (new.target !== VkExportMemoryAllocateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportMemoryAllocateInfoNV, STRUCT_CACHE_VkExportMemoryAllocateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportMemoryAllocateInfoNV, STRUCT_CACHE_VkExportMemoryAllocateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportMemoryAllocateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportMemoryAllocateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportMemoryAllocateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportMemoryAllocateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportMemoryAllocateInfoNV.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExportMemoryAllocateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExportMemoryAllocateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryAllocateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportMemoryAllocateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportMemoryAllocateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExportMemoryAllocateInfoNV.byteLength = 0x0;

VkExportMemoryAllocateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImportMemoryWin32HandleInfoNV **/
function VkImportMemoryWin32HandleInfoNV(opts, byteOffset) {
  if (new.target !== VkImportMemoryWin32HandleInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImportMemoryWin32HandleInfoNV, STRUCT_CACHE_VkImportMemoryWin32HandleInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImportMemoryWin32HandleInfoNV, STRUCT_CACHE_VkImportMemoryWin32HandleInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImportMemoryWin32HandleInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    
  }
};

Object.defineProperties(VkImportMemoryWin32HandleInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportMemoryWin32HandleInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportMemoryWin32HandleInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportMemoryWin32HandleInfoNV.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "handle": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkImportMemoryWin32HandleInfoNV.handle")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  
});

VkImportMemoryWin32HandleInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    
  }
};

VkImportMemoryWin32HandleInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportMemoryWin32HandleInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkImportMemoryWin32HandleInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImportMemoryWin32HandleInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleType = original.handleType;
  copy.handle = original.handle;
  
  return copy;
};

VkImportMemoryWin32HandleInfoNV.byteLength = 0x0;

VkImportMemoryWin32HandleInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportMemoryWin32HandleInfoNV **/
function VkExportMemoryWin32HandleInfoNV(opts, byteOffset) {
  if (new.target !== VkExportMemoryWin32HandleInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportMemoryWin32HandleInfoNV, STRUCT_CACHE_VkExportMemoryWin32HandleInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportMemoryWin32HandleInfoNV, STRUCT_CACHE_VkExportMemoryWin32HandleInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportMemoryWin32HandleInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pAttributes !== void 0) this.pAttributes = opts.pAttributes;
    if (opts.dwAccess !== void 0) this.dwAccess = opts.dwAccess;
    
  }
};

Object.defineProperties(VkExportMemoryWin32HandleInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportMemoryWin32HandleInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportMemoryWin32HandleInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "pAttributes": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkExportMemoryWin32HandleInfoNV.pAttributes")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "dwAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportMemoryWin32HandleInfoNV.dwAccess");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkExportMemoryWin32HandleInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pAttributes !== void 0) this.pAttributes = opts.pAttributes;
    if (opts.dwAccess !== void 0) this.dwAccess = opts.dwAccess;
    
  }
};

VkExportMemoryWin32HandleInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryWin32HandleInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportMemoryWin32HandleInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportMemoryWin32HandleInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pAttributes = original.pAttributes;
  copy.dwAccess = original.dwAccess;
  
  return copy;
};

VkExportMemoryWin32HandleInfoNV.byteLength = 0x0;

VkExportMemoryWin32HandleInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttributes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dwAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkWin32KeyedMutexAcquireReleaseInfoNV **/
function VkWin32KeyedMutexAcquireReleaseInfoNV(opts, byteOffset) {
  if (new.target !== VkWin32KeyedMutexAcquireReleaseInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkWin32KeyedMutexAcquireReleaseInfoNV, STRUCT_CACHE_VkWin32KeyedMutexAcquireReleaseInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkWin32KeyedMutexAcquireReleaseInfoNV, STRUCT_CACHE_VkWin32KeyedMutexAcquireReleaseInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkWin32KeyedMutexAcquireReleaseInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAcquireSyncs = null;
  this._pAcquireSyncsNative = null;
  this._pAcquireKeys = null;
  this._pAcquireTimeoutMilliseconds = null;
  
  this._pReleaseSyncs = null;
  this._pReleaseSyncsNative = null;
  this._pReleaseKeys = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.acquireCount !== void 0) this.acquireCount = opts.acquireCount;
    if (opts.pAcquireSyncs !== void 0) this.pAcquireSyncs = opts.pAcquireSyncs;
    if (opts.pAcquireKeys !== void 0) this.pAcquireKeys = opts.pAcquireKeys;
    if (opts.pAcquireTimeoutMilliseconds !== void 0) this.pAcquireTimeoutMilliseconds = opts.pAcquireTimeoutMilliseconds;
    if (opts.releaseCount !== void 0) this.releaseCount = opts.releaseCount;
    if (opts.pReleaseSyncs !== void 0) this.pReleaseSyncs = opts.pReleaseSyncs;
    if (opts.pReleaseKeys !== void 0) this.pReleaseKeys = opts.pReleaseKeys;
    
  }
};

Object.defineProperties(VkWin32KeyedMutexAcquireReleaseInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWin32KeyedMutexAcquireReleaseInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "acquireCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.acquireCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAcquireSyncs": {
    get() {
    if (this._pAcquireSyncs === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.acquireCount, VkDeviceMemory);
      this._pAcquireSyncs = array;
      return this.pAcquireSyncs;
    } else {
      return this._pAcquireSyncs;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAcquireSyncs = value;
    } else if (value === null) {
      this._pAcquireSyncs = null;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs': Expected 'Array VkDeviceMemory' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pAcquireKeys": {
    get() {
    return this._pAcquireKeys;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pAcquireKeys = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pAcquireKeys = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireKeys': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pAcquireTimeoutMilliseconds": {
    get() {
    return this._pAcquireTimeoutMilliseconds;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pAcquireTimeoutMilliseconds = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pAcquireTimeoutMilliseconds = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireTimeoutMilliseconds': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "releaseCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.releaseCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pReleaseSyncs": {
    get() {
    if (this._pReleaseSyncs === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.releaseCount, VkDeviceMemory);
      this._pReleaseSyncs = array;
      return this.pReleaseSyncs;
    } else {
      return this._pReleaseSyncs;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pReleaseSyncs = value;
    } else if (value === null) {
      this._pReleaseSyncs = null;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs': Expected 'Array VkDeviceMemory' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pReleaseKeys": {
    get() {
    return this._pReleaseKeys;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pReleaseKeys = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pReleaseKeys = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseKeys': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkWin32KeyedMutexAcquireReleaseInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAcquireSyncs = null;
  this._pAcquireSyncsNative = null;
  this._pAcquireKeys = null;
  this._pAcquireTimeoutMilliseconds = null;
  
  this._pReleaseSyncs = null;
  this._pReleaseSyncsNative = null;
  this._pReleaseKeys = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.acquireCount !== void 0) this.acquireCount = opts.acquireCount;
    if (opts.pAcquireSyncs !== void 0) this.pAcquireSyncs = opts.pAcquireSyncs;
    if (opts.pAcquireKeys !== void 0) this.pAcquireKeys = opts.pAcquireKeys;
    if (opts.pAcquireTimeoutMilliseconds !== void 0) this.pAcquireTimeoutMilliseconds = opts.pAcquireTimeoutMilliseconds;
    if (opts.releaseCount !== void 0) this.releaseCount = opts.releaseCount;
    if (opts.pReleaseSyncs !== void 0) this.pReleaseSyncs = opts.pReleaseSyncs;
    if (opts.pReleaseKeys !== void 0) this.pReleaseKeys = opts.pReleaseKeys;
    
  }
};

VkWin32KeyedMutexAcquireReleaseInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAcquireSyncs !== null) {
    let array = this._pAcquireSyncs;
    
    if (array.length !== this.acquireCount) {
      throw new RangeError("Invalid array length, expected length of 'acquireCount' for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDeviceMemory)) {
        throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs[" + ii + "]': Expected 'VkDeviceMemory' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAcquireSyncsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAcquireSyncsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pReleaseSyncs !== null) {
    let array = this._pReleaseSyncs;
    
    if (array.length !== this.releaseCount) {
      throw new RangeError("Invalid array length, expected length of 'releaseCount' for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDeviceMemory)) {
        throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs[" + ii + "]': Expected 'VkDeviceMemory' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pReleaseSyncsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pReleaseSyncsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkWin32KeyedMutexAcquireReleaseInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkWin32KeyedMutexAcquireReleaseInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkWin32KeyedMutexAcquireReleaseInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.acquireCount = original.acquireCount;
  if (original.pAcquireSyncs !== null) {
        copy.pAcquireSyncs = [...Array(original.pAcquireSyncs.length)].map((v, i) => {
          return original.pAcquireSyncs[i].constructor.createCopyFrom(original.pAcquireSyncs[i]);
        });
      }
  if (original.pAcquireKeys !== null) {
        copy.pAcquireKeys = new BigUint64Array(original.pAcquireKeys);
      }
  if (original.pAcquireTimeoutMilliseconds !== null) {
        copy.pAcquireTimeoutMilliseconds = new Uint32Array(original.pAcquireTimeoutMilliseconds);
      }
  copy.releaseCount = original.releaseCount;
  if (original.pReleaseSyncs !== null) {
        copy.pReleaseSyncs = [...Array(original.pReleaseSyncs.length)].map((v, i) => {
          return original.pReleaseSyncs[i].constructor.createCopyFrom(original.pReleaseSyncs[i]);
        });
      }
  if (original.pReleaseKeys !== null) {
        copy.pReleaseKeys = new BigUint64Array(original.pReleaseKeys);
      }
  
  return copy;
};

VkWin32KeyedMutexAcquireReleaseInfoNV.byteLength = 0x0;

VkWin32KeyedMutexAcquireReleaseInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  acquireCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAcquireSyncs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAcquireKeys: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAcquireTimeoutMilliseconds: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  releaseCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pReleaseSyncs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pReleaseKeys: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV **/
function VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceGeneratedCommands !== void 0) this.deviceGeneratedCommands = opts.deviceGeneratedCommands;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "deviceGeneratedCommands": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceGeneratedCommands !== void 0) this.deviceGeneratedCommands = opts.deviceGeneratedCommands;
    
  }
};

VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceGeneratedCommands = original.deviceGeneratedCommands;
  
  return copy;
};

VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceGeneratedCommands: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDevicePrivateDataCreateInfoEXT **/
function VkDevicePrivateDataCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkDevicePrivateDataCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDevicePrivateDataCreateInfoEXT, STRUCT_CACHE_VkDevicePrivateDataCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDevicePrivateDataCreateInfoEXT, STRUCT_CACHE_VkDevicePrivateDataCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDevicePrivateDataCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.privateDataSlotRequestCount !== void 0) this.privateDataSlotRequestCount = opts.privateDataSlotRequestCount;
    
  }
};

Object.defineProperties(VkDevicePrivateDataCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDevicePrivateDataCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDevicePrivateDataCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "privateDataSlotRequestCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDevicePrivateDataCreateInfoEXT.privateDataSlotRequestCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDevicePrivateDataCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.privateDataSlotRequestCount !== void 0) this.privateDataSlotRequestCount = opts.privateDataSlotRequestCount;
    
  }
};

VkDevicePrivateDataCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDevicePrivateDataCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDevicePrivateDataCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDevicePrivateDataCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.privateDataSlotRequestCount = original.privateDataSlotRequestCount;
  
  return copy;
};

VkDevicePrivateDataCreateInfoEXT.byteLength = 0x0;

VkDevicePrivateDataCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  privateDataSlotRequestCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPrivateDataSlotCreateInfoEXT **/
function VkPrivateDataSlotCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPrivateDataSlotCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPrivateDataSlotCreateInfoEXT, STRUCT_CACHE_VkPrivateDataSlotCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPrivateDataSlotCreateInfoEXT, STRUCT_CACHE_VkPrivateDataSlotCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPrivateDataSlotCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkPrivateDataSlotCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPrivateDataSlotCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPrivateDataSlotCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPrivateDataSlotCreateInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPrivateDataSlotCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkPrivateDataSlotCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPrivateDataSlotCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPrivateDataSlotCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPrivateDataSlotCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  
  return copy;
};

VkPrivateDataSlotCreateInfoEXT.byteLength = 0x0;

VkPrivateDataSlotCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevicePrivateDataFeaturesEXT **/
function VkPhysicalDevicePrivateDataFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDevicePrivateDataFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevicePrivateDataFeaturesEXT, STRUCT_CACHE_VkPhysicalDevicePrivateDataFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevicePrivateDataFeaturesEXT, STRUCT_CACHE_VkPhysicalDevicePrivateDataFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevicePrivateDataFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.privateData !== void 0) this.privateData = opts.privateData;
    
  }
};

Object.defineProperties(VkPhysicalDevicePrivateDataFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevicePrivateDataFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePrivateDataFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "privateData": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDevicePrivateDataFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.privateData !== void 0) this.privateData = opts.privateData;
    
  }
};

VkPhysicalDevicePrivateDataFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePrivateDataFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDevicePrivateDataFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevicePrivateDataFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.privateData = original.privateData;
  
  return copy;
};

VkPhysicalDevicePrivateDataFeaturesEXT.byteLength = 0x0;

VkPhysicalDevicePrivateDataFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  privateData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV **/
function VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "maxGraphicsShaderGroupCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxIndirectSequenceCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxIndirectCommandsTokenCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxIndirectCommandsStreamCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxIndirectCommandsTokenOffset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxIndirectCommandsStreamStride": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "minSequencesCountBufferOffsetAlignment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "minSequencesIndexBufferOffsetAlignment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "minIndirectCommandsBufferOffsetAlignment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxGraphicsShaderGroupCount = original.maxGraphicsShaderGroupCount;
  copy.maxIndirectSequenceCount = original.maxIndirectSequenceCount;
  copy.maxIndirectCommandsTokenCount = original.maxIndirectCommandsTokenCount;
  copy.maxIndirectCommandsStreamCount = original.maxIndirectCommandsStreamCount;
  copy.maxIndirectCommandsTokenOffset = original.maxIndirectCommandsTokenOffset;
  copy.maxIndirectCommandsStreamStride = original.maxIndirectCommandsStreamStride;
  copy.minSequencesCountBufferOffsetAlignment = original.minSequencesCountBufferOffsetAlignment;
  copy.minSequencesIndexBufferOffsetAlignment = original.minSequencesIndexBufferOffsetAlignment;
  copy.minIndirectCommandsBufferOffsetAlignment = original.minIndirectCommandsBufferOffsetAlignment;
  
  return copy;
};

VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.byteLength = 0x0;

VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxGraphicsShaderGroupCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxIndirectSequenceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxIndirectCommandsTokenCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxIndirectCommandsStreamCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxIndirectCommandsTokenOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxIndirectCommandsStreamStride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minSequencesCountBufferOffsetAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minSequencesIndexBufferOffsetAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minIndirectCommandsBufferOffsetAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkGraphicsShaderGroupCreateInfoNV **/
function VkGraphicsShaderGroupCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkGraphicsShaderGroupCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkGraphicsShaderGroupCreateInfoNV, STRUCT_CACHE_VkGraphicsShaderGroupCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkGraphicsShaderGroupCreateInfoNV, STRUCT_CACHE_VkGraphicsShaderGroupCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkGraphicsShaderGroupCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pStages = null;
  this._pStagesNative = null;
  this._pVertexInputState = null;
  this._pTessellationState = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
    if (opts.pStages !== void 0) this.pStages = opts.pStages;
    if (opts.pVertexInputState !== void 0) this.pVertexInputState = opts.pVertexInputState;
    if (opts.pTessellationState !== void 0) this.pTessellationState = opts.pTessellationState;
    
  }
};

Object.defineProperties(VkGraphicsShaderGroupCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGraphicsShaderGroupCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkGraphicsShaderGroupCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "stageCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGraphicsShaderGroupCreateInfoNV.stageCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pStages": {
    get() {
    if (this._pStages === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.stageCount, VkPipelineShaderStageCreateInfo);
      this._pStages = array;
      return this.pStages;
    } else {
      return this._pStages;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pStages = value;
    } else if (value === null) {
      this._pStages = null;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsShaderGroupCreateInfoNV.pStages': Expected 'Array VkPipelineShaderStageCreateInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pVertexInputState": {
    get() {
    if (this._pVertexInputState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineVertexInputStateCreateInfo.byteLength));
      this._pVertexInputState = new VkPipelineVertexInputStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pVertexInputState.memoryAddress, true);
      return this.pVertexInputState;
    } else {
      return this._pVertexInputState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineVertexInputStateCreateInfo) {
      value.flush();
      this._pVertexInputState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pVertexInputState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsShaderGroupCreateInfoNV.pVertexInputState': Expected 'VkPipelineVertexInputStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pTessellationState": {
    get() {
    if (this._pTessellationState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineTessellationStateCreateInfo.byteLength));
      this._pTessellationState = new VkPipelineTessellationStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pTessellationState.memoryAddress, true);
      return this.pTessellationState;
    } else {
      return this._pTessellationState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineTessellationStateCreateInfo) {
      value.flush();
      this._pTessellationState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pTessellationState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsShaderGroupCreateInfoNV.pTessellationState': Expected 'VkPipelineTessellationStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkGraphicsShaderGroupCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pStages = null;
  this._pStagesNative = null;
  this._pVertexInputState = null;
  this._pTessellationState = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
    if (opts.pStages !== void 0) this.pStages = opts.pStages;
    if (opts.pVertexInputState !== void 0) this.pVertexInputState = opts.pVertexInputState;
    if (opts.pTessellationState !== void 0) this.pTessellationState = opts.pTessellationState;
    
  }
};

VkGraphicsShaderGroupCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pStages !== null) {
    let array = this._pStages;
    
    if (array.length !== this.stageCount) {
      throw new RangeError("Invalid array length, expected length of 'stageCount' for 'VkGraphicsShaderGroupCreateInfoNV.pStages'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipelineShaderStageCreateInfo)) {
        throw new TypeError("Invalid type for 'VkGraphicsShaderGroupCreateInfoNV.pStages[" + ii + "]': Expected 'VkPipelineShaderStageCreateInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pStagesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pStagesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkGraphicsShaderGroupCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkGraphicsShaderGroupCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkGraphicsShaderGroupCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.stageCount = original.stageCount;
  if (original.pStages !== null) {
        copy.pStages = [...Array(original.pStages.length)].map((v, i) => {
          return original.pStages[i].constructor.createCopyFrom(original.pStages[i]);
        });
      }
  if (original.pVertexInputState !== null) {
        copy.pVertexInputState = original.pVertexInputState.constructor.createCopyFrom(original.pVertexInputState);
      }
  if (original.pTessellationState !== null) {
        copy.pTessellationState = original.pTessellationState.constructor.createCopyFrom(original.pTessellationState);
      }
  
  return copy;
};

VkGraphicsShaderGroupCreateInfoNV.byteLength = 0x0;

VkGraphicsShaderGroupCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stageCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pStages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pVertexInputState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pTessellationState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkGraphicsPipelineShaderGroupsCreateInfoNV **/
function VkGraphicsPipelineShaderGroupsCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkGraphicsPipelineShaderGroupsCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkGraphicsPipelineShaderGroupsCreateInfoNV, STRUCT_CACHE_VkGraphicsPipelineShaderGroupsCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkGraphicsPipelineShaderGroupsCreateInfoNV, STRUCT_CACHE_VkGraphicsPipelineShaderGroupsCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkGraphicsPipelineShaderGroupsCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pGroups = null;
  this._pGroupsNative = null;
  
  this._pPipelines = null;
  this._pPipelinesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.groupCount !== void 0) this.groupCount = opts.groupCount;
    if (opts.pGroups !== void 0) this.pGroups = opts.pGroups;
    if (opts.pipelineCount !== void 0) this.pipelineCount = opts.pipelineCount;
    if (opts.pPipelines !== void 0) this.pPipelines = opts.pPipelines;
    
  }
};

Object.defineProperties(VkGraphicsPipelineShaderGroupsCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGraphicsPipelineShaderGroupsCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkGraphicsPipelineShaderGroupsCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "groupCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGraphicsPipelineShaderGroupsCreateInfoNV.groupCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pGroups": {
    get() {
    if (this._pGroups === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.groupCount, VkGraphicsShaderGroupCreateInfoNV);
      this._pGroups = array;
      return this.pGroups;
    } else {
      return this._pGroups;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pGroups = value;
    } else if (value === null) {
      this._pGroups = null;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineShaderGroupsCreateInfoNV.pGroups': Expected 'Array VkGraphicsShaderGroupCreateInfoNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pipelineCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGraphicsPipelineShaderGroupsCreateInfoNV.pipelineCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPipelines": {
    get() {
    if (this._pPipelines === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.pipelineCount, VkPipeline);
      this._pPipelines = array;
      return this.pPipelines;
    } else {
      return this._pPipelines;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPipelines = value;
    } else if (value === null) {
      this._pPipelines = null;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineShaderGroupsCreateInfoNV.pPipelines': Expected 'Array VkPipeline' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkGraphicsPipelineShaderGroupsCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pGroups = null;
  this._pGroupsNative = null;
  
  this._pPipelines = null;
  this._pPipelinesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.groupCount !== void 0) this.groupCount = opts.groupCount;
    if (opts.pGroups !== void 0) this.pGroups = opts.pGroups;
    if (opts.pipelineCount !== void 0) this.pipelineCount = opts.pipelineCount;
    if (opts.pPipelines !== void 0) this.pPipelines = opts.pPipelines;
    
  }
};

VkGraphicsPipelineShaderGroupsCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pGroups !== null) {
    let array = this._pGroups;
    
    if (array.length !== this.groupCount) {
      throw new RangeError("Invalid array length, expected length of 'groupCount' for 'VkGraphicsPipelineShaderGroupsCreateInfoNV.pGroups'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkGraphicsShaderGroupCreateInfoNV)) {
        throw new TypeError("Invalid type for 'VkGraphicsPipelineShaderGroupsCreateInfoNV.pGroups[" + ii + "]': Expected 'VkGraphicsShaderGroupCreateInfoNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pGroupsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pGroupsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pPipelines !== null) {
    let array = this._pPipelines;
    
    if (array.length !== this.pipelineCount) {
      throw new RangeError("Invalid array length, expected length of 'pipelineCount' for 'VkGraphicsPipelineShaderGroupsCreateInfoNV.pPipelines'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipeline)) {
        throw new TypeError("Invalid type for 'VkGraphicsPipelineShaderGroupsCreateInfoNV.pPipelines[" + ii + "]': Expected 'VkPipeline' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPipelinesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pPipelinesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkGraphicsPipelineShaderGroupsCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkGraphicsPipelineShaderGroupsCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkGraphicsPipelineShaderGroupsCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.groupCount = original.groupCount;
  if (original.pGroups !== null) {
        copy.pGroups = [...Array(original.pGroups.length)].map((v, i) => {
          return original.pGroups[i].constructor.createCopyFrom(original.pGroups[i]);
        });
      }
  copy.pipelineCount = original.pipelineCount;
  if (original.pPipelines !== null) {
        copy.pPipelines = [...Array(original.pPipelines.length)].map((v, i) => {
          return original.pPipelines[i].constructor.createCopyFrom(original.pPipelines[i]);
        });
      }
  
  return copy;
};

VkGraphicsPipelineShaderGroupsCreateInfoNV.byteLength = 0x0;

VkGraphicsPipelineShaderGroupsCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  groupCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pGroups: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPipelines: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindShaderGroupIndirectCommandNV **/
function VkBindShaderGroupIndirectCommandNV(opts, byteOffset) {
  if (new.target !== VkBindShaderGroupIndirectCommandNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindShaderGroupIndirectCommandNV, STRUCT_CACHE_VkBindShaderGroupIndirectCommandNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindShaderGroupIndirectCommandNV, STRUCT_CACHE_VkBindShaderGroupIndirectCommandNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindShaderGroupIndirectCommandNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  if (typeof opts === "object") {
    if (opts.groupIndex !== void 0) this.groupIndex = opts.groupIndex;
    
  }
};

Object.defineProperties(VkBindShaderGroupIndirectCommandNV.prototype, {
  "groupIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindShaderGroupIndirectCommandNV.groupIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkBindShaderGroupIndirectCommandNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  if (typeof opts === "object") {
    if (opts.groupIndex !== void 0) this.groupIndex = opts.groupIndex;
    
  }
};

VkBindShaderGroupIndirectCommandNV.prototype.flush = function flush() {
  
  return true;
};

VkBindShaderGroupIndirectCommandNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindShaderGroupIndirectCommandNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindShaderGroupIndirectCommandNV();
  copy.groupIndex = original.groupIndex;
  
  return copy;
};

VkBindShaderGroupIndirectCommandNV.byteLength = 0x0;

VkBindShaderGroupIndirectCommandNV.memoryLayout = {
  groupIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindIndexBufferIndirectCommandNV **/
function VkBindIndexBufferIndirectCommandNV(opts, byteOffset) {
  if (new.target !== VkBindIndexBufferIndirectCommandNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindIndexBufferIndirectCommandNV, STRUCT_CACHE_VkBindIndexBufferIndirectCommandNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindIndexBufferIndirectCommandNV, STRUCT_CACHE_VkBindIndexBufferIndirectCommandNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindIndexBufferIndirectCommandNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.bufferAddress !== void 0) this.bufferAddress = opts.bufferAddress;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.indexType !== void 0) this.indexType = opts.indexType;
    
  }
};

Object.defineProperties(VkBindIndexBufferIndirectCommandNV.prototype, {
  "bufferAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBindIndexBufferIndirectCommandNV.bufferAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindIndexBufferIndirectCommandNV.size");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "indexType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindIndexBufferIndirectCommandNV.indexType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkBindIndexBufferIndirectCommandNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.bufferAddress !== void 0) this.bufferAddress = opts.bufferAddress;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.indexType !== void 0) this.indexType = opts.indexType;
    
  }
};

VkBindIndexBufferIndirectCommandNV.prototype.flush = function flush() {
  
  return true;
};

VkBindIndexBufferIndirectCommandNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindIndexBufferIndirectCommandNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindIndexBufferIndirectCommandNV();
  copy.bufferAddress = original.bufferAddress;
  copy.size = original.size;
  copy.indexType = original.indexType;
  
  return copy;
};

VkBindIndexBufferIndirectCommandNV.byteLength = 0x0;

VkBindIndexBufferIndirectCommandNV.memoryLayout = {
  bufferAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indexType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindVertexBufferIndirectCommandNV **/
function VkBindVertexBufferIndirectCommandNV(opts, byteOffset) {
  if (new.target !== VkBindVertexBufferIndirectCommandNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindVertexBufferIndirectCommandNV, STRUCT_CACHE_VkBindVertexBufferIndirectCommandNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindVertexBufferIndirectCommandNV, STRUCT_CACHE_VkBindVertexBufferIndirectCommandNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindVertexBufferIndirectCommandNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.bufferAddress !== void 0) this.bufferAddress = opts.bufferAddress;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.stride !== void 0) this.stride = opts.stride;
    
  }
};

Object.defineProperties(VkBindVertexBufferIndirectCommandNV.prototype, {
  "bufferAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBindVertexBufferIndirectCommandNV.bufferAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindVertexBufferIndirectCommandNV.size");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "stride": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindVertexBufferIndirectCommandNV.stride");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkBindVertexBufferIndirectCommandNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.bufferAddress !== void 0) this.bufferAddress = opts.bufferAddress;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.stride !== void 0) this.stride = opts.stride;
    
  }
};

VkBindVertexBufferIndirectCommandNV.prototype.flush = function flush() {
  
  return true;
};

VkBindVertexBufferIndirectCommandNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindVertexBufferIndirectCommandNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindVertexBufferIndirectCommandNV();
  copy.bufferAddress = original.bufferAddress;
  copy.size = original.size;
  copy.stride = original.stride;
  
  return copy;
};

VkBindVertexBufferIndirectCommandNV.byteLength = 0x0;

VkBindVertexBufferIndirectCommandNV.memoryLayout = {
  bufferAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSetStateFlagsIndirectCommandNV **/
function VkSetStateFlagsIndirectCommandNV(opts, byteOffset) {
  if (new.target !== VkSetStateFlagsIndirectCommandNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSetStateFlagsIndirectCommandNV, STRUCT_CACHE_VkSetStateFlagsIndirectCommandNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSetStateFlagsIndirectCommandNV, STRUCT_CACHE_VkSetStateFlagsIndirectCommandNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSetStateFlagsIndirectCommandNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  if (typeof opts === "object") {
    if (opts.data !== void 0) this.data = opts.data;
    
  }
};

Object.defineProperties(VkSetStateFlagsIndirectCommandNV.prototype, {
  "data": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSetStateFlagsIndirectCommandNV.data");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkSetStateFlagsIndirectCommandNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  if (typeof opts === "object") {
    if (opts.data !== void 0) this.data = opts.data;
    
  }
};

VkSetStateFlagsIndirectCommandNV.prototype.flush = function flush() {
  
  return true;
};

VkSetStateFlagsIndirectCommandNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkSetStateFlagsIndirectCommandNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSetStateFlagsIndirectCommandNV();
  copy.data = original.data;
  
  return copy;
};

VkSetStateFlagsIndirectCommandNV.byteLength = 0x0;

VkSetStateFlagsIndirectCommandNV.memoryLayout = {
  data: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkIndirectCommandsStreamNV **/
function VkIndirectCommandsStreamNV(opts, byteOffset) {
  if (new.target !== VkIndirectCommandsStreamNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkIndirectCommandsStreamNV, STRUCT_CACHE_VkIndirectCommandsStreamNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkIndirectCommandsStreamNV, STRUCT_CACHE_VkIndirectCommandsStreamNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkIndirectCommandsStreamNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._buffer = null;
  
  
  if (typeof opts === "object") {
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    
  }
};

Object.defineProperties(VkIndirectCommandsStreamNV.prototype, {
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkIndirectCommandsStreamNV.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkIndirectCommandsStreamNV.offset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkIndirectCommandsStreamNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  this._buffer = null;
  
  
  if (typeof opts === "object") {
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    
  }
};

VkIndirectCommandsStreamNV.prototype.flush = function flush() {
  
  return true;
};

VkIndirectCommandsStreamNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkIndirectCommandsStreamNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkIndirectCommandsStreamNV();
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  copy.offset = original.offset;
  
  return copy;
};

VkIndirectCommandsStreamNV.byteLength = 0x0;

VkIndirectCommandsStreamNV.memoryLayout = {
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkIndirectCommandsLayoutTokenNV **/
function VkIndirectCommandsLayoutTokenNV(opts, byteOffset) {
  if (new.target !== VkIndirectCommandsLayoutTokenNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkIndirectCommandsLayoutTokenNV, STRUCT_CACHE_VkIndirectCommandsLayoutTokenNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkIndirectCommandsLayoutTokenNV, STRUCT_CACHE_VkIndirectCommandsLayoutTokenNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkIndirectCommandsLayoutTokenNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this._pushconstantPipelineLayout = null;
  
  
  
  
  
  this._pIndexTypes = null;
  this._pIndexTypeValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.tokenType !== void 0) this.tokenType = opts.tokenType;
    if (opts.stream !== void 0) this.stream = opts.stream;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.vertexBindingUnit !== void 0) this.vertexBindingUnit = opts.vertexBindingUnit;
    if (opts.vertexDynamicStride !== void 0) this.vertexDynamicStride = opts.vertexDynamicStride;
    if (opts.pushconstantPipelineLayout !== void 0) this.pushconstantPipelineLayout = opts.pushconstantPipelineLayout;
    if (opts.pushconstantShaderStageFlags !== void 0) this.pushconstantShaderStageFlags = opts.pushconstantShaderStageFlags;
    if (opts.pushconstantOffset !== void 0) this.pushconstantOffset = opts.pushconstantOffset;
    if (opts.pushconstantSize !== void 0) this.pushconstantSize = opts.pushconstantSize;
    if (opts.indirectStateFlags !== void 0) this.indirectStateFlags = opts.indirectStateFlags;
    if (opts.indexTypeCount !== void 0) this.indexTypeCount = opts.indexTypeCount;
    if (opts.pIndexTypes !== void 0) this.pIndexTypes = opts.pIndexTypes;
    if (opts.pIndexTypeValues !== void 0) this.pIndexTypeValues = opts.pIndexTypeValues;
    
  }
};

Object.defineProperties(VkIndirectCommandsLayoutTokenNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutTokenNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkIndirectCommandsLayoutTokenNV.pNext' isn't allowed to be filled");
    }
    },
  "tokenType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutTokenNV.tokenType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stream": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutTokenNV.stream");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "offset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutTokenNV.offset");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "vertexBindingUnit": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutTokenNV.vertexBindingUnit");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "vertexDynamicStride": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "pushconstantPipelineLayout": {
    get() {
    return this._pushconstantPipelineLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pushconstantPipelineLayout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._pushconstantPipelineLayout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNV.pushconstantPipelineLayout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pushconstantShaderStageFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutTokenNV.pushconstantShaderStageFlags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pushconstantOffset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutTokenNV.pushconstantOffset");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pushconstantSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutTokenNV.pushconstantSize");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "indirectStateFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutTokenNV.indirectStateFlags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "indexTypeCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutTokenNV.indexTypeCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pIndexTypes": {
    get() {
    return this._pIndexTypes;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pIndexTypes = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pIndexTypes = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNV.pIndexTypes': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pIndexTypeValues": {
    get() {
    return this._pIndexTypeValues;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pIndexTypeValues = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pIndexTypeValues = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNV.pIndexTypeValues': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkIndirectCommandsLayoutTokenNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this._pushconstantPipelineLayout = null;
  
  
  
  
  
  this._pIndexTypes = null;
  this._pIndexTypeValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.tokenType !== void 0) this.tokenType = opts.tokenType;
    if (opts.stream !== void 0) this.stream = opts.stream;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.vertexBindingUnit !== void 0) this.vertexBindingUnit = opts.vertexBindingUnit;
    if (opts.vertexDynamicStride !== void 0) this.vertexDynamicStride = opts.vertexDynamicStride;
    if (opts.pushconstantPipelineLayout !== void 0) this.pushconstantPipelineLayout = opts.pushconstantPipelineLayout;
    if (opts.pushconstantShaderStageFlags !== void 0) this.pushconstantShaderStageFlags = opts.pushconstantShaderStageFlags;
    if (opts.pushconstantOffset !== void 0) this.pushconstantOffset = opts.pushconstantOffset;
    if (opts.pushconstantSize !== void 0) this.pushconstantSize = opts.pushconstantSize;
    if (opts.indirectStateFlags !== void 0) this.indirectStateFlags = opts.indirectStateFlags;
    if (opts.indexTypeCount !== void 0) this.indexTypeCount = opts.indexTypeCount;
    if (opts.pIndexTypes !== void 0) this.pIndexTypes = opts.pIndexTypes;
    if (opts.pIndexTypeValues !== void 0) this.pIndexTypeValues = opts.pIndexTypeValues;
    
  }
};

VkIndirectCommandsLayoutTokenNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkIndirectCommandsLayoutTokenNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkIndirectCommandsLayoutTokenNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkIndirectCommandsLayoutTokenNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.tokenType = original.tokenType;
  copy.stream = original.stream;
  copy.offset = original.offset;
  copy.vertexBindingUnit = original.vertexBindingUnit;
  copy.vertexDynamicStride = original.vertexDynamicStride;
  if (original.pushconstantPipelineLayout !== null) {
        copy.pushconstantPipelineLayout = original.pushconstantPipelineLayout.constructor.createCopyFrom(original.pushconstantPipelineLayout);
      }
  copy.pushconstantShaderStageFlags = original.pushconstantShaderStageFlags;
  copy.pushconstantOffset = original.pushconstantOffset;
  copy.pushconstantSize = original.pushconstantSize;
  copy.indirectStateFlags = original.indirectStateFlags;
  copy.indexTypeCount = original.indexTypeCount;
  if (original.pIndexTypes !== null) {
        copy.pIndexTypes = new Int32Array(original.pIndexTypes);
      }
  if (original.pIndexTypeValues !== null) {
        copy.pIndexTypeValues = new Uint32Array(original.pIndexTypeValues);
      }
  
  return copy;
};

VkIndirectCommandsLayoutTokenNV.byteLength = 0x0;

VkIndirectCommandsLayoutTokenNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tokenType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stream: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexBindingUnit: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexDynamicStride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pushconstantPipelineLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pushconstantShaderStageFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pushconstantOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pushconstantSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indirectStateFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indexTypeCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pIndexTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pIndexTypeValues: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkIndirectCommandsLayoutCreateInfoNV **/
function VkIndirectCommandsLayoutCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkIndirectCommandsLayoutCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkIndirectCommandsLayoutCreateInfoNV, STRUCT_CACHE_VkIndirectCommandsLayoutCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkIndirectCommandsLayoutCreateInfoNV, STRUCT_CACHE_VkIndirectCommandsLayoutCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkIndirectCommandsLayoutCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._pTokens = null;
  this._pTokensNative = null;
  
  this._pStreamStrides = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.tokenCount !== void 0) this.tokenCount = opts.tokenCount;
    if (opts.pTokens !== void 0) this.pTokens = opts.pTokens;
    if (opts.streamCount !== void 0) this.streamCount = opts.streamCount;
    if (opts.pStreamStrides !== void 0) this.pStreamStrides = opts.pStreamStrides;
    
  }
};

Object.defineProperties(VkIndirectCommandsLayoutCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkIndirectCommandsLayoutCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutCreateInfoNV.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutCreateInfoNV.pipelineBindPoint");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "tokenCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutCreateInfoNV.tokenCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pTokens": {
    get() {
    if (this._pTokens === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.tokenCount, VkIndirectCommandsLayoutTokenNV);
      this._pTokens = array;
      return this.pTokens;
    } else {
      return this._pTokens;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pTokens = value;
    } else if (value === null) {
      this._pTokens = null;
    } else {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNV.pTokens': Expected 'Array VkIndirectCommandsLayoutTokenNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "streamCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkIndirectCommandsLayoutCreateInfoNV.streamCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pStreamStrides": {
    get() {
    return this._pStreamStrides;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pStreamStrides = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pStreamStrides = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNV.pStreamStrides': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkIndirectCommandsLayoutCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this._pTokens = null;
  this._pTokensNative = null;
  
  this._pStreamStrides = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.tokenCount !== void 0) this.tokenCount = opts.tokenCount;
    if (opts.pTokens !== void 0) this.pTokens = opts.pTokens;
    if (opts.streamCount !== void 0) this.streamCount = opts.streamCount;
    if (opts.pStreamStrides !== void 0) this.pStreamStrides = opts.pStreamStrides;
    
  }
};

VkIndirectCommandsLayoutCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pTokens !== null) {
    let array = this._pTokens;
    
    if (array.length !== this.tokenCount) {
      throw new RangeError("Invalid array length, expected length of 'tokenCount' for 'VkIndirectCommandsLayoutCreateInfoNV.pTokens'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkIndirectCommandsLayoutTokenNV)) {
        throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNV.pTokens[" + ii + "]': Expected 'VkIndirectCommandsLayoutTokenNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pTokensNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pTokensNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkIndirectCommandsLayoutCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkIndirectCommandsLayoutCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkIndirectCommandsLayoutCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.pipelineBindPoint = original.pipelineBindPoint;
  copy.tokenCount = original.tokenCount;
  if (original.pTokens !== null) {
        copy.pTokens = [...Array(original.pTokens.length)].map((v, i) => {
          return original.pTokens[i].constructor.createCopyFrom(original.pTokens[i]);
        });
      }
  copy.streamCount = original.streamCount;
  if (original.pStreamStrides !== null) {
        copy.pStreamStrides = new Uint32Array(original.pStreamStrides);
      }
  
  return copy;
};

VkIndirectCommandsLayoutCreateInfoNV.byteLength = 0x0;

VkIndirectCommandsLayoutCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineBindPoint: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tokenCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pTokens: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  streamCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pStreamStrides: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkGeneratedCommandsInfoNV **/
function VkGeneratedCommandsInfoNV(opts, byteOffset) {
  if (new.target !== VkGeneratedCommandsInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkGeneratedCommandsInfoNV, STRUCT_CACHE_VkGeneratedCommandsInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkGeneratedCommandsInfoNV, STRUCT_CACHE_VkGeneratedCommandsInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkGeneratedCommandsInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pipeline = null;
  this._indirectCommandsLayout = null;
  
  this._pStreams = null;
  this._pStreamsNative = null;
  
  this._preprocessBuffer = null;
  
  
  this._sequencesCountBuffer = null;
  
  this._sequencesIndexBuffer = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.pipeline !== void 0) this.pipeline = opts.pipeline;
    if (opts.indirectCommandsLayout !== void 0) this.indirectCommandsLayout = opts.indirectCommandsLayout;
    if (opts.streamCount !== void 0) this.streamCount = opts.streamCount;
    if (opts.pStreams !== void 0) this.pStreams = opts.pStreams;
    if (opts.sequencesCount !== void 0) this.sequencesCount = opts.sequencesCount;
    if (opts.preprocessBuffer !== void 0) this.preprocessBuffer = opts.preprocessBuffer;
    if (opts.preprocessOffset !== void 0) this.preprocessOffset = opts.preprocessOffset;
    if (opts.preprocessSize !== void 0) this.preprocessSize = opts.preprocessSize;
    if (opts.sequencesCountBuffer !== void 0) this.sequencesCountBuffer = opts.sequencesCountBuffer;
    if (opts.sequencesCountOffset !== void 0) this.sequencesCountOffset = opts.sequencesCountOffset;
    if (opts.sequencesIndexBuffer !== void 0) this.sequencesIndexBuffer = opts.sequencesIndexBuffer;
    if (opts.sequencesIndexOffset !== void 0) this.sequencesIndexOffset = opts.sequencesIndexOffset;
    
  }
};

Object.defineProperties(VkGeneratedCommandsInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeneratedCommandsInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkGeneratedCommandsInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeneratedCommandsInfoNV.pipelineBindPoint");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pipeline": {
    get() {
    return this._pipeline;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._pipeline = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._pipeline = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeneratedCommandsInfoNV.pipeline': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "indirectCommandsLayout": {
    get() {
    return this._indirectCommandsLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkIndirectCommandsLayoutNV) {
      
      this._indirectCommandsLayout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._indirectCommandsLayout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeneratedCommandsInfoNV.indirectCommandsLayout': Expected 'VkIndirectCommandsLayoutNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "streamCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeneratedCommandsInfoNV.streamCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pStreams": {
    get() {
    if (this._pStreams === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.streamCount, VkIndirectCommandsStreamNV);
      this._pStreams = array;
      return this.pStreams;
    } else {
      return this._pStreams;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pStreams = value;
    } else if (value === null) {
      this._pStreams = null;
    } else {
      throw new TypeError("Invalid type for 'VkGeneratedCommandsInfoNV.pStreams': Expected 'Array VkIndirectCommandsStreamNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "sequencesCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeneratedCommandsInfoNV.sequencesCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "preprocessBuffer": {
    get() {
    return this._preprocessBuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._preprocessBuffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._preprocessBuffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeneratedCommandsInfoNV.preprocessBuffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "preprocessOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkGeneratedCommandsInfoNV.preprocessOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "preprocessSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkGeneratedCommandsInfoNV.preprocessSize")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "sequencesCountBuffer": {
    get() {
    return this._sequencesCountBuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._sequencesCountBuffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._sequencesCountBuffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeneratedCommandsInfoNV.sequencesCountBuffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "sequencesCountOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkGeneratedCommandsInfoNV.sequencesCountOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "sequencesIndexBuffer": {
    get() {
    return this._sequencesIndexBuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._sequencesIndexBuffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._sequencesIndexBuffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeneratedCommandsInfoNV.sequencesIndexBuffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "sequencesIndexOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkGeneratedCommandsInfoNV.sequencesIndexOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkGeneratedCommandsInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pipeline = null;
  this._indirectCommandsLayout = null;
  
  this._pStreams = null;
  this._pStreamsNative = null;
  
  this._preprocessBuffer = null;
  
  
  this._sequencesCountBuffer = null;
  
  this._sequencesIndexBuffer = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.pipeline !== void 0) this.pipeline = opts.pipeline;
    if (opts.indirectCommandsLayout !== void 0) this.indirectCommandsLayout = opts.indirectCommandsLayout;
    if (opts.streamCount !== void 0) this.streamCount = opts.streamCount;
    if (opts.pStreams !== void 0) this.pStreams = opts.pStreams;
    if (opts.sequencesCount !== void 0) this.sequencesCount = opts.sequencesCount;
    if (opts.preprocessBuffer !== void 0) this.preprocessBuffer = opts.preprocessBuffer;
    if (opts.preprocessOffset !== void 0) this.preprocessOffset = opts.preprocessOffset;
    if (opts.preprocessSize !== void 0) this.preprocessSize = opts.preprocessSize;
    if (opts.sequencesCountBuffer !== void 0) this.sequencesCountBuffer = opts.sequencesCountBuffer;
    if (opts.sequencesCountOffset !== void 0) this.sequencesCountOffset = opts.sequencesCountOffset;
    if (opts.sequencesIndexBuffer !== void 0) this.sequencesIndexBuffer = opts.sequencesIndexBuffer;
    if (opts.sequencesIndexOffset !== void 0) this.sequencesIndexOffset = opts.sequencesIndexOffset;
    
  }
};

VkGeneratedCommandsInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pStreams !== null) {
    let array = this._pStreams;
    
    if (array.length !== this.streamCount) {
      throw new RangeError("Invalid array length, expected length of 'streamCount' for 'VkGeneratedCommandsInfoNV.pStreams'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkIndirectCommandsStreamNV)) {
        throw new TypeError("Invalid type for 'VkGeneratedCommandsInfoNV.pStreams[" + ii + "]': Expected 'VkIndirectCommandsStreamNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pStreamsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pStreamsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkGeneratedCommandsInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkGeneratedCommandsInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkGeneratedCommandsInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pipelineBindPoint = original.pipelineBindPoint;
  if (original.pipeline !== null) {
        copy.pipeline = original.pipeline.constructor.createCopyFrom(original.pipeline);
      }
  if (original.indirectCommandsLayout !== null) {
        copy.indirectCommandsLayout = original.indirectCommandsLayout.constructor.createCopyFrom(original.indirectCommandsLayout);
      }
  copy.streamCount = original.streamCount;
  if (original.pStreams !== null) {
        copy.pStreams = [...Array(original.pStreams.length)].map((v, i) => {
          return original.pStreams[i].constructor.createCopyFrom(original.pStreams[i]);
        });
      }
  copy.sequencesCount = original.sequencesCount;
  if (original.preprocessBuffer !== null) {
        copy.preprocessBuffer = original.preprocessBuffer.constructor.createCopyFrom(original.preprocessBuffer);
      }
  copy.preprocessOffset = original.preprocessOffset;
  copy.preprocessSize = original.preprocessSize;
  if (original.sequencesCountBuffer !== null) {
        copy.sequencesCountBuffer = original.sequencesCountBuffer.constructor.createCopyFrom(original.sequencesCountBuffer);
      }
  copy.sequencesCountOffset = original.sequencesCountOffset;
  if (original.sequencesIndexBuffer !== null) {
        copy.sequencesIndexBuffer = original.sequencesIndexBuffer.constructor.createCopyFrom(original.sequencesIndexBuffer);
      }
  copy.sequencesIndexOffset = original.sequencesIndexOffset;
  
  return copy;
};

VkGeneratedCommandsInfoNV.byteLength = 0x0;

VkGeneratedCommandsInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineBindPoint: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipeline: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indirectCommandsLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  streamCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pStreams: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sequencesCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  preprocessBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  preprocessOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  preprocessSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sequencesCountBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sequencesCountOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sequencesIndexBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sequencesIndexOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkGeneratedCommandsMemoryRequirementsInfoNV **/
function VkGeneratedCommandsMemoryRequirementsInfoNV(opts, byteOffset) {
  if (new.target !== VkGeneratedCommandsMemoryRequirementsInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkGeneratedCommandsMemoryRequirementsInfoNV, STRUCT_CACHE_VkGeneratedCommandsMemoryRequirementsInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkGeneratedCommandsMemoryRequirementsInfoNV, STRUCT_CACHE_VkGeneratedCommandsMemoryRequirementsInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkGeneratedCommandsMemoryRequirementsInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pipeline = null;
  this._indirectCommandsLayout = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.pipeline !== void 0) this.pipeline = opts.pipeline;
    if (opts.indirectCommandsLayout !== void 0) this.indirectCommandsLayout = opts.indirectCommandsLayout;
    if (opts.maxSequencesCount !== void 0) this.maxSequencesCount = opts.maxSequencesCount;
    
  }
};

Object.defineProperties(VkGeneratedCommandsMemoryRequirementsInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeneratedCommandsMemoryRequirementsInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkGeneratedCommandsMemoryRequirementsInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeneratedCommandsMemoryRequirementsInfoNV.pipelineBindPoint");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pipeline": {
    get() {
    return this._pipeline;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._pipeline = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._pipeline = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeneratedCommandsMemoryRequirementsInfoNV.pipeline': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "indirectCommandsLayout": {
    get() {
    return this._indirectCommandsLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkIndirectCommandsLayoutNV) {
      
      this._indirectCommandsLayout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._indirectCommandsLayout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeneratedCommandsMemoryRequirementsInfoNV.indirectCommandsLayout': Expected 'VkIndirectCommandsLayoutNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "maxSequencesCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeneratedCommandsMemoryRequirementsInfoNV.maxSequencesCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkGeneratedCommandsMemoryRequirementsInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pipeline = null;
  this._indirectCommandsLayout = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.pipeline !== void 0) this.pipeline = opts.pipeline;
    if (opts.indirectCommandsLayout !== void 0) this.indirectCommandsLayout = opts.indirectCommandsLayout;
    if (opts.maxSequencesCount !== void 0) this.maxSequencesCount = opts.maxSequencesCount;
    
  }
};

VkGeneratedCommandsMemoryRequirementsInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkGeneratedCommandsMemoryRequirementsInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkGeneratedCommandsMemoryRequirementsInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkGeneratedCommandsMemoryRequirementsInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pipelineBindPoint = original.pipelineBindPoint;
  if (original.pipeline !== null) {
        copy.pipeline = original.pipeline.constructor.createCopyFrom(original.pipeline);
      }
  if (original.indirectCommandsLayout !== null) {
        copy.indirectCommandsLayout = original.indirectCommandsLayout.constructor.createCopyFrom(original.indirectCommandsLayout);
      }
  copy.maxSequencesCount = original.maxSequencesCount;
  
  return copy;
};

VkGeneratedCommandsMemoryRequirementsInfoNV.byteLength = 0x0;

VkGeneratedCommandsMemoryRequirementsInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineBindPoint: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipeline: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indirectCommandsLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSequencesCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFeatures2 **/
function VkPhysicalDeviceFeatures2(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFeatures2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFeatures2, STRUCT_CACHE_VkPhysicalDeviceFeatures2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFeatures2, STRUCT_CACHE_VkPhysicalDeviceFeatures2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFeatures2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._features = new VkPhysicalDeviceFeatures({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.features !== void 0) this.features = opts.features;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFeatures2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFeatures2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.pNext'");
    }
    
    }
    },
  "features": {
    get() {
    return this._features;
    },
    set(value) {
    if (value !== null && value.constructor === VkPhysicalDeviceFeatures) {
      value.flush();
      this._features = value;
      
      
    } else if (value === null) {
      this._features = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.features': Expected 'VkPhysicalDeviceFeatures' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPhysicalDeviceFeatures2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._features !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._features.memoryBuffer) this._features = new VkPhysicalDeviceFeatures({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._features.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.features !== void 0) this.features = opts.features;
    
  }
};

VkPhysicalDeviceFeatures2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._features !== null) {
    let features = this._features;
    features.flush();
    if (this.memoryBuffer !== features.memoryBuffer) {
      let srcView = new Uint8Array(features.memoryBuffer, features.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPhysicalDeviceFeatures2.features' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkPhysicalDeviceFeatures2.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFeatures2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFeatures2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.features !== null) {
        copy.features = original.features.constructor.createCopyFrom(original.features);
      }
  
  return copy;
};

VkPhysicalDeviceFeatures2.byteLength = 0x0;

VkPhysicalDeviceFeatures2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  features: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFeatures2KHR **/
function VkPhysicalDeviceFeatures2KHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFeatures2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFeatures2KHR, STRUCT_CACHE_VkPhysicalDeviceFeatures2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFeatures2KHR, STRUCT_CACHE_VkPhysicalDeviceFeatures2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFeatures2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._features = new VkPhysicalDeviceFeatures({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.features !== void 0) this.features = opts.features;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFeatures2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFeatures2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.pNext'");
    }
    
    }
    },
  "features": {
    get() {
    return this._features;
    },
    set(value) {
    if (value !== null && value.constructor === VkPhysicalDeviceFeatures) {
      value.flush();
      this._features = value;
      
      
    } else if (value === null) {
      this._features = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.features': Expected 'VkPhysicalDeviceFeatures' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPhysicalDeviceFeatures2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._features !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._features.memoryBuffer) this._features = new VkPhysicalDeviceFeatures({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._features.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.features !== void 0) this.features = opts.features;
    
  }
};

VkPhysicalDeviceFeatures2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._features !== null) {
    let features = this._features;
    features.flush();
    if (this.memoryBuffer !== features.memoryBuffer) {
      let srcView = new Uint8Array(features.memoryBuffer, features.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPhysicalDeviceFeatures2KHR.features' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkPhysicalDeviceFeatures2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFeatures2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFeatures2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.features !== null) {
        copy.features = original.features.constructor.createCopyFrom(original.features);
      }
  
  return copy;
};

VkPhysicalDeviceFeatures2KHR.byteLength = 0x0;

VkPhysicalDeviceFeatures2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  features: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceProperties2 **/
function VkPhysicalDeviceProperties2(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceProperties2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceProperties2, STRUCT_CACHE_VkPhysicalDeviceProperties2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceProperties2, STRUCT_CACHE_VkPhysicalDeviceProperties2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceProperties2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._properties = new VkPhysicalDeviceProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceProperties2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.pNext'");
    }
    
    }
    },
  "properties": {
    get() {
    return this._properties;
    },
    },
  
});

VkPhysicalDeviceProperties2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._properties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._properties.memoryBuffer) this._properties = new VkPhysicalDeviceProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._properties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceProperties2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceProperties2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.properties !== null) {
        copy.properties = original.properties.constructor.createCopyFrom(original.properties);
      }
  
  return copy;
};

VkPhysicalDeviceProperties2.byteLength = 0x0;

VkPhysicalDeviceProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  properties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceProperties2KHR **/
function VkPhysicalDeviceProperties2KHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceProperties2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceProperties2KHR, STRUCT_CACHE_VkPhysicalDeviceProperties2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceProperties2KHR, STRUCT_CACHE_VkPhysicalDeviceProperties2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceProperties2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._properties = new VkPhysicalDeviceProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceProperties2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.pNext'");
    }
    
    }
    },
  "properties": {
    get() {
    return this._properties;
    },
    },
  
});

VkPhysicalDeviceProperties2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._properties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._properties.memoryBuffer) this._properties = new VkPhysicalDeviceProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._properties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceProperties2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceProperties2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.properties !== null) {
        copy.properties = original.properties.constructor.createCopyFrom(original.properties);
      }
  
  return copy;
};

VkPhysicalDeviceProperties2KHR.byteLength = 0x0;

VkPhysicalDeviceProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  properties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFormatProperties2 **/
function VkFormatProperties2(opts, byteOffset) {
  if (new.target !== VkFormatProperties2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFormatProperties2, STRUCT_CACHE_VkFormatProperties2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFormatProperties2, STRUCT_CACHE_VkFormatProperties2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFormatProperties2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._formatProperties = new VkFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkFormatProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFormatProperties2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFormatProperties2.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkFormatProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkFormatProperties2.pNext'");
    }
    
    }
    },
  "formatProperties": {
    get() {
    return this._formatProperties;
    },
    },
  
});

VkFormatProperties2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._formatProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._formatProperties.memoryBuffer) this._formatProperties = new VkFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._formatProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkFormatProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFormatProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkFormatProperties2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFormatProperties2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.formatProperties !== null) {
        copy.formatProperties = original.formatProperties.constructor.createCopyFrom(original.formatProperties);
      }
  
  return copy;
};

VkFormatProperties2.byteLength = 0x0;

VkFormatProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  formatProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFormatProperties2KHR **/
function VkFormatProperties2KHR(opts, byteOffset) {
  if (new.target !== VkFormatProperties2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFormatProperties2KHR, STRUCT_CACHE_VkFormatProperties2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFormatProperties2KHR, STRUCT_CACHE_VkFormatProperties2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFormatProperties2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._formatProperties = new VkFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkFormatProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFormatProperties2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFormatProperties2KHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkFormatProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkFormatProperties2KHR.pNext'");
    }
    
    }
    },
  "formatProperties": {
    get() {
    return this._formatProperties;
    },
    },
  
});

VkFormatProperties2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._formatProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._formatProperties.memoryBuffer) this._formatProperties = new VkFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._formatProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkFormatProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFormatProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkFormatProperties2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFormatProperties2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.formatProperties !== null) {
        copy.formatProperties = original.formatProperties.constructor.createCopyFrom(original.formatProperties);
      }
  
  return copy;
};

VkFormatProperties2KHR.byteLength = 0x0;

VkFormatProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  formatProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageFormatProperties2 **/
function VkImageFormatProperties2(opts, byteOffset) {
  if (new.target !== VkImageFormatProperties2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageFormatProperties2, STRUCT_CACHE_VkImageFormatProperties2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageFormatProperties2, STRUCT_CACHE_VkImageFormatProperties2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageFormatProperties2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkImageFormatProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageFormatProperties2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageFormatProperties2.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageFormatProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageFormatProperties2.pNext'");
    }
    
    }
    },
  "imageFormatProperties": {
    get() {
    return this._imageFormatProperties;
    },
    },
  
});

VkImageFormatProperties2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._imageFormatProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageFormatProperties.memoryBuffer) this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageFormatProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkImageFormatProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageFormatProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkImageFormatProperties2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageFormatProperties2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.imageFormatProperties !== null) {
        copy.imageFormatProperties = original.imageFormatProperties.constructor.createCopyFrom(original.imageFormatProperties);
      }
  
  return copy;
};

VkImageFormatProperties2.byteLength = 0x0;

VkImageFormatProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageFormatProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageFormatProperties2KHR **/
function VkImageFormatProperties2KHR(opts, byteOffset) {
  if (new.target !== VkImageFormatProperties2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageFormatProperties2KHR, STRUCT_CACHE_VkImageFormatProperties2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageFormatProperties2KHR, STRUCT_CACHE_VkImageFormatProperties2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageFormatProperties2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkImageFormatProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageFormatProperties2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.pNext'");
    }
    
    }
    },
  "imageFormatProperties": {
    get() {
    return this._imageFormatProperties;
    },
    },
  
});

VkImageFormatProperties2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._imageFormatProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageFormatProperties.memoryBuffer) this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageFormatProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkImageFormatProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageFormatProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkImageFormatProperties2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageFormatProperties2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.imageFormatProperties !== null) {
        copy.imageFormatProperties = original.imageFormatProperties.constructor.createCopyFrom(original.imageFormatProperties);
      }
  
  return copy;
};

VkImageFormatProperties2KHR.byteLength = 0x0;

VkImageFormatProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageFormatProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceImageFormatInfo2 **/
function VkPhysicalDeviceImageFormatInfo2(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceImageFormatInfo2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceImageFormatInfo2, STRUCT_CACHE_VkPhysicalDeviceImageFormatInfo2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceImageFormatInfo2, STRUCT_CACHE_VkPhysicalDeviceImageFormatInfo2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceImageFormatInfo2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImageFormatInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.pNext'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "tiling": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2.tiling");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceImageFormatInfo2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkPhysicalDeviceImageFormatInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageFormatInfo2.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceImageFormatInfo2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceImageFormatInfo2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.format = original.format;
  copy.type = original.type;
  copy.tiling = original.tiling;
  copy.usage = original.usage;
  copy.flags = original.flags;
  
  return copy;
};

VkPhysicalDeviceImageFormatInfo2.byteLength = 0x0;

VkPhysicalDeviceImageFormatInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tiling: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceImageFormatInfo2KHR **/
function VkPhysicalDeviceImageFormatInfo2KHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceImageFormatInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceImageFormatInfo2KHR, STRUCT_CACHE_VkPhysicalDeviceImageFormatInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceImageFormatInfo2KHR, STRUCT_CACHE_VkPhysicalDeviceImageFormatInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceImageFormatInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImageFormatInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.pNext'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2KHR.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2KHR.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "tiling": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2KHR.tiling");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2KHR.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageFormatInfo2KHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceImageFormatInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkPhysicalDeviceImageFormatInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageFormatInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceImageFormatInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceImageFormatInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.format = original.format;
  copy.type = original.type;
  copy.tiling = original.tiling;
  copy.usage = original.usage;
  copy.flags = original.flags;
  
  return copy;
};

VkPhysicalDeviceImageFormatInfo2KHR.byteLength = 0x0;

VkPhysicalDeviceImageFormatInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tiling: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkQueueFamilyProperties2 **/
function VkQueueFamilyProperties2(opts, byteOffset) {
  if (new.target !== VkQueueFamilyProperties2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkQueueFamilyProperties2, STRUCT_CACHE_VkQueueFamilyProperties2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkQueueFamilyProperties2, STRUCT_CACHE_VkQueueFamilyProperties2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkQueueFamilyProperties2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._queueFamilyProperties = new VkQueueFamilyProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkQueueFamilyProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueueFamilyProperties2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.pNext'");
    }
    
    }
    },
  "queueFamilyProperties": {
    get() {
    return this._queueFamilyProperties;
    },
    },
  
});

VkQueueFamilyProperties2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._queueFamilyProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._queueFamilyProperties.memoryBuffer) this._queueFamilyProperties = new VkQueueFamilyProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._queueFamilyProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkQueueFamilyProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueueFamilyProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkQueueFamilyProperties2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkQueueFamilyProperties2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.queueFamilyProperties !== null) {
        copy.queueFamilyProperties = original.queueFamilyProperties.constructor.createCopyFrom(original.queueFamilyProperties);
      }
  
  return copy;
};

VkQueueFamilyProperties2.byteLength = 0x0;

VkQueueFamilyProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueFamilyProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkQueueFamilyProperties2KHR **/
function VkQueueFamilyProperties2KHR(opts, byteOffset) {
  if (new.target !== VkQueueFamilyProperties2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkQueueFamilyProperties2KHR, STRUCT_CACHE_VkQueueFamilyProperties2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkQueueFamilyProperties2KHR, STRUCT_CACHE_VkQueueFamilyProperties2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkQueueFamilyProperties2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._queueFamilyProperties = new VkQueueFamilyProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkQueueFamilyProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueueFamilyProperties2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.pNext'");
    }
    
    }
    },
  "queueFamilyProperties": {
    get() {
    return this._queueFamilyProperties;
    },
    },
  
});

VkQueueFamilyProperties2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._queueFamilyProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._queueFamilyProperties.memoryBuffer) this._queueFamilyProperties = new VkQueueFamilyProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._queueFamilyProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkQueueFamilyProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueueFamilyProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkQueueFamilyProperties2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkQueueFamilyProperties2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.queueFamilyProperties !== null) {
        copy.queueFamilyProperties = original.queueFamilyProperties.constructor.createCopyFrom(original.queueFamilyProperties);
      }
  
  return copy;
};

VkQueueFamilyProperties2KHR.byteLength = 0x0;

VkQueueFamilyProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueFamilyProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMemoryProperties2 **/
function VkPhysicalDeviceMemoryProperties2(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMemoryProperties2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMemoryProperties2, STRUCT_CACHE_VkPhysicalDeviceMemoryProperties2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMemoryProperties2, STRUCT_CACHE_VkPhysicalDeviceMemoryProperties2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMemoryProperties2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memoryProperties = new VkPhysicalDeviceMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMemoryProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMemoryProperties2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.pNext'");
    }
    
    }
    },
  "memoryProperties": {
    get() {
    return this._memoryProperties;
    },
    },
  
});

VkPhysicalDeviceMemoryProperties2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._memoryProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._memoryProperties.memoryBuffer) this._memoryProperties = new VkPhysicalDeviceMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._memoryProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceMemoryProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceMemoryProperties2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMemoryProperties2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memoryProperties !== null) {
        copy.memoryProperties = original.memoryProperties.constructor.createCopyFrom(original.memoryProperties);
      }
  
  return copy;
};

VkPhysicalDeviceMemoryProperties2.byteLength = 0x0;

VkPhysicalDeviceMemoryProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMemoryProperties2KHR **/
function VkPhysicalDeviceMemoryProperties2KHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMemoryProperties2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMemoryProperties2KHR, STRUCT_CACHE_VkPhysicalDeviceMemoryProperties2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMemoryProperties2KHR, STRUCT_CACHE_VkPhysicalDeviceMemoryProperties2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMemoryProperties2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memoryProperties = new VkPhysicalDeviceMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMemoryProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMemoryProperties2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.pNext'");
    }
    
    }
    },
  "memoryProperties": {
    get() {
    return this._memoryProperties;
    },
    },
  
});

VkPhysicalDeviceMemoryProperties2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._memoryProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._memoryProperties.memoryBuffer) this._memoryProperties = new VkPhysicalDeviceMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._memoryProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceMemoryProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceMemoryProperties2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMemoryProperties2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memoryProperties !== null) {
        copy.memoryProperties = original.memoryProperties.constructor.createCopyFrom(original.memoryProperties);
      }
  
  return copy;
};

VkPhysicalDeviceMemoryProperties2KHR.byteLength = 0x0;

VkPhysicalDeviceMemoryProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseImageFormatProperties2 **/
function VkSparseImageFormatProperties2(opts, byteOffset) {
  if (new.target !== VkSparseImageFormatProperties2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseImageFormatProperties2, STRUCT_CACHE_VkSparseImageFormatProperties2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseImageFormatProperties2, STRUCT_CACHE_VkSparseImageFormatProperties2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseImageFormatProperties2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._properties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSparseImageFormatProperties2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSparseImageFormatProperties2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSparseImageFormatProperties2.pNext' isn't allowed to be filled");
    }
    },
  "properties": {
    get() {
    return this._properties;
    },
    },
  
});

VkSparseImageFormatProperties2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._properties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._properties.memoryBuffer) this._properties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._properties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSparseImageFormatProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageFormatProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSparseImageFormatProperties2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseImageFormatProperties2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.properties !== null) {
        copy.properties = original.properties.constructor.createCopyFrom(original.properties);
      }
  
  return copy;
};

VkSparseImageFormatProperties2.byteLength = 0x0;

VkSparseImageFormatProperties2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  properties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseImageFormatProperties2KHR **/
function VkSparseImageFormatProperties2KHR(opts, byteOffset) {
  if (new.target !== VkSparseImageFormatProperties2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseImageFormatProperties2KHR, STRUCT_CACHE_VkSparseImageFormatProperties2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseImageFormatProperties2KHR, STRUCT_CACHE_VkSparseImageFormatProperties2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseImageFormatProperties2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._properties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSparseImageFormatProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSparseImageFormatProperties2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSparseImageFormatProperties2KHR.pNext' isn't allowed to be filled");
    }
    },
  "properties": {
    get() {
    return this._properties;
    },
    },
  
});

VkSparseImageFormatProperties2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._properties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._properties.memoryBuffer) this._properties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._properties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSparseImageFormatProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageFormatProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSparseImageFormatProperties2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseImageFormatProperties2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.properties !== null) {
        copy.properties = original.properties.constructor.createCopyFrom(original.properties);
      }
  
  return copy;
};

VkSparseImageFormatProperties2KHR.byteLength = 0x0;

VkSparseImageFormatProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  properties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSparseImageFormatInfo2 **/
function VkPhysicalDeviceSparseImageFormatInfo2(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSparseImageFormatInfo2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSparseImageFormatInfo2, STRUCT_CACHE_VkPhysicalDeviceSparseImageFormatInfo2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSparseImageFormatInfo2, STRUCT_CACHE_VkPhysicalDeviceSparseImageFormatInfo2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSparseImageFormatInfo2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSparseImageFormatInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSparseImageFormatInfo2.pNext' isn't allowed to be filled");
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "samples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2.samples");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "tiling": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2.tiling");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceSparseImageFormatInfo2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    
  }
};

VkPhysicalDeviceSparseImageFormatInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSparseImageFormatInfo2.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceSparseImageFormatInfo2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSparseImageFormatInfo2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.format = original.format;
  copy.type = original.type;
  copy.samples = original.samples;
  copy.usage = original.usage;
  copy.tiling = original.tiling;
  
  return copy;
};

VkPhysicalDeviceSparseImageFormatInfo2.byteLength = 0x0;

VkPhysicalDeviceSparseImageFormatInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tiling: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSparseImageFormatInfo2KHR **/
function VkPhysicalDeviceSparseImageFormatInfo2KHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSparseImageFormatInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSparseImageFormatInfo2KHR, STRUCT_CACHE_VkPhysicalDeviceSparseImageFormatInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSparseImageFormatInfo2KHR, STRUCT_CACHE_VkPhysicalDeviceSparseImageFormatInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSparseImageFormatInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSparseImageFormatInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSparseImageFormatInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "samples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.samples");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "tiling": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSparseImageFormatInfo2KHR.tiling");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceSparseImageFormatInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.tiling !== void 0) this.tiling = opts.tiling;
    
  }
};

VkPhysicalDeviceSparseImageFormatInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSparseImageFormatInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceSparseImageFormatInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSparseImageFormatInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.format = original.format;
  copy.type = original.type;
  copy.samples = original.samples;
  copy.usage = original.usage;
  copy.tiling = original.tiling;
  
  return copy;
};

VkPhysicalDeviceSparseImageFormatInfo2KHR.byteLength = 0x0;

VkPhysicalDeviceSparseImageFormatInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tiling: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevicePushDescriptorPropertiesKHR **/
function VkPhysicalDevicePushDescriptorPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDevicePushDescriptorPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevicePushDescriptorPropertiesKHR, STRUCT_CACHE_VkPhysicalDevicePushDescriptorPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevicePushDescriptorPropertiesKHR, STRUCT_CACHE_VkPhysicalDevicePushDescriptorPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevicePushDescriptorPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDevicePushDescriptorPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevicePushDescriptorPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePushDescriptorPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "maxPushDescriptors": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDevicePushDescriptorPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDevicePushDescriptorPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePushDescriptorPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDevicePushDescriptorPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevicePushDescriptorPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxPushDescriptors = original.maxPushDescriptors;
  
  return copy;
};

VkPhysicalDevicePushDescriptorPropertiesKHR.byteLength = 0x0;

VkPhysicalDevicePushDescriptorPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPushDescriptors: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkConformanceVersion **/
function VkConformanceVersion(opts, byteOffset) {
  if (new.target !== VkConformanceVersion) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkConformanceVersion, STRUCT_CACHE_VkConformanceVersion);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkConformanceVersion, STRUCT_CACHE_VkConformanceVersion);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkConformanceVersion'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.major !== void 0) this.major = opts.major;
    if (opts.minor !== void 0) this.minor = opts.minor;
    if (opts.subminor !== void 0) this.subminor = opts.subminor;
    if (opts.patch !== void 0) this.patch = opts.patch;
    
  }
};

Object.defineProperties(VkConformanceVersion.prototype, {
  "major": {
    get() {
    return this.memoryView.getUint8(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkConformanceVersion.major");
    this.memoryView.setUint8(0x0, value, true);
    }
    },
  "minor": {
    get() {
    return this.memoryView.getUint8(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkConformanceVersion.minor");
    this.memoryView.setUint8(0x0, value, true);
    }
    },
  "subminor": {
    get() {
    return this.memoryView.getUint8(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkConformanceVersion.subminor");
    this.memoryView.setUint8(0x0, value, true);
    }
    },
  "patch": {
    get() {
    return this.memoryView.getUint8(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkConformanceVersion.patch");
    this.memoryView.setUint8(0x0, value, true);
    }
    },
  
});

VkConformanceVersion.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.major !== void 0) this.major = opts.major;
    if (opts.minor !== void 0) this.minor = opts.minor;
    if (opts.subminor !== void 0) this.subminor = opts.subminor;
    if (opts.patch !== void 0) this.patch = opts.patch;
    
  }
};

VkConformanceVersion.prototype.flush = function flush() {
  
  return true;
};

VkConformanceVersion.prototype.reflect = function reflect(memoryAddress) {
  };

VkConformanceVersion.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkConformanceVersion();
  copy.major = original.major;
  copy.minor = original.minor;
  copy.subminor = original.subminor;
  copy.patch = original.patch;
  
  return copy;
};

VkConformanceVersion.byteLength = 0x0;

VkConformanceVersion.memoryLayout = {
  major: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subminor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  patch: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkConformanceVersionKHR **/
function VkConformanceVersionKHR(opts, byteOffset) {
  if (new.target !== VkConformanceVersionKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkConformanceVersionKHR, STRUCT_CACHE_VkConformanceVersionKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkConformanceVersionKHR, STRUCT_CACHE_VkConformanceVersionKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkConformanceVersionKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.major !== void 0) this.major = opts.major;
    if (opts.minor !== void 0) this.minor = opts.minor;
    if (opts.subminor !== void 0) this.subminor = opts.subminor;
    if (opts.patch !== void 0) this.patch = opts.patch;
    
  }
};

Object.defineProperties(VkConformanceVersionKHR.prototype, {
  "major": {
    get() {
    return this.memoryView.getUint8(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkConformanceVersionKHR.major");
    this.memoryView.setUint8(0x0, value, true);
    }
    },
  "minor": {
    get() {
    return this.memoryView.getUint8(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkConformanceVersionKHR.minor");
    this.memoryView.setUint8(0x0, value, true);
    }
    },
  "subminor": {
    get() {
    return this.memoryView.getUint8(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkConformanceVersionKHR.subminor");
    this.memoryView.setUint8(0x0, value, true);
    }
    },
  "patch": {
    get() {
    return this.memoryView.getUint8(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkConformanceVersionKHR.patch");
    this.memoryView.setUint8(0x0, value, true);
    }
    },
  
});

VkConformanceVersionKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.major !== void 0) this.major = opts.major;
    if (opts.minor !== void 0) this.minor = opts.minor;
    if (opts.subminor !== void 0) this.subminor = opts.subminor;
    if (opts.patch !== void 0) this.patch = opts.patch;
    
  }
};

VkConformanceVersionKHR.prototype.flush = function flush() {
  
  return true;
};

VkConformanceVersionKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkConformanceVersionKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkConformanceVersionKHR();
  copy.major = original.major;
  copy.minor = original.minor;
  copy.subminor = original.subminor;
  copy.patch = original.patch;
  
  return copy;
};

VkConformanceVersionKHR.byteLength = 0x0;

VkConformanceVersionKHR.memoryLayout = {
  major: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subminor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  patch: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDriverProperties **/
function VkPhysicalDeviceDriverProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDriverProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDriverProperties, STRUCT_CACHE_VkPhysicalDeviceDriverProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDriverProperties, STRUCT_CACHE_VkPhysicalDeviceDriverProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDriverProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._conformanceVersion = new VkConformanceVersion({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDriverProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDriverProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDriverProperties.pNext' isn't allowed to be filled");
    }
    },
  "driverID": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "driverName": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "driverInfo": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "conformanceVersion": {
    get() {
    return this._conformanceVersion;
    },
    },
  
});

VkPhysicalDeviceDriverProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  if (this._conformanceVersion !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._conformanceVersion.memoryBuffer) this._conformanceVersion = new VkConformanceVersion({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._conformanceVersion.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceDriverProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDriverProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceDriverProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDriverProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.driverID = original.driverID;
  copy.driverName = original.driverName;
  copy.driverInfo = original.driverInfo;
  if (original.conformanceVersion !== null) {
        copy.conformanceVersion = original.conformanceVersion.constructor.createCopyFrom(original.conformanceVersion);
      }
  
  return copy;
};

VkPhysicalDeviceDriverProperties.byteLength = 0x0;

VkPhysicalDeviceDriverProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  conformanceVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDriverPropertiesKHR **/
function VkPhysicalDeviceDriverPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDriverPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDriverPropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceDriverPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDriverPropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceDriverPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDriverPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._conformanceVersion = new VkConformanceVersion({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDriverPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDriverPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDriverPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "driverID": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "driverName": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "driverInfo": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "conformanceVersion": {
    get() {
    return this._conformanceVersion;
    },
    },
  
});

VkPhysicalDeviceDriverPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  if (this._conformanceVersion !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._conformanceVersion.memoryBuffer) this._conformanceVersion = new VkConformanceVersion({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._conformanceVersion.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceDriverPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDriverPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceDriverPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDriverPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.driverID = original.driverID;
  copy.driverName = original.driverName;
  copy.driverInfo = original.driverInfo;
  if (original.conformanceVersion !== null) {
        copy.conformanceVersion = original.conformanceVersion.constructor.createCopyFrom(original.conformanceVersion);
      }
  
  return copy;
};

VkPhysicalDeviceDriverPropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceDriverPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  conformanceVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPresentRegionsKHR **/
function VkPresentRegionsKHR(opts, byteOffset) {
  if (new.target !== VkPresentRegionsKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPresentRegionsKHR, STRUCT_CACHE_VkPresentRegionsKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPresentRegionsKHR, STRUCT_CACHE_VkPresentRegionsKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPresentRegionsKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

Object.defineProperties(VkPresentRegionsKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPresentRegionsKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPresentRegionsKHR.pNext' isn't allowed to be filled");
    }
    },
  "swapchainCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPresentRegionsKHR.swapchainCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pRegions": {
    get() {
    if (this._pRegions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.swapchainCount, VkPresentRegionKHR);
      this._pRegions = array;
      return this.pRegions;
    } else {
      return this._pRegions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pRegions = value;
    } else if (value === null) {
      this._pRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentRegionsKHR.pRegions': Expected 'Array VkPresentRegionKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPresentRegionsKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

VkPresentRegionsKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pRegions !== null) {
    let array = this._pRegions;
    
    if (array.length !== this.swapchainCount) {
      throw new RangeError("Invalid array length, expected length of 'swapchainCount' for 'VkPresentRegionsKHR.pRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPresentRegionKHR)) {
        throw new TypeError("Invalid type for 'VkPresentRegionsKHR.pRegions[" + ii + "]': Expected 'VkPresentRegionKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pRegionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pRegionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPresentRegionsKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPresentRegionsKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPresentRegionsKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.swapchainCount = original.swapchainCount;
  if (original.pRegions !== null) {
        copy.pRegions = [...Array(original.pRegions.length)].map((v, i) => {
          return original.pRegions[i].constructor.createCopyFrom(original.pRegions[i]);
        });
      }
  
  return copy;
};

VkPresentRegionsKHR.byteLength = 0x0;

VkPresentRegionsKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  swapchainCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pRegions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPresentRegionKHR **/
function VkPresentRegionKHR(opts, byteOffset) {
  if (new.target !== VkPresentRegionKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPresentRegionKHR, STRUCT_CACHE_VkPresentRegionKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPresentRegionKHR, STRUCT_CACHE_VkPresentRegionKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPresentRegionKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pRectangles = null;
  this._pRectanglesNative = null;
  
  if (typeof opts === "object") {
    if (opts.rectangleCount !== void 0) this.rectangleCount = opts.rectangleCount;
    if (opts.pRectangles !== void 0) this.pRectangles = opts.pRectangles;
    
  }
};

Object.defineProperties(VkPresentRegionKHR.prototype, {
  "rectangleCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPresentRegionKHR.rectangleCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pRectangles": {
    get() {
    if (this._pRectangles === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.rectangleCount, VkRectLayerKHR);
      this._pRectangles = array;
      return this.pRectangles;
    } else {
      return this._pRectangles;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pRectangles = value;
    } else if (value === null) {
      this._pRectangles = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentRegionKHR.pRectangles': Expected 'Array VkRectLayerKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPresentRegionKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pRectangles = null;
  this._pRectanglesNative = null;
  
  if (typeof opts === "object") {
    if (opts.rectangleCount !== void 0) this.rectangleCount = opts.rectangleCount;
    if (opts.pRectangles !== void 0) this.pRectangles = opts.pRectangles;
    
  }
};

VkPresentRegionKHR.prototype.flush = function flush() {
  
  
  if (this._pRectangles !== null) {
    let array = this._pRectangles;
    
    if (array.length !== this.rectangleCount) {
      throw new RangeError("Invalid array length, expected length of 'rectangleCount' for 'VkPresentRegionKHR.pRectangles'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRectLayerKHR)) {
        throw new TypeError("Invalid type for 'VkPresentRegionKHR.pRectangles[" + ii + "]': Expected 'VkRectLayerKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pRectanglesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pRectanglesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPresentRegionKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPresentRegionKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPresentRegionKHR();
  copy.rectangleCount = original.rectangleCount;
  if (original.pRectangles !== null) {
        copy.pRectangles = [...Array(original.pRectangles.length)].map((v, i) => {
          return original.pRectangles[i].constructor.createCopyFrom(original.pRectangles[i]);
        });
      }
  
  return copy;
};

VkPresentRegionKHR.byteLength = 0x0;

VkPresentRegionKHR.memoryLayout = {
  rectangleCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pRectangles: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRectLayerKHR **/
function VkRectLayerKHR(opts, byteOffset) {
  if (new.target !== VkRectLayerKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRectLayerKHR, STRUCT_CACHE_VkRectLayerKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRectLayerKHR, STRUCT_CACHE_VkRectLayerKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRectLayerKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._offset = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._extent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  if (typeof opts === "object") {
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    if (opts.layer !== void 0) this.layer = opts.layer;
    
  }
};

Object.defineProperties(VkRectLayerKHR.prototype, {
  "offset": {
    get() {
    return this._offset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset2D) {
      value.flush();
      this._offset = value;
      
      
    } else if (value === null) {
      this._offset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRectLayerKHR.offset': Expected 'VkOffset2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRectLayerKHR.extent': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "layer": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRectLayerKHR.layer");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkRectLayerKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._offset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._offset.memoryBuffer) this._offset = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._offset.reset();
  }
  if (this._extent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._extent.memoryBuffer) this._extent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._extent.reset();
  }
  
  
  if (typeof opts === "object") {
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    if (opts.layer !== void 0) this.layer = opts.layer;
    
  }
};

VkRectLayerKHR.prototype.flush = function flush() {
  
  
  if (this._offset !== null) {
    let offset = this._offset;
    offset.flush();
    if (this.memoryBuffer !== offset.memoryBuffer) {
      let srcView = new Uint8Array(offset.memoryBuffer, offset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRectLayerKHR.offset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer, extent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRectLayerKHR.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkRectLayerKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkRectLayerKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRectLayerKHR();
  if (original.offset !== null) {
        copy.offset = original.offset.constructor.createCopyFrom(original.offset);
      }
  if (original.extent !== null) {
        copy.extent = original.extent.constructor.createCopyFrom(original.extent);
      }
  copy.layer = original.layer;
  
  return copy;
};

VkRectLayerKHR.byteLength = 0x0;

VkRectLayerKHR.memoryLayout = {
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVariablePointersFeatures **/
function VkPhysicalDeviceVariablePointersFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVariablePointersFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVariablePointersFeatures, STRUCT_CACHE_VkPhysicalDeviceVariablePointersFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVariablePointersFeatures, STRUCT_CACHE_VkPhysicalDeviceVariablePointersFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVariablePointersFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVariablePointersFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVariablePointersFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVariablePointersFeatures.pNext' isn't allowed to be filled");
    }
    },
  "variablePointersStorageBuffer": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "variablePointers": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceVariablePointersFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

VkPhysicalDeviceVariablePointersFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVariablePointersFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceVariablePointersFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVariablePointersFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.variablePointersStorageBuffer = original.variablePointersStorageBuffer;
  copy.variablePointers = original.variablePointers;
  
  return copy;
};

VkPhysicalDeviceVariablePointersFeatures.byteLength = 0x0;

VkPhysicalDeviceVariablePointersFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variablePointersStorageBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variablePointers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVariablePointersFeaturesKHR **/
function VkPhysicalDeviceVariablePointersFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVariablePointersFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVariablePointersFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceVariablePointersFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVariablePointersFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceVariablePointersFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVariablePointersFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVariablePointersFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVariablePointersFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVariablePointersFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "variablePointersStorageBuffer": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "variablePointers": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceVariablePointersFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

VkPhysicalDeviceVariablePointersFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVariablePointersFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceVariablePointersFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVariablePointersFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.variablePointersStorageBuffer = original.variablePointersStorageBuffer;
  copy.variablePointers = original.variablePointers;
  
  return copy;
};

VkPhysicalDeviceVariablePointersFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceVariablePointersFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variablePointersStorageBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variablePointers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVariablePointerFeaturesKHR **/
function VkPhysicalDeviceVariablePointerFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVariablePointerFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVariablePointerFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceVariablePointerFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVariablePointerFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceVariablePointerFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVariablePointerFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVariablePointerFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVariablePointerFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVariablePointerFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "variablePointersStorageBuffer": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "variablePointers": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceVariablePointerFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

VkPhysicalDeviceVariablePointerFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVariablePointerFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceVariablePointerFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVariablePointerFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.variablePointersStorageBuffer = original.variablePointersStorageBuffer;
  copy.variablePointers = original.variablePointers;
  
  return copy;
};

VkPhysicalDeviceVariablePointerFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceVariablePointerFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variablePointersStorageBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variablePointers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVariablePointerFeatures **/
function VkPhysicalDeviceVariablePointerFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVariablePointerFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVariablePointerFeatures, STRUCT_CACHE_VkPhysicalDeviceVariablePointerFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVariablePointerFeatures, STRUCT_CACHE_VkPhysicalDeviceVariablePointerFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVariablePointerFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVariablePointerFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVariablePointerFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVariablePointerFeatures.pNext' isn't allowed to be filled");
    }
    },
  "variablePointersStorageBuffer": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "variablePointers": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceVariablePointerFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    
  }
};

VkPhysicalDeviceVariablePointerFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVariablePointerFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceVariablePointerFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVariablePointerFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.variablePointersStorageBuffer = original.variablePointersStorageBuffer;
  copy.variablePointers = original.variablePointers;
  
  return copy;
};

VkPhysicalDeviceVariablePointerFeatures.byteLength = 0x0;

VkPhysicalDeviceVariablePointerFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variablePointersStorageBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variablePointers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalMemoryProperties **/
function VkExternalMemoryProperties(opts, byteOffset) {
  if (new.target !== VkExternalMemoryProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalMemoryProperties, STRUCT_CACHE_VkExternalMemoryProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalMemoryProperties, STRUCT_CACHE_VkExternalMemoryProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalMemoryProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkExternalMemoryProperties.prototype, {
  "externalMemoryFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkExternalMemoryProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkExternalMemoryProperties.prototype.flush = function flush() {
  
  return true;
};

VkExternalMemoryProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalMemoryProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalMemoryProperties();
  copy.externalMemoryFeatures = original.externalMemoryFeatures;
  copy.exportFromImportedHandleTypes = original.exportFromImportedHandleTypes;
  copy.compatibleHandleTypes = original.compatibleHandleTypes;
  
  return copy;
};

VkExternalMemoryProperties.byteLength = 0x0;

VkExternalMemoryProperties.memoryLayout = {
  externalMemoryFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compatibleHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalMemoryPropertiesKHR **/
function VkExternalMemoryPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkExternalMemoryPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalMemoryPropertiesKHR, STRUCT_CACHE_VkExternalMemoryPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalMemoryPropertiesKHR, STRUCT_CACHE_VkExternalMemoryPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalMemoryPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkExternalMemoryPropertiesKHR.prototype, {
  "externalMemoryFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkExternalMemoryPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkExternalMemoryPropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkExternalMemoryPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalMemoryPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalMemoryPropertiesKHR();
  copy.externalMemoryFeatures = original.externalMemoryFeatures;
  copy.exportFromImportedHandleTypes = original.exportFromImportedHandleTypes;
  copy.compatibleHandleTypes = original.compatibleHandleTypes;
  
  return copy;
};

VkExternalMemoryPropertiesKHR.byteLength = 0x0;

VkExternalMemoryPropertiesKHR.memoryLayout = {
  externalMemoryFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compatibleHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExternalImageFormatInfo **/
function VkPhysicalDeviceExternalImageFormatInfo(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExternalImageFormatInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExternalImageFormatInfo, STRUCT_CACHE_VkPhysicalDeviceExternalImageFormatInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExternalImageFormatInfo, STRUCT_CACHE_VkPhysicalDeviceExternalImageFormatInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExternalImageFormatInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalImageFormatInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalImageFormatInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalImageFormatInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalImageFormatInfo.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceExternalImageFormatInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkPhysicalDeviceExternalImageFormatInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalImageFormatInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceExternalImageFormatInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExternalImageFormatInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleType = original.handleType;
  
  return copy;
};

VkPhysicalDeviceExternalImageFormatInfo.byteLength = 0x0;

VkPhysicalDeviceExternalImageFormatInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExternalImageFormatInfoKHR **/
function VkPhysicalDeviceExternalImageFormatInfoKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExternalImageFormatInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExternalImageFormatInfoKHR, STRUCT_CACHE_VkPhysicalDeviceExternalImageFormatInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExternalImageFormatInfoKHR, STRUCT_CACHE_VkPhysicalDeviceExternalImageFormatInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExternalImageFormatInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalImageFormatInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalImageFormatInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalImageFormatInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalImageFormatInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceExternalImageFormatInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkPhysicalDeviceExternalImageFormatInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalImageFormatInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceExternalImageFormatInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExternalImageFormatInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleType = original.handleType;
  
  return copy;
};

VkPhysicalDeviceExternalImageFormatInfoKHR.byteLength = 0x0;

VkPhysicalDeviceExternalImageFormatInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalImageFormatProperties **/
function VkExternalImageFormatProperties(opts, byteOffset) {
  if (new.target !== VkExternalImageFormatProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalImageFormatProperties, STRUCT_CACHE_VkExternalImageFormatProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalImageFormatProperties, STRUCT_CACHE_VkExternalImageFormatProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalImageFormatProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalImageFormatProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalImageFormatProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalImageFormatProperties.pNext' isn't allowed to be filled");
    }
    },
  "externalMemoryProperties": {
    get() {
    return this._externalMemoryProperties;
    },
    },
  
});

VkExternalImageFormatProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._externalMemoryProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._externalMemoryProperties.memoryBuffer) this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._externalMemoryProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkExternalImageFormatProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalImageFormatProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalImageFormatProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.externalMemoryProperties !== null) {
        copy.externalMemoryProperties = original.externalMemoryProperties.constructor.createCopyFrom(original.externalMemoryProperties);
      }
  
  return copy;
};

VkExternalImageFormatProperties.byteLength = 0x0;

VkExternalImageFormatProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  externalMemoryProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalImageFormatPropertiesKHR **/
function VkExternalImageFormatPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkExternalImageFormatPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalImageFormatPropertiesKHR, STRUCT_CACHE_VkExternalImageFormatPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalImageFormatPropertiesKHR, STRUCT_CACHE_VkExternalImageFormatPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalImageFormatPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalImageFormatPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalImageFormatPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalImageFormatPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "externalMemoryProperties": {
    get() {
    return this._externalMemoryProperties;
    },
    },
  
});

VkExternalImageFormatPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._externalMemoryProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._externalMemoryProperties.memoryBuffer) this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._externalMemoryProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkExternalImageFormatPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalImageFormatPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalImageFormatPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalImageFormatPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.externalMemoryProperties !== null) {
        copy.externalMemoryProperties = original.externalMemoryProperties.constructor.createCopyFrom(original.externalMemoryProperties);
      }
  
  return copy;
};

VkExternalImageFormatPropertiesKHR.byteLength = 0x0;

VkExternalImageFormatPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  externalMemoryProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExternalBufferInfo **/
function VkPhysicalDeviceExternalBufferInfo(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExternalBufferInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExternalBufferInfo, STRUCT_CACHE_VkPhysicalDeviceExternalBufferInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExternalBufferInfo, STRUCT_CACHE_VkPhysicalDeviceExternalBufferInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExternalBufferInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalBufferInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalBufferInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalBufferInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalBufferInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalBufferInfo.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalBufferInfo.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceExternalBufferInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkPhysicalDeviceExternalBufferInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalBufferInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceExternalBufferInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExternalBufferInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.usage = original.usage;
  copy.handleType = original.handleType;
  
  return copy;
};

VkPhysicalDeviceExternalBufferInfo.byteLength = 0x0;

VkPhysicalDeviceExternalBufferInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExternalBufferInfoKHR **/
function VkPhysicalDeviceExternalBufferInfoKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExternalBufferInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExternalBufferInfoKHR, STRUCT_CACHE_VkPhysicalDeviceExternalBufferInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExternalBufferInfoKHR, STRUCT_CACHE_VkPhysicalDeviceExternalBufferInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExternalBufferInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalBufferInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalBufferInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalBufferInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalBufferInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalBufferInfoKHR.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalBufferInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceExternalBufferInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkPhysicalDeviceExternalBufferInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalBufferInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceExternalBufferInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExternalBufferInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.usage = original.usage;
  copy.handleType = original.handleType;
  
  return copy;
};

VkPhysicalDeviceExternalBufferInfoKHR.byteLength = 0x0;

VkPhysicalDeviceExternalBufferInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalBufferProperties **/
function VkExternalBufferProperties(opts, byteOffset) {
  if (new.target !== VkExternalBufferProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalBufferProperties, STRUCT_CACHE_VkExternalBufferProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalBufferProperties, STRUCT_CACHE_VkExternalBufferProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalBufferProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalBufferProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalBufferProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalBufferProperties.pNext' isn't allowed to be filled");
    }
    },
  "externalMemoryProperties": {
    get() {
    return this._externalMemoryProperties;
    },
    },
  
});

VkExternalBufferProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._externalMemoryProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._externalMemoryProperties.memoryBuffer) this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._externalMemoryProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkExternalBufferProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalBufferProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalBufferProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalBufferProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.externalMemoryProperties !== null) {
        copy.externalMemoryProperties = original.externalMemoryProperties.constructor.createCopyFrom(original.externalMemoryProperties);
      }
  
  return copy;
};

VkExternalBufferProperties.byteLength = 0x0;

VkExternalBufferProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  externalMemoryProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalBufferPropertiesKHR **/
function VkExternalBufferPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkExternalBufferPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalBufferPropertiesKHR, STRUCT_CACHE_VkExternalBufferPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalBufferPropertiesKHR, STRUCT_CACHE_VkExternalBufferPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalBufferPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalBufferPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalBufferPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalBufferPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "externalMemoryProperties": {
    get() {
    return this._externalMemoryProperties;
    },
    },
  
});

VkExternalBufferPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._externalMemoryProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._externalMemoryProperties.memoryBuffer) this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._externalMemoryProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkExternalBufferPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalBufferPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalBufferPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalBufferPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.externalMemoryProperties !== null) {
        copy.externalMemoryProperties = original.externalMemoryProperties.constructor.createCopyFrom(original.externalMemoryProperties);
      }
  
  return copy;
};

VkExternalBufferPropertiesKHR.byteLength = 0x0;

VkExternalBufferPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  externalMemoryProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceIDProperties **/
function VkPhysicalDeviceIDProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceIDProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceIDProperties, STRUCT_CACHE_VkPhysicalDeviceIDProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceIDProperties, STRUCT_CACHE_VkPhysicalDeviceIDProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceIDProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._deviceUUID = [...Array(16)].fill(0x0);
  this._driverUUID = [...Array(16)].fill(0x0);
  this._deviceLUID = [...Array(8)].fill(0x0);
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceIDProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceIDProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceIDProperties.pNext' isn't allowed to be filled");
    }
    },
  "deviceUUID": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true),
      this.memoryView.getUint8(0x8, true),
      this.memoryView.getUint8(0x9, true),
      this.memoryView.getUint8(0xA, true),
      this.memoryView.getUint8(0xB, true),
      this.memoryView.getUint8(0xC, true),
      this.memoryView.getUint8(0xD, true),
      this.memoryView.getUint8(0xE, true),
      this.memoryView.getUint8(0xF, true)
    ];
    },
    },
  "driverUUID": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true),
      this.memoryView.getUint8(0x8, true),
      this.memoryView.getUint8(0x9, true),
      this.memoryView.getUint8(0xA, true),
      this.memoryView.getUint8(0xB, true),
      this.memoryView.getUint8(0xC, true),
      this.memoryView.getUint8(0xD, true),
      this.memoryView.getUint8(0xE, true),
      this.memoryView.getUint8(0xF, true)
    ];
    },
    },
  "deviceLUID": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true)
    ];
    },
    },
  "deviceNodeMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "deviceLUIDValid": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceIDProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._deviceUUID !== null) this._deviceUUID.fill(0x0);
      else this._deviceUUID = [...Array(16)].fill(0x0);
  if (this._driverUUID !== null) this._driverUUID.fill(0x0);
      else this._driverUUID = [...Array(16)].fill(0x0);
  if (this._deviceLUID !== null) this._deviceLUID.fill(0x0);
      else this._deviceLUID = [...Array(8)].fill(0x0);
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceIDProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceIDProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceIDProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceIDProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.deviceUUID !== null) {
        copy.deviceUUID = [...Array(original.deviceUUID.length)].map((v, i) => {
          return original.deviceUUID[i];
        });
      }
  if (original.driverUUID !== null) {
        copy.driverUUID = [...Array(original.driverUUID.length)].map((v, i) => {
          return original.driverUUID[i];
        });
      }
  if (original.deviceLUID !== null) {
        copy.deviceLUID = [...Array(original.deviceLUID.length)].map((v, i) => {
          return original.deviceLUID[i];
        });
      }
  copy.deviceNodeMask = original.deviceNodeMask;
  copy.deviceLUIDValid = original.deviceLUIDValid;
  
  return copy;
};

VkPhysicalDeviceIDProperties.byteLength = 0x0;

VkPhysicalDeviceIDProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceUUID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverUUID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceLUID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceNodeMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceLUIDValid: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceIDPropertiesKHR **/
function VkPhysicalDeviceIDPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceIDPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceIDPropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceIDPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceIDPropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceIDPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceIDPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._deviceUUID = [...Array(16)].fill(0x0);
  this._driverUUID = [...Array(16)].fill(0x0);
  this._deviceLUID = [...Array(8)].fill(0x0);
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceIDPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceIDPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceIDPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "deviceUUID": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true),
      this.memoryView.getUint8(0x8, true),
      this.memoryView.getUint8(0x9, true),
      this.memoryView.getUint8(0xA, true),
      this.memoryView.getUint8(0xB, true),
      this.memoryView.getUint8(0xC, true),
      this.memoryView.getUint8(0xD, true),
      this.memoryView.getUint8(0xE, true),
      this.memoryView.getUint8(0xF, true)
    ];
    },
    },
  "driverUUID": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true),
      this.memoryView.getUint8(0x8, true),
      this.memoryView.getUint8(0x9, true),
      this.memoryView.getUint8(0xA, true),
      this.memoryView.getUint8(0xB, true),
      this.memoryView.getUint8(0xC, true),
      this.memoryView.getUint8(0xD, true),
      this.memoryView.getUint8(0xE, true),
      this.memoryView.getUint8(0xF, true)
    ];
    },
    },
  "deviceLUID": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true)
    ];
    },
    },
  "deviceNodeMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "deviceLUIDValid": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceIDPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._deviceUUID !== null) this._deviceUUID.fill(0x0);
      else this._deviceUUID = [...Array(16)].fill(0x0);
  if (this._driverUUID !== null) this._driverUUID.fill(0x0);
      else this._driverUUID = [...Array(16)].fill(0x0);
  if (this._deviceLUID !== null) this._deviceLUID.fill(0x0);
      else this._deviceLUID = [...Array(8)].fill(0x0);
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceIDPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceIDPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceIDPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceIDPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.deviceUUID !== null) {
        copy.deviceUUID = [...Array(original.deviceUUID.length)].map((v, i) => {
          return original.deviceUUID[i];
        });
      }
  if (original.driverUUID !== null) {
        copy.driverUUID = [...Array(original.driverUUID.length)].map((v, i) => {
          return original.driverUUID[i];
        });
      }
  if (original.deviceLUID !== null) {
        copy.deviceLUID = [...Array(original.deviceLUID.length)].map((v, i) => {
          return original.deviceLUID[i];
        });
      }
  copy.deviceNodeMask = original.deviceNodeMask;
  copy.deviceLUIDValid = original.deviceLUIDValid;
  
  return copy;
};

VkPhysicalDeviceIDPropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceIDPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceUUID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverUUID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceLUID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceNodeMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceLUIDValid: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalMemoryImageCreateInfo **/
function VkExternalMemoryImageCreateInfo(opts, byteOffset) {
  if (new.target !== VkExternalMemoryImageCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalMemoryImageCreateInfo, STRUCT_CACHE_VkExternalMemoryImageCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalMemoryImageCreateInfo, STRUCT_CACHE_VkExternalMemoryImageCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalMemoryImageCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExternalMemoryImageCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalMemoryImageCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalMemoryImageCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalMemoryImageCreateInfo.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExternalMemoryImageCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExternalMemoryImageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryImageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkExternalMemoryImageCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalMemoryImageCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExternalMemoryImageCreateInfo.byteLength = 0x0;

VkExternalMemoryImageCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalMemoryImageCreateInfoKHR **/
function VkExternalMemoryImageCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkExternalMemoryImageCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalMemoryImageCreateInfoKHR, STRUCT_CACHE_VkExternalMemoryImageCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalMemoryImageCreateInfoKHR, STRUCT_CACHE_VkExternalMemoryImageCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalMemoryImageCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExternalMemoryImageCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalMemoryImageCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalMemoryImageCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalMemoryImageCreateInfoKHR.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExternalMemoryImageCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExternalMemoryImageCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryImageCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkExternalMemoryImageCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalMemoryImageCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExternalMemoryImageCreateInfoKHR.byteLength = 0x0;

VkExternalMemoryImageCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalMemoryBufferCreateInfo **/
function VkExternalMemoryBufferCreateInfo(opts, byteOffset) {
  if (new.target !== VkExternalMemoryBufferCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalMemoryBufferCreateInfo, STRUCT_CACHE_VkExternalMemoryBufferCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalMemoryBufferCreateInfo, STRUCT_CACHE_VkExternalMemoryBufferCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalMemoryBufferCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExternalMemoryBufferCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalMemoryBufferCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalMemoryBufferCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalMemoryBufferCreateInfo.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExternalMemoryBufferCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExternalMemoryBufferCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryBufferCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkExternalMemoryBufferCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalMemoryBufferCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExternalMemoryBufferCreateInfo.byteLength = 0x0;

VkExternalMemoryBufferCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalMemoryBufferCreateInfoKHR **/
function VkExternalMemoryBufferCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkExternalMemoryBufferCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalMemoryBufferCreateInfoKHR, STRUCT_CACHE_VkExternalMemoryBufferCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalMemoryBufferCreateInfoKHR, STRUCT_CACHE_VkExternalMemoryBufferCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalMemoryBufferCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExternalMemoryBufferCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalMemoryBufferCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalMemoryBufferCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalMemoryBufferCreateInfoKHR.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExternalMemoryBufferCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExternalMemoryBufferCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryBufferCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkExternalMemoryBufferCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalMemoryBufferCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExternalMemoryBufferCreateInfoKHR.byteLength = 0x0;

VkExternalMemoryBufferCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportMemoryAllocateInfo **/
function VkExportMemoryAllocateInfo(opts, byteOffset) {
  if (new.target !== VkExportMemoryAllocateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportMemoryAllocateInfo, STRUCT_CACHE_VkExportMemoryAllocateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportMemoryAllocateInfo, STRUCT_CACHE_VkExportMemoryAllocateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportMemoryAllocateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportMemoryAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportMemoryAllocateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportMemoryAllocateInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportMemoryAllocateInfo.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExportMemoryAllocateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExportMemoryAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportMemoryAllocateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportMemoryAllocateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExportMemoryAllocateInfo.byteLength = 0x0;

VkExportMemoryAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportMemoryAllocateInfoKHR **/
function VkExportMemoryAllocateInfoKHR(opts, byteOffset) {
  if (new.target !== VkExportMemoryAllocateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportMemoryAllocateInfoKHR, STRUCT_CACHE_VkExportMemoryAllocateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportMemoryAllocateInfoKHR, STRUCT_CACHE_VkExportMemoryAllocateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportMemoryAllocateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportMemoryAllocateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportMemoryAllocateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportMemoryAllocateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportMemoryAllocateInfoKHR.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExportMemoryAllocateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExportMemoryAllocateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryAllocateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportMemoryAllocateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportMemoryAllocateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExportMemoryAllocateInfoKHR.byteLength = 0x0;

VkExportMemoryAllocateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImportMemoryWin32HandleInfoKHR **/
function VkImportMemoryWin32HandleInfoKHR(opts, byteOffset) {
  if (new.target !== VkImportMemoryWin32HandleInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImportMemoryWin32HandleInfoKHR, STRUCT_CACHE_VkImportMemoryWin32HandleInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImportMemoryWin32HandleInfoKHR, STRUCT_CACHE_VkImportMemoryWin32HandleInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImportMemoryWin32HandleInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkImportMemoryWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportMemoryWin32HandleInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportMemoryWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportMemoryWin32HandleInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "handle": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkImportMemoryWin32HandleInfoKHR.handle")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._name = buffer;
        return this.name;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._name), true);
    } else if (value === null) {
      this._name = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkImportMemoryWin32HandleInfoKHR.name");
    }
    
    }
    },
  
});

VkImportMemoryWin32HandleInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

VkImportMemoryWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportMemoryWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImportMemoryWin32HandleInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImportMemoryWin32HandleInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleType = original.handleType;
  copy.handle = original.handle;
  copy.name = original.name;
  
  return copy;
};

VkImportMemoryWin32HandleInfoKHR.byteLength = 0x0;

VkImportMemoryWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportMemoryWin32HandleInfoKHR **/
function VkExportMemoryWin32HandleInfoKHR(opts, byteOffset) {
  if (new.target !== VkExportMemoryWin32HandleInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportMemoryWin32HandleInfoKHR, STRUCT_CACHE_VkExportMemoryWin32HandleInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportMemoryWin32HandleInfoKHR, STRUCT_CACHE_VkExportMemoryWin32HandleInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportMemoryWin32HandleInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pAttributes !== void 0) this.pAttributes = opts.pAttributes;
    if (opts.dwAccess !== void 0) this.dwAccess = opts.dwAccess;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkExportMemoryWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportMemoryWin32HandleInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportMemoryWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "pAttributes": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkExportMemoryWin32HandleInfoKHR.pAttributes")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "dwAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportMemoryWin32HandleInfoKHR.dwAccess");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._name = buffer;
        return this.name;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._name), true);
    } else if (value === null) {
      this._name = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkExportMemoryWin32HandleInfoKHR.name");
    }
    
    }
    },
  
});

VkExportMemoryWin32HandleInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pAttributes !== void 0) this.pAttributes = opts.pAttributes;
    if (opts.dwAccess !== void 0) this.dwAccess = opts.dwAccess;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

VkExportMemoryWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportMemoryWin32HandleInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportMemoryWin32HandleInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pAttributes = original.pAttributes;
  copy.dwAccess = original.dwAccess;
  copy.name = original.name;
  
  return copy;
};

VkExportMemoryWin32HandleInfoKHR.byteLength = 0x0;

VkExportMemoryWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttributes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dwAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryWin32HandlePropertiesKHR **/
function VkMemoryWin32HandlePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkMemoryWin32HandlePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryWin32HandlePropertiesKHR, STRUCT_CACHE_VkMemoryWin32HandlePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryWin32HandlePropertiesKHR, STRUCT_CACHE_VkMemoryWin32HandlePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryWin32HandlePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryWin32HandlePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryWin32HandlePropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryWin32HandlePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "memoryTypeBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkMemoryWin32HandlePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkMemoryWin32HandlePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryWin32HandlePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMemoryWin32HandlePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryWin32HandlePropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.memoryTypeBits = original.memoryTypeBits;
  
  return copy;
};

VkMemoryWin32HandlePropertiesKHR.byteLength = 0x0;

VkMemoryWin32HandlePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryTypeBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryGetWin32HandleInfoKHR **/
function VkMemoryGetWin32HandleInfoKHR(opts, byteOffset) {
  if (new.target !== VkMemoryGetWin32HandleInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryGetWin32HandleInfoKHR, STRUCT_CACHE_VkMemoryGetWin32HandleInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryGetWin32HandleInfoKHR, STRUCT_CACHE_VkMemoryGetWin32HandleInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryGetWin32HandleInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkMemoryGetWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryGetWin32HandleInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryGetWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkMemoryGetWin32HandleInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryGetWin32HandleInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkMemoryGetWin32HandleInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkMemoryGetWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryGetWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryGetWin32HandleInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryGetWin32HandleInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  copy.handleType = original.handleType;
  
  return copy;
};

VkMemoryGetWin32HandleInfoKHR.byteLength = 0x0;

VkMemoryGetWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImportMemoryFdInfoKHR **/
function VkImportMemoryFdInfoKHR(opts, byteOffset) {
  if (new.target !== VkImportMemoryFdInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImportMemoryFdInfoKHR, STRUCT_CACHE_VkImportMemoryFdInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImportMemoryFdInfoKHR, STRUCT_CACHE_VkImportMemoryFdInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImportMemoryFdInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.fd !== void 0) this.fd = opts.fd;
    
  }
};

Object.defineProperties(VkImportMemoryFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportMemoryFdInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportMemoryFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportMemoryFdInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "fd": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportMemoryFdInfoKHR.fd");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImportMemoryFdInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.fd !== void 0) this.fd = opts.fd;
    
  }
};

VkImportMemoryFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportMemoryFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImportMemoryFdInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImportMemoryFdInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleType = original.handleType;
  copy.fd = original.fd;
  
  return copy;
};

VkImportMemoryFdInfoKHR.byteLength = 0x0;

VkImportMemoryFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryFdPropertiesKHR **/
function VkMemoryFdPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkMemoryFdPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryFdPropertiesKHR, STRUCT_CACHE_VkMemoryFdPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryFdPropertiesKHR, STRUCT_CACHE_VkMemoryFdPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryFdPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryFdPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryFdPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryFdPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "memoryTypeBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkMemoryFdPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkMemoryFdPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryFdPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMemoryFdPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryFdPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.memoryTypeBits = original.memoryTypeBits;
  
  return copy;
};

VkMemoryFdPropertiesKHR.byteLength = 0x0;

VkMemoryFdPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryTypeBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryGetFdInfoKHR **/
function VkMemoryGetFdInfoKHR(opts, byteOffset) {
  if (new.target !== VkMemoryGetFdInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryGetFdInfoKHR, STRUCT_CACHE_VkMemoryGetFdInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryGetFdInfoKHR, STRUCT_CACHE_VkMemoryGetFdInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryGetFdInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkMemoryGetFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryGetFdInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryGetFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkMemoryGetFdInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryGetFdInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkMemoryGetFdInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkMemoryGetFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryGetFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryGetFdInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryGetFdInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  copy.handleType = original.handleType;
  
  return copy;
};

VkMemoryGetFdInfoKHR.byteLength = 0x0;

VkMemoryGetFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkWin32KeyedMutexAcquireReleaseInfoKHR **/
function VkWin32KeyedMutexAcquireReleaseInfoKHR(opts, byteOffset) {
  if (new.target !== VkWin32KeyedMutexAcquireReleaseInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkWin32KeyedMutexAcquireReleaseInfoKHR, STRUCT_CACHE_VkWin32KeyedMutexAcquireReleaseInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkWin32KeyedMutexAcquireReleaseInfoKHR, STRUCT_CACHE_VkWin32KeyedMutexAcquireReleaseInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkWin32KeyedMutexAcquireReleaseInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAcquireSyncs = null;
  this._pAcquireSyncsNative = null;
  this._pAcquireKeys = null;
  this._pAcquireTimeouts = null;
  
  this._pReleaseSyncs = null;
  this._pReleaseSyncsNative = null;
  this._pReleaseKeys = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.acquireCount !== void 0) this.acquireCount = opts.acquireCount;
    if (opts.pAcquireSyncs !== void 0) this.pAcquireSyncs = opts.pAcquireSyncs;
    if (opts.pAcquireKeys !== void 0) this.pAcquireKeys = opts.pAcquireKeys;
    if (opts.pAcquireTimeouts !== void 0) this.pAcquireTimeouts = opts.pAcquireTimeouts;
    if (opts.releaseCount !== void 0) this.releaseCount = opts.releaseCount;
    if (opts.pReleaseSyncs !== void 0) this.pReleaseSyncs = opts.pReleaseSyncs;
    if (opts.pReleaseKeys !== void 0) this.pReleaseKeys = opts.pReleaseKeys;
    
  }
};

Object.defineProperties(VkWin32KeyedMutexAcquireReleaseInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWin32KeyedMutexAcquireReleaseInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "acquireCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.acquireCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAcquireSyncs": {
    get() {
    if (this._pAcquireSyncs === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.acquireCount, VkDeviceMemory);
      this._pAcquireSyncs = array;
      return this.pAcquireSyncs;
    } else {
      return this._pAcquireSyncs;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAcquireSyncs = value;
    } else if (value === null) {
      this._pAcquireSyncs = null;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs': Expected 'Array VkDeviceMemory' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pAcquireKeys": {
    get() {
    return this._pAcquireKeys;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pAcquireKeys = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pAcquireKeys = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireKeys': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pAcquireTimeouts": {
    get() {
    return this._pAcquireTimeouts;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pAcquireTimeouts = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pAcquireTimeouts = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireTimeouts': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "releaseCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.releaseCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pReleaseSyncs": {
    get() {
    if (this._pReleaseSyncs === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.releaseCount, VkDeviceMemory);
      this._pReleaseSyncs = array;
      return this.pReleaseSyncs;
    } else {
      return this._pReleaseSyncs;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pReleaseSyncs = value;
    } else if (value === null) {
      this._pReleaseSyncs = null;
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs': Expected 'Array VkDeviceMemory' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pReleaseKeys": {
    get() {
    return this._pReleaseKeys;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pReleaseKeys = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pReleaseKeys = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseKeys': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkWin32KeyedMutexAcquireReleaseInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAcquireSyncs = null;
  this._pAcquireSyncsNative = null;
  this._pAcquireKeys = null;
  this._pAcquireTimeouts = null;
  
  this._pReleaseSyncs = null;
  this._pReleaseSyncsNative = null;
  this._pReleaseKeys = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.acquireCount !== void 0) this.acquireCount = opts.acquireCount;
    if (opts.pAcquireSyncs !== void 0) this.pAcquireSyncs = opts.pAcquireSyncs;
    if (opts.pAcquireKeys !== void 0) this.pAcquireKeys = opts.pAcquireKeys;
    if (opts.pAcquireTimeouts !== void 0) this.pAcquireTimeouts = opts.pAcquireTimeouts;
    if (opts.releaseCount !== void 0) this.releaseCount = opts.releaseCount;
    if (opts.pReleaseSyncs !== void 0) this.pReleaseSyncs = opts.pReleaseSyncs;
    if (opts.pReleaseKeys !== void 0) this.pReleaseKeys = opts.pReleaseKeys;
    
  }
};

VkWin32KeyedMutexAcquireReleaseInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAcquireSyncs !== null) {
    let array = this._pAcquireSyncs;
    
    if (array.length !== this.acquireCount) {
      throw new RangeError("Invalid array length, expected length of 'acquireCount' for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDeviceMemory)) {
        throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs[" + ii + "]': Expected 'VkDeviceMemory' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAcquireSyncsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAcquireSyncsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pReleaseSyncs !== null) {
    let array = this._pReleaseSyncs;
    
    if (array.length !== this.releaseCount) {
      throw new RangeError("Invalid array length, expected length of 'releaseCount' for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDeviceMemory)) {
        throw new TypeError("Invalid type for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs[" + ii + "]': Expected 'VkDeviceMemory' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pReleaseSyncsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pReleaseSyncsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkWin32KeyedMutexAcquireReleaseInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkWin32KeyedMutexAcquireReleaseInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkWin32KeyedMutexAcquireReleaseInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.acquireCount = original.acquireCount;
  if (original.pAcquireSyncs !== null) {
        copy.pAcquireSyncs = [...Array(original.pAcquireSyncs.length)].map((v, i) => {
          return original.pAcquireSyncs[i].constructor.createCopyFrom(original.pAcquireSyncs[i]);
        });
      }
  if (original.pAcquireKeys !== null) {
        copy.pAcquireKeys = new BigUint64Array(original.pAcquireKeys);
      }
  if (original.pAcquireTimeouts !== null) {
        copy.pAcquireTimeouts = new Uint32Array(original.pAcquireTimeouts);
      }
  copy.releaseCount = original.releaseCount;
  if (original.pReleaseSyncs !== null) {
        copy.pReleaseSyncs = [...Array(original.pReleaseSyncs.length)].map((v, i) => {
          return original.pReleaseSyncs[i].constructor.createCopyFrom(original.pReleaseSyncs[i]);
        });
      }
  if (original.pReleaseKeys !== null) {
        copy.pReleaseKeys = new BigUint64Array(original.pReleaseKeys);
      }
  
  return copy;
};

VkWin32KeyedMutexAcquireReleaseInfoKHR.byteLength = 0x0;

VkWin32KeyedMutexAcquireReleaseInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  acquireCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAcquireSyncs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAcquireKeys: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAcquireTimeouts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  releaseCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pReleaseSyncs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pReleaseKeys: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExternalSemaphoreInfo **/
function VkPhysicalDeviceExternalSemaphoreInfo(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExternalSemaphoreInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExternalSemaphoreInfo, STRUCT_CACHE_VkPhysicalDeviceExternalSemaphoreInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExternalSemaphoreInfo, STRUCT_CACHE_VkPhysicalDeviceExternalSemaphoreInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExternalSemaphoreInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalSemaphoreInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalSemaphoreInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfo.pNext'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalSemaphoreInfo.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceExternalSemaphoreInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkPhysicalDeviceExternalSemaphoreInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalSemaphoreInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceExternalSemaphoreInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExternalSemaphoreInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleType = original.handleType;
  
  return copy;
};

VkPhysicalDeviceExternalSemaphoreInfo.byteLength = 0x0;

VkPhysicalDeviceExternalSemaphoreInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExternalSemaphoreInfoKHR **/
function VkPhysicalDeviceExternalSemaphoreInfoKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExternalSemaphoreInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExternalSemaphoreInfoKHR, STRUCT_CACHE_VkPhysicalDeviceExternalSemaphoreInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExternalSemaphoreInfoKHR, STRUCT_CACHE_VkPhysicalDeviceExternalSemaphoreInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExternalSemaphoreInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalSemaphoreInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalSemaphoreInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfoKHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfoKHR.pNext'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalSemaphoreInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceExternalSemaphoreInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkPhysicalDeviceExternalSemaphoreInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalSemaphoreInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceExternalSemaphoreInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExternalSemaphoreInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleType = original.handleType;
  
  return copy;
};

VkPhysicalDeviceExternalSemaphoreInfoKHR.byteLength = 0x0;

VkPhysicalDeviceExternalSemaphoreInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalSemaphoreProperties **/
function VkExternalSemaphoreProperties(opts, byteOffset) {
  if (new.target !== VkExternalSemaphoreProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalSemaphoreProperties, STRUCT_CACHE_VkExternalSemaphoreProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalSemaphoreProperties, STRUCT_CACHE_VkExternalSemaphoreProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalSemaphoreProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalSemaphoreProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalSemaphoreProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalSemaphoreProperties.pNext' isn't allowed to be filled");
    }
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "externalSemaphoreFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkExternalSemaphoreProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkExternalSemaphoreProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalSemaphoreProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalSemaphoreProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalSemaphoreProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.exportFromImportedHandleTypes = original.exportFromImportedHandleTypes;
  copy.compatibleHandleTypes = original.compatibleHandleTypes;
  copy.externalSemaphoreFeatures = original.externalSemaphoreFeatures;
  
  return copy;
};

VkExternalSemaphoreProperties.byteLength = 0x0;

VkExternalSemaphoreProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compatibleHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  externalSemaphoreFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalSemaphorePropertiesKHR **/
function VkExternalSemaphorePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkExternalSemaphorePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalSemaphorePropertiesKHR, STRUCT_CACHE_VkExternalSemaphorePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalSemaphorePropertiesKHR, STRUCT_CACHE_VkExternalSemaphorePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalSemaphorePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalSemaphorePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalSemaphorePropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalSemaphorePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "externalSemaphoreFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkExternalSemaphorePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkExternalSemaphorePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalSemaphorePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalSemaphorePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalSemaphorePropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.exportFromImportedHandleTypes = original.exportFromImportedHandleTypes;
  copy.compatibleHandleTypes = original.compatibleHandleTypes;
  copy.externalSemaphoreFeatures = original.externalSemaphoreFeatures;
  
  return copy;
};

VkExternalSemaphorePropertiesKHR.byteLength = 0x0;

VkExternalSemaphorePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compatibleHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  externalSemaphoreFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportSemaphoreCreateInfo **/
function VkExportSemaphoreCreateInfo(opts, byteOffset) {
  if (new.target !== VkExportSemaphoreCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportSemaphoreCreateInfo, STRUCT_CACHE_VkExportSemaphoreCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportSemaphoreCreateInfo, STRUCT_CACHE_VkExportSemaphoreCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportSemaphoreCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportSemaphoreCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportSemaphoreCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportSemaphoreCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportSemaphoreCreateInfo.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExportSemaphoreCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExportSemaphoreCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportSemaphoreCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportSemaphoreCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportSemaphoreCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExportSemaphoreCreateInfo.byteLength = 0x0;

VkExportSemaphoreCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportSemaphoreCreateInfoKHR **/
function VkExportSemaphoreCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkExportSemaphoreCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportSemaphoreCreateInfoKHR, STRUCT_CACHE_VkExportSemaphoreCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportSemaphoreCreateInfoKHR, STRUCT_CACHE_VkExportSemaphoreCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportSemaphoreCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportSemaphoreCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportSemaphoreCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportSemaphoreCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportSemaphoreCreateInfoKHR.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExportSemaphoreCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExportSemaphoreCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportSemaphoreCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportSemaphoreCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportSemaphoreCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExportSemaphoreCreateInfoKHR.byteLength = 0x0;

VkExportSemaphoreCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImportSemaphoreWin32HandleInfoKHR **/
function VkImportSemaphoreWin32HandleInfoKHR(opts, byteOffset) {
  if (new.target !== VkImportSemaphoreWin32HandleInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImportSemaphoreWin32HandleInfoKHR, STRUCT_CACHE_VkImportSemaphoreWin32HandleInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImportSemaphoreWin32HandleInfoKHR, STRUCT_CACHE_VkImportSemaphoreWin32HandleInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImportSemaphoreWin32HandleInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._semaphore = null;
  
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkImportSemaphoreWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportSemaphoreWin32HandleInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportSemaphoreWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._semaphore = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImportSemaphoreWin32HandleInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportSemaphoreWin32HandleInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportSemaphoreWin32HandleInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "handle": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkImportSemaphoreWin32HandleInfoKHR.handle")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._name = buffer;
        return this.name;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._name), true);
    } else if (value === null) {
      this._name = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkImportSemaphoreWin32HandleInfoKHR.name");
    }
    
    }
    },
  
});

VkImportSemaphoreWin32HandleInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._semaphore = null;
  
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

VkImportSemaphoreWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportSemaphoreWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImportSemaphoreWin32HandleInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImportSemaphoreWin32HandleInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.semaphore !== null) {
        copy.semaphore = original.semaphore.constructor.createCopyFrom(original.semaphore);
      }
  copy.flags = original.flags;
  copy.handleType = original.handleType;
  copy.handle = original.handle;
  copy.name = original.name;
  
  return copy;
};

VkImportSemaphoreWin32HandleInfoKHR.byteLength = 0x0;

VkImportSemaphoreWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphore: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportSemaphoreWin32HandleInfoKHR **/
function VkExportSemaphoreWin32HandleInfoKHR(opts, byteOffset) {
  if (new.target !== VkExportSemaphoreWin32HandleInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportSemaphoreWin32HandleInfoKHR, STRUCT_CACHE_VkExportSemaphoreWin32HandleInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportSemaphoreWin32HandleInfoKHR, STRUCT_CACHE_VkExportSemaphoreWin32HandleInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportSemaphoreWin32HandleInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pAttributes !== void 0) this.pAttributes = opts.pAttributes;
    if (opts.dwAccess !== void 0) this.dwAccess = opts.dwAccess;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkExportSemaphoreWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportSemaphoreWin32HandleInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportSemaphoreWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "pAttributes": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkExportSemaphoreWin32HandleInfoKHR.pAttributes")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "dwAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportSemaphoreWin32HandleInfoKHR.dwAccess");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._name = buffer;
        return this.name;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._name), true);
    } else if (value === null) {
      this._name = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkExportSemaphoreWin32HandleInfoKHR.name");
    }
    
    }
    },
  
});

VkExportSemaphoreWin32HandleInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pAttributes !== void 0) this.pAttributes = opts.pAttributes;
    if (opts.dwAccess !== void 0) this.dwAccess = opts.dwAccess;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

VkExportSemaphoreWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportSemaphoreWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportSemaphoreWin32HandleInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportSemaphoreWin32HandleInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pAttributes = original.pAttributes;
  copy.dwAccess = original.dwAccess;
  copy.name = original.name;
  
  return copy;
};

VkExportSemaphoreWin32HandleInfoKHR.byteLength = 0x0;

VkExportSemaphoreWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttributes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dwAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkD3D12FenceSubmitInfoKHR **/
function VkD3D12FenceSubmitInfoKHR(opts, byteOffset) {
  if (new.target !== VkD3D12FenceSubmitInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkD3D12FenceSubmitInfoKHR, STRUCT_CACHE_VkD3D12FenceSubmitInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkD3D12FenceSubmitInfoKHR, STRUCT_CACHE_VkD3D12FenceSubmitInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkD3D12FenceSubmitInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphoreValues = null;
  
  this._pSignalSemaphoreValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreValuesCount !== void 0) this.waitSemaphoreValuesCount = opts.waitSemaphoreValuesCount;
    if (opts.pWaitSemaphoreValues !== void 0) this.pWaitSemaphoreValues = opts.pWaitSemaphoreValues;
    if (opts.signalSemaphoreValuesCount !== void 0) this.signalSemaphoreValuesCount = opts.signalSemaphoreValuesCount;
    if (opts.pSignalSemaphoreValues !== void 0) this.pSignalSemaphoreValues = opts.pSignalSemaphoreValues;
    
  }
};

Object.defineProperties(VkD3D12FenceSubmitInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkD3D12FenceSubmitInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkD3D12FenceSubmitInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "waitSemaphoreValuesCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkD3D12FenceSubmitInfoKHR.waitSemaphoreValuesCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pWaitSemaphoreValues": {
    get() {
    return this._pWaitSemaphoreValues;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pWaitSemaphoreValues = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pWaitSemaphoreValues = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkD3D12FenceSubmitInfoKHR.pWaitSemaphoreValues': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "signalSemaphoreValuesCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkD3D12FenceSubmitInfoKHR.signalSemaphoreValuesCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSignalSemaphoreValues": {
    get() {
    return this._pSignalSemaphoreValues;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pSignalSemaphoreValues = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pSignalSemaphoreValues = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkD3D12FenceSubmitInfoKHR.pSignalSemaphoreValues': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkD3D12FenceSubmitInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphoreValues = null;
  
  this._pSignalSemaphoreValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreValuesCount !== void 0) this.waitSemaphoreValuesCount = opts.waitSemaphoreValuesCount;
    if (opts.pWaitSemaphoreValues !== void 0) this.pWaitSemaphoreValues = opts.pWaitSemaphoreValues;
    if (opts.signalSemaphoreValuesCount !== void 0) this.signalSemaphoreValuesCount = opts.signalSemaphoreValuesCount;
    if (opts.pSignalSemaphoreValues !== void 0) this.pSignalSemaphoreValues = opts.pSignalSemaphoreValues;
    
  }
};

VkD3D12FenceSubmitInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkD3D12FenceSubmitInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkD3D12FenceSubmitInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkD3D12FenceSubmitInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.waitSemaphoreValuesCount = original.waitSemaphoreValuesCount;
  if (original.pWaitSemaphoreValues !== null) {
        copy.pWaitSemaphoreValues = new BigUint64Array(original.pWaitSemaphoreValues);
      }
  copy.signalSemaphoreValuesCount = original.signalSemaphoreValuesCount;
  if (original.pSignalSemaphoreValues !== null) {
        copy.pSignalSemaphoreValues = new BigUint64Array(original.pSignalSemaphoreValues);
      }
  
  return copy;
};

VkD3D12FenceSubmitInfoKHR.byteLength = 0x0;

VkD3D12FenceSubmitInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  waitSemaphoreValuesCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pWaitSemaphoreValues: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  signalSemaphoreValuesCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSignalSemaphoreValues: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSemaphoreGetWin32HandleInfoKHR **/
function VkSemaphoreGetWin32HandleInfoKHR(opts, byteOffset) {
  if (new.target !== VkSemaphoreGetWin32HandleInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSemaphoreGetWin32HandleInfoKHR, STRUCT_CACHE_VkSemaphoreGetWin32HandleInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSemaphoreGetWin32HandleInfoKHR, STRUCT_CACHE_VkSemaphoreGetWin32HandleInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSemaphoreGetWin32HandleInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkSemaphoreGetWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreGetWin32HandleInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSemaphoreGetWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._semaphore = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreGetWin32HandleInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreGetWin32HandleInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSemaphoreGetWin32HandleInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkSemaphoreGetWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreGetWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSemaphoreGetWin32HandleInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSemaphoreGetWin32HandleInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.semaphore !== null) {
        copy.semaphore = original.semaphore.constructor.createCopyFrom(original.semaphore);
      }
  copy.handleType = original.handleType;
  
  return copy;
};

VkSemaphoreGetWin32HandleInfoKHR.byteLength = 0x0;

VkSemaphoreGetWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphore: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImportSemaphoreFdInfoKHR **/
function VkImportSemaphoreFdInfoKHR(opts, byteOffset) {
  if (new.target !== VkImportSemaphoreFdInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImportSemaphoreFdInfoKHR, STRUCT_CACHE_VkImportSemaphoreFdInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImportSemaphoreFdInfoKHR, STRUCT_CACHE_VkImportSemaphoreFdInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImportSemaphoreFdInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._semaphore = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.fd !== void 0) this.fd = opts.fd;
    
  }
};

Object.defineProperties(VkImportSemaphoreFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportSemaphoreFdInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportSemaphoreFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._semaphore = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportSemaphoreFdInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportSemaphoreFdInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "fd": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportSemaphoreFdInfoKHR.fd");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImportSemaphoreFdInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._semaphore = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.fd !== void 0) this.fd = opts.fd;
    
  }
};

VkImportSemaphoreFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportSemaphoreFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImportSemaphoreFdInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImportSemaphoreFdInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.semaphore !== null) {
        copy.semaphore = original.semaphore.constructor.createCopyFrom(original.semaphore);
      }
  copy.flags = original.flags;
  copy.handleType = original.handleType;
  copy.fd = original.fd;
  
  return copy;
};

VkImportSemaphoreFdInfoKHR.byteLength = 0x0;

VkImportSemaphoreFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphore: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSemaphoreGetFdInfoKHR **/
function VkSemaphoreGetFdInfoKHR(opts, byteOffset) {
  if (new.target !== VkSemaphoreGetFdInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSemaphoreGetFdInfoKHR, STRUCT_CACHE_VkSemaphoreGetFdInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSemaphoreGetFdInfoKHR, STRUCT_CACHE_VkSemaphoreGetFdInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSemaphoreGetFdInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkSemaphoreGetFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreGetFdInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSemaphoreGetFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._semaphore = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreGetFdInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreGetFdInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSemaphoreGetFdInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkSemaphoreGetFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreGetFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSemaphoreGetFdInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSemaphoreGetFdInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.semaphore !== null) {
        copy.semaphore = original.semaphore.constructor.createCopyFrom(original.semaphore);
      }
  copy.handleType = original.handleType;
  
  return copy;
};

VkSemaphoreGetFdInfoKHR.byteLength = 0x0;

VkSemaphoreGetFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphore: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExternalFenceInfo **/
function VkPhysicalDeviceExternalFenceInfo(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExternalFenceInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExternalFenceInfo, STRUCT_CACHE_VkPhysicalDeviceExternalFenceInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExternalFenceInfo, STRUCT_CACHE_VkPhysicalDeviceExternalFenceInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExternalFenceInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalFenceInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalFenceInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalFenceInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalFenceInfo.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceExternalFenceInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkPhysicalDeviceExternalFenceInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalFenceInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceExternalFenceInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExternalFenceInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleType = original.handleType;
  
  return copy;
};

VkPhysicalDeviceExternalFenceInfo.byteLength = 0x0;

VkPhysicalDeviceExternalFenceInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExternalFenceInfoKHR **/
function VkPhysicalDeviceExternalFenceInfoKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExternalFenceInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExternalFenceInfoKHR, STRUCT_CACHE_VkPhysicalDeviceExternalFenceInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExternalFenceInfoKHR, STRUCT_CACHE_VkPhysicalDeviceExternalFenceInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExternalFenceInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalFenceInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalFenceInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalFenceInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalFenceInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceExternalFenceInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkPhysicalDeviceExternalFenceInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalFenceInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceExternalFenceInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExternalFenceInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleType = original.handleType;
  
  return copy;
};

VkPhysicalDeviceExternalFenceInfoKHR.byteLength = 0x0;

VkPhysicalDeviceExternalFenceInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalFenceProperties **/
function VkExternalFenceProperties(opts, byteOffset) {
  if (new.target !== VkExternalFenceProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalFenceProperties, STRUCT_CACHE_VkExternalFenceProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalFenceProperties, STRUCT_CACHE_VkExternalFenceProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalFenceProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalFenceProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalFenceProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalFenceProperties.pNext' isn't allowed to be filled");
    }
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "externalFenceFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkExternalFenceProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkExternalFenceProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalFenceProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalFenceProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalFenceProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.exportFromImportedHandleTypes = original.exportFromImportedHandleTypes;
  copy.compatibleHandleTypes = original.compatibleHandleTypes;
  copy.externalFenceFeatures = original.externalFenceFeatures;
  
  return copy;
};

VkExternalFenceProperties.byteLength = 0x0;

VkExternalFenceProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compatibleHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  externalFenceFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExternalFencePropertiesKHR **/
function VkExternalFencePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkExternalFencePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExternalFencePropertiesKHR, STRUCT_CACHE_VkExternalFencePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExternalFencePropertiesKHR, STRUCT_CACHE_VkExternalFencePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExternalFencePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkExternalFencePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExternalFencePropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExternalFencePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "exportFromImportedHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "compatibleHandleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "externalFenceFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkExternalFencePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkExternalFencePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalFencePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkExternalFencePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExternalFencePropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.exportFromImportedHandleTypes = original.exportFromImportedHandleTypes;
  copy.compatibleHandleTypes = original.compatibleHandleTypes;
  copy.externalFenceFeatures = original.externalFenceFeatures;
  
  return copy;
};

VkExternalFencePropertiesKHR.byteLength = 0x0;

VkExternalFencePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  exportFromImportedHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compatibleHandleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  externalFenceFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportFenceCreateInfo **/
function VkExportFenceCreateInfo(opts, byteOffset) {
  if (new.target !== VkExportFenceCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportFenceCreateInfo, STRUCT_CACHE_VkExportFenceCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportFenceCreateInfo, STRUCT_CACHE_VkExportFenceCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportFenceCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportFenceCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportFenceCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportFenceCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportFenceCreateInfo.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExportFenceCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExportFenceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportFenceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportFenceCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportFenceCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExportFenceCreateInfo.byteLength = 0x0;

VkExportFenceCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportFenceCreateInfoKHR **/
function VkExportFenceCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkExportFenceCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportFenceCreateInfoKHR, STRUCT_CACHE_VkExportFenceCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportFenceCreateInfoKHR, STRUCT_CACHE_VkExportFenceCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportFenceCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

Object.defineProperties(VkExportFenceCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportFenceCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportFenceCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "handleTypes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportFenceCreateInfoKHR.handleTypes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkExportFenceCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
    
  }
};

VkExportFenceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportFenceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportFenceCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportFenceCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleTypes = original.handleTypes;
  
  return copy;
};

VkExportFenceCreateInfoKHR.byteLength = 0x0;

VkExportFenceCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImportFenceWin32HandleInfoKHR **/
function VkImportFenceWin32HandleInfoKHR(opts, byteOffset) {
  if (new.target !== VkImportFenceWin32HandleInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImportFenceWin32HandleInfoKHR, STRUCT_CACHE_VkImportFenceWin32HandleInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImportFenceWin32HandleInfoKHR, STRUCT_CACHE_VkImportFenceWin32HandleInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImportFenceWin32HandleInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._fence = null;
  
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkImportFenceWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportFenceWin32HandleInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportFenceWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "fence": {
    get() {
    return this._fence;
    },
    set(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._fence = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImportFenceWin32HandleInfoKHR.fence': Expected 'VkFence' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportFenceWin32HandleInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportFenceWin32HandleInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "handle": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkImportFenceWin32HandleInfoKHR.handle")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._name = buffer;
        return this.name;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._name), true);
    } else if (value === null) {
      this._name = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkImportFenceWin32HandleInfoKHR.name");
    }
    
    }
    },
  
});

VkImportFenceWin32HandleInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._fence = null;
  
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.handle !== void 0) this.handle = opts.handle;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

VkImportFenceWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportFenceWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImportFenceWin32HandleInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImportFenceWin32HandleInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.fence !== null) {
        copy.fence = original.fence.constructor.createCopyFrom(original.fence);
      }
  copy.flags = original.flags;
  copy.handleType = original.handleType;
  copy.handle = original.handle;
  copy.name = original.name;
  
  return copy;
};

VkImportFenceWin32HandleInfoKHR.byteLength = 0x0;

VkImportFenceWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkExportFenceWin32HandleInfoKHR **/
function VkExportFenceWin32HandleInfoKHR(opts, byteOffset) {
  if (new.target !== VkExportFenceWin32HandleInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkExportFenceWin32HandleInfoKHR, STRUCT_CACHE_VkExportFenceWin32HandleInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkExportFenceWin32HandleInfoKHR, STRUCT_CACHE_VkExportFenceWin32HandleInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkExportFenceWin32HandleInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pAttributes !== void 0) this.pAttributes = opts.pAttributes;
    if (opts.dwAccess !== void 0) this.dwAccess = opts.dwAccess;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

Object.defineProperties(VkExportFenceWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportFenceWin32HandleInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkExportFenceWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "pAttributes": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkExportFenceWin32HandleInfoKHR.pAttributes")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "dwAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkExportFenceWin32HandleInfoKHR.dwAccess");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "name": {
    get() {
    if (this._name !== null) {
      let str = textDecoder.decode(this._name);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._name = buffer;
        return this.name;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._name = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._name), true);
    } else if (value === null) {
      this._name = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkExportFenceWin32HandleInfoKHR.name");
    }
    
    }
    },
  
});

VkExportFenceWin32HandleInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._name = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pAttributes !== void 0) this.pAttributes = opts.pAttributes;
    if (opts.dwAccess !== void 0) this.dwAccess = opts.dwAccess;
    if (opts.name !== void 0) this.name = opts.name;
    
  }
};

VkExportFenceWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportFenceWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkExportFenceWin32HandleInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkExportFenceWin32HandleInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pAttributes = original.pAttributes;
  copy.dwAccess = original.dwAccess;
  copy.name = original.name;
  
  return copy;
};

VkExportFenceWin32HandleInfoKHR.byteLength = 0x0;

VkExportFenceWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttributes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dwAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFenceGetWin32HandleInfoKHR **/
function VkFenceGetWin32HandleInfoKHR(opts, byteOffset) {
  if (new.target !== VkFenceGetWin32HandleInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFenceGetWin32HandleInfoKHR, STRUCT_CACHE_VkFenceGetWin32HandleInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFenceGetWin32HandleInfoKHR, STRUCT_CACHE_VkFenceGetWin32HandleInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFenceGetWin32HandleInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._fence = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkFenceGetWin32HandleInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFenceGetWin32HandleInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFenceGetWin32HandleInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "fence": {
    get() {
    return this._fence;
    },
    set(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._fence = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkFenceGetWin32HandleInfoKHR.fence': Expected 'VkFence' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFenceGetWin32HandleInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkFenceGetWin32HandleInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._fence = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkFenceGetWin32HandleInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFenceGetWin32HandleInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkFenceGetWin32HandleInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFenceGetWin32HandleInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.fence !== null) {
        copy.fence = original.fence.constructor.createCopyFrom(original.fence);
      }
  copy.handleType = original.handleType;
  
  return copy;
};

VkFenceGetWin32HandleInfoKHR.byteLength = 0x0;

VkFenceGetWin32HandleInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImportFenceFdInfoKHR **/
function VkImportFenceFdInfoKHR(opts, byteOffset) {
  if (new.target !== VkImportFenceFdInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImportFenceFdInfoKHR, STRUCT_CACHE_VkImportFenceFdInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImportFenceFdInfoKHR, STRUCT_CACHE_VkImportFenceFdInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImportFenceFdInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._fence = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.fd !== void 0) this.fd = opts.fd;
    
  }
};

Object.defineProperties(VkImportFenceFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportFenceFdInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportFenceFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "fence": {
    get() {
    return this._fence;
    },
    set(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._fence = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.fence': Expected 'VkFence' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportFenceFdInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportFenceFdInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "fd": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportFenceFdInfoKHR.fd");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImportFenceFdInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._fence = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.fd !== void 0) this.fd = opts.fd;
    
  }
};

VkImportFenceFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportFenceFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImportFenceFdInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImportFenceFdInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.fence !== null) {
        copy.fence = original.fence.constructor.createCopyFrom(original.fence);
      }
  copy.flags = original.flags;
  copy.handleType = original.handleType;
  copy.fd = original.fd;
  
  return copy;
};

VkImportFenceFdInfoKHR.byteLength = 0x0;

VkImportFenceFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFenceGetFdInfoKHR **/
function VkFenceGetFdInfoKHR(opts, byteOffset) {
  if (new.target !== VkFenceGetFdInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFenceGetFdInfoKHR, STRUCT_CACHE_VkFenceGetFdInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFenceGetFdInfoKHR, STRUCT_CACHE_VkFenceGetFdInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFenceGetFdInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._fence = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

Object.defineProperties(VkFenceGetFdInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFenceGetFdInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFenceGetFdInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "fence": {
    get() {
    return this._fence;
    },
    set(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._fence = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkFenceGetFdInfoKHR.fence': Expected 'VkFence' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFenceGetFdInfoKHR.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkFenceGetFdInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._fence = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    
  }
};

VkFenceGetFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFenceGetFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkFenceGetFdInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFenceGetFdInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.fence !== null) {
        copy.fence = original.fence.constructor.createCopyFrom(original.fence);
      }
  copy.handleType = original.handleType;
  
  return copy;
};

VkFenceGetFdInfoKHR.byteLength = 0x0;

VkFenceGetFdInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMultiviewFeatures **/
function VkPhysicalDeviceMultiviewFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMultiviewFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMultiviewFeatures, STRUCT_CACHE_VkPhysicalDeviceMultiviewFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMultiviewFeatures, STRUCT_CACHE_VkPhysicalDeviceMultiviewFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMultiviewFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.multiview !== void 0) this.multiview = opts.multiview;
    if (opts.multiviewGeometryShader !== void 0) this.multiviewGeometryShader = opts.multiviewGeometryShader;
    if (opts.multiviewTessellationShader !== void 0) this.multiviewTessellationShader = opts.multiviewTessellationShader;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMultiviewFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMultiviewFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMultiviewFeatures.pNext' isn't allowed to be filled");
    }
    },
  "multiview": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "multiviewGeometryShader": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "multiviewTessellationShader": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceMultiviewFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.multiview !== void 0) this.multiview = opts.multiview;
    if (opts.multiviewGeometryShader !== void 0) this.multiviewGeometryShader = opts.multiviewGeometryShader;
    if (opts.multiviewTessellationShader !== void 0) this.multiviewTessellationShader = opts.multiviewTessellationShader;
    
  }
};

VkPhysicalDeviceMultiviewFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceMultiviewFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMultiviewFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.multiview = original.multiview;
  copy.multiviewGeometryShader = original.multiviewGeometryShader;
  copy.multiviewTessellationShader = original.multiviewTessellationShader;
  
  return copy;
};

VkPhysicalDeviceMultiviewFeatures.byteLength = 0x0;

VkPhysicalDeviceMultiviewFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiview: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiviewGeometryShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiviewTessellationShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMultiviewFeaturesKHR **/
function VkPhysicalDeviceMultiviewFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMultiviewFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMultiviewFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceMultiviewFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMultiviewFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceMultiviewFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMultiviewFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.multiview !== void 0) this.multiview = opts.multiview;
    if (opts.multiviewGeometryShader !== void 0) this.multiviewGeometryShader = opts.multiviewGeometryShader;
    if (opts.multiviewTessellationShader !== void 0) this.multiviewTessellationShader = opts.multiviewTessellationShader;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMultiviewFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMultiviewFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMultiviewFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "multiview": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "multiviewGeometryShader": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "multiviewTessellationShader": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceMultiviewFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.multiview !== void 0) this.multiview = opts.multiview;
    if (opts.multiviewGeometryShader !== void 0) this.multiviewGeometryShader = opts.multiviewGeometryShader;
    if (opts.multiviewTessellationShader !== void 0) this.multiviewTessellationShader = opts.multiviewTessellationShader;
    
  }
};

VkPhysicalDeviceMultiviewFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceMultiviewFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMultiviewFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.multiview = original.multiview;
  copy.multiviewGeometryShader = original.multiviewGeometryShader;
  copy.multiviewTessellationShader = original.multiviewTessellationShader;
  
  return copy;
};

VkPhysicalDeviceMultiviewFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceMultiviewFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiview: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiviewGeometryShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiviewTessellationShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMultiviewProperties **/
function VkPhysicalDeviceMultiviewProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMultiviewProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMultiviewProperties, STRUCT_CACHE_VkPhysicalDeviceMultiviewProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMultiviewProperties, STRUCT_CACHE_VkPhysicalDeviceMultiviewProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMultiviewProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMultiviewProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMultiviewProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMultiviewProperties.pNext' isn't allowed to be filled");
    }
    },
  "maxMultiviewViewCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMultiviewInstanceIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceMultiviewProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceMultiviewProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceMultiviewProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMultiviewProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxMultiviewViewCount = original.maxMultiviewViewCount;
  copy.maxMultiviewInstanceIndex = original.maxMultiviewInstanceIndex;
  
  return copy;
};

VkPhysicalDeviceMultiviewProperties.byteLength = 0x0;

VkPhysicalDeviceMultiviewProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMultiviewViewCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMultiviewInstanceIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMultiviewPropertiesKHR **/
function VkPhysicalDeviceMultiviewPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMultiviewPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMultiviewPropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceMultiviewPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMultiviewPropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceMultiviewPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMultiviewPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMultiviewPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMultiviewPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMultiviewPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "maxMultiviewViewCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMultiviewInstanceIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceMultiviewPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceMultiviewPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceMultiviewPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMultiviewPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxMultiviewViewCount = original.maxMultiviewViewCount;
  copy.maxMultiviewInstanceIndex = original.maxMultiviewInstanceIndex;
  
  return copy;
};

VkPhysicalDeviceMultiviewPropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceMultiviewPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMultiviewViewCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMultiviewInstanceIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassMultiviewCreateInfo **/
function VkRenderPassMultiviewCreateInfo(opts, byteOffset) {
  if (new.target !== VkRenderPassMultiviewCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassMultiviewCreateInfo, STRUCT_CACHE_VkRenderPassMultiviewCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassMultiviewCreateInfo, STRUCT_CACHE_VkRenderPassMultiviewCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassMultiviewCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pViewMasks = null;
  
  this._pViewOffsets = null;
  
  this._pCorrelationMasks = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pViewMasks !== void 0) this.pViewMasks = opts.pViewMasks;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pViewOffsets !== void 0) this.pViewOffsets = opts.pViewOffsets;
    if (opts.correlationMaskCount !== void 0) this.correlationMaskCount = opts.correlationMaskCount;
    if (opts.pCorrelationMasks !== void 0) this.pCorrelationMasks = opts.pCorrelationMasks;
    
  }
};

Object.defineProperties(VkRenderPassMultiviewCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassMultiviewCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassMultiviewCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "subpassCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassMultiviewCreateInfo.subpassCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewMasks": {
    get() {
    return this._pViewMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pViewMasks = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pViewMasks = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.pViewMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dependencyCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassMultiviewCreateInfo.dependencyCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewOffsets": {
    get() {
    return this._pViewOffsets;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewOffsets = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pViewOffsets = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.pViewOffsets': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "correlationMaskCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassMultiviewCreateInfo.correlationMaskCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCorrelationMasks": {
    get() {
    return this._pCorrelationMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCorrelationMasks = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pCorrelationMasks = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.pCorrelationMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRenderPassMultiviewCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pViewMasks = null;
  
  this._pViewOffsets = null;
  
  this._pCorrelationMasks = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pViewMasks !== void 0) this.pViewMasks = opts.pViewMasks;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pViewOffsets !== void 0) this.pViewOffsets = opts.pViewOffsets;
    if (opts.correlationMaskCount !== void 0) this.correlationMaskCount = opts.correlationMaskCount;
    if (opts.pCorrelationMasks !== void 0) this.pCorrelationMasks = opts.pCorrelationMasks;
    
  }
};

VkRenderPassMultiviewCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRenderPassMultiviewCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassMultiviewCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassMultiviewCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.subpassCount = original.subpassCount;
  if (original.pViewMasks !== null) {
        copy.pViewMasks = new Uint32Array(original.pViewMasks);
      }
  copy.dependencyCount = original.dependencyCount;
  if (original.pViewOffsets !== null) {
        copy.pViewOffsets = new Int32Array(original.pViewOffsets);
      }
  copy.correlationMaskCount = original.correlationMaskCount;
  if (original.pCorrelationMasks !== null) {
        copy.pCorrelationMasks = new Uint32Array(original.pCorrelationMasks);
      }
  
  return copy;
};

VkRenderPassMultiviewCreateInfo.byteLength = 0x0;

VkRenderPassMultiviewCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subpassCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewMasks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dependencyCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewOffsets: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  correlationMaskCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCorrelationMasks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassMultiviewCreateInfoKHR **/
function VkRenderPassMultiviewCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkRenderPassMultiviewCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassMultiviewCreateInfoKHR, STRUCT_CACHE_VkRenderPassMultiviewCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassMultiviewCreateInfoKHR, STRUCT_CACHE_VkRenderPassMultiviewCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassMultiviewCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pViewMasks = null;
  
  this._pViewOffsets = null;
  
  this._pCorrelationMasks = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pViewMasks !== void 0) this.pViewMasks = opts.pViewMasks;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pViewOffsets !== void 0) this.pViewOffsets = opts.pViewOffsets;
    if (opts.correlationMaskCount !== void 0) this.correlationMaskCount = opts.correlationMaskCount;
    if (opts.pCorrelationMasks !== void 0) this.pCorrelationMasks = opts.pCorrelationMasks;
    
  }
};

Object.defineProperties(VkRenderPassMultiviewCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassMultiviewCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassMultiviewCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "subpassCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassMultiviewCreateInfoKHR.subpassCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewMasks": {
    get() {
    return this._pViewMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pViewMasks = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pViewMasks = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.pViewMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dependencyCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassMultiviewCreateInfoKHR.dependencyCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewOffsets": {
    get() {
    return this._pViewOffsets;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewOffsets = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pViewOffsets = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.pViewOffsets': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "correlationMaskCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassMultiviewCreateInfoKHR.correlationMaskCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCorrelationMasks": {
    get() {
    return this._pCorrelationMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCorrelationMasks = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pCorrelationMasks = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.pCorrelationMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRenderPassMultiviewCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pViewMasks = null;
  
  this._pViewOffsets = null;
  
  this._pCorrelationMasks = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pViewMasks !== void 0) this.pViewMasks = opts.pViewMasks;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pViewOffsets !== void 0) this.pViewOffsets = opts.pViewOffsets;
    if (opts.correlationMaskCount !== void 0) this.correlationMaskCount = opts.correlationMaskCount;
    if (opts.pCorrelationMasks !== void 0) this.pCorrelationMasks = opts.pCorrelationMasks;
    
  }
};

VkRenderPassMultiviewCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRenderPassMultiviewCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassMultiviewCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassMultiviewCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.subpassCount = original.subpassCount;
  if (original.pViewMasks !== null) {
        copy.pViewMasks = new Uint32Array(original.pViewMasks);
      }
  copy.dependencyCount = original.dependencyCount;
  if (original.pViewOffsets !== null) {
        copy.pViewOffsets = new Int32Array(original.pViewOffsets);
      }
  copy.correlationMaskCount = original.correlationMaskCount;
  if (original.pCorrelationMasks !== null) {
        copy.pCorrelationMasks = new Uint32Array(original.pCorrelationMasks);
      }
  
  return copy;
};

VkRenderPassMultiviewCreateInfoKHR.byteLength = 0x0;

VkRenderPassMultiviewCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subpassCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewMasks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dependencyCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewOffsets: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  correlationMaskCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCorrelationMasks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSurfaceCapabilities2EXT **/
function VkSurfaceCapabilities2EXT(opts, byteOffset) {
  if (new.target !== VkSurfaceCapabilities2EXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSurfaceCapabilities2EXT, STRUCT_CACHE_VkSurfaceCapabilities2EXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSurfaceCapabilities2EXT, STRUCT_CACHE_VkSurfaceCapabilities2EXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSurfaceCapabilities2EXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._currentExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._minImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._maxImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSurfaceCapabilities2EXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSurfaceCapabilities2EXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceCapabilities2EXT.pNext' isn't allowed to be filled");
    }
    },
  "minImageCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxImageCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "currentExtent": {
    get() {
    return this._currentExtent;
    },
    },
  "minImageExtent": {
    get() {
    return this._minImageExtent;
    },
    },
  "maxImageExtent": {
    get() {
    return this._maxImageExtent;
    },
    },
  "maxImageArrayLayers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "supportedTransforms": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "currentTransform": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "supportedCompositeAlpha": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "supportedUsageFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "supportedSurfaceCounters": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkSurfaceCapabilities2EXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  if (this._currentExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._currentExtent.memoryBuffer) this._currentExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._currentExtent.reset();
  }
  if (this._minImageExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._minImageExtent.memoryBuffer) this._minImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._minImageExtent.reset();
  }
  if (this._maxImageExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxImageExtent.memoryBuffer) this._maxImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxImageExtent.reset();
  }
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSurfaceCapabilities2EXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceCapabilities2EXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSurfaceCapabilities2EXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSurfaceCapabilities2EXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.minImageCount = original.minImageCount;
  copy.maxImageCount = original.maxImageCount;
  if (original.currentExtent !== null) {
        copy.currentExtent = original.currentExtent.constructor.createCopyFrom(original.currentExtent);
      }
  if (original.minImageExtent !== null) {
        copy.minImageExtent = original.minImageExtent.constructor.createCopyFrom(original.minImageExtent);
      }
  if (original.maxImageExtent !== null) {
        copy.maxImageExtent = original.maxImageExtent.constructor.createCopyFrom(original.maxImageExtent);
      }
  copy.maxImageArrayLayers = original.maxImageArrayLayers;
  copy.supportedTransforms = original.supportedTransforms;
  copy.currentTransform = original.currentTransform;
  copy.supportedCompositeAlpha = original.supportedCompositeAlpha;
  copy.supportedUsageFlags = original.supportedUsageFlags;
  copy.supportedSurfaceCounters = original.supportedSurfaceCounters;
  
  return copy;
};

VkSurfaceCapabilities2EXT.byteLength = 0x0;

VkSurfaceCapabilities2EXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minImageCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxImageCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  currentExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minImageExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxImageExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxImageArrayLayers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedTransforms: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  currentTransform: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedCompositeAlpha: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedUsageFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedSurfaceCounters: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayPowerInfoEXT **/
function VkDisplayPowerInfoEXT(opts, byteOffset) {
  if (new.target !== VkDisplayPowerInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayPowerInfoEXT, STRUCT_CACHE_VkDisplayPowerInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayPowerInfoEXT, STRUCT_CACHE_VkDisplayPowerInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayPowerInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.powerState !== void 0) this.powerState = opts.powerState;
    
  }
};

Object.defineProperties(VkDisplayPowerInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayPowerInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayPowerInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "powerState": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayPowerInfoEXT.powerState");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkDisplayPowerInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.powerState !== void 0) this.powerState = opts.powerState;
    
  }
};

VkDisplayPowerInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPowerInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDisplayPowerInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayPowerInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.powerState = original.powerState;
  
  return copy;
};

VkDisplayPowerInfoEXT.byteLength = 0x0;

VkDisplayPowerInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  powerState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceEventInfoEXT **/
function VkDeviceEventInfoEXT(opts, byteOffset) {
  if (new.target !== VkDeviceEventInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceEventInfoEXT, STRUCT_CACHE_VkDeviceEventInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceEventInfoEXT, STRUCT_CACHE_VkDeviceEventInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceEventInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceEvent !== void 0) this.deviceEvent = opts.deviceEvent;
    
  }
};

Object.defineProperties(VkDeviceEventInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceEventInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceEventInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "deviceEvent": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceEventInfoEXT.deviceEvent");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkDeviceEventInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceEvent !== void 0) this.deviceEvent = opts.deviceEvent;
    
  }
};

VkDeviceEventInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceEventInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceEventInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceEventInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceEvent = original.deviceEvent;
  
  return copy;
};

VkDeviceEventInfoEXT.byteLength = 0x0;

VkDeviceEventInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceEvent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayEventInfoEXT **/
function VkDisplayEventInfoEXT(opts, byteOffset) {
  if (new.target !== VkDisplayEventInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayEventInfoEXT, STRUCT_CACHE_VkDisplayEventInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayEventInfoEXT, STRUCT_CACHE_VkDisplayEventInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayEventInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.displayEvent !== void 0) this.displayEvent = opts.displayEvent;
    
  }
};

Object.defineProperties(VkDisplayEventInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayEventInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayEventInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "displayEvent": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayEventInfoEXT.displayEvent");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkDisplayEventInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.displayEvent !== void 0) this.displayEvent = opts.displayEvent;
    
  }
};

VkDisplayEventInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayEventInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDisplayEventInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayEventInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.displayEvent = original.displayEvent;
  
  return copy;
};

VkDisplayEventInfoEXT.byteLength = 0x0;

VkDisplayEventInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  displayEvent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSwapchainCounterCreateInfoEXT **/
function VkSwapchainCounterCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkSwapchainCounterCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSwapchainCounterCreateInfoEXT, STRUCT_CACHE_VkSwapchainCounterCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSwapchainCounterCreateInfoEXT, STRUCT_CACHE_VkSwapchainCounterCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSwapchainCounterCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.surfaceCounters !== void 0) this.surfaceCounters = opts.surfaceCounters;
    
  }
};

Object.defineProperties(VkSwapchainCounterCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCounterCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSwapchainCounterCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "surfaceCounters": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainCounterCreateInfoEXT.surfaceCounters");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSwapchainCounterCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.surfaceCounters !== void 0) this.surfaceCounters = opts.surfaceCounters;
    
  }
};

VkSwapchainCounterCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSwapchainCounterCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkSwapchainCounterCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSwapchainCounterCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.surfaceCounters = original.surfaceCounters;
  
  return copy;
};

VkSwapchainCounterCreateInfoEXT.byteLength = 0x0;

VkSwapchainCounterCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  surfaceCounters: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceGroupProperties **/
function VkPhysicalDeviceGroupProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceGroupProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceGroupProperties, STRUCT_CACHE_VkPhysicalDeviceGroupProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceGroupProperties, STRUCT_CACHE_VkPhysicalDeviceGroupProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceGroupProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._physicalDevices = [...Array(32)].map((v, i) => null);
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceGroupProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceGroupProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceGroupProperties.pNext' isn't allowed to be filled");
    }
    },
  "physicalDeviceCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "physicalDevices": {
    get() {
    return this._physicalDevices;
    },
    },
  "subsetAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceGroupProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._physicalDevices !== null) {
    let array = this._physicalDevices;
    for (let ii = 0; ii < array.length; ++ii) {
      array[ii] = null;
    };
  }
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceGroupProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceGroupProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceGroupProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceGroupProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.physicalDeviceCount = original.physicalDeviceCount;
  if (original.physicalDevices !== null) {
        copy.physicalDevices = [...Array(original.physicalDevices.length)].map((v, i) => {
          return original.physicalDevices[i].constructor.createCopyFrom(original.physicalDevices[i]);
        });
      }
  copy.subsetAllocation = original.subsetAllocation;
  
  return copy;
};

VkPhysicalDeviceGroupProperties.byteLength = 0x0;

VkPhysicalDeviceGroupProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  physicalDeviceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  physicalDevices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subsetAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceGroupPropertiesKHR **/
function VkPhysicalDeviceGroupPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceGroupPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceGroupPropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceGroupPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceGroupPropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceGroupPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceGroupPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._physicalDevices = [...Array(32)].map((v, i) => null);
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceGroupPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceGroupPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceGroupPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "physicalDeviceCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "physicalDevices": {
    get() {
    return this._physicalDevices;
    },
    },
  "subsetAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceGroupPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._physicalDevices !== null) {
    let array = this._physicalDevices;
    for (let ii = 0; ii < array.length; ++ii) {
      array[ii] = null;
    };
  }
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceGroupPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceGroupPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceGroupPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceGroupPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.physicalDeviceCount = original.physicalDeviceCount;
  if (original.physicalDevices !== null) {
        copy.physicalDevices = [...Array(original.physicalDevices.length)].map((v, i) => {
          return original.physicalDevices[i].constructor.createCopyFrom(original.physicalDevices[i]);
        });
      }
  copy.subsetAllocation = original.subsetAllocation;
  
  return copy;
};

VkPhysicalDeviceGroupPropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceGroupPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  physicalDeviceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  physicalDevices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subsetAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryAllocateFlagsInfo **/
function VkMemoryAllocateFlagsInfo(opts, byteOffset) {
  if (new.target !== VkMemoryAllocateFlagsInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryAllocateFlagsInfo, STRUCT_CACHE_VkMemoryAllocateFlagsInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryAllocateFlagsInfo, STRUCT_CACHE_VkMemoryAllocateFlagsInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryAllocateFlagsInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

Object.defineProperties(VkMemoryAllocateFlagsInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryAllocateFlagsInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryAllocateFlagsInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryAllocateFlagsInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "deviceMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryAllocateFlagsInfo.deviceMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkMemoryAllocateFlagsInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

VkMemoryAllocateFlagsInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryAllocateFlagsInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryAllocateFlagsInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryAllocateFlagsInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.deviceMask = original.deviceMask;
  
  return copy;
};

VkMemoryAllocateFlagsInfo.byteLength = 0x0;

VkMemoryAllocateFlagsInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryAllocateFlagsInfoKHR **/
function VkMemoryAllocateFlagsInfoKHR(opts, byteOffset) {
  if (new.target !== VkMemoryAllocateFlagsInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryAllocateFlagsInfoKHR, STRUCT_CACHE_VkMemoryAllocateFlagsInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryAllocateFlagsInfoKHR, STRUCT_CACHE_VkMemoryAllocateFlagsInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryAllocateFlagsInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

Object.defineProperties(VkMemoryAllocateFlagsInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryAllocateFlagsInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryAllocateFlagsInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryAllocateFlagsInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "deviceMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryAllocateFlagsInfoKHR.deviceMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkMemoryAllocateFlagsInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

VkMemoryAllocateFlagsInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryAllocateFlagsInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryAllocateFlagsInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryAllocateFlagsInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.deviceMask = original.deviceMask;
  
  return copy;
};

VkMemoryAllocateFlagsInfoKHR.byteLength = 0x0;

VkMemoryAllocateFlagsInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindBufferMemoryInfo **/
function VkBindBufferMemoryInfo(opts, byteOffset) {
  if (new.target !== VkBindBufferMemoryInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindBufferMemoryInfo, STRUCT_CACHE_VkBindBufferMemoryInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindBufferMemoryInfo, STRUCT_CACHE_VkBindBufferMemoryInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindBufferMemoryInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._buffer = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

Object.defineProperties(VkBindBufferMemoryInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindBufferMemoryInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.pNext'");
    }
    
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBindBufferMemoryInfo.memoryOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBindBufferMemoryInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

VkBindBufferMemoryInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindBufferMemoryInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindBufferMemoryInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  copy.memoryOffset = original.memoryOffset;
  
  return copy;
};

VkBindBufferMemoryInfo.byteLength = 0x0;

VkBindBufferMemoryInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindBufferMemoryInfoKHR **/
function VkBindBufferMemoryInfoKHR(opts, byteOffset) {
  if (new.target !== VkBindBufferMemoryInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindBufferMemoryInfoKHR, STRUCT_CACHE_VkBindBufferMemoryInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindBufferMemoryInfoKHR, STRUCT_CACHE_VkBindBufferMemoryInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindBufferMemoryInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._buffer = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

Object.defineProperties(VkBindBufferMemoryInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindBufferMemoryInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.pNext'");
    }
    
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBindBufferMemoryInfoKHR.memoryOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBindBufferMemoryInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

VkBindBufferMemoryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindBufferMemoryInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindBufferMemoryInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  copy.memoryOffset = original.memoryOffset;
  
  return copy;
};

VkBindBufferMemoryInfoKHR.byteLength = 0x0;

VkBindBufferMemoryInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindBufferMemoryDeviceGroupInfo **/
function VkBindBufferMemoryDeviceGroupInfo(opts, byteOffset) {
  if (new.target !== VkBindBufferMemoryDeviceGroupInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindBufferMemoryDeviceGroupInfo, STRUCT_CACHE_VkBindBufferMemoryDeviceGroupInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindBufferMemoryDeviceGroupInfo, STRUCT_CACHE_VkBindBufferMemoryDeviceGroupInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindBufferMemoryDeviceGroupInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    
  }
};

Object.defineProperties(VkBindBufferMemoryDeviceGroupInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindBufferMemoryDeviceGroupInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindBufferMemoryDeviceGroupInfo.pNext' isn't allowed to be filled");
    }
    },
  "deviceIndexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindBufferMemoryDeviceGroupInfo.deviceIndexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDeviceIndices": {
    get() {
    return this._pDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfo.pDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBindBufferMemoryDeviceGroupInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    
  }
};

VkBindBufferMemoryDeviceGroupInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryDeviceGroupInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindBufferMemoryDeviceGroupInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindBufferMemoryDeviceGroupInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceIndexCount = original.deviceIndexCount;
  if (original.pDeviceIndices !== null) {
        copy.pDeviceIndices = new Uint32Array(original.pDeviceIndices);
      }
  
  return copy;
};

VkBindBufferMemoryDeviceGroupInfo.byteLength = 0x0;

VkBindBufferMemoryDeviceGroupInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceIndexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDeviceIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindBufferMemoryDeviceGroupInfoKHR **/
function VkBindBufferMemoryDeviceGroupInfoKHR(opts, byteOffset) {
  if (new.target !== VkBindBufferMemoryDeviceGroupInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindBufferMemoryDeviceGroupInfoKHR, STRUCT_CACHE_VkBindBufferMemoryDeviceGroupInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindBufferMemoryDeviceGroupInfoKHR, STRUCT_CACHE_VkBindBufferMemoryDeviceGroupInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindBufferMemoryDeviceGroupInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    
  }
};

Object.defineProperties(VkBindBufferMemoryDeviceGroupInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindBufferMemoryDeviceGroupInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindBufferMemoryDeviceGroupInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "deviceIndexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindBufferMemoryDeviceGroupInfoKHR.deviceIndexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDeviceIndices": {
    get() {
    return this._pDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfoKHR.pDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBindBufferMemoryDeviceGroupInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    
  }
};

VkBindBufferMemoryDeviceGroupInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryDeviceGroupInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindBufferMemoryDeviceGroupInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindBufferMemoryDeviceGroupInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceIndexCount = original.deviceIndexCount;
  if (original.pDeviceIndices !== null) {
        copy.pDeviceIndices = new Uint32Array(original.pDeviceIndices);
      }
  
  return copy;
};

VkBindBufferMemoryDeviceGroupInfoKHR.byteLength = 0x0;

VkBindBufferMemoryDeviceGroupInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceIndexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDeviceIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindImageMemoryInfo **/
function VkBindImageMemoryInfo(opts, byteOffset) {
  if (new.target !== VkBindImageMemoryInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindImageMemoryInfo, STRUCT_CACHE_VkBindImageMemoryInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindImageMemoryInfo, STRUCT_CACHE_VkBindImageMemoryInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindImageMemoryInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._image = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

Object.defineProperties(VkBindImageMemoryInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImageMemoryInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.pNext'");
    }
    
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBindImageMemoryInfo.memoryOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBindImageMemoryInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._image = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

VkBindImageMemoryInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImageMemoryInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindImageMemoryInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindImageMemoryInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  copy.memoryOffset = original.memoryOffset;
  
  return copy;
};

VkBindImageMemoryInfo.byteLength = 0x0;

VkBindImageMemoryInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindImageMemoryInfoKHR **/
function VkBindImageMemoryInfoKHR(opts, byteOffset) {
  if (new.target !== VkBindImageMemoryInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindImageMemoryInfoKHR, STRUCT_CACHE_VkBindImageMemoryInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindImageMemoryInfoKHR, STRUCT_CACHE_VkBindImageMemoryInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindImageMemoryInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._image = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

Object.defineProperties(VkBindImageMemoryInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImageMemoryInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.pNext'");
    }
    
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBindImageMemoryInfoKHR.memoryOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBindImageMemoryInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._image = null;
  this._memory = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    
  }
};

VkBindImageMemoryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImageMemoryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindImageMemoryInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindImageMemoryInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  copy.memoryOffset = original.memoryOffset;
  
  return copy;
};

VkBindImageMemoryInfoKHR.byteLength = 0x0;

VkBindImageMemoryInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindImageMemoryDeviceGroupInfo **/
function VkBindImageMemoryDeviceGroupInfo(opts, byteOffset) {
  if (new.target !== VkBindImageMemoryDeviceGroupInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindImageMemoryDeviceGroupInfo, STRUCT_CACHE_VkBindImageMemoryDeviceGroupInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindImageMemoryDeviceGroupInfo, STRUCT_CACHE_VkBindImageMemoryDeviceGroupInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindImageMemoryDeviceGroupInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  
  this._pSplitInstanceBindRegions = null;
  this._pSplitInstanceBindRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    if (opts.splitInstanceBindRegionCount !== void 0) this.splitInstanceBindRegionCount = opts.splitInstanceBindRegionCount;
    if (opts.pSplitInstanceBindRegions !== void 0) this.pSplitInstanceBindRegions = opts.pSplitInstanceBindRegions;
    
  }
};

Object.defineProperties(VkBindImageMemoryDeviceGroupInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImageMemoryDeviceGroupInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindImageMemoryDeviceGroupInfo.pNext' isn't allowed to be filled");
    }
    },
  "deviceIndexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImageMemoryDeviceGroupInfo.deviceIndexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDeviceIndices": {
    get() {
    return this._pDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.pDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "splitInstanceBindRegionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImageMemoryDeviceGroupInfo.splitInstanceBindRegionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSplitInstanceBindRegions": {
    get() {
    if (this._pSplitInstanceBindRegions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.splitInstanceBindRegionCount, VkRect2D);
      this._pSplitInstanceBindRegions = array;
      return this.pSplitInstanceBindRegions;
    } else {
      return this._pSplitInstanceBindRegions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSplitInstanceBindRegions = value;
    } else if (value === null) {
      this._pSplitInstanceBindRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkBindImageMemoryDeviceGroupInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  
  this._pSplitInstanceBindRegions = null;
  this._pSplitInstanceBindRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    if (opts.splitInstanceBindRegionCount !== void 0) this.splitInstanceBindRegionCount = opts.splitInstanceBindRegionCount;
    if (opts.pSplitInstanceBindRegions !== void 0) this.pSplitInstanceBindRegions = opts.pSplitInstanceBindRegions;
    
  }
};

VkBindImageMemoryDeviceGroupInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSplitInstanceBindRegions !== null) {
    let array = this._pSplitInstanceBindRegions;
    
    if (array.length !== this.splitInstanceBindRegionCount) {
      throw new RangeError("Invalid array length, expected length of 'splitInstanceBindRegionCount' for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSplitInstanceBindRegionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSplitInstanceBindRegionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkBindImageMemoryDeviceGroupInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindImageMemoryDeviceGroupInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindImageMemoryDeviceGroupInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceIndexCount = original.deviceIndexCount;
  if (original.pDeviceIndices !== null) {
        copy.pDeviceIndices = new Uint32Array(original.pDeviceIndices);
      }
  copy.splitInstanceBindRegionCount = original.splitInstanceBindRegionCount;
  if (original.pSplitInstanceBindRegions !== null) {
        copy.pSplitInstanceBindRegions = [...Array(original.pSplitInstanceBindRegions.length)].map((v, i) => {
          return original.pSplitInstanceBindRegions[i].constructor.createCopyFrom(original.pSplitInstanceBindRegions[i]);
        });
      }
  
  return copy;
};

VkBindImageMemoryDeviceGroupInfo.byteLength = 0x0;

VkBindImageMemoryDeviceGroupInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceIndexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDeviceIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  splitInstanceBindRegionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSplitInstanceBindRegions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindImageMemoryDeviceGroupInfoKHR **/
function VkBindImageMemoryDeviceGroupInfoKHR(opts, byteOffset) {
  if (new.target !== VkBindImageMemoryDeviceGroupInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindImageMemoryDeviceGroupInfoKHR, STRUCT_CACHE_VkBindImageMemoryDeviceGroupInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindImageMemoryDeviceGroupInfoKHR, STRUCT_CACHE_VkBindImageMemoryDeviceGroupInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindImageMemoryDeviceGroupInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  
  this._pSplitInstanceBindRegions = null;
  this._pSplitInstanceBindRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    if (opts.splitInstanceBindRegionCount !== void 0) this.splitInstanceBindRegionCount = opts.splitInstanceBindRegionCount;
    if (opts.pSplitInstanceBindRegions !== void 0) this.pSplitInstanceBindRegions = opts.pSplitInstanceBindRegions;
    
  }
};

Object.defineProperties(VkBindImageMemoryDeviceGroupInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImageMemoryDeviceGroupInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindImageMemoryDeviceGroupInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "deviceIndexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImageMemoryDeviceGroupInfoKHR.deviceIndexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDeviceIndices": {
    get() {
    return this._pDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.pDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "splitInstanceBindRegionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImageMemoryDeviceGroupInfoKHR.splitInstanceBindRegionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSplitInstanceBindRegions": {
    get() {
    if (this._pSplitInstanceBindRegions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.splitInstanceBindRegionCount, VkRect2D);
      this._pSplitInstanceBindRegions = array;
      return this.pSplitInstanceBindRegions;
    } else {
      return this._pSplitInstanceBindRegions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSplitInstanceBindRegions = value;
    } else if (value === null) {
      this._pSplitInstanceBindRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkBindImageMemoryDeviceGroupInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pDeviceIndices = null;
  
  this._pSplitInstanceBindRegions = null;
  this._pSplitInstanceBindRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    if (opts.splitInstanceBindRegionCount !== void 0) this.splitInstanceBindRegionCount = opts.splitInstanceBindRegionCount;
    if (opts.pSplitInstanceBindRegions !== void 0) this.pSplitInstanceBindRegions = opts.pSplitInstanceBindRegions;
    
  }
};

VkBindImageMemoryDeviceGroupInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSplitInstanceBindRegions !== null) {
    let array = this._pSplitInstanceBindRegions;
    
    if (array.length !== this.splitInstanceBindRegionCount) {
      throw new RangeError("Invalid array length, expected length of 'splitInstanceBindRegionCount' for 'VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSplitInstanceBindRegionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSplitInstanceBindRegionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkBindImageMemoryDeviceGroupInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindImageMemoryDeviceGroupInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindImageMemoryDeviceGroupInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceIndexCount = original.deviceIndexCount;
  if (original.pDeviceIndices !== null) {
        copy.pDeviceIndices = new Uint32Array(original.pDeviceIndices);
      }
  copy.splitInstanceBindRegionCount = original.splitInstanceBindRegionCount;
  if (original.pSplitInstanceBindRegions !== null) {
        copy.pSplitInstanceBindRegions = [...Array(original.pSplitInstanceBindRegions.length)].map((v, i) => {
          return original.pSplitInstanceBindRegions[i].constructor.createCopyFrom(original.pSplitInstanceBindRegions[i]);
        });
      }
  
  return copy;
};

VkBindImageMemoryDeviceGroupInfoKHR.byteLength = 0x0;

VkBindImageMemoryDeviceGroupInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceIndexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDeviceIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  splitInstanceBindRegionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSplitInstanceBindRegions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupRenderPassBeginInfo **/
function VkDeviceGroupRenderPassBeginInfo(opts, byteOffset) {
  if (new.target !== VkDeviceGroupRenderPassBeginInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupRenderPassBeginInfo, STRUCT_CACHE_VkDeviceGroupRenderPassBeginInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupRenderPassBeginInfo, STRUCT_CACHE_VkDeviceGroupRenderPassBeginInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupRenderPassBeginInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pDeviceRenderAreas = null;
  this._pDeviceRenderAreasNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    if (opts.deviceRenderAreaCount !== void 0) this.deviceRenderAreaCount = opts.deviceRenderAreaCount;
    if (opts.pDeviceRenderAreas !== void 0) this.pDeviceRenderAreas = opts.pDeviceRenderAreas;
    
  }
};

Object.defineProperties(VkDeviceGroupRenderPassBeginInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupRenderPassBeginInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupRenderPassBeginInfo.pNext' isn't allowed to be filled");
    }
    },
  "deviceMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupRenderPassBeginInfo.deviceMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "deviceRenderAreaCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupRenderPassBeginInfo.deviceRenderAreaCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDeviceRenderAreas": {
    get() {
    if (this._pDeviceRenderAreas === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.deviceRenderAreaCount, VkRect2D);
      this._pDeviceRenderAreas = array;
      return this.pDeviceRenderAreas;
    } else {
      return this._pDeviceRenderAreas;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDeviceRenderAreas = value;
    } else if (value === null) {
      this._pDeviceRenderAreas = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDeviceGroupRenderPassBeginInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pDeviceRenderAreas = null;
  this._pDeviceRenderAreasNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    if (opts.deviceRenderAreaCount !== void 0) this.deviceRenderAreaCount = opts.deviceRenderAreaCount;
    if (opts.pDeviceRenderAreas !== void 0) this.pDeviceRenderAreas = opts.pDeviceRenderAreas;
    
  }
};

VkDeviceGroupRenderPassBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDeviceRenderAreas !== null) {
    let array = this._pDeviceRenderAreas;
    
    if (array.length !== this.deviceRenderAreaCount) {
      throw new RangeError("Invalid array length, expected length of 'deviceRenderAreaCount' for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDeviceRenderAreasNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pDeviceRenderAreasNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDeviceGroupRenderPassBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupRenderPassBeginInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupRenderPassBeginInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceMask = original.deviceMask;
  copy.deviceRenderAreaCount = original.deviceRenderAreaCount;
  if (original.pDeviceRenderAreas !== null) {
        copy.pDeviceRenderAreas = [...Array(original.pDeviceRenderAreas.length)].map((v, i) => {
          return original.pDeviceRenderAreas[i].constructor.createCopyFrom(original.pDeviceRenderAreas[i]);
        });
      }
  
  return copy;
};

VkDeviceGroupRenderPassBeginInfo.byteLength = 0x0;

VkDeviceGroupRenderPassBeginInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceRenderAreaCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDeviceRenderAreas: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupRenderPassBeginInfoKHR **/
function VkDeviceGroupRenderPassBeginInfoKHR(opts, byteOffset) {
  if (new.target !== VkDeviceGroupRenderPassBeginInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupRenderPassBeginInfoKHR, STRUCT_CACHE_VkDeviceGroupRenderPassBeginInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupRenderPassBeginInfoKHR, STRUCT_CACHE_VkDeviceGroupRenderPassBeginInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupRenderPassBeginInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pDeviceRenderAreas = null;
  this._pDeviceRenderAreasNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    if (opts.deviceRenderAreaCount !== void 0) this.deviceRenderAreaCount = opts.deviceRenderAreaCount;
    if (opts.pDeviceRenderAreas !== void 0) this.pDeviceRenderAreas = opts.pDeviceRenderAreas;
    
  }
};

Object.defineProperties(VkDeviceGroupRenderPassBeginInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupRenderPassBeginInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupRenderPassBeginInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "deviceMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupRenderPassBeginInfoKHR.deviceMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "deviceRenderAreaCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupRenderPassBeginInfoKHR.deviceRenderAreaCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDeviceRenderAreas": {
    get() {
    if (this._pDeviceRenderAreas === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.deviceRenderAreaCount, VkRect2D);
      this._pDeviceRenderAreas = array;
      return this.pDeviceRenderAreas;
    } else {
      return this._pDeviceRenderAreas;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDeviceRenderAreas = value;
    } else if (value === null) {
      this._pDeviceRenderAreas = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDeviceGroupRenderPassBeginInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pDeviceRenderAreas = null;
  this._pDeviceRenderAreasNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    if (opts.deviceRenderAreaCount !== void 0) this.deviceRenderAreaCount = opts.deviceRenderAreaCount;
    if (opts.pDeviceRenderAreas !== void 0) this.pDeviceRenderAreas = opts.pDeviceRenderAreas;
    
  }
};

VkDeviceGroupRenderPassBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDeviceRenderAreas !== null) {
    let array = this._pDeviceRenderAreas;
    
    if (array.length !== this.deviceRenderAreaCount) {
      throw new RangeError("Invalid array length, expected length of 'deviceRenderAreaCount' for 'VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDeviceRenderAreasNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pDeviceRenderAreasNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDeviceGroupRenderPassBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupRenderPassBeginInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupRenderPassBeginInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceMask = original.deviceMask;
  copy.deviceRenderAreaCount = original.deviceRenderAreaCount;
  if (original.pDeviceRenderAreas !== null) {
        copy.pDeviceRenderAreas = [...Array(original.pDeviceRenderAreas.length)].map((v, i) => {
          return original.pDeviceRenderAreas[i].constructor.createCopyFrom(original.pDeviceRenderAreas[i]);
        });
      }
  
  return copy;
};

VkDeviceGroupRenderPassBeginInfoKHR.byteLength = 0x0;

VkDeviceGroupRenderPassBeginInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceRenderAreaCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDeviceRenderAreas: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupCommandBufferBeginInfo **/
function VkDeviceGroupCommandBufferBeginInfo(opts, byteOffset) {
  if (new.target !== VkDeviceGroupCommandBufferBeginInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupCommandBufferBeginInfo, STRUCT_CACHE_VkDeviceGroupCommandBufferBeginInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupCommandBufferBeginInfo, STRUCT_CACHE_VkDeviceGroupCommandBufferBeginInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupCommandBufferBeginInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

Object.defineProperties(VkDeviceGroupCommandBufferBeginInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupCommandBufferBeginInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupCommandBufferBeginInfo.pNext' isn't allowed to be filled");
    }
    },
  "deviceMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupCommandBufferBeginInfo.deviceMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDeviceGroupCommandBufferBeginInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

VkDeviceGroupCommandBufferBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupCommandBufferBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupCommandBufferBeginInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupCommandBufferBeginInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceMask = original.deviceMask;
  
  return copy;
};

VkDeviceGroupCommandBufferBeginInfo.byteLength = 0x0;

VkDeviceGroupCommandBufferBeginInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupCommandBufferBeginInfoKHR **/
function VkDeviceGroupCommandBufferBeginInfoKHR(opts, byteOffset) {
  if (new.target !== VkDeviceGroupCommandBufferBeginInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupCommandBufferBeginInfoKHR, STRUCT_CACHE_VkDeviceGroupCommandBufferBeginInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupCommandBufferBeginInfoKHR, STRUCT_CACHE_VkDeviceGroupCommandBufferBeginInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupCommandBufferBeginInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

Object.defineProperties(VkDeviceGroupCommandBufferBeginInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupCommandBufferBeginInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupCommandBufferBeginInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "deviceMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupCommandBufferBeginInfoKHR.deviceMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDeviceGroupCommandBufferBeginInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

VkDeviceGroupCommandBufferBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupCommandBufferBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupCommandBufferBeginInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupCommandBufferBeginInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceMask = original.deviceMask;
  
  return copy;
};

VkDeviceGroupCommandBufferBeginInfoKHR.byteLength = 0x0;

VkDeviceGroupCommandBufferBeginInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupSubmitInfo **/
function VkDeviceGroupSubmitInfo(opts, byteOffset) {
  if (new.target !== VkDeviceGroupSubmitInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupSubmitInfo, STRUCT_CACHE_VkDeviceGroupSubmitInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupSubmitInfo, STRUCT_CACHE_VkDeviceGroupSubmitInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupSubmitInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphoreDeviceIndices = null;
  
  this._pCommandBufferDeviceMasks = null;
  
  this._pSignalSemaphoreDeviceIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphoreDeviceIndices !== void 0) this.pWaitSemaphoreDeviceIndices = opts.pWaitSemaphoreDeviceIndices;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    if (opts.pCommandBufferDeviceMasks !== void 0) this.pCommandBufferDeviceMasks = opts.pCommandBufferDeviceMasks;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphoreDeviceIndices !== void 0) this.pSignalSemaphoreDeviceIndices = opts.pSignalSemaphoreDeviceIndices;
    
  }
};

Object.defineProperties(VkDeviceGroupSubmitInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupSubmitInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupSubmitInfo.pNext' isn't allowed to be filled");
    }
    },
  "waitSemaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupSubmitInfo.waitSemaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pWaitSemaphoreDeviceIndices": {
    get() {
    return this._pWaitSemaphoreDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pWaitSemaphoreDeviceIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pWaitSemaphoreDeviceIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.pWaitSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "commandBufferCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupSubmitInfo.commandBufferCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCommandBufferDeviceMasks": {
    get() {
    return this._pCommandBufferDeviceMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCommandBufferDeviceMasks = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pCommandBufferDeviceMasks = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.pCommandBufferDeviceMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "signalSemaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupSubmitInfo.signalSemaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSignalSemaphoreDeviceIndices": {
    get() {
    return this._pSignalSemaphoreDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pSignalSemaphoreDeviceIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pSignalSemaphoreDeviceIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.pSignalSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceGroupSubmitInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphoreDeviceIndices = null;
  
  this._pCommandBufferDeviceMasks = null;
  
  this._pSignalSemaphoreDeviceIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphoreDeviceIndices !== void 0) this.pWaitSemaphoreDeviceIndices = opts.pWaitSemaphoreDeviceIndices;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    if (opts.pCommandBufferDeviceMasks !== void 0) this.pCommandBufferDeviceMasks = opts.pCommandBufferDeviceMasks;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphoreDeviceIndices !== void 0) this.pSignalSemaphoreDeviceIndices = opts.pSignalSemaphoreDeviceIndices;
    
  }
};

VkDeviceGroupSubmitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupSubmitInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupSubmitInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupSubmitInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.waitSemaphoreCount = original.waitSemaphoreCount;
  if (original.pWaitSemaphoreDeviceIndices !== null) {
        copy.pWaitSemaphoreDeviceIndices = new Uint32Array(original.pWaitSemaphoreDeviceIndices);
      }
  copy.commandBufferCount = original.commandBufferCount;
  if (original.pCommandBufferDeviceMasks !== null) {
        copy.pCommandBufferDeviceMasks = new Uint32Array(original.pCommandBufferDeviceMasks);
      }
  copy.signalSemaphoreCount = original.signalSemaphoreCount;
  if (original.pSignalSemaphoreDeviceIndices !== null) {
        copy.pSignalSemaphoreDeviceIndices = new Uint32Array(original.pSignalSemaphoreDeviceIndices);
      }
  
  return copy;
};

VkDeviceGroupSubmitInfo.byteLength = 0x0;

VkDeviceGroupSubmitInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  waitSemaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pWaitSemaphoreDeviceIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  commandBufferCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCommandBufferDeviceMasks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  signalSemaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSignalSemaphoreDeviceIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupSubmitInfoKHR **/
function VkDeviceGroupSubmitInfoKHR(opts, byteOffset) {
  if (new.target !== VkDeviceGroupSubmitInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupSubmitInfoKHR, STRUCT_CACHE_VkDeviceGroupSubmitInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupSubmitInfoKHR, STRUCT_CACHE_VkDeviceGroupSubmitInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupSubmitInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphoreDeviceIndices = null;
  
  this._pCommandBufferDeviceMasks = null;
  
  this._pSignalSemaphoreDeviceIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphoreDeviceIndices !== void 0) this.pWaitSemaphoreDeviceIndices = opts.pWaitSemaphoreDeviceIndices;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    if (opts.pCommandBufferDeviceMasks !== void 0) this.pCommandBufferDeviceMasks = opts.pCommandBufferDeviceMasks;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphoreDeviceIndices !== void 0) this.pSignalSemaphoreDeviceIndices = opts.pSignalSemaphoreDeviceIndices;
    
  }
};

Object.defineProperties(VkDeviceGroupSubmitInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupSubmitInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupSubmitInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "waitSemaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupSubmitInfoKHR.waitSemaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pWaitSemaphoreDeviceIndices": {
    get() {
    return this._pWaitSemaphoreDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pWaitSemaphoreDeviceIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pWaitSemaphoreDeviceIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.pWaitSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "commandBufferCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupSubmitInfoKHR.commandBufferCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCommandBufferDeviceMasks": {
    get() {
    return this._pCommandBufferDeviceMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCommandBufferDeviceMasks = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pCommandBufferDeviceMasks = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.pCommandBufferDeviceMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "signalSemaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupSubmitInfoKHR.signalSemaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSignalSemaphoreDeviceIndices": {
    get() {
    return this._pSignalSemaphoreDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pSignalSemaphoreDeviceIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pSignalSemaphoreDeviceIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.pSignalSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceGroupSubmitInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphoreDeviceIndices = null;
  
  this._pCommandBufferDeviceMasks = null;
  
  this._pSignalSemaphoreDeviceIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
    if (opts.pWaitSemaphoreDeviceIndices !== void 0) this.pWaitSemaphoreDeviceIndices = opts.pWaitSemaphoreDeviceIndices;
    if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
    if (opts.pCommandBufferDeviceMasks !== void 0) this.pCommandBufferDeviceMasks = opts.pCommandBufferDeviceMasks;
    if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
    if (opts.pSignalSemaphoreDeviceIndices !== void 0) this.pSignalSemaphoreDeviceIndices = opts.pSignalSemaphoreDeviceIndices;
    
  }
};

VkDeviceGroupSubmitInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupSubmitInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupSubmitInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupSubmitInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.waitSemaphoreCount = original.waitSemaphoreCount;
  if (original.pWaitSemaphoreDeviceIndices !== null) {
        copy.pWaitSemaphoreDeviceIndices = new Uint32Array(original.pWaitSemaphoreDeviceIndices);
      }
  copy.commandBufferCount = original.commandBufferCount;
  if (original.pCommandBufferDeviceMasks !== null) {
        copy.pCommandBufferDeviceMasks = new Uint32Array(original.pCommandBufferDeviceMasks);
      }
  copy.signalSemaphoreCount = original.signalSemaphoreCount;
  if (original.pSignalSemaphoreDeviceIndices !== null) {
        copy.pSignalSemaphoreDeviceIndices = new Uint32Array(original.pSignalSemaphoreDeviceIndices);
      }
  
  return copy;
};

VkDeviceGroupSubmitInfoKHR.byteLength = 0x0;

VkDeviceGroupSubmitInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  waitSemaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pWaitSemaphoreDeviceIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  commandBufferCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCommandBufferDeviceMasks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  signalSemaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSignalSemaphoreDeviceIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupBindSparseInfo **/
function VkDeviceGroupBindSparseInfo(opts, byteOffset) {
  if (new.target !== VkDeviceGroupBindSparseInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupBindSparseInfo, STRUCT_CACHE_VkDeviceGroupBindSparseInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupBindSparseInfo, STRUCT_CACHE_VkDeviceGroupBindSparseInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupBindSparseInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.resourceDeviceIndex !== void 0) this.resourceDeviceIndex = opts.resourceDeviceIndex;
    if (opts.memoryDeviceIndex !== void 0) this.memoryDeviceIndex = opts.memoryDeviceIndex;
    
  }
};

Object.defineProperties(VkDeviceGroupBindSparseInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupBindSparseInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupBindSparseInfo.pNext' isn't allowed to be filled");
    }
    },
  "resourceDeviceIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupBindSparseInfo.resourceDeviceIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "memoryDeviceIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupBindSparseInfo.memoryDeviceIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDeviceGroupBindSparseInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.resourceDeviceIndex !== void 0) this.resourceDeviceIndex = opts.resourceDeviceIndex;
    if (opts.memoryDeviceIndex !== void 0) this.memoryDeviceIndex = opts.memoryDeviceIndex;
    
  }
};

VkDeviceGroupBindSparseInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupBindSparseInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupBindSparseInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupBindSparseInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.resourceDeviceIndex = original.resourceDeviceIndex;
  copy.memoryDeviceIndex = original.memoryDeviceIndex;
  
  return copy;
};

VkDeviceGroupBindSparseInfo.byteLength = 0x0;

VkDeviceGroupBindSparseInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  resourceDeviceIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryDeviceIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupBindSparseInfoKHR **/
function VkDeviceGroupBindSparseInfoKHR(opts, byteOffset) {
  if (new.target !== VkDeviceGroupBindSparseInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupBindSparseInfoKHR, STRUCT_CACHE_VkDeviceGroupBindSparseInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupBindSparseInfoKHR, STRUCT_CACHE_VkDeviceGroupBindSparseInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupBindSparseInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.resourceDeviceIndex !== void 0) this.resourceDeviceIndex = opts.resourceDeviceIndex;
    if (opts.memoryDeviceIndex !== void 0) this.memoryDeviceIndex = opts.memoryDeviceIndex;
    
  }
};

Object.defineProperties(VkDeviceGroupBindSparseInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupBindSparseInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupBindSparseInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "resourceDeviceIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupBindSparseInfoKHR.resourceDeviceIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "memoryDeviceIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupBindSparseInfoKHR.memoryDeviceIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDeviceGroupBindSparseInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.resourceDeviceIndex !== void 0) this.resourceDeviceIndex = opts.resourceDeviceIndex;
    if (opts.memoryDeviceIndex !== void 0) this.memoryDeviceIndex = opts.memoryDeviceIndex;
    
  }
};

VkDeviceGroupBindSparseInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupBindSparseInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupBindSparseInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupBindSparseInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.resourceDeviceIndex = original.resourceDeviceIndex;
  copy.memoryDeviceIndex = original.memoryDeviceIndex;
  
  return copy;
};

VkDeviceGroupBindSparseInfoKHR.byteLength = 0x0;

VkDeviceGroupBindSparseInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  resourceDeviceIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryDeviceIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupPresentCapabilitiesKHR **/
function VkDeviceGroupPresentCapabilitiesKHR(opts, byteOffset) {
  if (new.target !== VkDeviceGroupPresentCapabilitiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupPresentCapabilitiesKHR, STRUCT_CACHE_VkDeviceGroupPresentCapabilitiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupPresentCapabilitiesKHR, STRUCT_CACHE_VkDeviceGroupPresentCapabilitiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupPresentCapabilitiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._presentMask = [...Array(32)].fill(0x0);
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDeviceGroupPresentCapabilitiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupPresentCapabilitiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupPresentCapabilitiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "presentMask": {
    get() {
    return [
      this.memoryView.getUint32(0x0, true),
      this.memoryView.getUint32(0x4, true),
      this.memoryView.getUint32(0x8, true),
      this.memoryView.getUint32(0xC, true),
      this.memoryView.getUint32(0x10, true),
      this.memoryView.getUint32(0x14, true),
      this.memoryView.getUint32(0x18, true),
      this.memoryView.getUint32(0x1C, true),
      this.memoryView.getUint32(0x20, true),
      this.memoryView.getUint32(0x24, true),
      this.memoryView.getUint32(0x28, true),
      this.memoryView.getUint32(0x2C, true),
      this.memoryView.getUint32(0x30, true),
      this.memoryView.getUint32(0x34, true),
      this.memoryView.getUint32(0x38, true),
      this.memoryView.getUint32(0x3C, true),
      this.memoryView.getUint32(0x40, true),
      this.memoryView.getUint32(0x44, true),
      this.memoryView.getUint32(0x48, true),
      this.memoryView.getUint32(0x4C, true),
      this.memoryView.getUint32(0x50, true),
      this.memoryView.getUint32(0x54, true),
      this.memoryView.getUint32(0x58, true),
      this.memoryView.getUint32(0x5C, true),
      this.memoryView.getUint32(0x60, true),
      this.memoryView.getUint32(0x64, true),
      this.memoryView.getUint32(0x68, true),
      this.memoryView.getUint32(0x6C, true),
      this.memoryView.getUint32(0x70, true),
      this.memoryView.getUint32(0x74, true),
      this.memoryView.getUint32(0x78, true),
      this.memoryView.getUint32(0x7C, true)
    ];
    },
    },
  "modes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkDeviceGroupPresentCapabilitiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._presentMask !== null) this._presentMask.fill(0x0);
      else this._presentMask = [...Array(32)].fill(0x0);
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDeviceGroupPresentCapabilitiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupPresentCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDeviceGroupPresentCapabilitiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupPresentCapabilitiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.presentMask !== null) {
        copy.presentMask = [...Array(original.presentMask.length)].map((v, i) => {
          return original.presentMask[i];
        });
      }
  copy.modes = original.modes;
  
  return copy;
};

VkDeviceGroupPresentCapabilitiesKHR.byteLength = 0x0;

VkDeviceGroupPresentCapabilitiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  presentMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  modes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageSwapchainCreateInfoKHR **/
function VkImageSwapchainCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkImageSwapchainCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageSwapchainCreateInfoKHR, STRUCT_CACHE_VkImageSwapchainCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageSwapchainCreateInfoKHR, STRUCT_CACHE_VkImageSwapchainCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageSwapchainCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._swapchain = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
    
  }
};

Object.defineProperties(VkImageSwapchainCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSwapchainCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageSwapchainCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "swapchain": {
    get() {
    return this._swapchain;
    },
    set(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._swapchain = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._swapchain = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageSwapchainCreateInfoKHR.swapchain': Expected 'VkSwapchainKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageSwapchainCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._swapchain = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
    
  }
};

VkImageSwapchainCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageSwapchainCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageSwapchainCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageSwapchainCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.swapchain !== null) {
        copy.swapchain = original.swapchain.constructor.createCopyFrom(original.swapchain);
      }
  
  return copy;
};

VkImageSwapchainCreateInfoKHR.byteLength = 0x0;

VkImageSwapchainCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  swapchain: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindImageMemorySwapchainInfoKHR **/
function VkBindImageMemorySwapchainInfoKHR(opts, byteOffset) {
  if (new.target !== VkBindImageMemorySwapchainInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindImageMemorySwapchainInfoKHR, STRUCT_CACHE_VkBindImageMemorySwapchainInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindImageMemorySwapchainInfoKHR, STRUCT_CACHE_VkBindImageMemorySwapchainInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindImageMemorySwapchainInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._swapchain = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
    if (opts.imageIndex !== void 0) this.imageIndex = opts.imageIndex;
    
  }
};

Object.defineProperties(VkBindImageMemorySwapchainInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImageMemorySwapchainInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindImageMemorySwapchainInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "swapchain": {
    get() {
    return this._swapchain;
    },
    set(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._swapchain = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._swapchain = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemorySwapchainInfoKHR.swapchain': Expected 'VkSwapchainKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImageMemorySwapchainInfoKHR.imageIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkBindImageMemorySwapchainInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._swapchain = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
    if (opts.imageIndex !== void 0) this.imageIndex = opts.imageIndex;
    
  }
};

VkBindImageMemorySwapchainInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImageMemorySwapchainInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindImageMemorySwapchainInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindImageMemorySwapchainInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.swapchain !== null) {
        copy.swapchain = original.swapchain.constructor.createCopyFrom(original.swapchain);
      }
  copy.imageIndex = original.imageIndex;
  
  return copy;
};

VkBindImageMemorySwapchainInfoKHR.byteLength = 0x0;

VkBindImageMemorySwapchainInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  swapchain: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAcquireNextImageInfoKHR **/
function VkAcquireNextImageInfoKHR(opts, byteOffset) {
  if (new.target !== VkAcquireNextImageInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAcquireNextImageInfoKHR, STRUCT_CACHE_VkAcquireNextImageInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAcquireNextImageInfoKHR, STRUCT_CACHE_VkAcquireNextImageInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAcquireNextImageInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._swapchain = null;
  
  this._semaphore = null;
  this._fence = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
    if (opts.timeout !== void 0) this.timeout = opts.timeout;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

Object.defineProperties(VkAcquireNextImageInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAcquireNextImageInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAcquireNextImageInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "swapchain": {
    get() {
    return this._swapchain;
    },
    set(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._swapchain = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._swapchain = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.swapchain': Expected 'VkSwapchainKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "timeout": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAcquireNextImageInfoKHR.timeout")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._semaphore = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "fence": {
    get() {
    return this._fence;
    },
    set(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._fence = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.fence': Expected 'VkFence' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "deviceMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAcquireNextImageInfoKHR.deviceMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkAcquireNextImageInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._swapchain = null;
  
  this._semaphore = null;
  this._fence = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
    if (opts.timeout !== void 0) this.timeout = opts.timeout;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.fence !== void 0) this.fence = opts.fence;
    if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
    
  }
};

VkAcquireNextImageInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAcquireNextImageInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAcquireNextImageInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAcquireNextImageInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.swapchain !== null) {
        copy.swapchain = original.swapchain.constructor.createCopyFrom(original.swapchain);
      }
  copy.timeout = original.timeout;
  if (original.semaphore !== null) {
        copy.semaphore = original.semaphore.constructor.createCopyFrom(original.semaphore);
      }
  if (original.fence !== null) {
        copy.fence = original.fence.constructor.createCopyFrom(original.fence);
      }
  copy.deviceMask = original.deviceMask;
  
  return copy;
};

VkAcquireNextImageInfoKHR.byteLength = 0x0;

VkAcquireNextImageInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  swapchain: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  timeout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphore: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupPresentInfoKHR **/
function VkDeviceGroupPresentInfoKHR(opts, byteOffset) {
  if (new.target !== VkDeviceGroupPresentInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupPresentInfoKHR, STRUCT_CACHE_VkDeviceGroupPresentInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupPresentInfoKHR, STRUCT_CACHE_VkDeviceGroupPresentInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupPresentInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pDeviceMasks = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pDeviceMasks !== void 0) this.pDeviceMasks = opts.pDeviceMasks;
    if (opts.mode !== void 0) this.mode = opts.mode;
    
  }
};

Object.defineProperties(VkDeviceGroupPresentInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupPresentInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupPresentInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "swapchainCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupPresentInfoKHR.swapchainCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDeviceMasks": {
    get() {
    return this._pDeviceMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceMasks = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDeviceMasks = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentInfoKHR.pDeviceMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "mode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupPresentInfoKHR.mode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkDeviceGroupPresentInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pDeviceMasks = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pDeviceMasks !== void 0) this.pDeviceMasks = opts.pDeviceMasks;
    if (opts.mode !== void 0) this.mode = opts.mode;
    
  }
};

VkDeviceGroupPresentInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupPresentInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupPresentInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupPresentInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.swapchainCount = original.swapchainCount;
  if (original.pDeviceMasks !== null) {
        copy.pDeviceMasks = new Uint32Array(original.pDeviceMasks);
      }
  copy.mode = original.mode;
  
  return copy;
};

VkDeviceGroupPresentInfoKHR.byteLength = 0x0;

VkDeviceGroupPresentInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  swapchainCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDeviceMasks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupDeviceCreateInfo **/
function VkDeviceGroupDeviceCreateInfo(opts, byteOffset) {
  if (new.target !== VkDeviceGroupDeviceCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupDeviceCreateInfo, STRUCT_CACHE_VkDeviceGroupDeviceCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupDeviceCreateInfo, STRUCT_CACHE_VkDeviceGroupDeviceCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupDeviceCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pPhysicalDevices = null;
  this._pPhysicalDevicesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.physicalDeviceCount !== void 0) this.physicalDeviceCount = opts.physicalDeviceCount;
    if (opts.pPhysicalDevices !== void 0) this.pPhysicalDevices = opts.pPhysicalDevices;
    
  }
};

Object.defineProperties(VkDeviceGroupDeviceCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupDeviceCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupDeviceCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "physicalDeviceCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupDeviceCreateInfo.physicalDeviceCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPhysicalDevices": {
    get() {
    if (this._pPhysicalDevices === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.physicalDeviceCount, VkPhysicalDevice);
      this._pPhysicalDevices = array;
      return this.pPhysicalDevices;
    } else {
      return this._pPhysicalDevices;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPhysicalDevices = value;
    } else if (value === null) {
      this._pPhysicalDevices = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices': Expected 'Array VkPhysicalDevice' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDeviceGroupDeviceCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pPhysicalDevices = null;
  this._pPhysicalDevicesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.physicalDeviceCount !== void 0) this.physicalDeviceCount = opts.physicalDeviceCount;
    if (opts.pPhysicalDevices !== void 0) this.pPhysicalDevices = opts.pPhysicalDevices;
    
  }
};

VkDeviceGroupDeviceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPhysicalDevices !== null) {
    let array = this._pPhysicalDevices;
    
    if (array.length !== this.physicalDeviceCount) {
      throw new RangeError("Invalid array length, expected length of 'physicalDeviceCount' for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPhysicalDevice)) {
        throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices[" + ii + "]': Expected 'VkPhysicalDevice' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPhysicalDevicesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pPhysicalDevicesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDeviceGroupDeviceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupDeviceCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupDeviceCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.physicalDeviceCount = original.physicalDeviceCount;
  if (original.pPhysicalDevices !== null) {
        copy.pPhysicalDevices = [...Array(original.pPhysicalDevices.length)].map((v, i) => {
          return original.pPhysicalDevices[i].constructor.createCopyFrom(original.pPhysicalDevices[i]);
        });
      }
  
  return copy;
};

VkDeviceGroupDeviceCreateInfo.byteLength = 0x0;

VkDeviceGroupDeviceCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  physicalDeviceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPhysicalDevices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupDeviceCreateInfoKHR **/
function VkDeviceGroupDeviceCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkDeviceGroupDeviceCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupDeviceCreateInfoKHR, STRUCT_CACHE_VkDeviceGroupDeviceCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupDeviceCreateInfoKHR, STRUCT_CACHE_VkDeviceGroupDeviceCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupDeviceCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pPhysicalDevices = null;
  this._pPhysicalDevicesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.physicalDeviceCount !== void 0) this.physicalDeviceCount = opts.physicalDeviceCount;
    if (opts.pPhysicalDevices !== void 0) this.pPhysicalDevices = opts.pPhysicalDevices;
    
  }
};

Object.defineProperties(VkDeviceGroupDeviceCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupDeviceCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupDeviceCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "physicalDeviceCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupDeviceCreateInfoKHR.physicalDeviceCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPhysicalDevices": {
    get() {
    if (this._pPhysicalDevices === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.physicalDeviceCount, VkPhysicalDevice);
      this._pPhysicalDevices = array;
      return this.pPhysicalDevices;
    } else {
      return this._pPhysicalDevices;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPhysicalDevices = value;
    } else if (value === null) {
      this._pPhysicalDevices = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices': Expected 'Array VkPhysicalDevice' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDeviceGroupDeviceCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pPhysicalDevices = null;
  this._pPhysicalDevicesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.physicalDeviceCount !== void 0) this.physicalDeviceCount = opts.physicalDeviceCount;
    if (opts.pPhysicalDevices !== void 0) this.pPhysicalDevices = opts.pPhysicalDevices;
    
  }
};

VkDeviceGroupDeviceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPhysicalDevices !== null) {
    let array = this._pPhysicalDevices;
    
    if (array.length !== this.physicalDeviceCount) {
      throw new RangeError("Invalid array length, expected length of 'physicalDeviceCount' for 'VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPhysicalDevice)) {
        throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices[" + ii + "]': Expected 'VkPhysicalDevice' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPhysicalDevicesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pPhysicalDevicesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDeviceGroupDeviceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupDeviceCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupDeviceCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.physicalDeviceCount = original.physicalDeviceCount;
  if (original.pPhysicalDevices !== null) {
        copy.pPhysicalDevices = [...Array(original.pPhysicalDevices.length)].map((v, i) => {
          return original.pPhysicalDevices[i].constructor.createCopyFrom(original.pPhysicalDevices[i]);
        });
      }
  
  return copy;
};

VkDeviceGroupDeviceCreateInfoKHR.byteLength = 0x0;

VkDeviceGroupDeviceCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  physicalDeviceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPhysicalDevices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceGroupSwapchainCreateInfoKHR **/
function VkDeviceGroupSwapchainCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkDeviceGroupSwapchainCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceGroupSwapchainCreateInfoKHR, STRUCT_CACHE_VkDeviceGroupSwapchainCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceGroupSwapchainCreateInfoKHR, STRUCT_CACHE_VkDeviceGroupSwapchainCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceGroupSwapchainCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.modes !== void 0) this.modes = opts.modes;
    
  }
};

Object.defineProperties(VkDeviceGroupSwapchainCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupSwapchainCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceGroupSwapchainCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "modes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceGroupSwapchainCreateInfoKHR.modes");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkDeviceGroupSwapchainCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.modes !== void 0) this.modes = opts.modes;
    
  }
};

VkDeviceGroupSwapchainCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupSwapchainCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceGroupSwapchainCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceGroupSwapchainCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.modes = original.modes;
  
  return copy;
};

VkDeviceGroupSwapchainCreateInfoKHR.byteLength = 0x0;

VkDeviceGroupSwapchainCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  modes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorUpdateTemplateEntry **/
function VkDescriptorUpdateTemplateEntry(opts, byteOffset) {
  if (new.target !== VkDescriptorUpdateTemplateEntry) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorUpdateTemplateEntry, STRUCT_CACHE_VkDescriptorUpdateTemplateEntry);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorUpdateTemplateEntry, STRUCT_CACHE_VkDescriptorUpdateTemplateEntry);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorUpdateTemplateEntry'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.stride !== void 0) this.stride = opts.stride;
    
  }
};

Object.defineProperties(VkDescriptorUpdateTemplateEntry.prototype, {
  "dstBinding": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateEntry.dstBinding");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "dstArrayElement": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateEntry.dstArrayElement");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateEntry.descriptorCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "descriptorType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateEntry.descriptorType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "offset": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDescriptorUpdateTemplateEntry.offset")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "stride": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDescriptorUpdateTemplateEntry.stride")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  
});

VkDescriptorUpdateTemplateEntry.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.stride !== void 0) this.stride = opts.stride;
    
  }
};

VkDescriptorUpdateTemplateEntry.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorUpdateTemplateEntry.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorUpdateTemplateEntry.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorUpdateTemplateEntry();
  copy.dstBinding = original.dstBinding;
  copy.dstArrayElement = original.dstArrayElement;
  copy.descriptorCount = original.descriptorCount;
  copy.descriptorType = original.descriptorType;
  copy.offset = original.offset;
  copy.stride = original.stride;
  
  return copy;
};

VkDescriptorUpdateTemplateEntry.byteLength = 0x0;

VkDescriptorUpdateTemplateEntry.memoryLayout = {
  dstBinding: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstArrayElement: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorUpdateTemplateEntryKHR **/
function VkDescriptorUpdateTemplateEntryKHR(opts, byteOffset) {
  if (new.target !== VkDescriptorUpdateTemplateEntryKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorUpdateTemplateEntryKHR, STRUCT_CACHE_VkDescriptorUpdateTemplateEntryKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorUpdateTemplateEntryKHR, STRUCT_CACHE_VkDescriptorUpdateTemplateEntryKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorUpdateTemplateEntryKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.stride !== void 0) this.stride = opts.stride;
    
  }
};

Object.defineProperties(VkDescriptorUpdateTemplateEntryKHR.prototype, {
  "dstBinding": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateEntryKHR.dstBinding");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "dstArrayElement": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateEntryKHR.dstArrayElement");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "descriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateEntryKHR.descriptorCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "descriptorType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateEntryKHR.descriptorType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "offset": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDescriptorUpdateTemplateEntryKHR.offset")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "stride": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDescriptorUpdateTemplateEntryKHR.stride")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  
});

VkDescriptorUpdateTemplateEntryKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
    if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
    if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.stride !== void 0) this.stride = opts.stride;
    
  }
};

VkDescriptorUpdateTemplateEntryKHR.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorUpdateTemplateEntryKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorUpdateTemplateEntryKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorUpdateTemplateEntryKHR();
  copy.dstBinding = original.dstBinding;
  copy.dstArrayElement = original.dstArrayElement;
  copy.descriptorCount = original.descriptorCount;
  copy.descriptorType = original.descriptorType;
  copy.offset = original.offset;
  copy.stride = original.stride;
  
  return copy;
};

VkDescriptorUpdateTemplateEntryKHR.byteLength = 0x0;

VkDescriptorUpdateTemplateEntryKHR.memoryLayout = {
  dstBinding: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstArrayElement: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorUpdateTemplateCreateInfo **/
function VkDescriptorUpdateTemplateCreateInfo(opts, byteOffset) {
  if (new.target !== VkDescriptorUpdateTemplateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorUpdateTemplateCreateInfo, STRUCT_CACHE_VkDescriptorUpdateTemplateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorUpdateTemplateCreateInfo, STRUCT_CACHE_VkDescriptorUpdateTemplateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorUpdateTemplateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pDescriptorUpdateEntries = null;
  this._pDescriptorUpdateEntriesNative = null;
  
  this._descriptorSetLayout = null;
  
  this._pipelineLayout = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.descriptorUpdateEntryCount !== void 0) this.descriptorUpdateEntryCount = opts.descriptorUpdateEntryCount;
    if (opts.pDescriptorUpdateEntries !== void 0) this.pDescriptorUpdateEntries = opts.pDescriptorUpdateEntries;
    if (opts.templateType !== void 0) this.templateType = opts.templateType;
    if (opts.descriptorSetLayout !== void 0) this.descriptorSetLayout = opts.descriptorSetLayout;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
    if (opts.set !== void 0) this.set = opts.set;
    
  }
};

Object.defineProperties(VkDescriptorUpdateTemplateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorUpdateTemplateCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "descriptorUpdateEntryCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfo.descriptorUpdateEntryCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDescriptorUpdateEntries": {
    get() {
    if (this._pDescriptorUpdateEntries === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.descriptorUpdateEntryCount, VkDescriptorUpdateTemplateEntry);
      this._pDescriptorUpdateEntries = array;
      return this.pDescriptorUpdateEntries;
    } else {
      return this._pDescriptorUpdateEntries;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDescriptorUpdateEntries = value;
    } else if (value === null) {
      this._pDescriptorUpdateEntries = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries': Expected 'Array VkDescriptorUpdateTemplateEntry' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "templateType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfo.templateType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "descriptorSetLayout": {
    get() {
    return this._descriptorSetLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSetLayout) {
      
      this._descriptorSetLayout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._descriptorSetLayout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.descriptorSetLayout': Expected 'VkDescriptorSetLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfo.pipelineBindPoint");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pipelineLayout": {
    get() {
    return this._pipelineLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pipelineLayout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._pipelineLayout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pipelineLayout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "set": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfo.set");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDescriptorUpdateTemplateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pDescriptorUpdateEntries = null;
  this._pDescriptorUpdateEntriesNative = null;
  
  this._descriptorSetLayout = null;
  
  this._pipelineLayout = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.descriptorUpdateEntryCount !== void 0) this.descriptorUpdateEntryCount = opts.descriptorUpdateEntryCount;
    if (opts.pDescriptorUpdateEntries !== void 0) this.pDescriptorUpdateEntries = opts.pDescriptorUpdateEntries;
    if (opts.templateType !== void 0) this.templateType = opts.templateType;
    if (opts.descriptorSetLayout !== void 0) this.descriptorSetLayout = opts.descriptorSetLayout;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
    if (opts.set !== void 0) this.set = opts.set;
    
  }
};

VkDescriptorUpdateTemplateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDescriptorUpdateEntries !== null) {
    let array = this._pDescriptorUpdateEntries;
    
    if (array.length !== this.descriptorUpdateEntryCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorUpdateEntryCount' for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorUpdateTemplateEntry)) {
        throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries[" + ii + "]': Expected 'VkDescriptorUpdateTemplateEntry' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDescriptorUpdateEntriesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pDescriptorUpdateEntriesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDescriptorUpdateTemplateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorUpdateTemplateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorUpdateTemplateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.descriptorUpdateEntryCount = original.descriptorUpdateEntryCount;
  if (original.pDescriptorUpdateEntries !== null) {
        copy.pDescriptorUpdateEntries = [...Array(original.pDescriptorUpdateEntries.length)].map((v, i) => {
          return original.pDescriptorUpdateEntries[i].constructor.createCopyFrom(original.pDescriptorUpdateEntries[i]);
        });
      }
  copy.templateType = original.templateType;
  if (original.descriptorSetLayout !== null) {
        copy.descriptorSetLayout = original.descriptorSetLayout.constructor.createCopyFrom(original.descriptorSetLayout);
      }
  copy.pipelineBindPoint = original.pipelineBindPoint;
  if (original.pipelineLayout !== null) {
        copy.pipelineLayout = original.pipelineLayout.constructor.createCopyFrom(original.pipelineLayout);
      }
  copy.set = original.set;
  
  return copy;
};

VkDescriptorUpdateTemplateCreateInfo.byteLength = 0x0;

VkDescriptorUpdateTemplateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorUpdateEntryCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDescriptorUpdateEntries: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  templateType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorSetLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineBindPoint: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  set: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorUpdateTemplateCreateInfoKHR **/
function VkDescriptorUpdateTemplateCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkDescriptorUpdateTemplateCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorUpdateTemplateCreateInfoKHR, STRUCT_CACHE_VkDescriptorUpdateTemplateCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorUpdateTemplateCreateInfoKHR, STRUCT_CACHE_VkDescriptorUpdateTemplateCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorUpdateTemplateCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pDescriptorUpdateEntries = null;
  this._pDescriptorUpdateEntriesNative = null;
  
  this._descriptorSetLayout = null;
  
  this._pipelineLayout = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.descriptorUpdateEntryCount !== void 0) this.descriptorUpdateEntryCount = opts.descriptorUpdateEntryCount;
    if (opts.pDescriptorUpdateEntries !== void 0) this.pDescriptorUpdateEntries = opts.pDescriptorUpdateEntries;
    if (opts.templateType !== void 0) this.templateType = opts.templateType;
    if (opts.descriptorSetLayout !== void 0) this.descriptorSetLayout = opts.descriptorSetLayout;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
    if (opts.set !== void 0) this.set = opts.set;
    
  }
};

Object.defineProperties(VkDescriptorUpdateTemplateCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorUpdateTemplateCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "descriptorUpdateEntryCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfoKHR.descriptorUpdateEntryCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDescriptorUpdateEntries": {
    get() {
    if (this._pDescriptorUpdateEntries === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.descriptorUpdateEntryCount, VkDescriptorUpdateTemplateEntry);
      this._pDescriptorUpdateEntries = array;
      return this.pDescriptorUpdateEntries;
    } else {
      return this._pDescriptorUpdateEntries;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDescriptorUpdateEntries = value;
    } else if (value === null) {
      this._pDescriptorUpdateEntries = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries': Expected 'Array VkDescriptorUpdateTemplateEntry' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "templateType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfoKHR.templateType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "descriptorSetLayout": {
    get() {
    return this._descriptorSetLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkDescriptorSetLayout) {
      
      this._descriptorSetLayout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._descriptorSetLayout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.descriptorSetLayout': Expected 'VkDescriptorSetLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfoKHR.pipelineBindPoint");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pipelineLayout": {
    get() {
    return this._pipelineLayout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pipelineLayout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._pipelineLayout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pipelineLayout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "set": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorUpdateTemplateCreateInfoKHR.set");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDescriptorUpdateTemplateCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pDescriptorUpdateEntries = null;
  this._pDescriptorUpdateEntriesNative = null;
  
  this._descriptorSetLayout = null;
  
  this._pipelineLayout = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.descriptorUpdateEntryCount !== void 0) this.descriptorUpdateEntryCount = opts.descriptorUpdateEntryCount;
    if (opts.pDescriptorUpdateEntries !== void 0) this.pDescriptorUpdateEntries = opts.pDescriptorUpdateEntries;
    if (opts.templateType !== void 0) this.templateType = opts.templateType;
    if (opts.descriptorSetLayout !== void 0) this.descriptorSetLayout = opts.descriptorSetLayout;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
    if (opts.set !== void 0) this.set = opts.set;
    
  }
};

VkDescriptorUpdateTemplateCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDescriptorUpdateEntries !== null) {
    let array = this._pDescriptorUpdateEntries;
    
    if (array.length !== this.descriptorUpdateEntryCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorUpdateEntryCount' for 'VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDescriptorUpdateTemplateEntry)) {
        throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries[" + ii + "]': Expected 'VkDescriptorUpdateTemplateEntry' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDescriptorUpdateEntriesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pDescriptorUpdateEntriesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDescriptorUpdateTemplateCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorUpdateTemplateCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorUpdateTemplateCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.descriptorUpdateEntryCount = original.descriptorUpdateEntryCount;
  if (original.pDescriptorUpdateEntries !== null) {
        copy.pDescriptorUpdateEntries = [...Array(original.pDescriptorUpdateEntries.length)].map((v, i) => {
          return original.pDescriptorUpdateEntries[i].constructor.createCopyFrom(original.pDescriptorUpdateEntries[i]);
        });
      }
  copy.templateType = original.templateType;
  if (original.descriptorSetLayout !== null) {
        copy.descriptorSetLayout = original.descriptorSetLayout.constructor.createCopyFrom(original.descriptorSetLayout);
      }
  copy.pipelineBindPoint = original.pipelineBindPoint;
  if (original.pipelineLayout !== null) {
        copy.pipelineLayout = original.pipelineLayout.constructor.createCopyFrom(original.pipelineLayout);
      }
  copy.set = original.set;
  
  return copy;
};

VkDescriptorUpdateTemplateCreateInfoKHR.byteLength = 0x0;

VkDescriptorUpdateTemplateCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorUpdateEntryCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDescriptorUpdateEntries: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  templateType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorSetLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineBindPoint: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  set: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkXYColorEXT **/
function VkXYColorEXT(opts, byteOffset) {
  if (new.target !== VkXYColorEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkXYColorEXT, STRUCT_CACHE_VkXYColorEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkXYColorEXT, STRUCT_CACHE_VkXYColorEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkXYColorEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    
  }
};

Object.defineProperties(VkXYColorEXT.prototype, {
  "x": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkXYColorEXT.x");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "y": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkXYColorEXT.y");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkXYColorEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    
  }
};

VkXYColorEXT.prototype.flush = function flush() {
  
  return true;
};

VkXYColorEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkXYColorEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkXYColorEXT();
  copy.x = original.x;
  copy.y = original.y;
  
  return copy;
};

VkXYColorEXT.byteLength = 0x0;

VkXYColorEXT.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  y: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkHdrMetadataEXT **/
function VkHdrMetadataEXT(opts, byteOffset) {
  if (new.target !== VkHdrMetadataEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkHdrMetadataEXT, STRUCT_CACHE_VkHdrMetadataEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkHdrMetadataEXT, STRUCT_CACHE_VkHdrMetadataEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkHdrMetadataEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._displayPrimaryRed = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._displayPrimaryGreen = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._displayPrimaryBlue = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._whitePoint = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.displayPrimaryRed !== void 0) this.displayPrimaryRed = opts.displayPrimaryRed;
    if (opts.displayPrimaryGreen !== void 0) this.displayPrimaryGreen = opts.displayPrimaryGreen;
    if (opts.displayPrimaryBlue !== void 0) this.displayPrimaryBlue = opts.displayPrimaryBlue;
    if (opts.whitePoint !== void 0) this.whitePoint = opts.whitePoint;
    if (opts.maxLuminance !== void 0) this.maxLuminance = opts.maxLuminance;
    if (opts.minLuminance !== void 0) this.minLuminance = opts.minLuminance;
    if (opts.maxContentLightLevel !== void 0) this.maxContentLightLevel = opts.maxContentLightLevel;
    if (opts.maxFrameAverageLightLevel !== void 0) this.maxFrameAverageLightLevel = opts.maxFrameAverageLightLevel;
    
  }
};

Object.defineProperties(VkHdrMetadataEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkHdrMetadataEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkHdrMetadataEXT.pNext' isn't allowed to be filled");
    }
    },
  "displayPrimaryRed": {
    get() {
    return this._displayPrimaryRed;
    },
    set(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._displayPrimaryRed = value;
      
      
    } else if (value === null) {
      this._displayPrimaryRed = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.displayPrimaryRed': Expected 'VkXYColorEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "displayPrimaryGreen": {
    get() {
    return this._displayPrimaryGreen;
    },
    set(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._displayPrimaryGreen = value;
      
      
    } else if (value === null) {
      this._displayPrimaryGreen = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.displayPrimaryGreen': Expected 'VkXYColorEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "displayPrimaryBlue": {
    get() {
    return this._displayPrimaryBlue;
    },
    set(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._displayPrimaryBlue = value;
      
      
    } else if (value === null) {
      this._displayPrimaryBlue = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.displayPrimaryBlue': Expected 'VkXYColorEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "whitePoint": {
    get() {
    return this._whitePoint;
    },
    set(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._whitePoint = value;
      
      
    } else if (value === null) {
      this._whitePoint = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.whitePoint': Expected 'VkXYColorEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "maxLuminance": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkHdrMetadataEXT.maxLuminance");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "minLuminance": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkHdrMetadataEXT.minLuminance");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxContentLightLevel": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkHdrMetadataEXT.maxContentLightLevel");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxFrameAverageLightLevel": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkHdrMetadataEXT.maxFrameAverageLightLevel");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkHdrMetadataEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._displayPrimaryRed !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._displayPrimaryRed.memoryBuffer) this._displayPrimaryRed = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._displayPrimaryRed.reset();
  }
  if (this._displayPrimaryGreen !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._displayPrimaryGreen.memoryBuffer) this._displayPrimaryGreen = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._displayPrimaryGreen.reset();
  }
  if (this._displayPrimaryBlue !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._displayPrimaryBlue.memoryBuffer) this._displayPrimaryBlue = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._displayPrimaryBlue.reset();
  }
  if (this._whitePoint !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._whitePoint.memoryBuffer) this._whitePoint = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._whitePoint.reset();
  }
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.displayPrimaryRed !== void 0) this.displayPrimaryRed = opts.displayPrimaryRed;
    if (opts.displayPrimaryGreen !== void 0) this.displayPrimaryGreen = opts.displayPrimaryGreen;
    if (opts.displayPrimaryBlue !== void 0) this.displayPrimaryBlue = opts.displayPrimaryBlue;
    if (opts.whitePoint !== void 0) this.whitePoint = opts.whitePoint;
    if (opts.maxLuminance !== void 0) this.maxLuminance = opts.maxLuminance;
    if (opts.minLuminance !== void 0) this.minLuminance = opts.minLuminance;
    if (opts.maxContentLightLevel !== void 0) this.maxContentLightLevel = opts.maxContentLightLevel;
    if (opts.maxFrameAverageLightLevel !== void 0) this.maxFrameAverageLightLevel = opts.maxFrameAverageLightLevel;
    
  }
};

VkHdrMetadataEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._displayPrimaryRed !== null) {
    let displayPrimaryRed = this._displayPrimaryRed;
    displayPrimaryRed.flush();
    if (this.memoryBuffer !== displayPrimaryRed.memoryBuffer) {
      let srcView = new Uint8Array(displayPrimaryRed.memoryBuffer, displayPrimaryRed.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkHdrMetadataEXT.displayPrimaryRed' isn't used as shared-memory");
    }
  }
  
  
  if (this._displayPrimaryGreen !== null) {
    let displayPrimaryGreen = this._displayPrimaryGreen;
    displayPrimaryGreen.flush();
    if (this.memoryBuffer !== displayPrimaryGreen.memoryBuffer) {
      let srcView = new Uint8Array(displayPrimaryGreen.memoryBuffer, displayPrimaryGreen.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkHdrMetadataEXT.displayPrimaryGreen' isn't used as shared-memory");
    }
  }
  
  
  if (this._displayPrimaryBlue !== null) {
    let displayPrimaryBlue = this._displayPrimaryBlue;
    displayPrimaryBlue.flush();
    if (this.memoryBuffer !== displayPrimaryBlue.memoryBuffer) {
      let srcView = new Uint8Array(displayPrimaryBlue.memoryBuffer, displayPrimaryBlue.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkHdrMetadataEXT.displayPrimaryBlue' isn't used as shared-memory");
    }
  }
  
  
  if (this._whitePoint !== null) {
    let whitePoint = this._whitePoint;
    whitePoint.flush();
    if (this.memoryBuffer !== whitePoint.memoryBuffer) {
      let srcView = new Uint8Array(whitePoint.memoryBuffer, whitePoint.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkHdrMetadataEXT.whitePoint' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkHdrMetadataEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkHdrMetadataEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkHdrMetadataEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.displayPrimaryRed !== null) {
        copy.displayPrimaryRed = original.displayPrimaryRed.constructor.createCopyFrom(original.displayPrimaryRed);
      }
  if (original.displayPrimaryGreen !== null) {
        copy.displayPrimaryGreen = original.displayPrimaryGreen.constructor.createCopyFrom(original.displayPrimaryGreen);
      }
  if (original.displayPrimaryBlue !== null) {
        copy.displayPrimaryBlue = original.displayPrimaryBlue.constructor.createCopyFrom(original.displayPrimaryBlue);
      }
  if (original.whitePoint !== null) {
        copy.whitePoint = original.whitePoint.constructor.createCopyFrom(original.whitePoint);
      }
  copy.maxLuminance = original.maxLuminance;
  copy.minLuminance = original.minLuminance;
  copy.maxContentLightLevel = original.maxContentLightLevel;
  copy.maxFrameAverageLightLevel = original.maxFrameAverageLightLevel;
  
  return copy;
};

VkHdrMetadataEXT.byteLength = 0x0;

VkHdrMetadataEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  displayPrimaryRed: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  displayPrimaryGreen: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  displayPrimaryBlue: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  whitePoint: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxLuminance: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minLuminance: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxContentLightLevel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFrameAverageLightLevel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayNativeHdrSurfaceCapabilitiesAMD **/
function VkDisplayNativeHdrSurfaceCapabilitiesAMD(opts, byteOffset) {
  if (new.target !== VkDisplayNativeHdrSurfaceCapabilitiesAMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayNativeHdrSurfaceCapabilitiesAMD, STRUCT_CACHE_VkDisplayNativeHdrSurfaceCapabilitiesAMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayNativeHdrSurfaceCapabilitiesAMD, STRUCT_CACHE_VkDisplayNativeHdrSurfaceCapabilitiesAMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayNativeHdrSurfaceCapabilitiesAMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDisplayNativeHdrSurfaceCapabilitiesAMD.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayNativeHdrSurfaceCapabilitiesAMD.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayNativeHdrSurfaceCapabilitiesAMD.pNext' isn't allowed to be filled");
    }
    },
  "localDimmingSupport": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkDisplayNativeHdrSurfaceCapabilitiesAMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDisplayNativeHdrSurfaceCapabilitiesAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayNativeHdrSurfaceCapabilitiesAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDisplayNativeHdrSurfaceCapabilitiesAMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayNativeHdrSurfaceCapabilitiesAMD();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.localDimmingSupport = original.localDimmingSupport;
  
  return copy;
};

VkDisplayNativeHdrSurfaceCapabilitiesAMD.byteLength = 0x0;

VkDisplayNativeHdrSurfaceCapabilitiesAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  localDimmingSupport: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSwapchainDisplayNativeHdrCreateInfoAMD **/
function VkSwapchainDisplayNativeHdrCreateInfoAMD(opts, byteOffset) {
  if (new.target !== VkSwapchainDisplayNativeHdrCreateInfoAMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSwapchainDisplayNativeHdrCreateInfoAMD, STRUCT_CACHE_VkSwapchainDisplayNativeHdrCreateInfoAMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSwapchainDisplayNativeHdrCreateInfoAMD, STRUCT_CACHE_VkSwapchainDisplayNativeHdrCreateInfoAMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSwapchainDisplayNativeHdrCreateInfoAMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.localDimmingEnable !== void 0) this.localDimmingEnable = opts.localDimmingEnable;
    
  }
};

Object.defineProperties(VkSwapchainDisplayNativeHdrCreateInfoAMD.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSwapchainDisplayNativeHdrCreateInfoAMD.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSwapchainDisplayNativeHdrCreateInfoAMD.pNext' isn't allowed to be filled");
    }
    },
  "localDimmingEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkSwapchainDisplayNativeHdrCreateInfoAMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.localDimmingEnable !== void 0) this.localDimmingEnable = opts.localDimmingEnable;
    
  }
};

VkSwapchainDisplayNativeHdrCreateInfoAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSwapchainDisplayNativeHdrCreateInfoAMD.prototype.reflect = function reflect(memoryAddress) {
  };

VkSwapchainDisplayNativeHdrCreateInfoAMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSwapchainDisplayNativeHdrCreateInfoAMD();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.localDimmingEnable = original.localDimmingEnable;
  
  return copy;
};

VkSwapchainDisplayNativeHdrCreateInfoAMD.byteLength = 0x0;

VkSwapchainDisplayNativeHdrCreateInfoAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  localDimmingEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRefreshCycleDurationGOOGLE **/
function VkRefreshCycleDurationGOOGLE(opts, byteOffset) {
  if (new.target !== VkRefreshCycleDurationGOOGLE) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRefreshCycleDurationGOOGLE, STRUCT_CACHE_VkRefreshCycleDurationGOOGLE);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRefreshCycleDurationGOOGLE, STRUCT_CACHE_VkRefreshCycleDurationGOOGLE);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRefreshCycleDurationGOOGLE'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkRefreshCycleDurationGOOGLE.prototype, {
  "refreshDuration": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkRefreshCycleDurationGOOGLE.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  if (typeof opts === "object") {
    
  }
};

VkRefreshCycleDurationGOOGLE.prototype.flush = function flush() {
  
  return true;
};

VkRefreshCycleDurationGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkRefreshCycleDurationGOOGLE.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRefreshCycleDurationGOOGLE();
  copy.refreshDuration = original.refreshDuration;
  
  return copy;
};

VkRefreshCycleDurationGOOGLE.byteLength = 0x0;

VkRefreshCycleDurationGOOGLE.memoryLayout = {
  refreshDuration: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPastPresentationTimingGOOGLE **/
function VkPastPresentationTimingGOOGLE(opts, byteOffset) {
  if (new.target !== VkPastPresentationTimingGOOGLE) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPastPresentationTimingGOOGLE, STRUCT_CACHE_VkPastPresentationTimingGOOGLE);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPastPresentationTimingGOOGLE, STRUCT_CACHE_VkPastPresentationTimingGOOGLE);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPastPresentationTimingGOOGLE'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPastPresentationTimingGOOGLE.prototype, {
  "presentID": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "desiredPresentTime": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "actualPresentTime": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "earliestPresentTime": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "presentMargin": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPastPresentationTimingGOOGLE.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkPastPresentationTimingGOOGLE.prototype.flush = function flush() {
  
  return true;
};

VkPastPresentationTimingGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPastPresentationTimingGOOGLE.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPastPresentationTimingGOOGLE();
  copy.presentID = original.presentID;
  copy.desiredPresentTime = original.desiredPresentTime;
  copy.actualPresentTime = original.actualPresentTime;
  copy.earliestPresentTime = original.earliestPresentTime;
  copy.presentMargin = original.presentMargin;
  
  return copy;
};

VkPastPresentationTimingGOOGLE.byteLength = 0x0;

VkPastPresentationTimingGOOGLE.memoryLayout = {
  presentID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  desiredPresentTime: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  actualPresentTime: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  earliestPresentTime: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  presentMargin: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPresentTimesInfoGOOGLE **/
function VkPresentTimesInfoGOOGLE(opts, byteOffset) {
  if (new.target !== VkPresentTimesInfoGOOGLE) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPresentTimesInfoGOOGLE, STRUCT_CACHE_VkPresentTimesInfoGOOGLE);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPresentTimesInfoGOOGLE, STRUCT_CACHE_VkPresentTimesInfoGOOGLE);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPresentTimesInfoGOOGLE'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pTimes = null;
  this._pTimesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pTimes !== void 0) this.pTimes = opts.pTimes;
    
  }
};

Object.defineProperties(VkPresentTimesInfoGOOGLE.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPresentTimesInfoGOOGLE.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPresentTimesInfoGOOGLE.pNext' isn't allowed to be filled");
    }
    },
  "swapchainCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPresentTimesInfoGOOGLE.swapchainCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pTimes": {
    get() {
    if (this._pTimes === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.swapchainCount, VkPresentTimeGOOGLE);
      this._pTimes = array;
      return this.pTimes;
    } else {
      return this._pTimes;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pTimes = value;
    } else if (value === null) {
      this._pTimes = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentTimesInfoGOOGLE.pTimes': Expected 'Array VkPresentTimeGOOGLE' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPresentTimesInfoGOOGLE.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pTimes = null;
  this._pTimesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
    if (opts.pTimes !== void 0) this.pTimes = opts.pTimes;
    
  }
};

VkPresentTimesInfoGOOGLE.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pTimes !== null) {
    let array = this._pTimes;
    
    if (array.length !== this.swapchainCount) {
      throw new RangeError("Invalid array length, expected length of 'swapchainCount' for 'VkPresentTimesInfoGOOGLE.pTimes'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPresentTimeGOOGLE)) {
        throw new TypeError("Invalid type for 'VkPresentTimesInfoGOOGLE.pTimes[" + ii + "]': Expected 'VkPresentTimeGOOGLE' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pTimesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pTimesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPresentTimesInfoGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  };

VkPresentTimesInfoGOOGLE.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPresentTimesInfoGOOGLE();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.swapchainCount = original.swapchainCount;
  if (original.pTimes !== null) {
        copy.pTimes = [...Array(original.pTimes.length)].map((v, i) => {
          return original.pTimes[i].constructor.createCopyFrom(original.pTimes[i]);
        });
      }
  
  return copy;
};

VkPresentTimesInfoGOOGLE.byteLength = 0x0;

VkPresentTimesInfoGOOGLE.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  swapchainCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pTimes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPresentTimeGOOGLE **/
function VkPresentTimeGOOGLE(opts, byteOffset) {
  if (new.target !== VkPresentTimeGOOGLE) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPresentTimeGOOGLE, STRUCT_CACHE_VkPresentTimeGOOGLE);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPresentTimeGOOGLE, STRUCT_CACHE_VkPresentTimeGOOGLE);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPresentTimeGOOGLE'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.presentID !== void 0) this.presentID = opts.presentID;
    if (opts.desiredPresentTime !== void 0) this.desiredPresentTime = opts.desiredPresentTime;
    
  }
};

Object.defineProperties(VkPresentTimeGOOGLE.prototype, {
  "presentID": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPresentTimeGOOGLE.presentID");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "desiredPresentTime": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkPresentTimeGOOGLE.desiredPresentTime")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkPresentTimeGOOGLE.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.presentID !== void 0) this.presentID = opts.presentID;
    if (opts.desiredPresentTime !== void 0) this.desiredPresentTime = opts.desiredPresentTime;
    
  }
};

VkPresentTimeGOOGLE.prototype.flush = function flush() {
  
  return true;
};

VkPresentTimeGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  };

VkPresentTimeGOOGLE.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPresentTimeGOOGLE();
  copy.presentID = original.presentID;
  copy.desiredPresentTime = original.desiredPresentTime;
  
  return copy;
};

VkPresentTimeGOOGLE.byteLength = 0x0;

VkPresentTimeGOOGLE.memoryLayout = {
  presentID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  desiredPresentTime: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkViewportWScalingNV **/
function VkViewportWScalingNV(opts, byteOffset) {
  if (new.target !== VkViewportWScalingNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkViewportWScalingNV, STRUCT_CACHE_VkViewportWScalingNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkViewportWScalingNV, STRUCT_CACHE_VkViewportWScalingNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkViewportWScalingNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.xcoeff !== void 0) this.xcoeff = opts.xcoeff;
    if (opts.ycoeff !== void 0) this.ycoeff = opts.ycoeff;
    
  }
};

Object.defineProperties(VkViewportWScalingNV.prototype, {
  "xcoeff": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewportWScalingNV.xcoeff");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "ycoeff": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewportWScalingNV.ycoeff");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkViewportWScalingNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.xcoeff !== void 0) this.xcoeff = opts.xcoeff;
    if (opts.ycoeff !== void 0) this.ycoeff = opts.ycoeff;
    
  }
};

VkViewportWScalingNV.prototype.flush = function flush() {
  
  return true;
};

VkViewportWScalingNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkViewportWScalingNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkViewportWScalingNV();
  copy.xcoeff = original.xcoeff;
  copy.ycoeff = original.ycoeff;
  
  return copy;
};

VkViewportWScalingNV.byteLength = 0x0;

VkViewportWScalingNV.memoryLayout = {
  xcoeff: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ycoeff: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineViewportWScalingStateCreateInfoNV **/
function VkPipelineViewportWScalingStateCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkPipelineViewportWScalingStateCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineViewportWScalingStateCreateInfoNV, STRUCT_CACHE_VkPipelineViewportWScalingStateCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineViewportWScalingStateCreateInfoNV, STRUCT_CACHE_VkPipelineViewportWScalingStateCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineViewportWScalingStateCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pViewportWScalings = null;
  this._pViewportWScalingsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.viewportWScalingEnable !== void 0) this.viewportWScalingEnable = opts.viewportWScalingEnable;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pViewportWScalings !== void 0) this.pViewportWScalings = opts.pViewportWScalings;
    
  }
};

Object.defineProperties(VkPipelineViewportWScalingStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportWScalingStateCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineViewportWScalingStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "viewportWScalingEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "viewportCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportWScalingStateCreateInfoNV.viewportCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewportWScalings": {
    get() {
    if (this._pViewportWScalings === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.viewportCount, VkViewportWScalingNV);
      this._pViewportWScalings = array;
      return this.pViewportWScalings;
    } else {
      return this._pViewportWScalings;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pViewportWScalings = value;
    } else if (value === null) {
      this._pViewportWScalings = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings': Expected 'Array VkViewportWScalingNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportWScalingStateCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pViewportWScalings = null;
  this._pViewportWScalingsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.viewportWScalingEnable !== void 0) this.viewportWScalingEnable = opts.viewportWScalingEnable;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pViewportWScalings !== void 0) this.pViewportWScalings = opts.pViewportWScalings;
    
  }
};

VkPipelineViewportWScalingStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pViewportWScalings !== null) {
    let array = this._pViewportWScalings;
    
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkViewportWScalingNV)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings[" + ii + "]': Expected 'VkViewportWScalingNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pViewportWScalingsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pViewportWScalingsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineViewportWScalingStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineViewportWScalingStateCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineViewportWScalingStateCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.viewportWScalingEnable = original.viewportWScalingEnable;
  copy.viewportCount = original.viewportCount;
  if (original.pViewportWScalings !== null) {
        copy.pViewportWScalings = [...Array(original.pViewportWScalings.length)].map((v, i) => {
          return original.pViewportWScalings[i].constructor.createCopyFrom(original.pViewportWScalings[i]);
        });
      }
  
  return copy;
};

VkPipelineViewportWScalingStateCreateInfoNV.byteLength = 0x0;

VkPipelineViewportWScalingStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewportWScalingEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewportCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewportWScalings: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkViewportSwizzleNV **/
function VkViewportSwizzleNV(opts, byteOffset) {
  if (new.target !== VkViewportSwizzleNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkViewportSwizzleNV, STRUCT_CACHE_VkViewportSwizzleNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkViewportSwizzleNV, STRUCT_CACHE_VkViewportSwizzleNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkViewportSwizzleNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.z !== void 0) this.z = opts.z;
    if (opts.w !== void 0) this.w = opts.w;
    
  }
};

Object.defineProperties(VkViewportSwizzleNV.prototype, {
  "x": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewportSwizzleNV.x");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "y": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewportSwizzleNV.y");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "z": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewportSwizzleNV.z");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "w": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkViewportSwizzleNV.w");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkViewportSwizzleNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    if (opts.z !== void 0) this.z = opts.z;
    if (opts.w !== void 0) this.w = opts.w;
    
  }
};

VkViewportSwizzleNV.prototype.flush = function flush() {
  
  return true;
};

VkViewportSwizzleNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkViewportSwizzleNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkViewportSwizzleNV();
  copy.x = original.x;
  copy.y = original.y;
  copy.z = original.z;
  copy.w = original.w;
  
  return copy;
};

VkViewportSwizzleNV.byteLength = 0x0;

VkViewportSwizzleNV.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  y: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  z: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  w: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineViewportSwizzleStateCreateInfoNV **/
function VkPipelineViewportSwizzleStateCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkPipelineViewportSwizzleStateCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineViewportSwizzleStateCreateInfoNV, STRUCT_CACHE_VkPipelineViewportSwizzleStateCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineViewportSwizzleStateCreateInfoNV, STRUCT_CACHE_VkPipelineViewportSwizzleStateCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineViewportSwizzleStateCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pViewportSwizzles = null;
  this._pViewportSwizzlesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pViewportSwizzles !== void 0) this.pViewportSwizzles = opts.pViewportSwizzles;
    
  }
};

Object.defineProperties(VkPipelineViewportSwizzleStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportSwizzleStateCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineViewportSwizzleStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportSwizzleStateCreateInfoNV.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "viewportCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportSwizzleStateCreateInfoNV.viewportCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewportSwizzles": {
    get() {
    if (this._pViewportSwizzles === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.viewportCount, VkViewportSwizzleNV);
      this._pViewportSwizzles = array;
      return this.pViewportSwizzles;
    } else {
      return this._pViewportSwizzles;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pViewportSwizzles = value;
    } else if (value === null) {
      this._pViewportSwizzles = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles': Expected 'Array VkViewportSwizzleNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportSwizzleStateCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pViewportSwizzles = null;
  this._pViewportSwizzlesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pViewportSwizzles !== void 0) this.pViewportSwizzles = opts.pViewportSwizzles;
    
  }
};

VkPipelineViewportSwizzleStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pViewportSwizzles !== null) {
    let array = this._pViewportSwizzles;
    
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkViewportSwizzleNV)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles[" + ii + "]': Expected 'VkViewportSwizzleNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pViewportSwizzlesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pViewportSwizzlesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineViewportSwizzleStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineViewportSwizzleStateCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineViewportSwizzleStateCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.viewportCount = original.viewportCount;
  if (original.pViewportSwizzles !== null) {
        copy.pViewportSwizzles = [...Array(original.pViewportSwizzles.length)].map((v, i) => {
          return original.pViewportSwizzles[i].constructor.createCopyFrom(original.pViewportSwizzles[i]);
        });
      }
  
  return copy;
};

VkPipelineViewportSwizzleStateCreateInfoNV.byteLength = 0x0;

VkPipelineViewportSwizzleStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewportCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewportSwizzles: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDiscardRectanglePropertiesEXT **/
function VkPhysicalDeviceDiscardRectanglePropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDiscardRectanglePropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDiscardRectanglePropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceDiscardRectanglePropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDiscardRectanglePropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceDiscardRectanglePropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDiscardRectanglePropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDiscardRectanglePropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDiscardRectanglePropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDiscardRectanglePropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxDiscardRectangles": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceDiscardRectanglePropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceDiscardRectanglePropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDiscardRectanglePropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceDiscardRectanglePropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDiscardRectanglePropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxDiscardRectangles = original.maxDiscardRectangles;
  
  return copy;
};

VkPhysicalDeviceDiscardRectanglePropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceDiscardRectanglePropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDiscardRectangles: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineDiscardRectangleStateCreateInfoEXT **/
function VkPipelineDiscardRectangleStateCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPipelineDiscardRectangleStateCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineDiscardRectangleStateCreateInfoEXT, STRUCT_CACHE_VkPipelineDiscardRectangleStateCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineDiscardRectangleStateCreateInfoEXT, STRUCT_CACHE_VkPipelineDiscardRectangleStateCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineDiscardRectangleStateCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._pDiscardRectangles = null;
  this._pDiscardRectanglesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.discardRectangleMode !== void 0) this.discardRectangleMode = opts.discardRectangleMode;
    if (opts.discardRectangleCount !== void 0) this.discardRectangleCount = opts.discardRectangleCount;
    if (opts.pDiscardRectangles !== void 0) this.pDiscardRectangles = opts.pDiscardRectangles;
    
  }
};

Object.defineProperties(VkPipelineDiscardRectangleStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineDiscardRectangleStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "discardRectangleMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "discardRectangleCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDiscardRectangles": {
    get() {
    if (this._pDiscardRectangles === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.discardRectangleCount, VkRect2D);
      this._pDiscardRectangles = array;
      return this.pDiscardRectangles;
    } else {
      return this._pDiscardRectangles;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDiscardRectangles = value;
    } else if (value === null) {
      this._pDiscardRectangles = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineDiscardRectangleStateCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this._pDiscardRectangles = null;
  this._pDiscardRectanglesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.discardRectangleMode !== void 0) this.discardRectangleMode = opts.discardRectangleMode;
    if (opts.discardRectangleCount !== void 0) this.discardRectangleCount = opts.discardRectangleCount;
    if (opts.pDiscardRectangles !== void 0) this.pDiscardRectangles = opts.pDiscardRectangles;
    
  }
};

VkPipelineDiscardRectangleStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDiscardRectangles !== null) {
    let array = this._pDiscardRectangles;
    
    if (array.length !== this.discardRectangleCount) {
      throw new RangeError("Invalid array length, expected length of 'discardRectangleCount' for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDiscardRectanglesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pDiscardRectanglesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineDiscardRectangleStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineDiscardRectangleStateCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineDiscardRectangleStateCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.discardRectangleMode = original.discardRectangleMode;
  copy.discardRectangleCount = original.discardRectangleCount;
  if (original.pDiscardRectangles !== null) {
        copy.pDiscardRectangles = [...Array(original.pDiscardRectangles.length)].map((v, i) => {
          return original.pDiscardRectangles[i].constructor.createCopyFrom(original.pDiscardRectangles[i]);
        });
      }
  
  return copy;
};

VkPipelineDiscardRectangleStateCreateInfoEXT.byteLength = 0x0;

VkPipelineDiscardRectangleStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  discardRectangleMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  discardRectangleCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDiscardRectangles: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX **/
function VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, STRUCT_CACHE_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, STRUCT_CACHE_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.pNext' isn't allowed to be filled");
    }
    },
  "perViewPositionAllComponents": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.perViewPositionAllComponents = original.perViewPositionAllComponents;
  
  return copy;
};

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.byteLength = 0x0;

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  perViewPositionAllComponents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkInputAttachmentAspectReference **/
function VkInputAttachmentAspectReference(opts, byteOffset) {
  if (new.target !== VkInputAttachmentAspectReference) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkInputAttachmentAspectReference, STRUCT_CACHE_VkInputAttachmentAspectReference);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkInputAttachmentAspectReference, STRUCT_CACHE_VkInputAttachmentAspectReference);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkInputAttachmentAspectReference'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.inputAttachmentIndex !== void 0) this.inputAttachmentIndex = opts.inputAttachmentIndex;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

Object.defineProperties(VkInputAttachmentAspectReference.prototype, {
  "subpass": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInputAttachmentAspectReference.subpass");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "inputAttachmentIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInputAttachmentAspectReference.inputAttachmentIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "aspectMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInputAttachmentAspectReference.aspectMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkInputAttachmentAspectReference.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.inputAttachmentIndex !== void 0) this.inputAttachmentIndex = opts.inputAttachmentIndex;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

VkInputAttachmentAspectReference.prototype.flush = function flush() {
  
  return true;
};

VkInputAttachmentAspectReference.prototype.reflect = function reflect(memoryAddress) {
  };

VkInputAttachmentAspectReference.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkInputAttachmentAspectReference();
  copy.subpass = original.subpass;
  copy.inputAttachmentIndex = original.inputAttachmentIndex;
  copy.aspectMask = original.aspectMask;
  
  return copy;
};

VkInputAttachmentAspectReference.byteLength = 0x0;

VkInputAttachmentAspectReference.memoryLayout = {
  subpass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  inputAttachmentIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkInputAttachmentAspectReferenceKHR **/
function VkInputAttachmentAspectReferenceKHR(opts, byteOffset) {
  if (new.target !== VkInputAttachmentAspectReferenceKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkInputAttachmentAspectReferenceKHR, STRUCT_CACHE_VkInputAttachmentAspectReferenceKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkInputAttachmentAspectReferenceKHR, STRUCT_CACHE_VkInputAttachmentAspectReferenceKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkInputAttachmentAspectReferenceKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.inputAttachmentIndex !== void 0) this.inputAttachmentIndex = opts.inputAttachmentIndex;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

Object.defineProperties(VkInputAttachmentAspectReferenceKHR.prototype, {
  "subpass": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInputAttachmentAspectReferenceKHR.subpass");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "inputAttachmentIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInputAttachmentAspectReferenceKHR.inputAttachmentIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "aspectMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInputAttachmentAspectReferenceKHR.aspectMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkInputAttachmentAspectReferenceKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.subpass !== void 0) this.subpass = opts.subpass;
    if (opts.inputAttachmentIndex !== void 0) this.inputAttachmentIndex = opts.inputAttachmentIndex;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

VkInputAttachmentAspectReferenceKHR.prototype.flush = function flush() {
  
  return true;
};

VkInputAttachmentAspectReferenceKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkInputAttachmentAspectReferenceKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkInputAttachmentAspectReferenceKHR();
  copy.subpass = original.subpass;
  copy.inputAttachmentIndex = original.inputAttachmentIndex;
  copy.aspectMask = original.aspectMask;
  
  return copy;
};

VkInputAttachmentAspectReferenceKHR.byteLength = 0x0;

VkInputAttachmentAspectReferenceKHR.memoryLayout = {
  subpass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  inputAttachmentIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassInputAttachmentAspectCreateInfo **/
function VkRenderPassInputAttachmentAspectCreateInfo(opts, byteOffset) {
  if (new.target !== VkRenderPassInputAttachmentAspectCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassInputAttachmentAspectCreateInfo, STRUCT_CACHE_VkRenderPassInputAttachmentAspectCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassInputAttachmentAspectCreateInfo, STRUCT_CACHE_VkRenderPassInputAttachmentAspectCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassInputAttachmentAspectCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAspectReferences = null;
  this._pAspectReferencesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.aspectReferenceCount !== void 0) this.aspectReferenceCount = opts.aspectReferenceCount;
    if (opts.pAspectReferences !== void 0) this.pAspectReferences = opts.pAspectReferences;
    
  }
};

Object.defineProperties(VkRenderPassInputAttachmentAspectCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassInputAttachmentAspectCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassInputAttachmentAspectCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "aspectReferenceCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassInputAttachmentAspectCreateInfo.aspectReferenceCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAspectReferences": {
    get() {
    if (this._pAspectReferences === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.aspectReferenceCount, VkInputAttachmentAspectReference);
      this._pAspectReferences = array;
      return this.pAspectReferences;
    } else {
      return this._pAspectReferences;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAspectReferences = value;
    } else if (value === null) {
      this._pAspectReferences = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences': Expected 'Array VkInputAttachmentAspectReference' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassInputAttachmentAspectCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAspectReferences = null;
  this._pAspectReferencesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.aspectReferenceCount !== void 0) this.aspectReferenceCount = opts.aspectReferenceCount;
    if (opts.pAspectReferences !== void 0) this.pAspectReferences = opts.pAspectReferences;
    
  }
};

VkRenderPassInputAttachmentAspectCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAspectReferences !== null) {
    let array = this._pAspectReferences;
    
    if (array.length !== this.aspectReferenceCount) {
      throw new RangeError("Invalid array length, expected length of 'aspectReferenceCount' for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkInputAttachmentAspectReference)) {
        throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences[" + ii + "]': Expected 'VkInputAttachmentAspectReference' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAspectReferencesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAspectReferencesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRenderPassInputAttachmentAspectCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassInputAttachmentAspectCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassInputAttachmentAspectCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.aspectReferenceCount = original.aspectReferenceCount;
  if (original.pAspectReferences !== null) {
        copy.pAspectReferences = [...Array(original.pAspectReferences.length)].map((v, i) => {
          return original.pAspectReferences[i].constructor.createCopyFrom(original.pAspectReferences[i]);
        });
      }
  
  return copy;
};

VkRenderPassInputAttachmentAspectCreateInfo.byteLength = 0x0;

VkRenderPassInputAttachmentAspectCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  aspectReferenceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAspectReferences: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassInputAttachmentAspectCreateInfoKHR **/
function VkRenderPassInputAttachmentAspectCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkRenderPassInputAttachmentAspectCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassInputAttachmentAspectCreateInfoKHR, STRUCT_CACHE_VkRenderPassInputAttachmentAspectCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassInputAttachmentAspectCreateInfoKHR, STRUCT_CACHE_VkRenderPassInputAttachmentAspectCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassInputAttachmentAspectCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAspectReferences = null;
  this._pAspectReferencesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.aspectReferenceCount !== void 0) this.aspectReferenceCount = opts.aspectReferenceCount;
    if (opts.pAspectReferences !== void 0) this.pAspectReferences = opts.pAspectReferences;
    
  }
};

Object.defineProperties(VkRenderPassInputAttachmentAspectCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassInputAttachmentAspectCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassInputAttachmentAspectCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "aspectReferenceCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassInputAttachmentAspectCreateInfoKHR.aspectReferenceCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAspectReferences": {
    get() {
    if (this._pAspectReferences === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.aspectReferenceCount, VkInputAttachmentAspectReference);
      this._pAspectReferences = array;
      return this.pAspectReferences;
    } else {
      return this._pAspectReferences;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAspectReferences = value;
    } else if (value === null) {
      this._pAspectReferences = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences': Expected 'Array VkInputAttachmentAspectReference' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassInputAttachmentAspectCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAspectReferences = null;
  this._pAspectReferencesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.aspectReferenceCount !== void 0) this.aspectReferenceCount = opts.aspectReferenceCount;
    if (opts.pAspectReferences !== void 0) this.pAspectReferences = opts.pAspectReferences;
    
  }
};

VkRenderPassInputAttachmentAspectCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAspectReferences !== null) {
    let array = this._pAspectReferences;
    
    if (array.length !== this.aspectReferenceCount) {
      throw new RangeError("Invalid array length, expected length of 'aspectReferenceCount' for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkInputAttachmentAspectReference)) {
        throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences[" + ii + "]': Expected 'VkInputAttachmentAspectReference' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAspectReferencesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAspectReferencesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRenderPassInputAttachmentAspectCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassInputAttachmentAspectCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassInputAttachmentAspectCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.aspectReferenceCount = original.aspectReferenceCount;
  if (original.pAspectReferences !== null) {
        copy.pAspectReferences = [...Array(original.pAspectReferences.length)].map((v, i) => {
          return original.pAspectReferences[i].constructor.createCopyFrom(original.pAspectReferences[i]);
        });
      }
  
  return copy;
};

VkRenderPassInputAttachmentAspectCreateInfoKHR.byteLength = 0x0;

VkRenderPassInputAttachmentAspectCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  aspectReferenceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAspectReferences: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSurfaceInfo2KHR **/
function VkPhysicalDeviceSurfaceInfo2KHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSurfaceInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSurfaceInfo2KHR, STRUCT_CACHE_VkPhysicalDeviceSurfaceInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSurfaceInfo2KHR, STRUCT_CACHE_VkPhysicalDeviceSurfaceInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSurfaceInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._surface = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.surface !== void 0) this.surface = opts.surface;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSurfaceInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSurfaceInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.pNext'");
      switch (sType) {
          
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.pNext'");
    }
    
    }
    },
  "surface": {
    get() {
    return this._surface;
    },
    set(value) {
    if (value !== null && value.constructor === VkSurfaceKHR) {
      
      this._surface = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._surface = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.surface': Expected 'VkSurfaceKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPhysicalDeviceSurfaceInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._surface = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.surface !== void 0) this.surface = opts.surface;
    
  }
};

VkPhysicalDeviceSurfaceInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSurfaceInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceSurfaceInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSurfaceInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.surface !== null) {
        copy.surface = original.surface.constructor.createCopyFrom(original.surface);
      }
  
  return copy;
};

VkPhysicalDeviceSurfaceInfo2KHR.byteLength = 0x0;

VkPhysicalDeviceSurfaceInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  surface: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSurfaceCapabilities2KHR **/
function VkSurfaceCapabilities2KHR(opts, byteOffset) {
  if (new.target !== VkSurfaceCapabilities2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSurfaceCapabilities2KHR, STRUCT_CACHE_VkSurfaceCapabilities2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSurfaceCapabilities2KHR, STRUCT_CACHE_VkSurfaceCapabilities2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSurfaceCapabilities2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._surfaceCapabilities = new VkSurfaceCapabilitiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSurfaceCapabilities2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSurfaceCapabilities2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.pNext'");
      switch (sType) {
          
        case :
        case :
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.pNext'");
    }
    
    }
    },
  "surfaceCapabilities": {
    get() {
    return this._surfaceCapabilities;
    },
    },
  
});

VkSurfaceCapabilities2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._surfaceCapabilities !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._surfaceCapabilities.memoryBuffer) this._surfaceCapabilities = new VkSurfaceCapabilitiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._surfaceCapabilities.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSurfaceCapabilities2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceCapabilities2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSurfaceCapabilities2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSurfaceCapabilities2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.surfaceCapabilities !== null) {
        copy.surfaceCapabilities = original.surfaceCapabilities.constructor.createCopyFrom(original.surfaceCapabilities);
      }
  
  return copy;
};

VkSurfaceCapabilities2KHR.byteLength = 0x0;

VkSurfaceCapabilities2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  surfaceCapabilities: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSurfaceFormat2KHR **/
function VkSurfaceFormat2KHR(opts, byteOffset) {
  if (new.target !== VkSurfaceFormat2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSurfaceFormat2KHR, STRUCT_CACHE_VkSurfaceFormat2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSurfaceFormat2KHR, STRUCT_CACHE_VkSurfaceFormat2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSurfaceFormat2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._surfaceFormat = new VkSurfaceFormatKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSurfaceFormat2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSurfaceFormat2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceFormat2KHR.pNext' isn't allowed to be filled");
    }
    },
  "surfaceFormat": {
    get() {
    return this._surfaceFormat;
    },
    },
  
});

VkSurfaceFormat2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._surfaceFormat !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._surfaceFormat.memoryBuffer) this._surfaceFormat = new VkSurfaceFormatKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._surfaceFormat.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSurfaceFormat2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceFormat2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSurfaceFormat2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSurfaceFormat2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.surfaceFormat !== null) {
        copy.surfaceFormat = original.surfaceFormat.constructor.createCopyFrom(original.surfaceFormat);
      }
  
  return copy;
};

VkSurfaceFormat2KHR.byteLength = 0x0;

VkSurfaceFormat2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  surfaceFormat: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayProperties2KHR **/
function VkDisplayProperties2KHR(opts, byteOffset) {
  if (new.target !== VkDisplayProperties2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayProperties2KHR, STRUCT_CACHE_VkDisplayProperties2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayProperties2KHR, STRUCT_CACHE_VkDisplayProperties2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayProperties2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._displayProperties = new VkDisplayPropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDisplayProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayProperties2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayProperties2KHR.pNext' isn't allowed to be filled");
    }
    },
  "displayProperties": {
    get() {
    return this._displayProperties;
    },
    },
  
});

VkDisplayProperties2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._displayProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._displayProperties.memoryBuffer) this._displayProperties = new VkDisplayPropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._displayProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDisplayProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDisplayProperties2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayProperties2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.displayProperties !== null) {
        copy.displayProperties = original.displayProperties.constructor.createCopyFrom(original.displayProperties);
      }
  
  return copy;
};

VkDisplayProperties2KHR.byteLength = 0x0;

VkDisplayProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  displayProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayPlaneProperties2KHR **/
function VkDisplayPlaneProperties2KHR(opts, byteOffset) {
  if (new.target !== VkDisplayPlaneProperties2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayPlaneProperties2KHR, STRUCT_CACHE_VkDisplayPlaneProperties2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayPlaneProperties2KHR, STRUCT_CACHE_VkDisplayPlaneProperties2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayPlaneProperties2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._displayPlaneProperties = new VkDisplayPlanePropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDisplayPlaneProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayPlaneProperties2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayPlaneProperties2KHR.pNext' isn't allowed to be filled");
    }
    },
  "displayPlaneProperties": {
    get() {
    return this._displayPlaneProperties;
    },
    },
  
});

VkDisplayPlaneProperties2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._displayPlaneProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._displayPlaneProperties.memoryBuffer) this._displayPlaneProperties = new VkDisplayPlanePropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._displayPlaneProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDisplayPlaneProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPlaneProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDisplayPlaneProperties2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayPlaneProperties2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.displayPlaneProperties !== null) {
        copy.displayPlaneProperties = original.displayPlaneProperties.constructor.createCopyFrom(original.displayPlaneProperties);
      }
  
  return copy;
};

VkDisplayPlaneProperties2KHR.byteLength = 0x0;

VkDisplayPlaneProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  displayPlaneProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayModeProperties2KHR **/
function VkDisplayModeProperties2KHR(opts, byteOffset) {
  if (new.target !== VkDisplayModeProperties2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayModeProperties2KHR, STRUCT_CACHE_VkDisplayModeProperties2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayModeProperties2KHR, STRUCT_CACHE_VkDisplayModeProperties2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayModeProperties2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._displayModeProperties = new VkDisplayModePropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDisplayModeProperties2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayModeProperties2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayModeProperties2KHR.pNext' isn't allowed to be filled");
    }
    },
  "displayModeProperties": {
    get() {
    return this._displayModeProperties;
    },
    },
  
});

VkDisplayModeProperties2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._displayModeProperties !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._displayModeProperties.memoryBuffer) this._displayModeProperties = new VkDisplayModePropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._displayModeProperties.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDisplayModeProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayModeProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDisplayModeProperties2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayModeProperties2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.displayModeProperties !== null) {
        copy.displayModeProperties = original.displayModeProperties.constructor.createCopyFrom(original.displayModeProperties);
      }
  
  return copy;
};

VkDisplayModeProperties2KHR.byteLength = 0x0;

VkDisplayModeProperties2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  displayModeProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayPlaneInfo2KHR **/
function VkDisplayPlaneInfo2KHR(opts, byteOffset) {
  if (new.target !== VkDisplayPlaneInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayPlaneInfo2KHR, STRUCT_CACHE_VkDisplayPlaneInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayPlaneInfo2KHR, STRUCT_CACHE_VkDisplayPlaneInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayPlaneInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._mode = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.mode !== void 0) this.mode = opts.mode;
    if (opts.planeIndex !== void 0) this.planeIndex = opts.planeIndex;
    
  }
};

Object.defineProperties(VkDisplayPlaneInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayPlaneInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayPlaneInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "mode": {
    get() {
    return this._mode;
    },
    set(value) {
    if (value !== null && value.constructor === VkDisplayModeKHR) {
      
      this._mode = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._mode = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDisplayPlaneInfo2KHR.mode': Expected 'VkDisplayModeKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "planeIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayPlaneInfo2KHR.planeIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDisplayPlaneInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._mode = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.mode !== void 0) this.mode = opts.mode;
    if (opts.planeIndex !== void 0) this.planeIndex = opts.planeIndex;
    
  }
};

VkDisplayPlaneInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPlaneInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDisplayPlaneInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayPlaneInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.mode !== null) {
        copy.mode = original.mode.constructor.createCopyFrom(original.mode);
      }
  copy.planeIndex = original.planeIndex;
  
  return copy;
};

VkDisplayPlaneInfo2KHR.byteLength = 0x0;

VkDisplayPlaneInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  planeIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDisplayPlaneCapabilities2KHR **/
function VkDisplayPlaneCapabilities2KHR(opts, byteOffset) {
  if (new.target !== VkDisplayPlaneCapabilities2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDisplayPlaneCapabilities2KHR, STRUCT_CACHE_VkDisplayPlaneCapabilities2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDisplayPlaneCapabilities2KHR, STRUCT_CACHE_VkDisplayPlaneCapabilities2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDisplayPlaneCapabilities2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._capabilities = new VkDisplayPlaneCapabilitiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDisplayPlaneCapabilities2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDisplayPlaneCapabilities2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDisplayPlaneCapabilities2KHR.pNext' isn't allowed to be filled");
    }
    },
  "capabilities": {
    get() {
    return this._capabilities;
    },
    },
  
});

VkDisplayPlaneCapabilities2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._capabilities !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._capabilities.memoryBuffer) this._capabilities = new VkDisplayPlaneCapabilitiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._capabilities.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDisplayPlaneCapabilities2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPlaneCapabilities2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDisplayPlaneCapabilities2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDisplayPlaneCapabilities2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.capabilities !== null) {
        copy.capabilities = original.capabilities.constructor.createCopyFrom(original.capabilities);
      }
  
  return copy;
};

VkDisplayPlaneCapabilities2KHR.byteLength = 0x0;

VkDisplayPlaneCapabilities2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  capabilities: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSharedPresentSurfaceCapabilitiesKHR **/
function VkSharedPresentSurfaceCapabilitiesKHR(opts, byteOffset) {
  if (new.target !== VkSharedPresentSurfaceCapabilitiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSharedPresentSurfaceCapabilitiesKHR, STRUCT_CACHE_VkSharedPresentSurfaceCapabilitiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSharedPresentSurfaceCapabilitiesKHR, STRUCT_CACHE_VkSharedPresentSurfaceCapabilitiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSharedPresentSurfaceCapabilitiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSharedPresentSurfaceCapabilitiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSharedPresentSurfaceCapabilitiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSharedPresentSurfaceCapabilitiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "sharedPresentSupportedUsageFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkSharedPresentSurfaceCapabilitiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSharedPresentSurfaceCapabilitiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSharedPresentSurfaceCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSharedPresentSurfaceCapabilitiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSharedPresentSurfaceCapabilitiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.sharedPresentSupportedUsageFlags = original.sharedPresentSupportedUsageFlags;
  
  return copy;
};

VkSharedPresentSurfaceCapabilitiesKHR.byteLength = 0x0;

VkSharedPresentSurfaceCapabilitiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sharedPresentSupportedUsageFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevice16BitStorageFeatures **/
function VkPhysicalDevice16BitStorageFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDevice16BitStorageFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevice16BitStorageFeatures, STRUCT_CACHE_VkPhysicalDevice16BitStorageFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevice16BitStorageFeatures, STRUCT_CACHE_VkPhysicalDevice16BitStorageFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevice16BitStorageFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer16BitAccess !== void 0) this.storageBuffer16BitAccess = opts.storageBuffer16BitAccess;
    if (opts.uniformAndStorageBuffer16BitAccess !== void 0) this.uniformAndStorageBuffer16BitAccess = opts.uniformAndStorageBuffer16BitAccess;
    if (opts.storagePushConstant16 !== void 0) this.storagePushConstant16 = opts.storagePushConstant16;
    if (opts.storageInputOutput16 !== void 0) this.storageInputOutput16 = opts.storageInputOutput16;
    
  }
};

Object.defineProperties(VkPhysicalDevice16BitStorageFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevice16BitStorageFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevice16BitStorageFeatures.pNext' isn't allowed to be filled");
    }
    },
  "storageBuffer16BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "uniformAndStorageBuffer16BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "storagePushConstant16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "storageInputOutput16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDevice16BitStorageFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer16BitAccess !== void 0) this.storageBuffer16BitAccess = opts.storageBuffer16BitAccess;
    if (opts.uniformAndStorageBuffer16BitAccess !== void 0) this.uniformAndStorageBuffer16BitAccess = opts.uniformAndStorageBuffer16BitAccess;
    if (opts.storagePushConstant16 !== void 0) this.storagePushConstant16 = opts.storagePushConstant16;
    if (opts.storageInputOutput16 !== void 0) this.storageInputOutput16 = opts.storageInputOutput16;
    
  }
};

VkPhysicalDevice16BitStorageFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice16BitStorageFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDevice16BitStorageFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevice16BitStorageFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.storageBuffer16BitAccess = original.storageBuffer16BitAccess;
  copy.uniformAndStorageBuffer16BitAccess = original.uniformAndStorageBuffer16BitAccess;
  copy.storagePushConstant16 = original.storagePushConstant16;
  copy.storageInputOutput16 = original.storageInputOutput16;
  
  return copy;
};

VkPhysicalDevice16BitStorageFeatures.byteLength = 0x0;

VkPhysicalDevice16BitStorageFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageBuffer16BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformAndStorageBuffer16BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storagePushConstant16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageInputOutput16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevice16BitStorageFeaturesKHR **/
function VkPhysicalDevice16BitStorageFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDevice16BitStorageFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevice16BitStorageFeaturesKHR, STRUCT_CACHE_VkPhysicalDevice16BitStorageFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevice16BitStorageFeaturesKHR, STRUCT_CACHE_VkPhysicalDevice16BitStorageFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevice16BitStorageFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer16BitAccess !== void 0) this.storageBuffer16BitAccess = opts.storageBuffer16BitAccess;
    if (opts.uniformAndStorageBuffer16BitAccess !== void 0) this.uniformAndStorageBuffer16BitAccess = opts.uniformAndStorageBuffer16BitAccess;
    if (opts.storagePushConstant16 !== void 0) this.storagePushConstant16 = opts.storagePushConstant16;
    if (opts.storageInputOutput16 !== void 0) this.storageInputOutput16 = opts.storageInputOutput16;
    
  }
};

Object.defineProperties(VkPhysicalDevice16BitStorageFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevice16BitStorageFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevice16BitStorageFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "storageBuffer16BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "uniformAndStorageBuffer16BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "storagePushConstant16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "storageInputOutput16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDevice16BitStorageFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer16BitAccess !== void 0) this.storageBuffer16BitAccess = opts.storageBuffer16BitAccess;
    if (opts.uniformAndStorageBuffer16BitAccess !== void 0) this.uniformAndStorageBuffer16BitAccess = opts.uniformAndStorageBuffer16BitAccess;
    if (opts.storagePushConstant16 !== void 0) this.storagePushConstant16 = opts.storagePushConstant16;
    if (opts.storageInputOutput16 !== void 0) this.storageInputOutput16 = opts.storageInputOutput16;
    
  }
};

VkPhysicalDevice16BitStorageFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice16BitStorageFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDevice16BitStorageFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevice16BitStorageFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.storageBuffer16BitAccess = original.storageBuffer16BitAccess;
  copy.uniformAndStorageBuffer16BitAccess = original.uniformAndStorageBuffer16BitAccess;
  copy.storagePushConstant16 = original.storagePushConstant16;
  copy.storageInputOutput16 = original.storageInputOutput16;
  
  return copy;
};

VkPhysicalDevice16BitStorageFeaturesKHR.byteLength = 0x0;

VkPhysicalDevice16BitStorageFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageBuffer16BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformAndStorageBuffer16BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storagePushConstant16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageInputOutput16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSubgroupProperties **/
function VkPhysicalDeviceSubgroupProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSubgroupProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSubgroupProperties, STRUCT_CACHE_VkPhysicalDeviceSubgroupProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSubgroupProperties, STRUCT_CACHE_VkPhysicalDeviceSubgroupProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSubgroupProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSubgroupProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSubgroupProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSubgroupProperties.pNext' isn't allowed to be filled");
    }
    },
  "subgroupSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "supportedStages": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "supportedOperations": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "quadOperationsInAllStages": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceSubgroupProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceSubgroupProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSubgroupProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceSubgroupProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSubgroupProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.subgroupSize = original.subgroupSize;
  copy.supportedStages = original.supportedStages;
  copy.supportedOperations = original.supportedOperations;
  copy.quadOperationsInAllStages = original.quadOperationsInAllStages;
  
  return copy;
};

VkPhysicalDeviceSubgroupProperties.byteLength = 0x0;

VkPhysicalDeviceSubgroupProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subgroupSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedStages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedOperations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  quadOperationsInAllStages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures **/
function VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, STRUCT_CACHE_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, STRUCT_CACHE_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderSubgroupExtendedTypes !== void 0) this.shaderSubgroupExtendedTypes = opts.shaderSubgroupExtendedTypes;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.pNext' isn't allowed to be filled");
    }
    },
  "shaderSubgroupExtendedTypes": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderSubgroupExtendedTypes !== void 0) this.shaderSubgroupExtendedTypes = opts.shaderSubgroupExtendedTypes;
    
  }
};

VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderSubgroupExtendedTypes = original.shaderSubgroupExtendedTypes;
  
  return copy;
};

VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.byteLength = 0x0;

VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSubgroupExtendedTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR **/
function VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderSubgroupExtendedTypes !== void 0) this.shaderSubgroupExtendedTypes = opts.shaderSubgroupExtendedTypes;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "shaderSubgroupExtendedTypes": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderSubgroupExtendedTypes !== void 0) this.shaderSubgroupExtendedTypes = opts.shaderSubgroupExtendedTypes;
    
  }
};

VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderSubgroupExtendedTypes = original.shaderSubgroupExtendedTypes;
  
  return copy;
};

VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSubgroupExtendedTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferMemoryRequirementsInfo2 **/
function VkBufferMemoryRequirementsInfo2(opts, byteOffset) {
  if (new.target !== VkBufferMemoryRequirementsInfo2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferMemoryRequirementsInfo2, STRUCT_CACHE_VkBufferMemoryRequirementsInfo2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferMemoryRequirementsInfo2, STRUCT_CACHE_VkBufferMemoryRequirementsInfo2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferMemoryRequirementsInfo2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkBufferMemoryRequirementsInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferMemoryRequirementsInfo2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferMemoryRequirementsInfo2.pNext' isn't allowed to be filled");
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBufferMemoryRequirementsInfo2.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferMemoryRequirementsInfo2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

VkBufferMemoryRequirementsInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferMemoryRequirementsInfo2.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferMemoryRequirementsInfo2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferMemoryRequirementsInfo2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  
  return copy;
};

VkBufferMemoryRequirementsInfo2.byteLength = 0x0;

VkBufferMemoryRequirementsInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferMemoryRequirementsInfo2KHR **/
function VkBufferMemoryRequirementsInfo2KHR(opts, byteOffset) {
  if (new.target !== VkBufferMemoryRequirementsInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferMemoryRequirementsInfo2KHR, STRUCT_CACHE_VkBufferMemoryRequirementsInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferMemoryRequirementsInfo2KHR, STRUCT_CACHE_VkBufferMemoryRequirementsInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferMemoryRequirementsInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkBufferMemoryRequirementsInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferMemoryRequirementsInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferMemoryRequirementsInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBufferMemoryRequirementsInfo2KHR.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferMemoryRequirementsInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

VkBufferMemoryRequirementsInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferMemoryRequirementsInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferMemoryRequirementsInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferMemoryRequirementsInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  
  return copy;
};

VkBufferMemoryRequirementsInfo2KHR.byteLength = 0x0;

VkBufferMemoryRequirementsInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageMemoryRequirementsInfo2 **/
function VkImageMemoryRequirementsInfo2(opts, byteOffset) {
  if (new.target !== VkImageMemoryRequirementsInfo2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageMemoryRequirementsInfo2, STRUCT_CACHE_VkImageMemoryRequirementsInfo2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageMemoryRequirementsInfo2, STRUCT_CACHE_VkImageMemoryRequirementsInfo2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageMemoryRequirementsInfo2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._image = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

Object.defineProperties(VkImageMemoryRequirementsInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageMemoryRequirementsInfo2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.pNext'");
    }
    
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageMemoryRequirementsInfo2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._image = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

VkImageMemoryRequirementsInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageMemoryRequirementsInfo2.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageMemoryRequirementsInfo2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageMemoryRequirementsInfo2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  
  return copy;
};

VkImageMemoryRequirementsInfo2.byteLength = 0x0;

VkImageMemoryRequirementsInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageMemoryRequirementsInfo2KHR **/
function VkImageMemoryRequirementsInfo2KHR(opts, byteOffset) {
  if (new.target !== VkImageMemoryRequirementsInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageMemoryRequirementsInfo2KHR, STRUCT_CACHE_VkImageMemoryRequirementsInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageMemoryRequirementsInfo2KHR, STRUCT_CACHE_VkImageMemoryRequirementsInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageMemoryRequirementsInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._image = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

Object.defineProperties(VkImageMemoryRequirementsInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageMemoryRequirementsInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.pNext'");
    }
    
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageMemoryRequirementsInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._image = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

VkImageMemoryRequirementsInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageMemoryRequirementsInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageMemoryRequirementsInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageMemoryRequirementsInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  
  return copy;
};

VkImageMemoryRequirementsInfo2KHR.byteLength = 0x0;

VkImageMemoryRequirementsInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageSparseMemoryRequirementsInfo2 **/
function VkImageSparseMemoryRequirementsInfo2(opts, byteOffset) {
  if (new.target !== VkImageSparseMemoryRequirementsInfo2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageSparseMemoryRequirementsInfo2, STRUCT_CACHE_VkImageSparseMemoryRequirementsInfo2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageSparseMemoryRequirementsInfo2, STRUCT_CACHE_VkImageSparseMemoryRequirementsInfo2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageSparseMemoryRequirementsInfo2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._image = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

Object.defineProperties(VkImageSparseMemoryRequirementsInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSparseMemoryRequirementsInfo2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageSparseMemoryRequirementsInfo2.pNext' isn't allowed to be filled");
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageSparseMemoryRequirementsInfo2.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageSparseMemoryRequirementsInfo2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._image = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

VkImageSparseMemoryRequirementsInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageSparseMemoryRequirementsInfo2.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageSparseMemoryRequirementsInfo2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageSparseMemoryRequirementsInfo2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  
  return copy;
};

VkImageSparseMemoryRequirementsInfo2.byteLength = 0x0;

VkImageSparseMemoryRequirementsInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageSparseMemoryRequirementsInfo2KHR **/
function VkImageSparseMemoryRequirementsInfo2KHR(opts, byteOffset) {
  if (new.target !== VkImageSparseMemoryRequirementsInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageSparseMemoryRequirementsInfo2KHR, STRUCT_CACHE_VkImageSparseMemoryRequirementsInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageSparseMemoryRequirementsInfo2KHR, STRUCT_CACHE_VkImageSparseMemoryRequirementsInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageSparseMemoryRequirementsInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._image = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

Object.defineProperties(VkImageSparseMemoryRequirementsInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageSparseMemoryRequirementsInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageSparseMemoryRequirementsInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageSparseMemoryRequirementsInfo2KHR.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageSparseMemoryRequirementsInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._image = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    
  }
};

VkImageSparseMemoryRequirementsInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageSparseMemoryRequirementsInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageSparseMemoryRequirementsInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageSparseMemoryRequirementsInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  
  return copy;
};

VkImageSparseMemoryRequirementsInfo2KHR.byteLength = 0x0;

VkImageSparseMemoryRequirementsInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryRequirements2 **/
function VkMemoryRequirements2(opts, byteOffset) {
  if (new.target !== VkMemoryRequirements2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryRequirements2, STRUCT_CACHE_VkMemoryRequirements2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryRequirements2, STRUCT_CACHE_VkMemoryRequirements2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryRequirements2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memoryRequirements = new VkMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryRequirements2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryRequirements2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkMemoryRequirements2.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkMemoryRequirements2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkMemoryRequirements2.pNext'");
    }
    
    }
    },
  "memoryRequirements": {
    get() {
    return this._memoryRequirements;
    },
    },
  
});

VkMemoryRequirements2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._memoryRequirements !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._memoryRequirements.memoryBuffer) this._memoryRequirements = new VkMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._memoryRequirements.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkMemoryRequirements2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryRequirements2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMemoryRequirements2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryRequirements2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memoryRequirements !== null) {
        copy.memoryRequirements = original.memoryRequirements.constructor.createCopyFrom(original.memoryRequirements);
      }
  
  return copy;
};

VkMemoryRequirements2.byteLength = 0x0;

VkMemoryRequirements2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryRequirements: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryRequirements2KHR **/
function VkMemoryRequirements2KHR(opts, byteOffset) {
  if (new.target !== VkMemoryRequirements2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryRequirements2KHR, STRUCT_CACHE_VkMemoryRequirements2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryRequirements2KHR, STRUCT_CACHE_VkMemoryRequirements2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryRequirements2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memoryRequirements = new VkMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryRequirements2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryRequirements2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.pNext'");
    }
    
    }
    },
  "memoryRequirements": {
    get() {
    return this._memoryRequirements;
    },
    },
  
});

VkMemoryRequirements2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._memoryRequirements !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._memoryRequirements.memoryBuffer) this._memoryRequirements = new VkMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._memoryRequirements.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkMemoryRequirements2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryRequirements2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMemoryRequirements2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryRequirements2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memoryRequirements !== null) {
        copy.memoryRequirements = original.memoryRequirements.constructor.createCopyFrom(original.memoryRequirements);
      }
  
  return copy;
};

VkMemoryRequirements2KHR.byteLength = 0x0;

VkMemoryRequirements2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryRequirements: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseImageMemoryRequirements2 **/
function VkSparseImageMemoryRequirements2(opts, byteOffset) {
  if (new.target !== VkSparseImageMemoryRequirements2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseImageMemoryRequirements2, STRUCT_CACHE_VkSparseImageMemoryRequirements2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseImageMemoryRequirements2, STRUCT_CACHE_VkSparseImageMemoryRequirements2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseImageMemoryRequirements2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memoryRequirements = new VkSparseImageMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSparseImageMemoryRequirements2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSparseImageMemoryRequirements2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSparseImageMemoryRequirements2.pNext' isn't allowed to be filled");
    }
    },
  "memoryRequirements": {
    get() {
    return this._memoryRequirements;
    },
    },
  
});

VkSparseImageMemoryRequirements2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._memoryRequirements !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._memoryRequirements.memoryBuffer) this._memoryRequirements = new VkSparseImageMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._memoryRequirements.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSparseImageMemoryRequirements2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageMemoryRequirements2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSparseImageMemoryRequirements2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseImageMemoryRequirements2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memoryRequirements !== null) {
        copy.memoryRequirements = original.memoryRequirements.constructor.createCopyFrom(original.memoryRequirements);
      }
  
  return copy;
};

VkSparseImageMemoryRequirements2.byteLength = 0x0;

VkSparseImageMemoryRequirements2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryRequirements: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSparseImageMemoryRequirements2KHR **/
function VkSparseImageMemoryRequirements2KHR(opts, byteOffset) {
  if (new.target !== VkSparseImageMemoryRequirements2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSparseImageMemoryRequirements2KHR, STRUCT_CACHE_VkSparseImageMemoryRequirements2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSparseImageMemoryRequirements2KHR, STRUCT_CACHE_VkSparseImageMemoryRequirements2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSparseImageMemoryRequirements2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memoryRequirements = new VkSparseImageMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSparseImageMemoryRequirements2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSparseImageMemoryRequirements2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSparseImageMemoryRequirements2KHR.pNext' isn't allowed to be filled");
    }
    },
  "memoryRequirements": {
    get() {
    return this._memoryRequirements;
    },
    },
  
});

VkSparseImageMemoryRequirements2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._memoryRequirements !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._memoryRequirements.memoryBuffer) this._memoryRequirements = new VkSparseImageMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._memoryRequirements.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSparseImageMemoryRequirements2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageMemoryRequirements2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSparseImageMemoryRequirements2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSparseImageMemoryRequirements2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memoryRequirements !== null) {
        copy.memoryRequirements = original.memoryRequirements.constructor.createCopyFrom(original.memoryRequirements);
      }
  
  return copy;
};

VkSparseImageMemoryRequirements2KHR.byteLength = 0x0;

VkSparseImageMemoryRequirements2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryRequirements: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevicePointClippingProperties **/
function VkPhysicalDevicePointClippingProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDevicePointClippingProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevicePointClippingProperties, STRUCT_CACHE_VkPhysicalDevicePointClippingProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevicePointClippingProperties, STRUCT_CACHE_VkPhysicalDevicePointClippingProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevicePointClippingProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDevicePointClippingProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevicePointClippingProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePointClippingProperties.pNext' isn't allowed to be filled");
    }
    },
  "pointClippingBehavior": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkPhysicalDevicePointClippingProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDevicePointClippingProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePointClippingProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDevicePointClippingProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevicePointClippingProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pointClippingBehavior = original.pointClippingBehavior;
  
  return copy;
};

VkPhysicalDevicePointClippingProperties.byteLength = 0x0;

VkPhysicalDevicePointClippingProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pointClippingBehavior: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevicePointClippingPropertiesKHR **/
function VkPhysicalDevicePointClippingPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDevicePointClippingPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevicePointClippingPropertiesKHR, STRUCT_CACHE_VkPhysicalDevicePointClippingPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevicePointClippingPropertiesKHR, STRUCT_CACHE_VkPhysicalDevicePointClippingPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevicePointClippingPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDevicePointClippingPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevicePointClippingPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePointClippingPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "pointClippingBehavior": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkPhysicalDevicePointClippingPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDevicePointClippingPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePointClippingPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDevicePointClippingPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevicePointClippingPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pointClippingBehavior = original.pointClippingBehavior;
  
  return copy;
};

VkPhysicalDevicePointClippingPropertiesKHR.byteLength = 0x0;

VkPhysicalDevicePointClippingPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pointClippingBehavior: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryDedicatedRequirements **/
function VkMemoryDedicatedRequirements(opts, byteOffset) {
  if (new.target !== VkMemoryDedicatedRequirements) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryDedicatedRequirements, STRUCT_CACHE_VkMemoryDedicatedRequirements);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryDedicatedRequirements, STRUCT_CACHE_VkMemoryDedicatedRequirements);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryDedicatedRequirements'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryDedicatedRequirements.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryDedicatedRequirements.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryDedicatedRequirements.pNext' isn't allowed to be filled");
    }
    },
  "prefersDedicatedAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "requiresDedicatedAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkMemoryDedicatedRequirements.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkMemoryDedicatedRequirements.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedRequirements.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMemoryDedicatedRequirements.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryDedicatedRequirements();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.prefersDedicatedAllocation = original.prefersDedicatedAllocation;
  copy.requiresDedicatedAllocation = original.requiresDedicatedAllocation;
  
  return copy;
};

VkMemoryDedicatedRequirements.byteLength = 0x0;

VkMemoryDedicatedRequirements.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  prefersDedicatedAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  requiresDedicatedAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryDedicatedRequirementsKHR **/
function VkMemoryDedicatedRequirementsKHR(opts, byteOffset) {
  if (new.target !== VkMemoryDedicatedRequirementsKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryDedicatedRequirementsKHR, STRUCT_CACHE_VkMemoryDedicatedRequirementsKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryDedicatedRequirementsKHR, STRUCT_CACHE_VkMemoryDedicatedRequirementsKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryDedicatedRequirementsKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryDedicatedRequirementsKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryDedicatedRequirementsKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryDedicatedRequirementsKHR.pNext' isn't allowed to be filled");
    }
    },
  "prefersDedicatedAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "requiresDedicatedAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkMemoryDedicatedRequirementsKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkMemoryDedicatedRequirementsKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedRequirementsKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMemoryDedicatedRequirementsKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryDedicatedRequirementsKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.prefersDedicatedAllocation = original.prefersDedicatedAllocation;
  copy.requiresDedicatedAllocation = original.requiresDedicatedAllocation;
  
  return copy;
};

VkMemoryDedicatedRequirementsKHR.byteLength = 0x0;

VkMemoryDedicatedRequirementsKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  prefersDedicatedAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  requiresDedicatedAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryDedicatedAllocateInfo **/
function VkMemoryDedicatedAllocateInfo(opts, byteOffset) {
  if (new.target !== VkMemoryDedicatedAllocateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryDedicatedAllocateInfo, STRUCT_CACHE_VkMemoryDedicatedAllocateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryDedicatedAllocateInfo, STRUCT_CACHE_VkMemoryDedicatedAllocateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryDedicatedAllocateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkMemoryDedicatedAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryDedicatedAllocateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryDedicatedAllocateInfo.pNext' isn't allowed to be filled");
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfo.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkMemoryDedicatedAllocateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

VkMemoryDedicatedAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryDedicatedAllocateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryDedicatedAllocateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  
  return copy;
};

VkMemoryDedicatedAllocateInfo.byteLength = 0x0;

VkMemoryDedicatedAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryDedicatedAllocateInfoKHR **/
function VkMemoryDedicatedAllocateInfoKHR(opts, byteOffset) {
  if (new.target !== VkMemoryDedicatedAllocateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryDedicatedAllocateInfoKHR, STRUCT_CACHE_VkMemoryDedicatedAllocateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryDedicatedAllocateInfoKHR, STRUCT_CACHE_VkMemoryDedicatedAllocateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryDedicatedAllocateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkMemoryDedicatedAllocateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryDedicatedAllocateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryDedicatedAllocateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "image": {
    get() {
    return this._image;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._image = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfoKHR.image': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfoKHR.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkMemoryDedicatedAllocateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._image = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.image !== void 0) this.image = opts.image;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

VkMemoryDedicatedAllocateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedAllocateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryDedicatedAllocateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryDedicatedAllocateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.image !== null) {
        copy.image = original.image.constructor.createCopyFrom(original.image);
      }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  
  return copy;
};

VkMemoryDedicatedAllocateInfoKHR.byteLength = 0x0;

VkMemoryDedicatedAllocateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  image: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageViewUsageCreateInfo **/
function VkImageViewUsageCreateInfo(opts, byteOffset) {
  if (new.target !== VkImageViewUsageCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageViewUsageCreateInfo, STRUCT_CACHE_VkImageViewUsageCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageViewUsageCreateInfo, STRUCT_CACHE_VkImageViewUsageCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageViewUsageCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.usage !== void 0) this.usage = opts.usage;
    
  }
};

Object.defineProperties(VkImageViewUsageCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewUsageCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageViewUsageCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewUsageCreateInfo.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImageViewUsageCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.usage !== void 0) this.usage = opts.usage;
    
  }
};

VkImageViewUsageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewUsageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageViewUsageCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageViewUsageCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.usage = original.usage;
  
  return copy;
};

VkImageViewUsageCreateInfo.byteLength = 0x0;

VkImageViewUsageCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageViewUsageCreateInfoKHR **/
function VkImageViewUsageCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkImageViewUsageCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageViewUsageCreateInfoKHR, STRUCT_CACHE_VkImageViewUsageCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageViewUsageCreateInfoKHR, STRUCT_CACHE_VkImageViewUsageCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageViewUsageCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.usage !== void 0) this.usage = opts.usage;
    
  }
};

Object.defineProperties(VkImageViewUsageCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewUsageCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageViewUsageCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewUsageCreateInfoKHR.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImageViewUsageCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.usage !== void 0) this.usage = opts.usage;
    
  }
};

VkImageViewUsageCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewUsageCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageViewUsageCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageViewUsageCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.usage = original.usage;
  
  return copy;
};

VkImageViewUsageCreateInfoKHR.byteLength = 0x0;

VkImageViewUsageCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineTessellationDomainOriginStateCreateInfo **/
function VkPipelineTessellationDomainOriginStateCreateInfo(opts, byteOffset) {
  if (new.target !== VkPipelineTessellationDomainOriginStateCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineTessellationDomainOriginStateCreateInfo, STRUCT_CACHE_VkPipelineTessellationDomainOriginStateCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineTessellationDomainOriginStateCreateInfo, STRUCT_CACHE_VkPipelineTessellationDomainOriginStateCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineTessellationDomainOriginStateCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.domainOrigin !== void 0) this.domainOrigin = opts.domainOrigin;
    
  }
};

Object.defineProperties(VkPipelineTessellationDomainOriginStateCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineTessellationDomainOriginStateCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineTessellationDomainOriginStateCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "domainOrigin": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineTessellationDomainOriginStateCreateInfo.domainOrigin");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPipelineTessellationDomainOriginStateCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.domainOrigin !== void 0) this.domainOrigin = opts.domainOrigin;
    
  }
};

VkPipelineTessellationDomainOriginStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineTessellationDomainOriginStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineTessellationDomainOriginStateCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineTessellationDomainOriginStateCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.domainOrigin = original.domainOrigin;
  
  return copy;
};

VkPipelineTessellationDomainOriginStateCreateInfo.byteLength = 0x0;

VkPipelineTessellationDomainOriginStateCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  domainOrigin: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineTessellationDomainOriginStateCreateInfoKHR **/
function VkPipelineTessellationDomainOriginStateCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkPipelineTessellationDomainOriginStateCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineTessellationDomainOriginStateCreateInfoKHR, STRUCT_CACHE_VkPipelineTessellationDomainOriginStateCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineTessellationDomainOriginStateCreateInfoKHR, STRUCT_CACHE_VkPipelineTessellationDomainOriginStateCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineTessellationDomainOriginStateCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.domainOrigin !== void 0) this.domainOrigin = opts.domainOrigin;
    
  }
};

Object.defineProperties(VkPipelineTessellationDomainOriginStateCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineTessellationDomainOriginStateCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineTessellationDomainOriginStateCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "domainOrigin": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineTessellationDomainOriginStateCreateInfoKHR.domainOrigin");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPipelineTessellationDomainOriginStateCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.domainOrigin !== void 0) this.domainOrigin = opts.domainOrigin;
    
  }
};

VkPipelineTessellationDomainOriginStateCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineTessellationDomainOriginStateCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineTessellationDomainOriginStateCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineTessellationDomainOriginStateCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.domainOrigin = original.domainOrigin;
  
  return copy;
};

VkPipelineTessellationDomainOriginStateCreateInfoKHR.byteLength = 0x0;

VkPipelineTessellationDomainOriginStateCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  domainOrigin: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSamplerYcbcrConversionInfo **/
function VkSamplerYcbcrConversionInfo(opts, byteOffset) {
  if (new.target !== VkSamplerYcbcrConversionInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSamplerYcbcrConversionInfo, STRUCT_CACHE_VkSamplerYcbcrConversionInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSamplerYcbcrConversionInfo, STRUCT_CACHE_VkSamplerYcbcrConversionInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSamplerYcbcrConversionInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._conversion = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conversion !== void 0) this.conversion = opts.conversion;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerYcbcrConversionInfo.pNext' isn't allowed to be filled");
    }
    },
  "conversion": {
    get() {
    return this._conversion;
    },
    set(value) {
    if (value !== null && value.constructor === VkSamplerYcbcrConversion) {
      
      this._conversion = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._conversion = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionInfo.conversion': Expected 'VkSamplerYcbcrConversion' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSamplerYcbcrConversionInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._conversion = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conversion !== void 0) this.conversion = opts.conversion;
    
  }
};

VkSamplerYcbcrConversionInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSamplerYcbcrConversionInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSamplerYcbcrConversionInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.conversion !== null) {
        copy.conversion = original.conversion.constructor.createCopyFrom(original.conversion);
      }
  
  return copy;
};

VkSamplerYcbcrConversionInfo.byteLength = 0x0;

VkSamplerYcbcrConversionInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  conversion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSamplerYcbcrConversionInfoKHR **/
function VkSamplerYcbcrConversionInfoKHR(opts, byteOffset) {
  if (new.target !== VkSamplerYcbcrConversionInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSamplerYcbcrConversionInfoKHR, STRUCT_CACHE_VkSamplerYcbcrConversionInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSamplerYcbcrConversionInfoKHR, STRUCT_CACHE_VkSamplerYcbcrConversionInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSamplerYcbcrConversionInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._conversion = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conversion !== void 0) this.conversion = opts.conversion;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerYcbcrConversionInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "conversion": {
    get() {
    return this._conversion;
    },
    set(value) {
    if (value !== null && value.constructor === VkSamplerYcbcrConversion) {
      
      this._conversion = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._conversion = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionInfoKHR.conversion': Expected 'VkSamplerYcbcrConversion' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSamplerYcbcrConversionInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._conversion = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conversion !== void 0) this.conversion = opts.conversion;
    
  }
};

VkSamplerYcbcrConversionInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSamplerYcbcrConversionInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSamplerYcbcrConversionInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.conversion !== null) {
        copy.conversion = original.conversion.constructor.createCopyFrom(original.conversion);
      }
  
  return copy;
};

VkSamplerYcbcrConversionInfoKHR.byteLength = 0x0;

VkSamplerYcbcrConversionInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  conversion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSamplerYcbcrConversionCreateInfo **/
function VkSamplerYcbcrConversionCreateInfo(opts, byteOffset) {
  if (new.target !== VkSamplerYcbcrConversionCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSamplerYcbcrConversionCreateInfo, STRUCT_CACHE_VkSamplerYcbcrConversionCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSamplerYcbcrConversionCreateInfo, STRUCT_CACHE_VkSamplerYcbcrConversionCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSamplerYcbcrConversionCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.ycbcrModel !== void 0) this.ycbcrModel = opts.ycbcrModel;
    if (opts.ycbcrRange !== void 0) this.ycbcrRange = opts.ycbcrRange;
    if (opts.components !== void 0) this.components = opts.components;
    if (opts.xChromaOffset !== void 0) this.xChromaOffset = opts.xChromaOffset;
    if (opts.yChromaOffset !== void 0) this.yChromaOffset = opts.yChromaOffset;
    if (opts.chromaFilter !== void 0) this.chromaFilter = opts.chromaFilter;
    if (opts.forceExplicitReconstruction !== void 0) this.forceExplicitReconstruction = opts.forceExplicitReconstruction;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.pNext'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfo.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "ycbcrModel": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfo.ycbcrModel");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "ycbcrRange": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfo.ycbcrRange");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "components": {
    get() {
    return this._components;
    },
    set(value) {
    if (value !== null && value.constructor === VkComponentMapping) {
      value.flush();
      this._components = value;
      
      
    } else if (value === null) {
      this._components = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.components': Expected 'VkComponentMapping' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "xChromaOffset": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfo.xChromaOffset");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "yChromaOffset": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfo.yChromaOffset");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "chromaFilter": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfo.chromaFilter");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "forceExplicitReconstruction": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkSamplerYcbcrConversionCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  if (this._components !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._components.memoryBuffer) this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._components.reset();
  }
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.ycbcrModel !== void 0) this.ycbcrModel = opts.ycbcrModel;
    if (opts.ycbcrRange !== void 0) this.ycbcrRange = opts.ycbcrRange;
    if (opts.components !== void 0) this.components = opts.components;
    if (opts.xChromaOffset !== void 0) this.xChromaOffset = opts.xChromaOffset;
    if (opts.yChromaOffset !== void 0) this.yChromaOffset = opts.yChromaOffset;
    if (opts.chromaFilter !== void 0) this.chromaFilter = opts.chromaFilter;
    if (opts.forceExplicitReconstruction !== void 0) this.forceExplicitReconstruction = opts.forceExplicitReconstruction;
    
  }
};

VkSamplerYcbcrConversionCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._components !== null) {
    let components = this._components;
    components.flush();
    if (this.memoryBuffer !== components.memoryBuffer) {
      let srcView = new Uint8Array(components.memoryBuffer, components.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSamplerYcbcrConversionCreateInfo.components' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSamplerYcbcrConversionCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSamplerYcbcrConversionCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSamplerYcbcrConversionCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.format = original.format;
  copy.ycbcrModel = original.ycbcrModel;
  copy.ycbcrRange = original.ycbcrRange;
  if (original.components !== null) {
        copy.components = original.components.constructor.createCopyFrom(original.components);
      }
  copy.xChromaOffset = original.xChromaOffset;
  copy.yChromaOffset = original.yChromaOffset;
  copy.chromaFilter = original.chromaFilter;
  copy.forceExplicitReconstruction = original.forceExplicitReconstruction;
  
  return copy;
};

VkSamplerYcbcrConversionCreateInfo.byteLength = 0x0;

VkSamplerYcbcrConversionCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ycbcrModel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ycbcrRange: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  components: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  xChromaOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  yChromaOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  chromaFilter: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  forceExplicitReconstruction: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSamplerYcbcrConversionCreateInfoKHR **/
function VkSamplerYcbcrConversionCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkSamplerYcbcrConversionCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSamplerYcbcrConversionCreateInfoKHR, STRUCT_CACHE_VkSamplerYcbcrConversionCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSamplerYcbcrConversionCreateInfoKHR, STRUCT_CACHE_VkSamplerYcbcrConversionCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSamplerYcbcrConversionCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.ycbcrModel !== void 0) this.ycbcrModel = opts.ycbcrModel;
    if (opts.ycbcrRange !== void 0) this.ycbcrRange = opts.ycbcrRange;
    if (opts.components !== void 0) this.components = opts.components;
    if (opts.xChromaOffset !== void 0) this.xChromaOffset = opts.xChromaOffset;
    if (opts.yChromaOffset !== void 0) this.yChromaOffset = opts.yChromaOffset;
    if (opts.chromaFilter !== void 0) this.chromaFilter = opts.chromaFilter;
    if (opts.forceExplicitReconstruction !== void 0) this.forceExplicitReconstruction = opts.forceExplicitReconstruction;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.pNext'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfoKHR.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "ycbcrModel": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfoKHR.ycbcrModel");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "ycbcrRange": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfoKHR.ycbcrRange");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "components": {
    get() {
    return this._components;
    },
    set(value) {
    if (value !== null && value.constructor === VkComponentMapping) {
      value.flush();
      this._components = value;
      
      
    } else if (value === null) {
      this._components = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.components': Expected 'VkComponentMapping' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "xChromaOffset": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfoKHR.xChromaOffset");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "yChromaOffset": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfoKHR.yChromaOffset");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "chromaFilter": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionCreateInfoKHR.chromaFilter");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "forceExplicitReconstruction": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkSamplerYcbcrConversionCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  if (this._components !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._components.memoryBuffer) this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._components.reset();
  }
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.ycbcrModel !== void 0) this.ycbcrModel = opts.ycbcrModel;
    if (opts.ycbcrRange !== void 0) this.ycbcrRange = opts.ycbcrRange;
    if (opts.components !== void 0) this.components = opts.components;
    if (opts.xChromaOffset !== void 0) this.xChromaOffset = opts.xChromaOffset;
    if (opts.yChromaOffset !== void 0) this.yChromaOffset = opts.yChromaOffset;
    if (opts.chromaFilter !== void 0) this.chromaFilter = opts.chromaFilter;
    if (opts.forceExplicitReconstruction !== void 0) this.forceExplicitReconstruction = opts.forceExplicitReconstruction;
    
  }
};

VkSamplerYcbcrConversionCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._components !== null) {
    let components = this._components;
    components.flush();
    if (this.memoryBuffer !== components.memoryBuffer) {
      let srcView = new Uint8Array(components.memoryBuffer, components.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSamplerYcbcrConversionCreateInfoKHR.components' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSamplerYcbcrConversionCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSamplerYcbcrConversionCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSamplerYcbcrConversionCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.format = original.format;
  copy.ycbcrModel = original.ycbcrModel;
  copy.ycbcrRange = original.ycbcrRange;
  if (original.components !== null) {
        copy.components = original.components.constructor.createCopyFrom(original.components);
      }
  copy.xChromaOffset = original.xChromaOffset;
  copy.yChromaOffset = original.yChromaOffset;
  copy.chromaFilter = original.chromaFilter;
  copy.forceExplicitReconstruction = original.forceExplicitReconstruction;
  
  return copy;
};

VkSamplerYcbcrConversionCreateInfoKHR.byteLength = 0x0;

VkSamplerYcbcrConversionCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ycbcrModel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ycbcrRange: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  components: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  xChromaOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  yChromaOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  chromaFilter: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  forceExplicitReconstruction: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindImagePlaneMemoryInfo **/
function VkBindImagePlaneMemoryInfo(opts, byteOffset) {
  if (new.target !== VkBindImagePlaneMemoryInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindImagePlaneMemoryInfo, STRUCT_CACHE_VkBindImagePlaneMemoryInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindImagePlaneMemoryInfo, STRUCT_CACHE_VkBindImagePlaneMemoryInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindImagePlaneMemoryInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

Object.defineProperties(VkBindImagePlaneMemoryInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImagePlaneMemoryInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindImagePlaneMemoryInfo.pNext' isn't allowed to be filled");
    }
    },
  "planeAspect": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImagePlaneMemoryInfo.planeAspect");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkBindImagePlaneMemoryInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

VkBindImagePlaneMemoryInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImagePlaneMemoryInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindImagePlaneMemoryInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindImagePlaneMemoryInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.planeAspect = original.planeAspect;
  
  return copy;
};

VkBindImagePlaneMemoryInfo.byteLength = 0x0;

VkBindImagePlaneMemoryInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  planeAspect: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindImagePlaneMemoryInfoKHR **/
function VkBindImagePlaneMemoryInfoKHR(opts, byteOffset) {
  if (new.target !== VkBindImagePlaneMemoryInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindImagePlaneMemoryInfoKHR, STRUCT_CACHE_VkBindImagePlaneMemoryInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindImagePlaneMemoryInfoKHR, STRUCT_CACHE_VkBindImagePlaneMemoryInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindImagePlaneMemoryInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

Object.defineProperties(VkBindImagePlaneMemoryInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImagePlaneMemoryInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindImagePlaneMemoryInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "planeAspect": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindImagePlaneMemoryInfoKHR.planeAspect");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkBindImagePlaneMemoryInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

VkBindImagePlaneMemoryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImagePlaneMemoryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindImagePlaneMemoryInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindImagePlaneMemoryInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.planeAspect = original.planeAspect;
  
  return copy;
};

VkBindImagePlaneMemoryInfoKHR.byteLength = 0x0;

VkBindImagePlaneMemoryInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  planeAspect: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImagePlaneMemoryRequirementsInfo **/
function VkImagePlaneMemoryRequirementsInfo(opts, byteOffset) {
  if (new.target !== VkImagePlaneMemoryRequirementsInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImagePlaneMemoryRequirementsInfo, STRUCT_CACHE_VkImagePlaneMemoryRequirementsInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImagePlaneMemoryRequirementsInfo, STRUCT_CACHE_VkImagePlaneMemoryRequirementsInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImagePlaneMemoryRequirementsInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

Object.defineProperties(VkImagePlaneMemoryRequirementsInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImagePlaneMemoryRequirementsInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImagePlaneMemoryRequirementsInfo.pNext' isn't allowed to be filled");
    }
    },
  "planeAspect": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImagePlaneMemoryRequirementsInfo.planeAspect");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImagePlaneMemoryRequirementsInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

VkImagePlaneMemoryRequirementsInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImagePlaneMemoryRequirementsInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkImagePlaneMemoryRequirementsInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImagePlaneMemoryRequirementsInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.planeAspect = original.planeAspect;
  
  return copy;
};

VkImagePlaneMemoryRequirementsInfo.byteLength = 0x0;

VkImagePlaneMemoryRequirementsInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  planeAspect: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImagePlaneMemoryRequirementsInfoKHR **/
function VkImagePlaneMemoryRequirementsInfoKHR(opts, byteOffset) {
  if (new.target !== VkImagePlaneMemoryRequirementsInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImagePlaneMemoryRequirementsInfoKHR, STRUCT_CACHE_VkImagePlaneMemoryRequirementsInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImagePlaneMemoryRequirementsInfoKHR, STRUCT_CACHE_VkImagePlaneMemoryRequirementsInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImagePlaneMemoryRequirementsInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

Object.defineProperties(VkImagePlaneMemoryRequirementsInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImagePlaneMemoryRequirementsInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImagePlaneMemoryRequirementsInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "planeAspect": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImagePlaneMemoryRequirementsInfoKHR.planeAspect");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImagePlaneMemoryRequirementsInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
    
  }
};

VkImagePlaneMemoryRequirementsInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImagePlaneMemoryRequirementsInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImagePlaneMemoryRequirementsInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImagePlaneMemoryRequirementsInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.planeAspect = original.planeAspect;
  
  return copy;
};

VkImagePlaneMemoryRequirementsInfoKHR.byteLength = 0x0;

VkImagePlaneMemoryRequirementsInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  planeAspect: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSamplerYcbcrConversionFeatures **/
function VkPhysicalDeviceSamplerYcbcrConversionFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSamplerYcbcrConversionFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSamplerYcbcrConversionFeatures, STRUCT_CACHE_VkPhysicalDeviceSamplerYcbcrConversionFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSamplerYcbcrConversionFeatures, STRUCT_CACHE_VkPhysicalDeviceSamplerYcbcrConversionFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSamplerYcbcrConversionFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.samplerYcbcrConversion !== void 0) this.samplerYcbcrConversion = opts.samplerYcbcrConversion;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSamplerYcbcrConversionFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSamplerYcbcrConversionFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSamplerYcbcrConversionFeatures.pNext' isn't allowed to be filled");
    }
    },
  "samplerYcbcrConversion": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceSamplerYcbcrConversionFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.samplerYcbcrConversion !== void 0) this.samplerYcbcrConversion = opts.samplerYcbcrConversion;
    
  }
};

VkPhysicalDeviceSamplerYcbcrConversionFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSamplerYcbcrConversionFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceSamplerYcbcrConversionFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSamplerYcbcrConversionFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.samplerYcbcrConversion = original.samplerYcbcrConversion;
  
  return copy;
};

VkPhysicalDeviceSamplerYcbcrConversionFeatures.byteLength = 0x0;

VkPhysicalDeviceSamplerYcbcrConversionFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samplerYcbcrConversion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR **/
function VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.samplerYcbcrConversion !== void 0) this.samplerYcbcrConversion = opts.samplerYcbcrConversion;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "samplerYcbcrConversion": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.samplerYcbcrConversion !== void 0) this.samplerYcbcrConversion = opts.samplerYcbcrConversion;
    
  }
};

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.samplerYcbcrConversion = original.samplerYcbcrConversion;
  
  return copy;
};

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samplerYcbcrConversion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSamplerYcbcrConversionImageFormatProperties **/
function VkSamplerYcbcrConversionImageFormatProperties(opts, byteOffset) {
  if (new.target !== VkSamplerYcbcrConversionImageFormatProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSamplerYcbcrConversionImageFormatProperties, STRUCT_CACHE_VkSamplerYcbcrConversionImageFormatProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSamplerYcbcrConversionImageFormatProperties, STRUCT_CACHE_VkSamplerYcbcrConversionImageFormatProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSamplerYcbcrConversionImageFormatProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionImageFormatProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionImageFormatProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerYcbcrConversionImageFormatProperties.pNext' isn't allowed to be filled");
    }
    },
  "combinedImageSamplerDescriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkSamplerYcbcrConversionImageFormatProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSamplerYcbcrConversionImageFormatProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSamplerYcbcrConversionImageFormatProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSamplerYcbcrConversionImageFormatProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.combinedImageSamplerDescriptorCount = original.combinedImageSamplerDescriptorCount;
  
  return copy;
};

VkSamplerYcbcrConversionImageFormatProperties.byteLength = 0x0;

VkSamplerYcbcrConversionImageFormatProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  combinedImageSamplerDescriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSamplerYcbcrConversionImageFormatPropertiesKHR **/
function VkSamplerYcbcrConversionImageFormatPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkSamplerYcbcrConversionImageFormatPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSamplerYcbcrConversionImageFormatPropertiesKHR, STRUCT_CACHE_VkSamplerYcbcrConversionImageFormatPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSamplerYcbcrConversionImageFormatPropertiesKHR, STRUCT_CACHE_VkSamplerYcbcrConversionImageFormatPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSamplerYcbcrConversionImageFormatPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSamplerYcbcrConversionImageFormatPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerYcbcrConversionImageFormatPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerYcbcrConversionImageFormatPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "combinedImageSamplerDescriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkSamplerYcbcrConversionImageFormatPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSamplerYcbcrConversionImageFormatPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionImageFormatPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkSamplerYcbcrConversionImageFormatPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSamplerYcbcrConversionImageFormatPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.combinedImageSamplerDescriptorCount = original.combinedImageSamplerDescriptorCount;
  
  return copy;
};

VkSamplerYcbcrConversionImageFormatPropertiesKHR.byteLength = 0x0;

VkSamplerYcbcrConversionImageFormatPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  combinedImageSamplerDescriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkTextureLODGatherFormatPropertiesAMD **/
function VkTextureLODGatherFormatPropertiesAMD(opts, byteOffset) {
  if (new.target !== VkTextureLODGatherFormatPropertiesAMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkTextureLODGatherFormatPropertiesAMD, STRUCT_CACHE_VkTextureLODGatherFormatPropertiesAMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkTextureLODGatherFormatPropertiesAMD, STRUCT_CACHE_VkTextureLODGatherFormatPropertiesAMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkTextureLODGatherFormatPropertiesAMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkTextureLODGatherFormatPropertiesAMD.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkTextureLODGatherFormatPropertiesAMD.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkTextureLODGatherFormatPropertiesAMD.pNext' isn't allowed to be filled");
    }
    },
  "supportsTextureGatherLODBiasAMD": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkTextureLODGatherFormatPropertiesAMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkTextureLODGatherFormatPropertiesAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkTextureLODGatherFormatPropertiesAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkTextureLODGatherFormatPropertiesAMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkTextureLODGatherFormatPropertiesAMD();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.supportsTextureGatherLODBiasAMD = original.supportsTextureGatherLODBiasAMD;
  
  return copy;
};

VkTextureLODGatherFormatPropertiesAMD.byteLength = 0x0;

VkTextureLODGatherFormatPropertiesAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportsTextureGatherLODBiasAMD: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkConditionalRenderingBeginInfoEXT **/
function VkConditionalRenderingBeginInfoEXT(opts, byteOffset) {
  if (new.target !== VkConditionalRenderingBeginInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkConditionalRenderingBeginInfoEXT, STRUCT_CACHE_VkConditionalRenderingBeginInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkConditionalRenderingBeginInfoEXT, STRUCT_CACHE_VkConditionalRenderingBeginInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkConditionalRenderingBeginInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._buffer = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkConditionalRenderingBeginInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkConditionalRenderingBeginInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkConditionalRenderingBeginInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkConditionalRenderingBeginInfoEXT.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkConditionalRenderingBeginInfoEXT.offset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkConditionalRenderingBeginInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkConditionalRenderingBeginInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkConditionalRenderingBeginInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkConditionalRenderingBeginInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkConditionalRenderingBeginInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkConditionalRenderingBeginInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  copy.offset = original.offset;
  copy.flags = original.flags;
  
  return copy;
};

VkConditionalRenderingBeginInfoEXT.byteLength = 0x0;

VkConditionalRenderingBeginInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkProtectedSubmitInfo **/
function VkProtectedSubmitInfo(opts, byteOffset) {
  if (new.target !== VkProtectedSubmitInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkProtectedSubmitInfo, STRUCT_CACHE_VkProtectedSubmitInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkProtectedSubmitInfo, STRUCT_CACHE_VkProtectedSubmitInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkProtectedSubmitInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.protectedSubmit !== void 0) this.protectedSubmit = opts.protectedSubmit;
    
  }
};

Object.defineProperties(VkProtectedSubmitInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkProtectedSubmitInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkProtectedSubmitInfo.pNext' isn't allowed to be filled");
    }
    },
  "protectedSubmit": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkProtectedSubmitInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.protectedSubmit !== void 0) this.protectedSubmit = opts.protectedSubmit;
    
  }
};

VkProtectedSubmitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkProtectedSubmitInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkProtectedSubmitInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkProtectedSubmitInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.protectedSubmit = original.protectedSubmit;
  
  return copy;
};

VkProtectedSubmitInfo.byteLength = 0x0;

VkProtectedSubmitInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  protectedSubmit: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceProtectedMemoryFeatures **/
function VkPhysicalDeviceProtectedMemoryFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceProtectedMemoryFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceProtectedMemoryFeatures, STRUCT_CACHE_VkPhysicalDeviceProtectedMemoryFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceProtectedMemoryFeatures, STRUCT_CACHE_VkPhysicalDeviceProtectedMemoryFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceProtectedMemoryFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.protectedMemory !== void 0) this.protectedMemory = opts.protectedMemory;
    
  }
};

Object.defineProperties(VkPhysicalDeviceProtectedMemoryFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceProtectedMemoryFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceProtectedMemoryFeatures.pNext' isn't allowed to be filled");
    }
    },
  "protectedMemory": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceProtectedMemoryFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.protectedMemory !== void 0) this.protectedMemory = opts.protectedMemory;
    
  }
};

VkPhysicalDeviceProtectedMemoryFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProtectedMemoryFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceProtectedMemoryFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceProtectedMemoryFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.protectedMemory = original.protectedMemory;
  
  return copy;
};

VkPhysicalDeviceProtectedMemoryFeatures.byteLength = 0x0;

VkPhysicalDeviceProtectedMemoryFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  protectedMemory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceProtectedMemoryProperties **/
function VkPhysicalDeviceProtectedMemoryProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceProtectedMemoryProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceProtectedMemoryProperties, STRUCT_CACHE_VkPhysicalDeviceProtectedMemoryProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceProtectedMemoryProperties, STRUCT_CACHE_VkPhysicalDeviceProtectedMemoryProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceProtectedMemoryProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceProtectedMemoryProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceProtectedMemoryProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceProtectedMemoryProperties.pNext' isn't allowed to be filled");
    }
    },
  "protectedNoFault": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceProtectedMemoryProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceProtectedMemoryProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProtectedMemoryProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceProtectedMemoryProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceProtectedMemoryProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.protectedNoFault = original.protectedNoFault;
  
  return copy;
};

VkPhysicalDeviceProtectedMemoryProperties.byteLength = 0x0;

VkPhysicalDeviceProtectedMemoryProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  protectedNoFault: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceQueueInfo2 **/
function VkDeviceQueueInfo2(opts, byteOffset) {
  if (new.target !== VkDeviceQueueInfo2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceQueueInfo2, STRUCT_CACHE_VkDeviceQueueInfo2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceQueueInfo2, STRUCT_CACHE_VkDeviceQueueInfo2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceQueueInfo2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    if (opts.queueIndex !== void 0) this.queueIndex = opts.queueIndex;
    
  }
};

Object.defineProperties(VkDeviceQueueInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceQueueInfo2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceQueueInfo2.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceQueueInfo2.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "queueFamilyIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceQueueInfo2.queueFamilyIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "queueIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceQueueInfo2.queueIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDeviceQueueInfo2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    if (opts.queueIndex !== void 0) this.queueIndex = opts.queueIndex;
    
  }
};

VkDeviceQueueInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceQueueInfo2.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceQueueInfo2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceQueueInfo2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.queueFamilyIndex = original.queueFamilyIndex;
  copy.queueIndex = original.queueIndex;
  
  return copy;
};

VkDeviceQueueInfo2.byteLength = 0x0;

VkDeviceQueueInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueFamilyIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineCoverageToColorStateCreateInfoNV **/
function VkPipelineCoverageToColorStateCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkPipelineCoverageToColorStateCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineCoverageToColorStateCreateInfoNV, STRUCT_CACHE_VkPipelineCoverageToColorStateCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineCoverageToColorStateCreateInfoNV, STRUCT_CACHE_VkPipelineCoverageToColorStateCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineCoverageToColorStateCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.coverageToColorEnable !== void 0) this.coverageToColorEnable = opts.coverageToColorEnable;
    if (opts.coverageToColorLocation !== void 0) this.coverageToColorLocation = opts.coverageToColorLocation;
    
  }
};

Object.defineProperties(VkPipelineCoverageToColorStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCoverageToColorStateCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCoverageToColorStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCoverageToColorStateCreateInfoNV.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "coverageToColorEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "coverageToColorLocation": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorLocation");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkPipelineCoverageToColorStateCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.coverageToColorEnable !== void 0) this.coverageToColorEnable = opts.coverageToColorEnable;
    if (opts.coverageToColorLocation !== void 0) this.coverageToColorLocation = opts.coverageToColorLocation;
    
  }
};

VkPipelineCoverageToColorStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCoverageToColorStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineCoverageToColorStateCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineCoverageToColorStateCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.coverageToColorEnable = original.coverageToColorEnable;
  copy.coverageToColorLocation = original.coverageToColorLocation;
  
  return copy;
};

VkPipelineCoverageToColorStateCreateInfoNV.byteLength = 0x0;

VkPipelineCoverageToColorStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  coverageToColorEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  coverageToColorLocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSamplerFilterMinmaxProperties **/
function VkPhysicalDeviceSamplerFilterMinmaxProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSamplerFilterMinmaxProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSamplerFilterMinmaxProperties, STRUCT_CACHE_VkPhysicalDeviceSamplerFilterMinmaxProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSamplerFilterMinmaxProperties, STRUCT_CACHE_VkPhysicalDeviceSamplerFilterMinmaxProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSamplerFilterMinmaxProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSamplerFilterMinmaxProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSamplerFilterMinmaxProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSamplerFilterMinmaxProperties.pNext' isn't allowed to be filled");
    }
    },
  "filterMinmaxSingleComponentFormats": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "filterMinmaxImageComponentMapping": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceSamplerFilterMinmaxProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceSamplerFilterMinmaxProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSamplerFilterMinmaxProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceSamplerFilterMinmaxProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSamplerFilterMinmaxProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.filterMinmaxSingleComponentFormats = original.filterMinmaxSingleComponentFormats;
  copy.filterMinmaxImageComponentMapping = original.filterMinmaxImageComponentMapping;
  
  return copy;
};

VkPhysicalDeviceSamplerFilterMinmaxProperties.byteLength = 0x0;

VkPhysicalDeviceSamplerFilterMinmaxProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  filterMinmaxSingleComponentFormats: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  filterMinmaxImageComponentMapping: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT **/
function VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "filterMinmaxSingleComponentFormats": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "filterMinmaxImageComponentMapping": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.filterMinmaxSingleComponentFormats = original.filterMinmaxSingleComponentFormats;
  copy.filterMinmaxImageComponentMapping = original.filterMinmaxImageComponentMapping;
  
  return copy;
};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  filterMinmaxSingleComponentFormats: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  filterMinmaxImageComponentMapping: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSampleLocationEXT **/
function VkSampleLocationEXT(opts, byteOffset) {
  if (new.target !== VkSampleLocationEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSampleLocationEXT, STRUCT_CACHE_VkSampleLocationEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSampleLocationEXT, STRUCT_CACHE_VkSampleLocationEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSampleLocationEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    
  }
};

Object.defineProperties(VkSampleLocationEXT.prototype, {
  "x": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSampleLocationEXT.x");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "y": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSampleLocationEXT.y");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkSampleLocationEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.x !== void 0) this.x = opts.x;
    if (opts.y !== void 0) this.y = opts.y;
    
  }
};

VkSampleLocationEXT.prototype.flush = function flush() {
  
  return true;
};

VkSampleLocationEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkSampleLocationEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSampleLocationEXT();
  copy.x = original.x;
  copy.y = original.y;
  
  return copy;
};

VkSampleLocationEXT.byteLength = 0x0;

VkSampleLocationEXT.memoryLayout = {
  x: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  y: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSampleLocationsInfoEXT **/
function VkSampleLocationsInfoEXT(opts, byteOffset) {
  if (new.target !== VkSampleLocationsInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSampleLocationsInfoEXT, STRUCT_CACHE_VkSampleLocationsInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSampleLocationsInfoEXT, STRUCT_CACHE_VkSampleLocationsInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSampleLocationsInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._sampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  this._pSampleLocations = null;
  this._pSampleLocationsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.sampleLocationsPerPixel !== void 0) this.sampleLocationsPerPixel = opts.sampleLocationsPerPixel;
    if (opts.sampleLocationGridSize !== void 0) this.sampleLocationGridSize = opts.sampleLocationGridSize;
    if (opts.sampleLocationsCount !== void 0) this.sampleLocationsCount = opts.sampleLocationsCount;
    if (opts.pSampleLocations !== void 0) this.pSampleLocations = opts.pSampleLocations;
    
  }
};

Object.defineProperties(VkSampleLocationsInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSampleLocationsInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSampleLocationsInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "sampleLocationsPerPixel": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSampleLocationsInfoEXT.sampleLocationsPerPixel");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "sampleLocationGridSize": {
    get() {
    return this._sampleLocationGridSize;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._sampleLocationGridSize = value;
      
      
    } else if (value === null) {
      this._sampleLocationGridSize = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.sampleLocationGridSize': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "sampleLocationsCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSampleLocationsInfoEXT.sampleLocationsCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSampleLocations": {
    get() {
    if (this._pSampleLocations === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.sampleLocationsCount, VkSampleLocationEXT);
      this._pSampleLocations = array;
      return this.pSampleLocations;
    } else {
      return this._pSampleLocations;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSampleLocations = value;
    } else if (value === null) {
      this._pSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.pSampleLocations': Expected 'Array VkSampleLocationEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkSampleLocationsInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._sampleLocationGridSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._sampleLocationGridSize.memoryBuffer) this._sampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._sampleLocationGridSize.reset();
  }
  
  this._pSampleLocations = null;
  this._pSampleLocationsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.sampleLocationsPerPixel !== void 0) this.sampleLocationsPerPixel = opts.sampleLocationsPerPixel;
    if (opts.sampleLocationGridSize !== void 0) this.sampleLocationGridSize = opts.sampleLocationGridSize;
    if (opts.sampleLocationsCount !== void 0) this.sampleLocationsCount = opts.sampleLocationsCount;
    if (opts.pSampleLocations !== void 0) this.pSampleLocations = opts.pSampleLocations;
    
  }
};

VkSampleLocationsInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._sampleLocationGridSize !== null) {
    let sampleLocationGridSize = this._sampleLocationGridSize;
    sampleLocationGridSize.flush();
    if (this.memoryBuffer !== sampleLocationGridSize.memoryBuffer) {
      let srcView = new Uint8Array(sampleLocationGridSize.memoryBuffer, sampleLocationGridSize.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSampleLocationsInfoEXT.sampleLocationGridSize' isn't used as shared-memory");
    }
  }
  
  
  if (this._pSampleLocations !== null) {
    let array = this._pSampleLocations;
    
    if (array.length !== this.sampleLocationsCount) {
      throw new RangeError("Invalid array length, expected length of 'sampleLocationsCount' for 'VkSampleLocationsInfoEXT.pSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSampleLocationEXT)) {
        throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.pSampleLocations[" + ii + "]': Expected 'VkSampleLocationEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSampleLocationsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSampleLocationsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSampleLocationsInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkSampleLocationsInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSampleLocationsInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.sampleLocationsPerPixel = original.sampleLocationsPerPixel;
  if (original.sampleLocationGridSize !== null) {
        copy.sampleLocationGridSize = original.sampleLocationGridSize.constructor.createCopyFrom(original.sampleLocationGridSize);
      }
  copy.sampleLocationsCount = original.sampleLocationsCount;
  if (original.pSampleLocations !== null) {
        copy.pSampleLocations = [...Array(original.pSampleLocations.length)].map((v, i) => {
          return original.pSampleLocations[i].constructor.createCopyFrom(original.pSampleLocations[i]);
        });
      }
  
  return copy;
};

VkSampleLocationsInfoEXT.byteLength = 0x0;

VkSampleLocationsInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationsPerPixel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationGridSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationsCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSampleLocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentSampleLocationsEXT **/
function VkAttachmentSampleLocationsEXT(opts, byteOffset) {
  if (new.target !== VkAttachmentSampleLocationsEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentSampleLocationsEXT, STRUCT_CACHE_VkAttachmentSampleLocationsEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentSampleLocationsEXT, STRUCT_CACHE_VkAttachmentSampleLocationsEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentSampleLocationsEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.attachmentIndex !== void 0) this.attachmentIndex = opts.attachmentIndex;
    if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
    
  }
};

Object.defineProperties(VkAttachmentSampleLocationsEXT.prototype, {
  "attachmentIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentSampleLocationsEXT.attachmentIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "sampleLocationsInfo": {
    get() {
    return this._sampleLocationsInfo;
    },
    set(value) {
    if (value !== null && value.constructor === VkSampleLocationsInfoEXT) {
      value.flush();
      this._sampleLocationsInfo = value;
      
      
    } else if (value === null) {
      this._sampleLocationsInfo = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAttachmentSampleLocationsEXT.sampleLocationsInfo': Expected 'VkSampleLocationsInfoEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAttachmentSampleLocationsEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  if (this._sampleLocationsInfo !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._sampleLocationsInfo.memoryBuffer) this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._sampleLocationsInfo.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.attachmentIndex !== void 0) this.attachmentIndex = opts.attachmentIndex;
    if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
    
  }
};

VkAttachmentSampleLocationsEXT.prototype.flush = function flush() {
  
  
  if (this._sampleLocationsInfo !== null) {
    let sampleLocationsInfo = this._sampleLocationsInfo;
    sampleLocationsInfo.flush();
    if (this.memoryBuffer !== sampleLocationsInfo.memoryBuffer) {
      let srcView = new Uint8Array(sampleLocationsInfo.memoryBuffer, sampleLocationsInfo.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAttachmentSampleLocationsEXT.sampleLocationsInfo' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAttachmentSampleLocationsEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentSampleLocationsEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentSampleLocationsEXT();
  copy.attachmentIndex = original.attachmentIndex;
  if (original.sampleLocationsInfo !== null) {
        copy.sampleLocationsInfo = original.sampleLocationsInfo.constructor.createCopyFrom(original.sampleLocationsInfo);
      }
  
  return copy;
};

VkAttachmentSampleLocationsEXT.byteLength = 0x0;

VkAttachmentSampleLocationsEXT.memoryLayout = {
  attachmentIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationsInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassSampleLocationsEXT **/
function VkSubpassSampleLocationsEXT(opts, byteOffset) {
  if (new.target !== VkSubpassSampleLocationsEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassSampleLocationsEXT, STRUCT_CACHE_VkSubpassSampleLocationsEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassSampleLocationsEXT, STRUCT_CACHE_VkSubpassSampleLocationsEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassSampleLocationsEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.subpassIndex !== void 0) this.subpassIndex = opts.subpassIndex;
    if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
    
  }
};

Object.defineProperties(VkSubpassSampleLocationsEXT.prototype, {
  "subpassIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassSampleLocationsEXT.subpassIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "sampleLocationsInfo": {
    get() {
    return this._sampleLocationsInfo;
    },
    set(value) {
    if (value !== null && value.constructor === VkSampleLocationsInfoEXT) {
      value.flush();
      this._sampleLocationsInfo = value;
      
      
    } else if (value === null) {
      this._sampleLocationsInfo = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSubpassSampleLocationsEXT.sampleLocationsInfo': Expected 'VkSampleLocationsInfoEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSubpassSampleLocationsEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  if (this._sampleLocationsInfo !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._sampleLocationsInfo.memoryBuffer) this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._sampleLocationsInfo.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.subpassIndex !== void 0) this.subpassIndex = opts.subpassIndex;
    if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
    
  }
};

VkSubpassSampleLocationsEXT.prototype.flush = function flush() {
  
  
  if (this._sampleLocationsInfo !== null) {
    let sampleLocationsInfo = this._sampleLocationsInfo;
    sampleLocationsInfo.flush();
    if (this.memoryBuffer !== sampleLocationsInfo.memoryBuffer) {
      let srcView = new Uint8Array(sampleLocationsInfo.memoryBuffer, sampleLocationsInfo.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSubpassSampleLocationsEXT.sampleLocationsInfo' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSubpassSampleLocationsEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassSampleLocationsEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassSampleLocationsEXT();
  copy.subpassIndex = original.subpassIndex;
  if (original.sampleLocationsInfo !== null) {
        copy.sampleLocationsInfo = original.sampleLocationsInfo.constructor.createCopyFrom(original.sampleLocationsInfo);
      }
  
  return copy;
};

VkSubpassSampleLocationsEXT.byteLength = 0x0;

VkSubpassSampleLocationsEXT.memoryLayout = {
  subpassIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationsInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassSampleLocationsBeginInfoEXT **/
function VkRenderPassSampleLocationsBeginInfoEXT(opts, byteOffset) {
  if (new.target !== VkRenderPassSampleLocationsBeginInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassSampleLocationsBeginInfoEXT, STRUCT_CACHE_VkRenderPassSampleLocationsBeginInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassSampleLocationsBeginInfoEXT, STRUCT_CACHE_VkRenderPassSampleLocationsBeginInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassSampleLocationsBeginInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAttachmentInitialSampleLocations = null;
  this._pAttachmentInitialSampleLocationsNative = null;
  
  this._pPostSubpassSampleLocations = null;
  this._pPostSubpassSampleLocationsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentInitialSampleLocationsCount !== void 0) this.attachmentInitialSampleLocationsCount = opts.attachmentInitialSampleLocationsCount;
    if (opts.pAttachmentInitialSampleLocations !== void 0) this.pAttachmentInitialSampleLocations = opts.pAttachmentInitialSampleLocations;
    if (opts.postSubpassSampleLocationsCount !== void 0) this.postSubpassSampleLocationsCount = opts.postSubpassSampleLocationsCount;
    if (opts.pPostSubpassSampleLocations !== void 0) this.pPostSubpassSampleLocations = opts.pPostSubpassSampleLocations;
    
  }
};

Object.defineProperties(VkRenderPassSampleLocationsBeginInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassSampleLocationsBeginInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassSampleLocationsBeginInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "attachmentInitialSampleLocationsCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassSampleLocationsBeginInfoEXT.attachmentInitialSampleLocationsCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAttachmentInitialSampleLocations": {
    get() {
    if (this._pAttachmentInitialSampleLocations === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.attachmentInitialSampleLocationsCount, VkAttachmentSampleLocationsEXT);
      this._pAttachmentInitialSampleLocations = array;
      return this.pAttachmentInitialSampleLocations;
    } else {
      return this._pAttachmentInitialSampleLocations;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachmentInitialSampleLocations = value;
    } else if (value === null) {
      this._pAttachmentInitialSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations': Expected 'Array VkAttachmentSampleLocationsEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "postSubpassSampleLocationsCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassSampleLocationsBeginInfoEXT.postSubpassSampleLocationsCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPostSubpassSampleLocations": {
    get() {
    if (this._pPostSubpassSampleLocations === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.postSubpassSampleLocationsCount, VkSubpassSampleLocationsEXT);
      this._pPostSubpassSampleLocations = array;
      return this.pPostSubpassSampleLocations;
    } else {
      return this._pPostSubpassSampleLocations;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPostSubpassSampleLocations = value;
    } else if (value === null) {
      this._pPostSubpassSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations': Expected 'Array VkSubpassSampleLocationsEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassSampleLocationsBeginInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAttachmentInitialSampleLocations = null;
  this._pAttachmentInitialSampleLocationsNative = null;
  
  this._pPostSubpassSampleLocations = null;
  this._pPostSubpassSampleLocationsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentInitialSampleLocationsCount !== void 0) this.attachmentInitialSampleLocationsCount = opts.attachmentInitialSampleLocationsCount;
    if (opts.pAttachmentInitialSampleLocations !== void 0) this.pAttachmentInitialSampleLocations = opts.pAttachmentInitialSampleLocations;
    if (opts.postSubpassSampleLocationsCount !== void 0) this.postSubpassSampleLocationsCount = opts.postSubpassSampleLocationsCount;
    if (opts.pPostSubpassSampleLocations !== void 0) this.pPostSubpassSampleLocations = opts.pPostSubpassSampleLocations;
    
  }
};

VkRenderPassSampleLocationsBeginInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachmentInitialSampleLocations !== null) {
    let array = this._pAttachmentInitialSampleLocations;
    
    if (array.length !== this.attachmentInitialSampleLocationsCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentInitialSampleLocationsCount' for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentSampleLocationsEXT)) {
        throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations[" + ii + "]': Expected 'VkAttachmentSampleLocationsEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentInitialSampleLocationsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAttachmentInitialSampleLocationsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pPostSubpassSampleLocations !== null) {
    let array = this._pPostSubpassSampleLocations;
    
    if (array.length !== this.postSubpassSampleLocationsCount) {
      throw new RangeError("Invalid array length, expected length of 'postSubpassSampleLocationsCount' for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassSampleLocationsEXT)) {
        throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations[" + ii + "]': Expected 'VkSubpassSampleLocationsEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPostSubpassSampleLocationsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pPostSubpassSampleLocationsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRenderPassSampleLocationsBeginInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassSampleLocationsBeginInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassSampleLocationsBeginInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.attachmentInitialSampleLocationsCount = original.attachmentInitialSampleLocationsCount;
  if (original.pAttachmentInitialSampleLocations !== null) {
        copy.pAttachmentInitialSampleLocations = [...Array(original.pAttachmentInitialSampleLocations.length)].map((v, i) => {
          return original.pAttachmentInitialSampleLocations[i].constructor.createCopyFrom(original.pAttachmentInitialSampleLocations[i]);
        });
      }
  copy.postSubpassSampleLocationsCount = original.postSubpassSampleLocationsCount;
  if (original.pPostSubpassSampleLocations !== null) {
        copy.pPostSubpassSampleLocations = [...Array(original.pPostSubpassSampleLocations.length)].map((v, i) => {
          return original.pPostSubpassSampleLocations[i].constructor.createCopyFrom(original.pPostSubpassSampleLocations[i]);
        });
      }
  
  return copy;
};

VkRenderPassSampleLocationsBeginInfoEXT.byteLength = 0x0;

VkRenderPassSampleLocationsBeginInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentInitialSampleLocationsCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttachmentInitialSampleLocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  postSubpassSampleLocationsCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPostSubpassSampleLocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineSampleLocationsStateCreateInfoEXT **/
function VkPipelineSampleLocationsStateCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPipelineSampleLocationsStateCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineSampleLocationsStateCreateInfoEXT, STRUCT_CACHE_VkPipelineSampleLocationsStateCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineSampleLocationsStateCreateInfoEXT, STRUCT_CACHE_VkPipelineSampleLocationsStateCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineSampleLocationsStateCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.sampleLocationsEnable !== void 0) this.sampleLocationsEnable = opts.sampleLocationsEnable;
    if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
    
  }
};

Object.defineProperties(VkPipelineSampleLocationsStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineSampleLocationsStateCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineSampleLocationsStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "sampleLocationsEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sampleLocationsInfo": {
    get() {
    return this._sampleLocationsInfo;
    },
    set(value) {
    if (value !== null && value.constructor === VkSampleLocationsInfoEXT) {
      value.flush();
      this._sampleLocationsInfo = value;
      
      
    } else if (value === null) {
      this._sampleLocationsInfo = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsInfo': Expected 'VkSampleLocationsInfoEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineSampleLocationsStateCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._sampleLocationsInfo !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._sampleLocationsInfo.memoryBuffer) this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._sampleLocationsInfo.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.sampleLocationsEnable !== void 0) this.sampleLocationsEnable = opts.sampleLocationsEnable;
    if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
    
  }
};

VkPipelineSampleLocationsStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._sampleLocationsInfo !== null) {
    let sampleLocationsInfo = this._sampleLocationsInfo;
    sampleLocationsInfo.flush();
    if (this.memoryBuffer !== sampleLocationsInfo.memoryBuffer) {
      let srcView = new Uint8Array(sampleLocationsInfo.memoryBuffer, sampleLocationsInfo.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsInfo' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkPipelineSampleLocationsStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineSampleLocationsStateCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineSampleLocationsStateCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.sampleLocationsEnable = original.sampleLocationsEnable;
  if (original.sampleLocationsInfo !== null) {
        copy.sampleLocationsInfo = original.sampleLocationsInfo.constructor.createCopyFrom(original.sampleLocationsInfo);
      }
  
  return copy;
};

VkPipelineSampleLocationsStateCreateInfoEXT.byteLength = 0x0;

VkPipelineSampleLocationsStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationsEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationsInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSampleLocationsPropertiesEXT **/
function VkPhysicalDeviceSampleLocationsPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSampleLocationsPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSampleLocationsPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceSampleLocationsPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSampleLocationsPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceSampleLocationsPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSampleLocationsPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._maxSampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._sampleLocationCoordinateRange = [...Array(2)].fill(0x0);
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSampleLocationsPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSampleLocationsPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSampleLocationsPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "sampleLocationSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "maxSampleLocationGridSize": {
    get() {
    return this._maxSampleLocationGridSize;
    },
    },
  "sampleLocationCoordinateRange": {
    get() {
    return [
      this.memoryView.getFloat32(0x0, true),
      this.memoryView.getFloat32(0x4, true)
    ];
    },
    },
  "sampleLocationSubPixelBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "variableSampleLocations": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceSampleLocationsPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._maxSampleLocationGridSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxSampleLocationGridSize.memoryBuffer) this._maxSampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxSampleLocationGridSize.reset();
  }
  if (this._sampleLocationCoordinateRange !== null) this._sampleLocationCoordinateRange.fill(0x0);
      else this._sampleLocationCoordinateRange = [...Array(2)].fill(0x0);
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceSampleLocationsPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSampleLocationsPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceSampleLocationsPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSampleLocationsPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.sampleLocationSampleCounts = original.sampleLocationSampleCounts;
  if (original.maxSampleLocationGridSize !== null) {
        copy.maxSampleLocationGridSize = original.maxSampleLocationGridSize.constructor.createCopyFrom(original.maxSampleLocationGridSize);
      }
  if (original.sampleLocationCoordinateRange !== null) {
        copy.sampleLocationCoordinateRange = [...Array(original.sampleLocationCoordinateRange.length)].map((v, i) => {
          return original.sampleLocationCoordinateRange[i];
        });
      }
  copy.sampleLocationSubPixelBits = original.sampleLocationSubPixelBits;
  copy.variableSampleLocations = original.variableSampleLocations;
  
  return copy;
};

VkPhysicalDeviceSampleLocationsPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceSampleLocationsPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSampleLocationGridSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationCoordinateRange: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationSubPixelBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variableSampleLocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMultisamplePropertiesEXT **/
function VkMultisamplePropertiesEXT(opts, byteOffset) {
  if (new.target !== VkMultisamplePropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMultisamplePropertiesEXT, STRUCT_CACHE_VkMultisamplePropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMultisamplePropertiesEXT, STRUCT_CACHE_VkMultisamplePropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMultisamplePropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._maxSampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMultisamplePropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMultisamplePropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMultisamplePropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxSampleLocationGridSize": {
    get() {
    return this._maxSampleLocationGridSize;
    },
    },
  
});

VkMultisamplePropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._maxSampleLocationGridSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxSampleLocationGridSize.memoryBuffer) this._maxSampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxSampleLocationGridSize.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkMultisamplePropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMultisamplePropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMultisamplePropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMultisamplePropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.maxSampleLocationGridSize !== null) {
        copy.maxSampleLocationGridSize = original.maxSampleLocationGridSize.constructor.createCopyFrom(original.maxSampleLocationGridSize);
      }
  
  return copy;
};

VkMultisamplePropertiesEXT.byteLength = 0x0;

VkMultisamplePropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSampleLocationGridSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSamplerReductionModeCreateInfo **/
function VkSamplerReductionModeCreateInfo(opts, byteOffset) {
  if (new.target !== VkSamplerReductionModeCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSamplerReductionModeCreateInfo, STRUCT_CACHE_VkSamplerReductionModeCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSamplerReductionModeCreateInfo, STRUCT_CACHE_VkSamplerReductionModeCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSamplerReductionModeCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.reductionMode !== void 0) this.reductionMode = opts.reductionMode;
    
  }
};

Object.defineProperties(VkSamplerReductionModeCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerReductionModeCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerReductionModeCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "reductionMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerReductionModeCreateInfo.reductionMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSamplerReductionModeCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.reductionMode !== void 0) this.reductionMode = opts.reductionMode;
    
  }
};

VkSamplerReductionModeCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerReductionModeCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSamplerReductionModeCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSamplerReductionModeCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.reductionMode = original.reductionMode;
  
  return copy;
};

VkSamplerReductionModeCreateInfo.byteLength = 0x0;

VkSamplerReductionModeCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  reductionMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSamplerReductionModeCreateInfoEXT **/
function VkSamplerReductionModeCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkSamplerReductionModeCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSamplerReductionModeCreateInfoEXT, STRUCT_CACHE_VkSamplerReductionModeCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSamplerReductionModeCreateInfoEXT, STRUCT_CACHE_VkSamplerReductionModeCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSamplerReductionModeCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.reductionMode !== void 0) this.reductionMode = opts.reductionMode;
    
  }
};

Object.defineProperties(VkSamplerReductionModeCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerReductionModeCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerReductionModeCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "reductionMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerReductionModeCreateInfoEXT.reductionMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSamplerReductionModeCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.reductionMode !== void 0) this.reductionMode = opts.reductionMode;
    
  }
};

VkSamplerReductionModeCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerReductionModeCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkSamplerReductionModeCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSamplerReductionModeCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.reductionMode = original.reductionMode;
  
  return copy;
};

VkSamplerReductionModeCreateInfoEXT.byteLength = 0x0;

VkSamplerReductionModeCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  reductionMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT **/
function VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.advancedBlendCoherentOperations !== void 0) this.advancedBlendCoherentOperations = opts.advancedBlendCoherentOperations;
    
  }
};

Object.defineProperties(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "advancedBlendCoherentOperations": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.advancedBlendCoherentOperations !== void 0) this.advancedBlendCoherentOperations = opts.advancedBlendCoherentOperations;
    
  }
};

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.advancedBlendCoherentOperations = original.advancedBlendCoherentOperations;
  
  return copy;
};

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  advancedBlendCoherentOperations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT **/
function VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "advancedBlendMaxColorAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "advancedBlendIndependentBlend": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "advancedBlendNonPremultipliedSrcColor": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "advancedBlendNonPremultipliedDstColor": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "advancedBlendCorrelatedOverlap": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "advancedBlendAllOperations": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.advancedBlendMaxColorAttachments = original.advancedBlendMaxColorAttachments;
  copy.advancedBlendIndependentBlend = original.advancedBlendIndependentBlend;
  copy.advancedBlendNonPremultipliedSrcColor = original.advancedBlendNonPremultipliedSrcColor;
  copy.advancedBlendNonPremultipliedDstColor = original.advancedBlendNonPremultipliedDstColor;
  copy.advancedBlendCorrelatedOverlap = original.advancedBlendCorrelatedOverlap;
  copy.advancedBlendAllOperations = original.advancedBlendAllOperations;
  
  return copy;
};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  advancedBlendMaxColorAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  advancedBlendIndependentBlend: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  advancedBlendNonPremultipliedSrcColor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  advancedBlendNonPremultipliedDstColor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  advancedBlendCorrelatedOverlap: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  advancedBlendAllOperations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineColorBlendAdvancedStateCreateInfoEXT **/
function VkPipelineColorBlendAdvancedStateCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPipelineColorBlendAdvancedStateCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineColorBlendAdvancedStateCreateInfoEXT, STRUCT_CACHE_VkPipelineColorBlendAdvancedStateCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineColorBlendAdvancedStateCreateInfoEXT, STRUCT_CACHE_VkPipelineColorBlendAdvancedStateCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcPremultiplied !== void 0) this.srcPremultiplied = opts.srcPremultiplied;
    if (opts.dstPremultiplied !== void 0) this.dstPremultiplied = opts.dstPremultiplied;
    if (opts.blendOverlap !== void 0) this.blendOverlap = opts.blendOverlap;
    
  }
};

Object.defineProperties(VkPipelineColorBlendAdvancedStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineColorBlendAdvancedStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "srcPremultiplied": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "dstPremultiplied": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "blendOverlap": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.blendOverlap");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPipelineColorBlendAdvancedStateCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcPremultiplied !== void 0) this.srcPremultiplied = opts.srcPremultiplied;
    if (opts.dstPremultiplied !== void 0) this.dstPremultiplied = opts.dstPremultiplied;
    if (opts.blendOverlap !== void 0) this.blendOverlap = opts.blendOverlap;
    
  }
};

VkPipelineColorBlendAdvancedStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineColorBlendAdvancedStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineColorBlendAdvancedStateCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineColorBlendAdvancedStateCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.srcPremultiplied = original.srcPremultiplied;
  copy.dstPremultiplied = original.dstPremultiplied;
  copy.blendOverlap = original.blendOverlap;
  
  return copy;
};

VkPipelineColorBlendAdvancedStateCreateInfoEXT.byteLength = 0x0;

VkPipelineColorBlendAdvancedStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcPremultiplied: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstPremultiplied: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  blendOverlap: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceInlineUniformBlockFeaturesEXT **/
function VkPhysicalDeviceInlineUniformBlockFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceInlineUniformBlockFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceInlineUniformBlockFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceInlineUniformBlockFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceInlineUniformBlockFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceInlineUniformBlockFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceInlineUniformBlockFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.inlineUniformBlock !== void 0) this.inlineUniformBlock = opts.inlineUniformBlock;
    if (opts.descriptorBindingInlineUniformBlockUpdateAfterBind !== void 0) this.descriptorBindingInlineUniformBlockUpdateAfterBind = opts.descriptorBindingInlineUniformBlockUpdateAfterBind;
    
  }
};

Object.defineProperties(VkPhysicalDeviceInlineUniformBlockFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceInlineUniformBlockFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceInlineUniformBlockFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "inlineUniformBlock": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingInlineUniformBlockUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.inlineUniformBlock !== void 0) this.inlineUniformBlock = opts.inlineUniformBlock;
    if (opts.descriptorBindingInlineUniformBlockUpdateAfterBind !== void 0) this.descriptorBindingInlineUniformBlockUpdateAfterBind = opts.descriptorBindingInlineUniformBlockUpdateAfterBind;
    
  }
};

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceInlineUniformBlockFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.inlineUniformBlock = original.inlineUniformBlock;
  copy.descriptorBindingInlineUniformBlockUpdateAfterBind = original.descriptorBindingInlineUniformBlockUpdateAfterBind;
  
  return copy;
};

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  inlineUniformBlock: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingInlineUniformBlockUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceInlineUniformBlockPropertiesEXT **/
function VkPhysicalDeviceInlineUniformBlockPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceInlineUniformBlockPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceInlineUniformBlockPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceInlineUniformBlockPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceInlineUniformBlockPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceInlineUniformBlockPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceInlineUniformBlockPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceInlineUniformBlockPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceInlineUniformBlockPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceInlineUniformBlockPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxInlineUniformBlockSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorInlineUniformBlocks": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetInlineUniformBlocks": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindInlineUniformBlocks": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceInlineUniformBlockPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxInlineUniformBlockSize = original.maxInlineUniformBlockSize;
  copy.maxPerStageDescriptorInlineUniformBlocks = original.maxPerStageDescriptorInlineUniformBlocks;
  copy.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = original.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
  copy.maxDescriptorSetInlineUniformBlocks = original.maxDescriptorSetInlineUniformBlocks;
  copy.maxDescriptorSetUpdateAfterBindInlineUniformBlocks = original.maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
  
  return copy;
};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxInlineUniformBlockSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorInlineUniformBlocks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetInlineUniformBlocks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindInlineUniformBlocks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkWriteDescriptorSetInlineUniformBlockEXT **/
function VkWriteDescriptorSetInlineUniformBlockEXT(opts, byteOffset) {
  if (new.target !== VkWriteDescriptorSetInlineUniformBlockEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkWriteDescriptorSetInlineUniformBlockEXT, STRUCT_CACHE_VkWriteDescriptorSetInlineUniformBlockEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkWriteDescriptorSetInlineUniformBlockEXT, STRUCT_CACHE_VkWriteDescriptorSetInlineUniformBlockEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkWriteDescriptorSetInlineUniformBlockEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dataSize !== void 0) this.dataSize = opts.dataSize;
    if (opts.pData !== void 0) this.pData = opts.pData;
    
  }
};

Object.defineProperties(VkWriteDescriptorSetInlineUniformBlockEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSetInlineUniformBlockEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWriteDescriptorSetInlineUniformBlockEXT.pNext' isn't allowed to be filled");
    }
    },
  "dataSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSetInlineUniformBlockEXT.dataSize");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pData": {
    get() {
    return this._pData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetInlineUniformBlockEXT.pData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkWriteDescriptorSetInlineUniformBlockEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dataSize !== void 0) this.dataSize = opts.dataSize;
    if (opts.pData !== void 0) this.pData = opts.pData;
    
  }
};

VkWriteDescriptorSetInlineUniformBlockEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkWriteDescriptorSetInlineUniformBlockEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkWriteDescriptorSetInlineUniformBlockEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkWriteDescriptorSetInlineUniformBlockEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.dataSize = original.dataSize;
  if (original.pData !== null) {
      let buf = new ArrayBuffer(original.pData.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pData), 0x0);
      copy.pData = buf;
    }
  
  return copy;
};

VkWriteDescriptorSetInlineUniformBlockEXT.byteLength = 0x0;

VkWriteDescriptorSetInlineUniformBlockEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dataSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorPoolInlineUniformBlockCreateInfoEXT **/
function VkDescriptorPoolInlineUniformBlockCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkDescriptorPoolInlineUniformBlockCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorPoolInlineUniformBlockCreateInfoEXT, STRUCT_CACHE_VkDescriptorPoolInlineUniformBlockCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorPoolInlineUniformBlockCreateInfoEXT, STRUCT_CACHE_VkDescriptorPoolInlineUniformBlockCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorPoolInlineUniformBlockCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.maxInlineUniformBlockBindings !== void 0) this.maxInlineUniformBlockBindings = opts.maxInlineUniformBlockBindings;
    
  }
};

Object.defineProperties(VkDescriptorPoolInlineUniformBlockCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorPoolInlineUniformBlockCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorPoolInlineUniformBlockCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxInlineUniformBlockBindings": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorPoolInlineUniformBlockCreateInfoEXT.maxInlineUniformBlockBindings");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.maxInlineUniformBlockBindings !== void 0) this.maxInlineUniformBlockBindings = opts.maxInlineUniformBlockBindings;
    
  }
};

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorPoolInlineUniformBlockCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxInlineUniformBlockBindings = original.maxInlineUniformBlockBindings;
  
  return copy;
};

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.byteLength = 0x0;

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxInlineUniformBlockBindings: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineCoverageModulationStateCreateInfoNV **/
function VkPipelineCoverageModulationStateCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkPipelineCoverageModulationStateCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineCoverageModulationStateCreateInfoNV, STRUCT_CACHE_VkPipelineCoverageModulationStateCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineCoverageModulationStateCreateInfoNV, STRUCT_CACHE_VkPipelineCoverageModulationStateCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineCoverageModulationStateCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this._pCoverageModulationTable = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.coverageModulationMode !== void 0) this.coverageModulationMode = opts.coverageModulationMode;
    if (opts.coverageModulationTableEnable !== void 0) this.coverageModulationTableEnable = opts.coverageModulationTableEnable;
    if (opts.coverageModulationTableCount !== void 0) this.coverageModulationTableCount = opts.coverageModulationTableCount;
    if (opts.pCoverageModulationTable !== void 0) this.pCoverageModulationTable = opts.pCoverageModulationTable;
    
  }
};

Object.defineProperties(VkPipelineCoverageModulationStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCoverageModulationStateCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCoverageModulationStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCoverageModulationStateCreateInfoNV.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "coverageModulationMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "coverageModulationTableEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "coverageModulationTableCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCoverageModulationTable": {
    get() {
    return this._pCoverageModulationTable;
    },
    set(value) {
    if (value !== null && value.constructor === Float32Array) {
      this._pCoverageModulationTable = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pCoverageModulationTable = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.pCoverageModulationTable': Expected 'Float32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineCoverageModulationStateCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pCoverageModulationTable = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.coverageModulationMode !== void 0) this.coverageModulationMode = opts.coverageModulationMode;
    if (opts.coverageModulationTableEnable !== void 0) this.coverageModulationTableEnable = opts.coverageModulationTableEnable;
    if (opts.coverageModulationTableCount !== void 0) this.coverageModulationTableCount = opts.coverageModulationTableCount;
    if (opts.pCoverageModulationTable !== void 0) this.pCoverageModulationTable = opts.pCoverageModulationTable;
    
  }
};

VkPipelineCoverageModulationStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCoverageModulationStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineCoverageModulationStateCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineCoverageModulationStateCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.coverageModulationMode = original.coverageModulationMode;
  copy.coverageModulationTableEnable = original.coverageModulationTableEnable;
  copy.coverageModulationTableCount = original.coverageModulationTableCount;
  if (original.pCoverageModulationTable !== null) {
        copy.pCoverageModulationTable = new Float32Array(original.pCoverageModulationTable);
      }
  
  return copy;
};

VkPipelineCoverageModulationStateCreateInfoNV.byteLength = 0x0;

VkPipelineCoverageModulationStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  coverageModulationMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  coverageModulationTableEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  coverageModulationTableCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCoverageModulationTable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageFormatListCreateInfo **/
function VkImageFormatListCreateInfo(opts, byteOffset) {
  if (new.target !== VkImageFormatListCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageFormatListCreateInfo, STRUCT_CACHE_VkImageFormatListCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageFormatListCreateInfo, STRUCT_CACHE_VkImageFormatListCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageFormatListCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pViewFormats = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
    if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
    
  }
};

Object.defineProperties(VkImageFormatListCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageFormatListCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageFormatListCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "viewFormatCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageFormatListCreateInfo.viewFormatCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewFormats": {
    get() {
    return this._pViewFormats;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewFormats = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pViewFormats = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageFormatListCreateInfo.pViewFormats': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageFormatListCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pViewFormats = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
    if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
    
  }
};

VkImageFormatListCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageFormatListCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageFormatListCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageFormatListCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.viewFormatCount = original.viewFormatCount;
  if (original.pViewFormats !== null) {
        copy.pViewFormats = new Int32Array(original.pViewFormats);
      }
  
  return copy;
};

VkImageFormatListCreateInfo.byteLength = 0x0;

VkImageFormatListCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewFormatCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewFormats: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageFormatListCreateInfoKHR **/
function VkImageFormatListCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkImageFormatListCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageFormatListCreateInfoKHR, STRUCT_CACHE_VkImageFormatListCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageFormatListCreateInfoKHR, STRUCT_CACHE_VkImageFormatListCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageFormatListCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pViewFormats = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
    if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
    
  }
};

Object.defineProperties(VkImageFormatListCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageFormatListCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageFormatListCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "viewFormatCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageFormatListCreateInfoKHR.viewFormatCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewFormats": {
    get() {
    return this._pViewFormats;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewFormats = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pViewFormats = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageFormatListCreateInfoKHR.pViewFormats': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageFormatListCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pViewFormats = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
    if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
    
  }
};

VkImageFormatListCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageFormatListCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageFormatListCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageFormatListCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.viewFormatCount = original.viewFormatCount;
  if (original.pViewFormats !== null) {
        copy.pViewFormats = new Int32Array(original.pViewFormats);
      }
  
  return copy;
};

VkImageFormatListCreateInfoKHR.byteLength = 0x0;

VkImageFormatListCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewFormatCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewFormats: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkValidationCacheCreateInfoEXT **/
function VkValidationCacheCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkValidationCacheCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkValidationCacheCreateInfoEXT, STRUCT_CACHE_VkValidationCacheCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkValidationCacheCreateInfoEXT, STRUCT_CACHE_VkValidationCacheCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkValidationCacheCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pInitialData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.initialDataSize !== void 0) this.initialDataSize = opts.initialDataSize;
    if (opts.pInitialData !== void 0) this.pInitialData = opts.pInitialData;
    
  }
};

Object.defineProperties(VkValidationCacheCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkValidationCacheCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkValidationCacheCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkValidationCacheCreateInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "initialDataSize": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkValidationCacheCreateInfoEXT.initialDataSize")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "pInitialData": {
    get() {
    return this._pInitialData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pInitialData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pInitialData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkValidationCacheCreateInfoEXT.pInitialData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkValidationCacheCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pInitialData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.initialDataSize !== void 0) this.initialDataSize = opts.initialDataSize;
    if (opts.pInitialData !== void 0) this.pInitialData = opts.pInitialData;
    
  }
};

VkValidationCacheCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkValidationCacheCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkValidationCacheCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkValidationCacheCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.initialDataSize = original.initialDataSize;
  if (original.pInitialData !== null) {
      let buf = new ArrayBuffer(original.pInitialData.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pInitialData), 0x0);
      copy.pInitialData = buf;
    }
  
  return copy;
};

VkValidationCacheCreateInfoEXT.byteLength = 0x0;

VkValidationCacheCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  initialDataSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pInitialData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkShaderModuleValidationCacheCreateInfoEXT **/
function VkShaderModuleValidationCacheCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkShaderModuleValidationCacheCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkShaderModuleValidationCacheCreateInfoEXT, STRUCT_CACHE_VkShaderModuleValidationCacheCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkShaderModuleValidationCacheCreateInfoEXT, STRUCT_CACHE_VkShaderModuleValidationCacheCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkShaderModuleValidationCacheCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._validationCache = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.validationCache !== void 0) this.validationCache = opts.validationCache;
    
  }
};

Object.defineProperties(VkShaderModuleValidationCacheCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkShaderModuleValidationCacheCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkShaderModuleValidationCacheCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "validationCache": {
    get() {
    return this._validationCache;
    },
    set(value) {
    if (value !== null && value.constructor === VkValidationCacheEXT) {
      
      this._validationCache = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._validationCache = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkShaderModuleValidationCacheCreateInfoEXT.validationCache': Expected 'VkValidationCacheEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkShaderModuleValidationCacheCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._validationCache = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.validationCache !== void 0) this.validationCache = opts.validationCache;
    
  }
};

VkShaderModuleValidationCacheCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkShaderModuleValidationCacheCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkShaderModuleValidationCacheCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkShaderModuleValidationCacheCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.validationCache !== null) {
        copy.validationCache = original.validationCache.constructor.createCopyFrom(original.validationCache);
      }
  
  return copy;
};

VkShaderModuleValidationCacheCreateInfoEXT.byteLength = 0x0;

VkShaderModuleValidationCacheCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  validationCache: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMaintenance3Properties **/
function VkPhysicalDeviceMaintenance3Properties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMaintenance3Properties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMaintenance3Properties, STRUCT_CACHE_VkPhysicalDeviceMaintenance3Properties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMaintenance3Properties, STRUCT_CACHE_VkPhysicalDeviceMaintenance3Properties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMaintenance3Properties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMaintenance3Properties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMaintenance3Properties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMaintenance3Properties.pNext' isn't allowed to be filled");
    }
    },
  "maxPerSetDescriptors": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMemoryAllocationSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPhysicalDeviceMaintenance3Properties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceMaintenance3Properties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMaintenance3Properties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceMaintenance3Properties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMaintenance3Properties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxPerSetDescriptors = original.maxPerSetDescriptors;
  copy.maxMemoryAllocationSize = original.maxMemoryAllocationSize;
  
  return copy;
};

VkPhysicalDeviceMaintenance3Properties.byteLength = 0x0;

VkPhysicalDeviceMaintenance3Properties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerSetDescriptors: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMemoryAllocationSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMaintenance3PropertiesKHR **/
function VkPhysicalDeviceMaintenance3PropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMaintenance3PropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMaintenance3PropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceMaintenance3PropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMaintenance3PropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceMaintenance3PropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMaintenance3PropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMaintenance3PropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMaintenance3PropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMaintenance3PropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "maxPerSetDescriptors": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMemoryAllocationSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPhysicalDeviceMaintenance3PropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceMaintenance3PropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMaintenance3PropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceMaintenance3PropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMaintenance3PropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxPerSetDescriptors = original.maxPerSetDescriptors;
  copy.maxMemoryAllocationSize = original.maxMemoryAllocationSize;
  
  return copy;
};

VkPhysicalDeviceMaintenance3PropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceMaintenance3PropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerSetDescriptors: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMemoryAllocationSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetLayoutSupport **/
function VkDescriptorSetLayoutSupport(opts, byteOffset) {
  if (new.target !== VkDescriptorSetLayoutSupport) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetLayoutSupport, STRUCT_CACHE_VkDescriptorSetLayoutSupport);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetLayoutSupport, STRUCT_CACHE_VkDescriptorSetLayoutSupport);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetLayoutSupport'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutSupport.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutSupport.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.pNext'");
    }
    
    }
    },
  "supported": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkDescriptorSetLayoutSupport.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDescriptorSetLayoutSupport.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetLayoutSupport.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDescriptorSetLayoutSupport.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetLayoutSupport();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.supported = original.supported;
  
  return copy;
};

VkDescriptorSetLayoutSupport.byteLength = 0x0;

VkDescriptorSetLayoutSupport.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supported: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetLayoutSupportKHR **/
function VkDescriptorSetLayoutSupportKHR(opts, byteOffset) {
  if (new.target !== VkDescriptorSetLayoutSupportKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetLayoutSupportKHR, STRUCT_CACHE_VkDescriptorSetLayoutSupportKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetLayoutSupportKHR, STRUCT_CACHE_VkDescriptorSetLayoutSupportKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetLayoutSupportKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutSupportKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutSupportKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.pNext'");
    }
    
    }
    },
  "supported": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkDescriptorSetLayoutSupportKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDescriptorSetLayoutSupportKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetLayoutSupportKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDescriptorSetLayoutSupportKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetLayoutSupportKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.supported = original.supported;
  
  return copy;
};

VkDescriptorSetLayoutSupportKHR.byteLength = 0x0;

VkDescriptorSetLayoutSupportKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supported: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderDrawParametersFeatures **/
function VkPhysicalDeviceShaderDrawParametersFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderDrawParametersFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderDrawParametersFeatures, STRUCT_CACHE_VkPhysicalDeviceShaderDrawParametersFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderDrawParametersFeatures, STRUCT_CACHE_VkPhysicalDeviceShaderDrawParametersFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderDrawParametersFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderDrawParameters !== void 0) this.shaderDrawParameters = opts.shaderDrawParameters;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderDrawParametersFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderDrawParametersFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderDrawParametersFeatures.pNext' isn't allowed to be filled");
    }
    },
  "shaderDrawParameters": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderDrawParametersFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderDrawParameters !== void 0) this.shaderDrawParameters = opts.shaderDrawParameters;
    
  }
};

VkPhysicalDeviceShaderDrawParametersFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderDrawParametersFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderDrawParametersFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderDrawParametersFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderDrawParameters = original.shaderDrawParameters;
  
  return copy;
};

VkPhysicalDeviceShaderDrawParametersFeatures.byteLength = 0x0;

VkPhysicalDeviceShaderDrawParametersFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDrawParameters: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderDrawParameterFeatures **/
function VkPhysicalDeviceShaderDrawParameterFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderDrawParameterFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderDrawParameterFeatures, STRUCT_CACHE_VkPhysicalDeviceShaderDrawParameterFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderDrawParameterFeatures, STRUCT_CACHE_VkPhysicalDeviceShaderDrawParameterFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderDrawParameterFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderDrawParameters !== void 0) this.shaderDrawParameters = opts.shaderDrawParameters;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderDrawParameterFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderDrawParameterFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderDrawParameterFeatures.pNext' isn't allowed to be filled");
    }
    },
  "shaderDrawParameters": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderDrawParameterFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderDrawParameters !== void 0) this.shaderDrawParameters = opts.shaderDrawParameters;
    
  }
};

VkPhysicalDeviceShaderDrawParameterFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderDrawParameterFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderDrawParameterFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderDrawParameterFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderDrawParameters = original.shaderDrawParameters;
  
  return copy;
};

VkPhysicalDeviceShaderDrawParameterFeatures.byteLength = 0x0;

VkPhysicalDeviceShaderDrawParameterFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDrawParameters: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderFloat16Int8Features **/
function VkPhysicalDeviceShaderFloat16Int8Features(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderFloat16Int8Features) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderFloat16Int8Features, STRUCT_CACHE_VkPhysicalDeviceShaderFloat16Int8Features);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderFloat16Int8Features, STRUCT_CACHE_VkPhysicalDeviceShaderFloat16Int8Features);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderFloat16Int8Features'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderFloat16 !== void 0) this.shaderFloat16 = opts.shaderFloat16;
    if (opts.shaderInt8 !== void 0) this.shaderInt8 = opts.shaderInt8;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderFloat16Int8Features.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderFloat16Int8Features.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderFloat16Int8Features.pNext' isn't allowed to be filled");
    }
    },
  "shaderFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderInt8": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderFloat16Int8Features.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderFloat16 !== void 0) this.shaderFloat16 = opts.shaderFloat16;
    if (opts.shaderInt8 !== void 0) this.shaderInt8 = opts.shaderInt8;
    
  }
};

VkPhysicalDeviceShaderFloat16Int8Features.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderFloat16Int8Features.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderFloat16Int8Features.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderFloat16Int8Features();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderFloat16 = original.shaderFloat16;
  copy.shaderInt8 = original.shaderInt8;
  
  return copy;
};

VkPhysicalDeviceShaderFloat16Int8Features.byteLength = 0x0;

VkPhysicalDeviceShaderFloat16Int8Features.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInt8: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderFloat16Int8FeaturesKHR **/
function VkPhysicalDeviceShaderFloat16Int8FeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderFloat16Int8FeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderFloat16Int8FeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderFloat16Int8FeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderFloat16Int8FeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderFloat16 !== void 0) this.shaderFloat16 = opts.shaderFloat16;
    if (opts.shaderInt8 !== void 0) this.shaderInt8 = opts.shaderInt8;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "shaderFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderInt8": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderFloat16 !== void 0) this.shaderFloat16 = opts.shaderFloat16;
    if (opts.shaderInt8 !== void 0) this.shaderInt8 = opts.shaderInt8;
    
  }
};

VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderFloat16Int8FeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderFloat16 = original.shaderFloat16;
  copy.shaderInt8 = original.shaderInt8;
  
  return copy;
};

VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceShaderFloat16Int8FeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInt8: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFloat16Int8FeaturesKHR **/
function VkPhysicalDeviceFloat16Int8FeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFloat16Int8FeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFloat16Int8FeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceFloat16Int8FeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFloat16Int8FeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceFloat16Int8FeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFloat16Int8FeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderFloat16 !== void 0) this.shaderFloat16 = opts.shaderFloat16;
    if (opts.shaderInt8 !== void 0) this.shaderInt8 = opts.shaderInt8;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFloat16Int8FeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFloat16Int8FeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFloat16Int8FeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "shaderFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderInt8": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceFloat16Int8FeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderFloat16 !== void 0) this.shaderFloat16 = opts.shaderFloat16;
    if (opts.shaderInt8 !== void 0) this.shaderInt8 = opts.shaderInt8;
    
  }
};

VkPhysicalDeviceFloat16Int8FeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFloat16Int8FeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFloat16Int8FeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFloat16Int8FeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderFloat16 = original.shaderFloat16;
  copy.shaderInt8 = original.shaderInt8;
  
  return copy;
};

VkPhysicalDeviceFloat16Int8FeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceFloat16Int8FeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInt8: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFloatControlsProperties **/
function VkPhysicalDeviceFloatControlsProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFloatControlsProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFloatControlsProperties, STRUCT_CACHE_VkPhysicalDeviceFloatControlsProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFloatControlsProperties, STRUCT_CACHE_VkPhysicalDeviceFloatControlsProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFloatControlsProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFloatControlsProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFloatControlsProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFloatControlsProperties.pNext' isn't allowed to be filled");
    }
    },
  "denormBehaviorIndependence": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "roundingModeIndependence": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "shaderSignedZeroInfNanPreserveFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderSignedZeroInfNanPreserveFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderSignedZeroInfNanPreserveFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormPreserveFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormPreserveFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormPreserveFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTEFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTEFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTEFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTZFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTZFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTZFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceFloatControlsProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceFloatControlsProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFloatControlsProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceFloatControlsProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFloatControlsProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.denormBehaviorIndependence = original.denormBehaviorIndependence;
  copy.roundingModeIndependence = original.roundingModeIndependence;
  copy.shaderSignedZeroInfNanPreserveFloat16 = original.shaderSignedZeroInfNanPreserveFloat16;
  copy.shaderSignedZeroInfNanPreserveFloat32 = original.shaderSignedZeroInfNanPreserveFloat32;
  copy.shaderSignedZeroInfNanPreserveFloat64 = original.shaderSignedZeroInfNanPreserveFloat64;
  copy.shaderDenormPreserveFloat16 = original.shaderDenormPreserveFloat16;
  copy.shaderDenormPreserveFloat32 = original.shaderDenormPreserveFloat32;
  copy.shaderDenormPreserveFloat64 = original.shaderDenormPreserveFloat64;
  copy.shaderDenormFlushToZeroFloat16 = original.shaderDenormFlushToZeroFloat16;
  copy.shaderDenormFlushToZeroFloat32 = original.shaderDenormFlushToZeroFloat32;
  copy.shaderDenormFlushToZeroFloat64 = original.shaderDenormFlushToZeroFloat64;
  copy.shaderRoundingModeRTEFloat16 = original.shaderRoundingModeRTEFloat16;
  copy.shaderRoundingModeRTEFloat32 = original.shaderRoundingModeRTEFloat32;
  copy.shaderRoundingModeRTEFloat64 = original.shaderRoundingModeRTEFloat64;
  copy.shaderRoundingModeRTZFloat16 = original.shaderRoundingModeRTZFloat16;
  copy.shaderRoundingModeRTZFloat32 = original.shaderRoundingModeRTZFloat32;
  copy.shaderRoundingModeRTZFloat64 = original.shaderRoundingModeRTZFloat64;
  
  return copy;
};

VkPhysicalDeviceFloatControlsProperties.byteLength = 0x0;

VkPhysicalDeviceFloatControlsProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  denormBehaviorIndependence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  roundingModeIndependence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSignedZeroInfNanPreserveFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSignedZeroInfNanPreserveFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSignedZeroInfNanPreserveFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormPreserveFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormPreserveFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormPreserveFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormFlushToZeroFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormFlushToZeroFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormFlushToZeroFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTEFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTEFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTEFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTZFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTZFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTZFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFloatControlsPropertiesKHR **/
function VkPhysicalDeviceFloatControlsPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFloatControlsPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFloatControlsPropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceFloatControlsPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFloatControlsPropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceFloatControlsPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFloatControlsPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFloatControlsPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFloatControlsPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFloatControlsPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "denormBehaviorIndependence": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "roundingModeIndependence": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "shaderSignedZeroInfNanPreserveFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderSignedZeroInfNanPreserveFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderSignedZeroInfNanPreserveFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormPreserveFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormPreserveFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormPreserveFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTEFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTEFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTEFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTZFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTZFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTZFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceFloatControlsPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceFloatControlsPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFloatControlsPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceFloatControlsPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFloatControlsPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.denormBehaviorIndependence = original.denormBehaviorIndependence;
  copy.roundingModeIndependence = original.roundingModeIndependence;
  copy.shaderSignedZeroInfNanPreserveFloat16 = original.shaderSignedZeroInfNanPreserveFloat16;
  copy.shaderSignedZeroInfNanPreserveFloat32 = original.shaderSignedZeroInfNanPreserveFloat32;
  copy.shaderSignedZeroInfNanPreserveFloat64 = original.shaderSignedZeroInfNanPreserveFloat64;
  copy.shaderDenormPreserveFloat16 = original.shaderDenormPreserveFloat16;
  copy.shaderDenormPreserveFloat32 = original.shaderDenormPreserveFloat32;
  copy.shaderDenormPreserveFloat64 = original.shaderDenormPreserveFloat64;
  copy.shaderDenormFlushToZeroFloat16 = original.shaderDenormFlushToZeroFloat16;
  copy.shaderDenormFlushToZeroFloat32 = original.shaderDenormFlushToZeroFloat32;
  copy.shaderDenormFlushToZeroFloat64 = original.shaderDenormFlushToZeroFloat64;
  copy.shaderRoundingModeRTEFloat16 = original.shaderRoundingModeRTEFloat16;
  copy.shaderRoundingModeRTEFloat32 = original.shaderRoundingModeRTEFloat32;
  copy.shaderRoundingModeRTEFloat64 = original.shaderRoundingModeRTEFloat64;
  copy.shaderRoundingModeRTZFloat16 = original.shaderRoundingModeRTZFloat16;
  copy.shaderRoundingModeRTZFloat32 = original.shaderRoundingModeRTZFloat32;
  copy.shaderRoundingModeRTZFloat64 = original.shaderRoundingModeRTZFloat64;
  
  return copy;
};

VkPhysicalDeviceFloatControlsPropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceFloatControlsPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  denormBehaviorIndependence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  roundingModeIndependence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSignedZeroInfNanPreserveFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSignedZeroInfNanPreserveFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSignedZeroInfNanPreserveFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormPreserveFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormPreserveFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormPreserveFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormFlushToZeroFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormFlushToZeroFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormFlushToZeroFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTEFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTEFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTEFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTZFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTZFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTZFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceHostQueryResetFeatures **/
function VkPhysicalDeviceHostQueryResetFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceHostQueryResetFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceHostQueryResetFeatures, STRUCT_CACHE_VkPhysicalDeviceHostQueryResetFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceHostQueryResetFeatures, STRUCT_CACHE_VkPhysicalDeviceHostQueryResetFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceHostQueryResetFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.hostQueryReset !== void 0) this.hostQueryReset = opts.hostQueryReset;
    
  }
};

Object.defineProperties(VkPhysicalDeviceHostQueryResetFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceHostQueryResetFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceHostQueryResetFeatures.pNext' isn't allowed to be filled");
    }
    },
  "hostQueryReset": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceHostQueryResetFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.hostQueryReset !== void 0) this.hostQueryReset = opts.hostQueryReset;
    
  }
};

VkPhysicalDeviceHostQueryResetFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceHostQueryResetFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceHostQueryResetFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceHostQueryResetFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.hostQueryReset = original.hostQueryReset;
  
  return copy;
};

VkPhysicalDeviceHostQueryResetFeatures.byteLength = 0x0;

VkPhysicalDeviceHostQueryResetFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  hostQueryReset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceHostQueryResetFeaturesEXT **/
function VkPhysicalDeviceHostQueryResetFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceHostQueryResetFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceHostQueryResetFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceHostQueryResetFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceHostQueryResetFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceHostQueryResetFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceHostQueryResetFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.hostQueryReset !== void 0) this.hostQueryReset = opts.hostQueryReset;
    
  }
};

Object.defineProperties(VkPhysicalDeviceHostQueryResetFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceHostQueryResetFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceHostQueryResetFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "hostQueryReset": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceHostQueryResetFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.hostQueryReset !== void 0) this.hostQueryReset = opts.hostQueryReset;
    
  }
};

VkPhysicalDeviceHostQueryResetFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceHostQueryResetFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceHostQueryResetFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceHostQueryResetFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.hostQueryReset = original.hostQueryReset;
  
  return copy;
};

VkPhysicalDeviceHostQueryResetFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceHostQueryResetFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  hostQueryReset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkShaderResourceUsageAMD **/
function VkShaderResourceUsageAMD(opts, byteOffset) {
  if (new.target !== VkShaderResourceUsageAMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkShaderResourceUsageAMD, STRUCT_CACHE_VkShaderResourceUsageAMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkShaderResourceUsageAMD, STRUCT_CACHE_VkShaderResourceUsageAMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkShaderResourceUsageAMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkShaderResourceUsageAMD.prototype, {
  "numUsedVgprs": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "numUsedSgprs": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "ldsSizePerLocalWorkGroup": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "ldsUsageSizeInBytes": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    },
  "scratchMemUsageInBytes": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    },
  
});

VkShaderResourceUsageAMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkShaderResourceUsageAMD.prototype.flush = function flush() {
  
  return true;
};

VkShaderResourceUsageAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkShaderResourceUsageAMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkShaderResourceUsageAMD();
  copy.numUsedVgprs = original.numUsedVgprs;
  copy.numUsedSgprs = original.numUsedSgprs;
  copy.ldsSizePerLocalWorkGroup = original.ldsSizePerLocalWorkGroup;
  copy.ldsUsageSizeInBytes = original.ldsUsageSizeInBytes;
  copy.scratchMemUsageInBytes = original.scratchMemUsageInBytes;
  
  return copy;
};

VkShaderResourceUsageAMD.byteLength = 0x0;

VkShaderResourceUsageAMD.memoryLayout = {
  numUsedVgprs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  numUsedSgprs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ldsSizePerLocalWorkGroup: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ldsUsageSizeInBytes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  scratchMemUsageInBytes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkShaderStatisticsInfoAMD **/
function VkShaderStatisticsInfoAMD(opts, byteOffset) {
  if (new.target !== VkShaderStatisticsInfoAMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkShaderStatisticsInfoAMD, STRUCT_CACHE_VkShaderStatisticsInfoAMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkShaderStatisticsInfoAMD, STRUCT_CACHE_VkShaderStatisticsInfoAMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkShaderStatisticsInfoAMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._resourceUsage = new VkShaderResourceUsageAMD({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  this._computeWorkGroupSize = [...Array(3)].fill(0x0);
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkShaderStatisticsInfoAMD.prototype, {
  "shaderStageMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "resourceUsage": {
    get() {
    return this._resourceUsage;
    },
    },
  "numPhysicalVgprs": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "numPhysicalSgprs": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "numAvailableVgprs": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "numAvailableSgprs": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "computeWorkGroupSize": {
    get() {
    return [
      this.memoryView.getUint32(0x0, true),
      this.memoryView.getUint32(0x4, true),
      this.memoryView.getUint32(0x8, true)
    ];
    },
    },
  
});

VkShaderStatisticsInfoAMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  if (this._resourceUsage !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._resourceUsage.memoryBuffer) this._resourceUsage = new VkShaderResourceUsageAMD({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._resourceUsage.reset();
  }
  
  
  
  
  if (this._computeWorkGroupSize !== null) this._computeWorkGroupSize.fill(0x0);
      else this._computeWorkGroupSize = [...Array(3)].fill(0x0);
  
  if (typeof opts === "object") {
    
  }
};

VkShaderStatisticsInfoAMD.prototype.flush = function flush() {
  
  return true;
};

VkShaderStatisticsInfoAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkShaderStatisticsInfoAMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkShaderStatisticsInfoAMD();
  copy.shaderStageMask = original.shaderStageMask;
  if (original.resourceUsage !== null) {
        copy.resourceUsage = original.resourceUsage.constructor.createCopyFrom(original.resourceUsage);
      }
  copy.numPhysicalVgprs = original.numPhysicalVgprs;
  copy.numPhysicalSgprs = original.numPhysicalSgprs;
  copy.numAvailableVgprs = original.numAvailableVgprs;
  copy.numAvailableSgprs = original.numAvailableSgprs;
  if (original.computeWorkGroupSize !== null) {
        copy.computeWorkGroupSize = [...Array(original.computeWorkGroupSize.length)].map((v, i) => {
          return original.computeWorkGroupSize[i];
        });
      }
  
  return copy;
};

VkShaderStatisticsInfoAMD.byteLength = 0x0;

VkShaderStatisticsInfoAMD.memoryLayout = {
  shaderStageMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  resourceUsage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  numPhysicalVgprs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  numPhysicalSgprs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  numAvailableVgprs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  numAvailableSgprs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  computeWorkGroupSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceQueueGlobalPriorityCreateInfoEXT **/
function VkDeviceQueueGlobalPriorityCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkDeviceQueueGlobalPriorityCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceQueueGlobalPriorityCreateInfoEXT, STRUCT_CACHE_VkDeviceQueueGlobalPriorityCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceQueueGlobalPriorityCreateInfoEXT, STRUCT_CACHE_VkDeviceQueueGlobalPriorityCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceQueueGlobalPriorityCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.globalPriority !== void 0) this.globalPriority = opts.globalPriority;
    
  }
};

Object.defineProperties(VkDeviceQueueGlobalPriorityCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceQueueGlobalPriorityCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceQueueGlobalPriorityCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "globalPriority": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceQueueGlobalPriorityCreateInfoEXT.globalPriority");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkDeviceQueueGlobalPriorityCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.globalPriority !== void 0) this.globalPriority = opts.globalPriority;
    
  }
};

VkDeviceQueueGlobalPriorityCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceQueueGlobalPriorityCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceQueueGlobalPriorityCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceQueueGlobalPriorityCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.globalPriority = original.globalPriority;
  
  return copy;
};

VkDeviceQueueGlobalPriorityCreateInfoEXT.byteLength = 0x0;

VkDeviceQueueGlobalPriorityCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  globalPriority: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDebugUtilsObjectNameInfoEXT **/
function VkDebugUtilsObjectNameInfoEXT(opts, byteOffset) {
  if (new.target !== VkDebugUtilsObjectNameInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDebugUtilsObjectNameInfoEXT, STRUCT_CACHE_VkDebugUtilsObjectNameInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDebugUtilsObjectNameInfoEXT, STRUCT_CACHE_VkDebugUtilsObjectNameInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDebugUtilsObjectNameInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pObjectName = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.objectHandle !== void 0) this.objectHandle = opts.objectHandle;
    if (opts.pObjectName !== void 0) this.pObjectName = opts.pObjectName;
    
  }
};

Object.defineProperties(VkDebugUtilsObjectNameInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsObjectNameInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugUtilsObjectNameInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "objectType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsObjectNameInfoEXT.objectType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "objectHandle": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDebugUtilsObjectNameInfoEXT.objectHandle")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "pObjectName": {
    get() {
    if (this._pObjectName !== null) {
      let str = textDecoder.decode(this._pObjectName);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._pObjectName = buffer;
        return this.pObjectName;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pObjectName = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._pObjectName), true);
    } else if (value === null) {
      this._pObjectName = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkDebugUtilsObjectNameInfoEXT.pObjectName");
    }
    
    }
    },
  
});

VkDebugUtilsObjectNameInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pObjectName = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.objectHandle !== void 0) this.objectHandle = opts.objectHandle;
    if (opts.pObjectName !== void 0) this.pObjectName = opts.pObjectName;
    
  }
};

VkDebugUtilsObjectNameInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugUtilsObjectNameInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDebugUtilsObjectNameInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDebugUtilsObjectNameInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.objectType = original.objectType;
  copy.objectHandle = original.objectHandle;
  copy.pObjectName = original.pObjectName;
  
  return copy;
};

VkDebugUtilsObjectNameInfoEXT.byteLength = 0x0;

VkDebugUtilsObjectNameInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  objectType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  objectHandle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pObjectName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDebugUtilsObjectTagInfoEXT **/
function VkDebugUtilsObjectTagInfoEXT(opts, byteOffset) {
  if (new.target !== VkDebugUtilsObjectTagInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDebugUtilsObjectTagInfoEXT, STRUCT_CACHE_VkDebugUtilsObjectTagInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDebugUtilsObjectTagInfoEXT, STRUCT_CACHE_VkDebugUtilsObjectTagInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDebugUtilsObjectTagInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this._pTag = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.objectHandle !== void 0) this.objectHandle = opts.objectHandle;
    if (opts.tagName !== void 0) this.tagName = opts.tagName;
    if (opts.tagSize !== void 0) this.tagSize = opts.tagSize;
    if (opts.pTag !== void 0) this.pTag = opts.pTag;
    
  }
};

Object.defineProperties(VkDebugUtilsObjectTagInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsObjectTagInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugUtilsObjectTagInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "objectType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsObjectTagInfoEXT.objectType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "objectHandle": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDebugUtilsObjectTagInfoEXT.objectHandle")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "tagName": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDebugUtilsObjectTagInfoEXT.tagName")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "tagSize": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkDebugUtilsObjectTagInfoEXT.tagSize")
    this.memoryView.setBigInt64(0x0, BigInt(value), true);
    }
    },
  "pTag": {
    get() {
    return this._pTag;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pTag = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pTag = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.pTag': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugUtilsObjectTagInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pTag = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.objectType !== void 0) this.objectType = opts.objectType;
    if (opts.objectHandle !== void 0) this.objectHandle = opts.objectHandle;
    if (opts.tagName !== void 0) this.tagName = opts.tagName;
    if (opts.tagSize !== void 0) this.tagSize = opts.tagSize;
    if (opts.pTag !== void 0) this.pTag = opts.pTag;
    
  }
};

VkDebugUtilsObjectTagInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugUtilsObjectTagInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDebugUtilsObjectTagInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDebugUtilsObjectTagInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.objectType = original.objectType;
  copy.objectHandle = original.objectHandle;
  copy.tagName = original.tagName;
  copy.tagSize = original.tagSize;
  if (original.pTag !== null) {
      let buf = new ArrayBuffer(original.pTag.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pTag), 0x0);
      copy.pTag = buf;
    }
  
  return copy;
};

VkDebugUtilsObjectTagInfoEXT.byteLength = 0x0;

VkDebugUtilsObjectTagInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  objectType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  objectHandle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tagName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  tagSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pTag: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDebugUtilsLabelEXT **/
function VkDebugUtilsLabelEXT(opts, byteOffset) {
  if (new.target !== VkDebugUtilsLabelEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDebugUtilsLabelEXT, STRUCT_CACHE_VkDebugUtilsLabelEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDebugUtilsLabelEXT, STRUCT_CACHE_VkDebugUtilsLabelEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDebugUtilsLabelEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._pLabelName = null;
  this._color = [...Array(4)].fill(0x0);
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pLabelName !== void 0) this.pLabelName = opts.pLabelName;
    if (opts.color !== void 0) this.color = opts.color;
    
  }
};

Object.defineProperties(VkDebugUtilsLabelEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsLabelEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugUtilsLabelEXT.pNext' isn't allowed to be filled");
    }
    },
  "pLabelName": {
    get() {
    if (this._pLabelName !== null) {
      let str = textDecoder.decode(this._pLabelName);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._pLabelName = buffer;
        return this.pLabelName;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pLabelName = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._pLabelName), true);
    } else if (value === null) {
      this._pLabelName = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkDebugUtilsLabelEXT.pLabelName");
    }
    
    }
    },
  "color": {
    get() {
    return this._color;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._color = value;
    } else if (value === null) {
      this._color = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsLabelEXT.color': Expected 'Array float' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugUtilsLabelEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._pLabelName = null;
  if (this._color !== null) this._color.fill(0x0);
      else this._color = [...Array(4)].fill(0x0);
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pLabelName !== void 0) this.pLabelName = opts.pLabelName;
    if (opts.color !== void 0) this.color = opts.color;
    
  }
};

VkDebugUtilsLabelEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._color !== null) {
    let array = this._color;
    
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkDebugUtilsLabelEXT.color'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkDebugUtilsLabelEXT.color[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryView.setFloat32(0x0 + (ii * 4), array[ii], true);
    };
  } else {
    this.memoryView.setFloat32(0x0, 0x0, true);
  }
  
  return true;
};

VkDebugUtilsLabelEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDebugUtilsLabelEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDebugUtilsLabelEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pLabelName = original.pLabelName;
  if (original.color !== null) {
        copy.color = [...Array(original.color.length)].map((v, i) => {
          return original.color[i];
        });
      }
  
  return copy;
};

VkDebugUtilsLabelEXT.byteLength = 0x0;

VkDebugUtilsLabelEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pLabelName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  color: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDebugUtilsMessengerCreateInfoEXT **/
function VkDebugUtilsMessengerCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkDebugUtilsMessengerCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDebugUtilsMessengerCreateInfoEXT, STRUCT_CACHE_VkDebugUtilsMessengerCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDebugUtilsMessengerCreateInfoEXT, STRUCT_CACHE_VkDebugUtilsMessengerCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDebugUtilsMessengerCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._pfnUserCallback = null;this._pfnUserCallbackCallbackProxy = null;
  this._pUserData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.messageSeverity !== void 0) this.messageSeverity = opts.messageSeverity;
    if (opts.messageType !== void 0) this.messageType = opts.messageType;
    if (opts.pfnUserCallback !== void 0) this.pfnUserCallback = opts.pfnUserCallback;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

Object.defineProperties(VkDebugUtilsMessengerCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsMessengerCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugUtilsMessengerCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsMessengerCreateInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "messageSeverity": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsMessengerCreateInfoEXT.messageSeverity");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "messageType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsMessengerCreateInfoEXT.messageType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pfnUserCallback": {
    get() {
    return this._pfnUserCallback;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      let MITM = function() {
        for (let ii = 0; ii < arguments.length; ++ii) {
          let arg = arguments[ii];
          if (arg instanceof Object && arg.constructor.createCopyFrom instanceof Function) {
            let copy = arg.constructor.createCopyFrom(arg);
            arguments[ii] = copy;
          }
        };
        return value.apply(this, arguments);
      }.bind(this);
      this._pfnUserCallback = value;
      this._pfnUserCallbackCallbackProxy = new nvk.$CallbackProxy(MITM, module.exports);
      this.memoryView.setBigInt64(0x0, nvk.$vulkanCallbackFunctionPointers["vkDebugUtilsMessengerCallbackEXT"], true);
      this.memoryView.setBigInt64(0x0, this._pfnUserCallbackCallbackProxy.getAddress(), true);
    } else if (value === null) {
      this._pfnUserCallback = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.pfnUserCallback': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pUserData": {
    get() {
    return this._pUserData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.pUserData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDebugUtilsMessengerCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this._pfnUserCallback = null;
  this._pUserData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.messageSeverity !== void 0) this.messageSeverity = opts.messageSeverity;
    if (opts.messageType !== void 0) this.messageType = opts.messageType;
    if (opts.pfnUserCallback !== void 0) this.pfnUserCallback = opts.pfnUserCallback;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

VkDebugUtilsMessengerCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugUtilsMessengerCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDebugUtilsMessengerCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDebugUtilsMessengerCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.messageSeverity = original.messageSeverity;
  copy.messageType = original.messageType;
  copy.pfnUserCallback = original.pfnUserCallback;
  if (original.pUserData !== null) {
      let buf = new ArrayBuffer(original.pUserData.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pUserData), 0x0);
      copy.pUserData = buf;
    }
  
  return copy;
};

VkDebugUtilsMessengerCreateInfoEXT.byteLength = 0x0;

VkDebugUtilsMessengerCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  messageSeverity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  messageType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pfnUserCallback: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pUserData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDebugUtilsMessengerCallbackDataEXT **/
function VkDebugUtilsMessengerCallbackDataEXT(opts, byteOffset) {
  if (new.target !== VkDebugUtilsMessengerCallbackDataEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDebugUtilsMessengerCallbackDataEXT, STRUCT_CACHE_VkDebugUtilsMessengerCallbackDataEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDebugUtilsMessengerCallbackDataEXT, STRUCT_CACHE_VkDebugUtilsMessengerCallbackDataEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDebugUtilsMessengerCallbackDataEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pMessageIdName = null;
  
  this._pMessage = null;
  
  this._pQueueLabels = null;
  this._pQueueLabelsNative = null;
  
  this._pCmdBufLabels = null;
  this._pCmdBufLabelsNative = null;
  
  this._pObjects = null;
  this._pObjectsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pMessageIdName !== void 0) this.pMessageIdName = opts.pMessageIdName;
    if (opts.messageIdNumber !== void 0) this.messageIdNumber = opts.messageIdNumber;
    if (opts.pMessage !== void 0) this.pMessage = opts.pMessage;
    if (opts.queueLabelCount !== void 0) this.queueLabelCount = opts.queueLabelCount;
    if (opts.pQueueLabels !== void 0) this.pQueueLabels = opts.pQueueLabels;
    if (opts.cmdBufLabelCount !== void 0) this.cmdBufLabelCount = opts.cmdBufLabelCount;
    if (opts.pCmdBufLabels !== void 0) this.pCmdBufLabels = opts.pCmdBufLabels;
    if (opts.objectCount !== void 0) this.objectCount = opts.objectCount;
    if (opts.pObjects !== void 0) this.pObjects = opts.pObjects;
    
  }
};

Object.defineProperties(VkDebugUtilsMessengerCallbackDataEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsMessengerCallbackDataEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDebugUtilsMessengerCallbackDataEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsMessengerCallbackDataEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pMessageIdName": {
    get() {
    if (this._pMessageIdName !== null) {
      let str = textDecoder.decode(this._pMessageIdName);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._pMessageIdName = buffer;
        return this.pMessageIdName;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pMessageIdName = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._pMessageIdName), true);
    } else if (value === null) {
      this._pMessageIdName = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkDebugUtilsMessengerCallbackDataEXT.pMessageIdName");
    }
    
    }
    },
  "messageIdNumber": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsMessengerCallbackDataEXT.messageIdNumber");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pMessage": {
    get() {
    if (this._pMessage !== null) {
      let str = textDecoder.decode(this._pMessage);
      return str.substr(0, str.length - 1);
    } else {
      // native memory contains a string which we didn't reflect yet
      if (this.memoryView.getBigInt64(0x0, true) !== BI0) {
        let addr = this.memoryView.getBigInt64(0x0, true);
        let length = findNullTerminatedUTF8StringLength(addr);
        let buffer = getArrayBufferFromAddress(addr, BigInt(length));
        this._pMessage = buffer;
        return this.pMessage;
      }
      return null;
    }
    },
    set(value) {
    if (value !== null && value.constructor === String) {
      this._pMessage = textEncoder.encode(value + NULLT).buffer;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(this._pMessage), true);
    } else if (value === null) {
      this._pMessage = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      ASSERT_IS_STRING(value, "VkDebugUtilsMessengerCallbackDataEXT.pMessage");
    }
    
    }
    },
  "queueLabelCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsMessengerCallbackDataEXT.queueLabelCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pQueueLabels": {
    get() {
    if (this._pQueueLabels === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.queueLabelCount, VkDebugUtilsLabelEXT);
      this._pQueueLabels = array;
      return this.pQueueLabels;
    } else {
      return this._pQueueLabels;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pQueueLabels = value;
    } else if (value === null) {
      this._pQueueLabels = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels': Expected 'Array VkDebugUtilsLabelEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "cmdBufLabelCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsMessengerCallbackDataEXT.cmdBufLabelCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCmdBufLabels": {
    get() {
    if (this._pCmdBufLabels === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.cmdBufLabelCount, VkDebugUtilsLabelEXT);
      this._pCmdBufLabels = array;
      return this.pCmdBufLabels;
    } else {
      return this._pCmdBufLabels;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pCmdBufLabels = value;
    } else if (value === null) {
      this._pCmdBufLabels = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels': Expected 'Array VkDebugUtilsLabelEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "objectCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDebugUtilsMessengerCallbackDataEXT.objectCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pObjects": {
    get() {
    if (this._pObjects === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.objectCount, VkDebugUtilsObjectNameInfoEXT);
      this._pObjects = array;
      return this.pObjects;
    } else {
      return this._pObjects;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pObjects = value;
    } else if (value === null) {
      this._pObjects = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects': Expected 'Array VkDebugUtilsObjectNameInfoEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkDebugUtilsMessengerCallbackDataEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pMessageIdName = null;
  
  this._pMessage = null;
  
  this._pQueueLabels = null;
  this._pQueueLabelsNative = null;
  
  this._pCmdBufLabels = null;
  this._pCmdBufLabelsNative = null;
  
  this._pObjects = null;
  this._pObjectsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pMessageIdName !== void 0) this.pMessageIdName = opts.pMessageIdName;
    if (opts.messageIdNumber !== void 0) this.messageIdNumber = opts.messageIdNumber;
    if (opts.pMessage !== void 0) this.pMessage = opts.pMessage;
    if (opts.queueLabelCount !== void 0) this.queueLabelCount = opts.queueLabelCount;
    if (opts.pQueueLabels !== void 0) this.pQueueLabels = opts.pQueueLabels;
    if (opts.cmdBufLabelCount !== void 0) this.cmdBufLabelCount = opts.cmdBufLabelCount;
    if (opts.pCmdBufLabels !== void 0) this.pCmdBufLabels = opts.pCmdBufLabels;
    if (opts.objectCount !== void 0) this.objectCount = opts.objectCount;
    if (opts.pObjects !== void 0) this.pObjects = opts.pObjects;
    
  }
};

VkDebugUtilsMessengerCallbackDataEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pQueueLabels !== null) {
    let array = this._pQueueLabels;
    
    if (array.length !== this.queueLabelCount) {
      throw new RangeError("Invalid array length, expected length of 'queueLabelCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDebugUtilsLabelEXT)) {
        throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels[" + ii + "]': Expected 'VkDebugUtilsLabelEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pQueueLabelsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pQueueLabelsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pCmdBufLabels !== null) {
    let array = this._pCmdBufLabels;
    
    if (array.length !== this.cmdBufLabelCount) {
      throw new RangeError("Invalid array length, expected length of 'cmdBufLabelCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDebugUtilsLabelEXT)) {
        throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels[" + ii + "]': Expected 'VkDebugUtilsLabelEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pCmdBufLabelsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pCmdBufLabelsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pObjects !== null) {
    let array = this._pObjects;
    
    if (array.length !== this.objectCount) {
      throw new RangeError("Invalid array length, expected length of 'objectCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkDebugUtilsObjectNameInfoEXT)) {
        throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects[" + ii + "]': Expected 'VkDebugUtilsObjectNameInfoEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pObjectsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pObjectsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkDebugUtilsMessengerCallbackDataEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDebugUtilsMessengerCallbackDataEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDebugUtilsMessengerCallbackDataEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.pMessageIdName = original.pMessageIdName;
  copy.messageIdNumber = original.messageIdNumber;
  copy.pMessage = original.pMessage;
  copy.queueLabelCount = original.queueLabelCount;
  if (original.pQueueLabels !== null) {
        copy.pQueueLabels = [...Array(original.pQueueLabels.length)].map((v, i) => {
          return original.pQueueLabels[i].constructor.createCopyFrom(original.pQueueLabels[i]);
        });
      }
  copy.cmdBufLabelCount = original.cmdBufLabelCount;
  if (original.pCmdBufLabels !== null) {
        copy.pCmdBufLabels = [...Array(original.pCmdBufLabels.length)].map((v, i) => {
          return original.pCmdBufLabels[i].constructor.createCopyFrom(original.pCmdBufLabels[i]);
        });
      }
  copy.objectCount = original.objectCount;
  if (original.pObjects !== null) {
        copy.pObjects = [...Array(original.pObjects.length)].map((v, i) => {
          return original.pObjects[i].constructor.createCopyFrom(original.pObjects[i]);
        });
      }
  
  return copy;
};

VkDebugUtilsMessengerCallbackDataEXT.byteLength = 0x0;

VkDebugUtilsMessengerCallbackDataEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pMessageIdName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  messageIdNumber: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pMessage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueLabelCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pQueueLabels: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  cmdBufLabelCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCmdBufLabels: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  objectCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pObjects: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDeviceMemoryReportFeaturesEXT **/
function VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDeviceMemoryReportFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDeviceMemoryReportFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMemoryReport !== void 0) this.deviceMemoryReport = opts.deviceMemoryReport;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "deviceMemoryReport": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceMemoryReport !== void 0) this.deviceMemoryReport = opts.deviceMemoryReport;
    
  }
};

VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDeviceMemoryReportFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceMemoryReport = original.deviceMemoryReport;
  
  return copy;
};

VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceMemoryReport: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceDeviceMemoryReportCreateInfoEXT **/
function VkDeviceDeviceMemoryReportCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkDeviceDeviceMemoryReportCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceDeviceMemoryReportCreateInfoEXT, STRUCT_CACHE_VkDeviceDeviceMemoryReportCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceDeviceMemoryReportCreateInfoEXT, STRUCT_CACHE_VkDeviceDeviceMemoryReportCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceDeviceMemoryReportCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pfnUserCallback = null;this._pfnUserCallbackCallbackProxy = null;
  this._pUserData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pfnUserCallback !== void 0) this.pfnUserCallback = opts.pfnUserCallback;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

Object.defineProperties(VkDeviceDeviceMemoryReportCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceDeviceMemoryReportCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceDeviceMemoryReportCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceDeviceMemoryReportCreateInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pfnUserCallback": {
    get() {
    return this._pfnUserCallback;
    },
    set(value) {
    if (value !== null && value.constructor === Function) {
      let MITM = function() {
        for (let ii = 0; ii < arguments.length; ++ii) {
          let arg = arguments[ii];
          if (arg instanceof Object && arg.constructor.createCopyFrom instanceof Function) {
            let copy = arg.constructor.createCopyFrom(arg);
            arguments[ii] = copy;
          }
        };
        return value.apply(this, arguments);
      }.bind(this);
      this._pfnUserCallback = value;
      this._pfnUserCallbackCallbackProxy = new nvk.$CallbackProxy(MITM, module.exports);
      this.memoryView.setBigInt64(0x0, nvk.$vulkanCallbackFunctionPointers["vkDeviceMemoryReportCallbackEXT"], true);
      this.memoryView.setBigInt64(0x0, this._pfnUserCallbackCallbackProxy.getAddress(), true);
    } else if (value === null) {
      this._pfnUserCallback = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceDeviceMemoryReportCreateInfoEXT.pfnUserCallback': Expected 'Function' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pUserData": {
    get() {
    return this._pUserData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceDeviceMemoryReportCreateInfoEXT.pUserData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceDeviceMemoryReportCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pfnUserCallback = null;
  this._pUserData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pfnUserCallback !== void 0) this.pfnUserCallback = opts.pfnUserCallback;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

VkDeviceDeviceMemoryReportCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceDeviceMemoryReportCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceDeviceMemoryReportCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceDeviceMemoryReportCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.pfnUserCallback = original.pfnUserCallback;
  if (original.pUserData !== null) {
      let buf = new ArrayBuffer(original.pUserData.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pUserData), 0x0);
      copy.pUserData = buf;
    }
  
  return copy;
};

VkDeviceDeviceMemoryReportCreateInfoEXT.byteLength = 0x0;

VkDeviceDeviceMemoryReportCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pfnUserCallback: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pUserData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceMemoryReportCallbackDataEXT **/
function VkDeviceMemoryReportCallbackDataEXT(opts, byteOffset) {
  if (new.target !== VkDeviceMemoryReportCallbackDataEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceMemoryReportCallbackDataEXT, STRUCT_CACHE_VkDeviceMemoryReportCallbackDataEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceMemoryReportCallbackDataEXT, STRUCT_CACHE_VkDeviceMemoryReportCallbackDataEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceMemoryReportCallbackDataEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDeviceMemoryReportCallbackDataEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceMemoryReportCallbackDataEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceMemoryReportCallbackDataEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "memoryObjectId": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "objectType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "objectHandle": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "heapIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkDeviceMemoryReportCallbackDataEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDeviceMemoryReportCallbackDataEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceMemoryReportCallbackDataEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDeviceMemoryReportCallbackDataEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceMemoryReportCallbackDataEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.type = original.type;
  copy.memoryObjectId = original.memoryObjectId;
  copy.size = original.size;
  copy.objectType = original.objectType;
  copy.objectHandle = original.objectHandle;
  copy.heapIndex = original.heapIndex;
  
  return copy;
};

VkDeviceMemoryReportCallbackDataEXT.byteLength = 0x0;

VkDeviceMemoryReportCallbackDataEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryObjectId: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  objectType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  objectHandle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  heapIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImportMemoryHostPointerInfoEXT **/
function VkImportMemoryHostPointerInfoEXT(opts, byteOffset) {
  if (new.target !== VkImportMemoryHostPointerInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImportMemoryHostPointerInfoEXT, STRUCT_CACHE_VkImportMemoryHostPointerInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImportMemoryHostPointerInfoEXT, STRUCT_CACHE_VkImportMemoryHostPointerInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImportMemoryHostPointerInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pHostPointer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.pHostPointer !== void 0) this.pHostPointer = opts.pHostPointer;
    
  }
};

Object.defineProperties(VkImportMemoryHostPointerInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportMemoryHostPointerInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImportMemoryHostPointerInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "handleType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImportMemoryHostPointerInfoEXT.handleType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pHostPointer": {
    get() {
    return this._pHostPointer;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pHostPointer = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pHostPointer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImportMemoryHostPointerInfoEXT.pHostPointer': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImportMemoryHostPointerInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pHostPointer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.handleType !== void 0) this.handleType = opts.handleType;
    if (opts.pHostPointer !== void 0) this.pHostPointer = opts.pHostPointer;
    
  }
};

VkImportMemoryHostPointerInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportMemoryHostPointerInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkImportMemoryHostPointerInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImportMemoryHostPointerInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.handleType = original.handleType;
  if (original.pHostPointer !== null) {
      let buf = new ArrayBuffer(original.pHostPointer.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pHostPointer), 0x0);
      copy.pHostPointer = buf;
    }
  
  return copy;
};

VkImportMemoryHostPointerInfoEXT.byteLength = 0x0;

VkImportMemoryHostPointerInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  handleType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pHostPointer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryHostPointerPropertiesEXT **/
function VkMemoryHostPointerPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkMemoryHostPointerPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryHostPointerPropertiesEXT, STRUCT_CACHE_VkMemoryHostPointerPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryHostPointerPropertiesEXT, STRUCT_CACHE_VkMemoryHostPointerPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryHostPointerPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkMemoryHostPointerPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryHostPointerPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryHostPointerPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "memoryTypeBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkMemoryHostPointerPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkMemoryHostPointerPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryHostPointerPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkMemoryHostPointerPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryHostPointerPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.memoryTypeBits = original.memoryTypeBits;
  
  return copy;
};

VkMemoryHostPointerPropertiesEXT.byteLength = 0x0;

VkMemoryHostPointerPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryTypeBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExternalMemoryHostPropertiesEXT **/
function VkPhysicalDeviceExternalMemoryHostPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExternalMemoryHostPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceExternalMemoryHostPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceExternalMemoryHostPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExternalMemoryHostPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExternalMemoryHostPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExternalMemoryHostPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "minImportedHostPointerAlignment": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExternalMemoryHostPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.minImportedHostPointerAlignment = original.minImportedHostPointerAlignment;
  
  return copy;
};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minImportedHostPointerAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceConservativeRasterizationPropertiesEXT **/
function VkPhysicalDeviceConservativeRasterizationPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceConservativeRasterizationPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceConservativeRasterizationPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceConservativeRasterizationPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceConservativeRasterizationPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceConservativeRasterizationPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceConservativeRasterizationPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "primitiveOverestimationSize": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    },
  "maxExtraPrimitiveOverestimationSize": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    },
  "extraPrimitiveOverestimationSizeGranularity": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    },
  "primitiveUnderestimation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "conservativePointAndLineRasterization": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "degenerateTrianglesRasterized": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "degenerateLinesRasterized": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "fullyCoveredFragmentShaderInputVariable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "conservativeRasterizationPostDepthCoverage": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceConservativeRasterizationPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.primitiveOverestimationSize = original.primitiveOverestimationSize;
  copy.maxExtraPrimitiveOverestimationSize = original.maxExtraPrimitiveOverestimationSize;
  copy.extraPrimitiveOverestimationSizeGranularity = original.extraPrimitiveOverestimationSizeGranularity;
  copy.primitiveUnderestimation = original.primitiveUnderestimation;
  copy.conservativePointAndLineRasterization = original.conservativePointAndLineRasterization;
  copy.degenerateTrianglesRasterized = original.degenerateTrianglesRasterized;
  copy.degenerateLinesRasterized = original.degenerateLinesRasterized;
  copy.fullyCoveredFragmentShaderInputVariable = original.fullyCoveredFragmentShaderInputVariable;
  copy.conservativeRasterizationPostDepthCoverage = original.conservativeRasterizationPostDepthCoverage;
  
  return copy;
};

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  primitiveOverestimationSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxExtraPrimitiveOverestimationSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extraPrimitiveOverestimationSizeGranularity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  primitiveUnderestimation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  conservativePointAndLineRasterization: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  degenerateTrianglesRasterized: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  degenerateLinesRasterized: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fullyCoveredFragmentShaderInputVariable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  conservativeRasterizationPostDepthCoverage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCalibratedTimestampInfoEXT **/
function VkCalibratedTimestampInfoEXT(opts, byteOffset) {
  if (new.target !== VkCalibratedTimestampInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCalibratedTimestampInfoEXT, STRUCT_CACHE_VkCalibratedTimestampInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCalibratedTimestampInfoEXT, STRUCT_CACHE_VkCalibratedTimestampInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCalibratedTimestampInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.timeDomain !== void 0) this.timeDomain = opts.timeDomain;
    
  }
};

Object.defineProperties(VkCalibratedTimestampInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCalibratedTimestampInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCalibratedTimestampInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "timeDomain": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCalibratedTimestampInfoEXT.timeDomain");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkCalibratedTimestampInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.timeDomain !== void 0) this.timeDomain = opts.timeDomain;
    
  }
};

VkCalibratedTimestampInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCalibratedTimestampInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkCalibratedTimestampInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCalibratedTimestampInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.timeDomain = original.timeDomain;
  
  return copy;
};

VkCalibratedTimestampInfoEXT.byteLength = 0x0;

VkCalibratedTimestampInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  timeDomain: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderCorePropertiesAMD **/
function VkPhysicalDeviceShaderCorePropertiesAMD(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderCorePropertiesAMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderCorePropertiesAMD, STRUCT_CACHE_VkPhysicalDeviceShaderCorePropertiesAMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderCorePropertiesAMD, STRUCT_CACHE_VkPhysicalDeviceShaderCorePropertiesAMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderCorePropertiesAMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderCorePropertiesAMD.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderCorePropertiesAMD.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderCorePropertiesAMD.pNext' isn't allowed to be filled");
    }
    },
  "shaderEngineCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "shaderArraysPerEngineCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "computeUnitsPerShaderArray": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "simdPerComputeUnit": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "wavefrontsPerSimd": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "wavefrontSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "sgprsPerSimd": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "minSgprAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxSgprAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "sgprAllocationGranularity": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "vgprsPerSimd": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "minVgprAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxVgprAllocation": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "vgprAllocationGranularity": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceShaderCorePropertiesAMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceShaderCorePropertiesAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderCorePropertiesAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceShaderCorePropertiesAMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderCorePropertiesAMD();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderEngineCount = original.shaderEngineCount;
  copy.shaderArraysPerEngineCount = original.shaderArraysPerEngineCount;
  copy.computeUnitsPerShaderArray = original.computeUnitsPerShaderArray;
  copy.simdPerComputeUnit = original.simdPerComputeUnit;
  copy.wavefrontsPerSimd = original.wavefrontsPerSimd;
  copy.wavefrontSize = original.wavefrontSize;
  copy.sgprsPerSimd = original.sgprsPerSimd;
  copy.minSgprAllocation = original.minSgprAllocation;
  copy.maxSgprAllocation = original.maxSgprAllocation;
  copy.sgprAllocationGranularity = original.sgprAllocationGranularity;
  copy.vgprsPerSimd = original.vgprsPerSimd;
  copy.minVgprAllocation = original.minVgprAllocation;
  copy.maxVgprAllocation = original.maxVgprAllocation;
  copy.vgprAllocationGranularity = original.vgprAllocationGranularity;
  
  return copy;
};

VkPhysicalDeviceShaderCorePropertiesAMD.byteLength = 0x0;

VkPhysicalDeviceShaderCorePropertiesAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderEngineCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderArraysPerEngineCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  computeUnitsPerShaderArray: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  simdPerComputeUnit: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  wavefrontsPerSimd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  wavefrontSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sgprsPerSimd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minSgprAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSgprAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sgprAllocationGranularity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vgprsPerSimd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minVgprAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxVgprAllocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vgprAllocationGranularity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderCoreProperties2AMD **/
function VkPhysicalDeviceShaderCoreProperties2AMD(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderCoreProperties2AMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderCoreProperties2AMD, STRUCT_CACHE_VkPhysicalDeviceShaderCoreProperties2AMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderCoreProperties2AMD, STRUCT_CACHE_VkPhysicalDeviceShaderCoreProperties2AMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderCoreProperties2AMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderCoreProperties2AMD.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderCoreProperties2AMD.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderCoreProperties2AMD.pNext' isn't allowed to be filled");
    }
    },
  "shaderCoreFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "activeComputeUnitCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceShaderCoreProperties2AMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceShaderCoreProperties2AMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderCoreProperties2AMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceShaderCoreProperties2AMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderCoreProperties2AMD();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderCoreFeatures = original.shaderCoreFeatures;
  copy.activeComputeUnitCount = original.activeComputeUnitCount;
  
  return copy;
};

VkPhysicalDeviceShaderCoreProperties2AMD.byteLength = 0x0;

VkPhysicalDeviceShaderCoreProperties2AMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderCoreFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  activeComputeUnitCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineRasterizationConservativeStateCreateInfoEXT **/
function VkPipelineRasterizationConservativeStateCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPipelineRasterizationConservativeStateCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineRasterizationConservativeStateCreateInfoEXT, STRUCT_CACHE_VkPipelineRasterizationConservativeStateCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineRasterizationConservativeStateCreateInfoEXT, STRUCT_CACHE_VkPipelineRasterizationConservativeStateCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineRasterizationConservativeStateCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.conservativeRasterizationMode !== void 0) this.conservativeRasterizationMode = opts.conservativeRasterizationMode;
    if (opts.extraPrimitiveOverestimationSize !== void 0) this.extraPrimitiveOverestimationSize = opts.extraPrimitiveOverestimationSize;
    
  }
};

Object.defineProperties(VkPipelineRasterizationConservativeStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRasterizationConservativeStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "conservativeRasterizationMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.conservativeRasterizationMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "extraPrimitiveOverestimationSize": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.extraPrimitiveOverestimationSize");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkPipelineRasterizationConservativeStateCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.conservativeRasterizationMode !== void 0) this.conservativeRasterizationMode = opts.conservativeRasterizationMode;
    if (opts.extraPrimitiveOverestimationSize !== void 0) this.extraPrimitiveOverestimationSize = opts.extraPrimitiveOverestimationSize;
    
  }
};

VkPipelineRasterizationConservativeStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationConservativeStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineRasterizationConservativeStateCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineRasterizationConservativeStateCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.conservativeRasterizationMode = original.conservativeRasterizationMode;
  copy.extraPrimitiveOverestimationSize = original.extraPrimitiveOverestimationSize;
  
  return copy;
};

VkPipelineRasterizationConservativeStateCreateInfoEXT.byteLength = 0x0;

VkPipelineRasterizationConservativeStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  conservativeRasterizationMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extraPrimitiveOverestimationSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDescriptorIndexingFeatures **/
function VkPhysicalDeviceDescriptorIndexingFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDescriptorIndexingFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDescriptorIndexingFeatures, STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDescriptorIndexingFeatures, STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDescriptorIndexingFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderInputAttachmentArrayDynamicIndexing !== void 0) this.shaderInputAttachmentArrayDynamicIndexing = opts.shaderInputAttachmentArrayDynamicIndexing;
    if (opts.shaderUniformTexelBufferArrayDynamicIndexing !== void 0) this.shaderUniformTexelBufferArrayDynamicIndexing = opts.shaderUniformTexelBufferArrayDynamicIndexing;
    if (opts.shaderStorageTexelBufferArrayDynamicIndexing !== void 0) this.shaderStorageTexelBufferArrayDynamicIndexing = opts.shaderStorageTexelBufferArrayDynamicIndexing;
    if (opts.shaderUniformBufferArrayNonUniformIndexing !== void 0) this.shaderUniformBufferArrayNonUniformIndexing = opts.shaderUniformBufferArrayNonUniformIndexing;
    if (opts.shaderSampledImageArrayNonUniformIndexing !== void 0) this.shaderSampledImageArrayNonUniformIndexing = opts.shaderSampledImageArrayNonUniformIndexing;
    if (opts.shaderStorageBufferArrayNonUniformIndexing !== void 0) this.shaderStorageBufferArrayNonUniformIndexing = opts.shaderStorageBufferArrayNonUniformIndexing;
    if (opts.shaderStorageImageArrayNonUniformIndexing !== void 0) this.shaderStorageImageArrayNonUniformIndexing = opts.shaderStorageImageArrayNonUniformIndexing;
    if (opts.shaderInputAttachmentArrayNonUniformIndexing !== void 0) this.shaderInputAttachmentArrayNonUniformIndexing = opts.shaderInputAttachmentArrayNonUniformIndexing;
    if (opts.shaderUniformTexelBufferArrayNonUniformIndexing !== void 0) this.shaderUniformTexelBufferArrayNonUniformIndexing = opts.shaderUniformTexelBufferArrayNonUniformIndexing;
    if (opts.shaderStorageTexelBufferArrayNonUniformIndexing !== void 0) this.shaderStorageTexelBufferArrayNonUniformIndexing = opts.shaderStorageTexelBufferArrayNonUniformIndexing;
    if (opts.descriptorBindingUniformBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformBufferUpdateAfterBind = opts.descriptorBindingUniformBufferUpdateAfterBind;
    if (opts.descriptorBindingSampledImageUpdateAfterBind !== void 0) this.descriptorBindingSampledImageUpdateAfterBind = opts.descriptorBindingSampledImageUpdateAfterBind;
    if (opts.descriptorBindingStorageImageUpdateAfterBind !== void 0) this.descriptorBindingStorageImageUpdateAfterBind = opts.descriptorBindingStorageImageUpdateAfterBind;
    if (opts.descriptorBindingStorageBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageBufferUpdateAfterBind = opts.descriptorBindingStorageBufferUpdateAfterBind;
    if (opts.descriptorBindingUniformTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformTexelBufferUpdateAfterBind = opts.descriptorBindingUniformTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingStorageTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageTexelBufferUpdateAfterBind = opts.descriptorBindingStorageTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingUpdateUnusedWhilePending !== void 0) this.descriptorBindingUpdateUnusedWhilePending = opts.descriptorBindingUpdateUnusedWhilePending;
    if (opts.descriptorBindingPartiallyBound !== void 0) this.descriptorBindingPartiallyBound = opts.descriptorBindingPartiallyBound;
    if (opts.descriptorBindingVariableDescriptorCount !== void 0) this.descriptorBindingVariableDescriptorCount = opts.descriptorBindingVariableDescriptorCount;
    if (opts.runtimeDescriptorArray !== void 0) this.runtimeDescriptorArray = opts.runtimeDescriptorArray;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDescriptorIndexingFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDescriptorIndexingFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDescriptorIndexingFeatures.pNext' isn't allowed to be filled");
    }
    },
  "shaderInputAttachmentArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderUniformTexelBufferArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageTexelBufferArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderUniformBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSampledImageArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageImageArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderInputAttachmentArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderUniformTexelBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageTexelBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingUniformBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingSampledImageUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingStorageImageUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingStorageBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingUniformTexelBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingStorageTexelBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingUpdateUnusedWhilePending": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingPartiallyBound": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingVariableDescriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "runtimeDescriptorArray": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceDescriptorIndexingFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderInputAttachmentArrayDynamicIndexing !== void 0) this.shaderInputAttachmentArrayDynamicIndexing = opts.shaderInputAttachmentArrayDynamicIndexing;
    if (opts.shaderUniformTexelBufferArrayDynamicIndexing !== void 0) this.shaderUniformTexelBufferArrayDynamicIndexing = opts.shaderUniformTexelBufferArrayDynamicIndexing;
    if (opts.shaderStorageTexelBufferArrayDynamicIndexing !== void 0) this.shaderStorageTexelBufferArrayDynamicIndexing = opts.shaderStorageTexelBufferArrayDynamicIndexing;
    if (opts.shaderUniformBufferArrayNonUniformIndexing !== void 0) this.shaderUniformBufferArrayNonUniformIndexing = opts.shaderUniformBufferArrayNonUniformIndexing;
    if (opts.shaderSampledImageArrayNonUniformIndexing !== void 0) this.shaderSampledImageArrayNonUniformIndexing = opts.shaderSampledImageArrayNonUniformIndexing;
    if (opts.shaderStorageBufferArrayNonUniformIndexing !== void 0) this.shaderStorageBufferArrayNonUniformIndexing = opts.shaderStorageBufferArrayNonUniformIndexing;
    if (opts.shaderStorageImageArrayNonUniformIndexing !== void 0) this.shaderStorageImageArrayNonUniformIndexing = opts.shaderStorageImageArrayNonUniformIndexing;
    if (opts.shaderInputAttachmentArrayNonUniformIndexing !== void 0) this.shaderInputAttachmentArrayNonUniformIndexing = opts.shaderInputAttachmentArrayNonUniformIndexing;
    if (opts.shaderUniformTexelBufferArrayNonUniformIndexing !== void 0) this.shaderUniformTexelBufferArrayNonUniformIndexing = opts.shaderUniformTexelBufferArrayNonUniformIndexing;
    if (opts.shaderStorageTexelBufferArrayNonUniformIndexing !== void 0) this.shaderStorageTexelBufferArrayNonUniformIndexing = opts.shaderStorageTexelBufferArrayNonUniformIndexing;
    if (opts.descriptorBindingUniformBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformBufferUpdateAfterBind = opts.descriptorBindingUniformBufferUpdateAfterBind;
    if (opts.descriptorBindingSampledImageUpdateAfterBind !== void 0) this.descriptorBindingSampledImageUpdateAfterBind = opts.descriptorBindingSampledImageUpdateAfterBind;
    if (opts.descriptorBindingStorageImageUpdateAfterBind !== void 0) this.descriptorBindingStorageImageUpdateAfterBind = opts.descriptorBindingStorageImageUpdateAfterBind;
    if (opts.descriptorBindingStorageBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageBufferUpdateAfterBind = opts.descriptorBindingStorageBufferUpdateAfterBind;
    if (opts.descriptorBindingUniformTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformTexelBufferUpdateAfterBind = opts.descriptorBindingUniformTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingStorageTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageTexelBufferUpdateAfterBind = opts.descriptorBindingStorageTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingUpdateUnusedWhilePending !== void 0) this.descriptorBindingUpdateUnusedWhilePending = opts.descriptorBindingUpdateUnusedWhilePending;
    if (opts.descriptorBindingPartiallyBound !== void 0) this.descriptorBindingPartiallyBound = opts.descriptorBindingPartiallyBound;
    if (opts.descriptorBindingVariableDescriptorCount !== void 0) this.descriptorBindingVariableDescriptorCount = opts.descriptorBindingVariableDescriptorCount;
    if (opts.runtimeDescriptorArray !== void 0) this.runtimeDescriptorArray = opts.runtimeDescriptorArray;
    
  }
};

VkPhysicalDeviceDescriptorIndexingFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDescriptorIndexingFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceDescriptorIndexingFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDescriptorIndexingFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderInputAttachmentArrayDynamicIndexing = original.shaderInputAttachmentArrayDynamicIndexing;
  copy.shaderUniformTexelBufferArrayDynamicIndexing = original.shaderUniformTexelBufferArrayDynamicIndexing;
  copy.shaderStorageTexelBufferArrayDynamicIndexing = original.shaderStorageTexelBufferArrayDynamicIndexing;
  copy.shaderUniformBufferArrayNonUniformIndexing = original.shaderUniformBufferArrayNonUniformIndexing;
  copy.shaderSampledImageArrayNonUniformIndexing = original.shaderSampledImageArrayNonUniformIndexing;
  copy.shaderStorageBufferArrayNonUniformIndexing = original.shaderStorageBufferArrayNonUniformIndexing;
  copy.shaderStorageImageArrayNonUniformIndexing = original.shaderStorageImageArrayNonUniformIndexing;
  copy.shaderInputAttachmentArrayNonUniformIndexing = original.shaderInputAttachmentArrayNonUniformIndexing;
  copy.shaderUniformTexelBufferArrayNonUniformIndexing = original.shaderUniformTexelBufferArrayNonUniformIndexing;
  copy.shaderStorageTexelBufferArrayNonUniformIndexing = original.shaderStorageTexelBufferArrayNonUniformIndexing;
  copy.descriptorBindingUniformBufferUpdateAfterBind = original.descriptorBindingUniformBufferUpdateAfterBind;
  copy.descriptorBindingSampledImageUpdateAfterBind = original.descriptorBindingSampledImageUpdateAfterBind;
  copy.descriptorBindingStorageImageUpdateAfterBind = original.descriptorBindingStorageImageUpdateAfterBind;
  copy.descriptorBindingStorageBufferUpdateAfterBind = original.descriptorBindingStorageBufferUpdateAfterBind;
  copy.descriptorBindingUniformTexelBufferUpdateAfterBind = original.descriptorBindingUniformTexelBufferUpdateAfterBind;
  copy.descriptorBindingStorageTexelBufferUpdateAfterBind = original.descriptorBindingStorageTexelBufferUpdateAfterBind;
  copy.descriptorBindingUpdateUnusedWhilePending = original.descriptorBindingUpdateUnusedWhilePending;
  copy.descriptorBindingPartiallyBound = original.descriptorBindingPartiallyBound;
  copy.descriptorBindingVariableDescriptorCount = original.descriptorBindingVariableDescriptorCount;
  copy.runtimeDescriptorArray = original.runtimeDescriptorArray;
  
  return copy;
};

VkPhysicalDeviceDescriptorIndexingFeatures.byteLength = 0x0;

VkPhysicalDeviceDescriptorIndexingFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInputAttachmentArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformTexelBufferArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageTexelBufferArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSampledImageArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInputAttachmentArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformTexelBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageTexelBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingUniformBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingSampledImageUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingStorageImageUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingStorageBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingUniformTexelBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingStorageTexelBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingUpdateUnusedWhilePending: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingPartiallyBound: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingVariableDescriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  runtimeDescriptorArray: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDescriptorIndexingFeaturesEXT **/
function VkPhysicalDeviceDescriptorIndexingFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDescriptorIndexingFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDescriptorIndexingFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDescriptorIndexingFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDescriptorIndexingFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderInputAttachmentArrayDynamicIndexing !== void 0) this.shaderInputAttachmentArrayDynamicIndexing = opts.shaderInputAttachmentArrayDynamicIndexing;
    if (opts.shaderUniformTexelBufferArrayDynamicIndexing !== void 0) this.shaderUniformTexelBufferArrayDynamicIndexing = opts.shaderUniformTexelBufferArrayDynamicIndexing;
    if (opts.shaderStorageTexelBufferArrayDynamicIndexing !== void 0) this.shaderStorageTexelBufferArrayDynamicIndexing = opts.shaderStorageTexelBufferArrayDynamicIndexing;
    if (opts.shaderUniformBufferArrayNonUniformIndexing !== void 0) this.shaderUniformBufferArrayNonUniformIndexing = opts.shaderUniformBufferArrayNonUniformIndexing;
    if (opts.shaderSampledImageArrayNonUniformIndexing !== void 0) this.shaderSampledImageArrayNonUniformIndexing = opts.shaderSampledImageArrayNonUniformIndexing;
    if (opts.shaderStorageBufferArrayNonUniformIndexing !== void 0) this.shaderStorageBufferArrayNonUniformIndexing = opts.shaderStorageBufferArrayNonUniformIndexing;
    if (opts.shaderStorageImageArrayNonUniformIndexing !== void 0) this.shaderStorageImageArrayNonUniformIndexing = opts.shaderStorageImageArrayNonUniformIndexing;
    if (opts.shaderInputAttachmentArrayNonUniformIndexing !== void 0) this.shaderInputAttachmentArrayNonUniformIndexing = opts.shaderInputAttachmentArrayNonUniformIndexing;
    if (opts.shaderUniformTexelBufferArrayNonUniformIndexing !== void 0) this.shaderUniformTexelBufferArrayNonUniformIndexing = opts.shaderUniformTexelBufferArrayNonUniformIndexing;
    if (opts.shaderStorageTexelBufferArrayNonUniformIndexing !== void 0) this.shaderStorageTexelBufferArrayNonUniformIndexing = opts.shaderStorageTexelBufferArrayNonUniformIndexing;
    if (opts.descriptorBindingUniformBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformBufferUpdateAfterBind = opts.descriptorBindingUniformBufferUpdateAfterBind;
    if (opts.descriptorBindingSampledImageUpdateAfterBind !== void 0) this.descriptorBindingSampledImageUpdateAfterBind = opts.descriptorBindingSampledImageUpdateAfterBind;
    if (opts.descriptorBindingStorageImageUpdateAfterBind !== void 0) this.descriptorBindingStorageImageUpdateAfterBind = opts.descriptorBindingStorageImageUpdateAfterBind;
    if (opts.descriptorBindingStorageBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageBufferUpdateAfterBind = opts.descriptorBindingStorageBufferUpdateAfterBind;
    if (opts.descriptorBindingUniformTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformTexelBufferUpdateAfterBind = opts.descriptorBindingUniformTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingStorageTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageTexelBufferUpdateAfterBind = opts.descriptorBindingStorageTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingUpdateUnusedWhilePending !== void 0) this.descriptorBindingUpdateUnusedWhilePending = opts.descriptorBindingUpdateUnusedWhilePending;
    if (opts.descriptorBindingPartiallyBound !== void 0) this.descriptorBindingPartiallyBound = opts.descriptorBindingPartiallyBound;
    if (opts.descriptorBindingVariableDescriptorCount !== void 0) this.descriptorBindingVariableDescriptorCount = opts.descriptorBindingVariableDescriptorCount;
    if (opts.runtimeDescriptorArray !== void 0) this.runtimeDescriptorArray = opts.runtimeDescriptorArray;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDescriptorIndexingFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDescriptorIndexingFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "shaderInputAttachmentArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderUniformTexelBufferArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageTexelBufferArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderUniformBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSampledImageArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageImageArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderInputAttachmentArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderUniformTexelBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageTexelBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingUniformBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingSampledImageUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingStorageImageUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingStorageBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingUniformTexelBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingStorageTexelBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingUpdateUnusedWhilePending": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingPartiallyBound": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingVariableDescriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "runtimeDescriptorArray": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderInputAttachmentArrayDynamicIndexing !== void 0) this.shaderInputAttachmentArrayDynamicIndexing = opts.shaderInputAttachmentArrayDynamicIndexing;
    if (opts.shaderUniformTexelBufferArrayDynamicIndexing !== void 0) this.shaderUniformTexelBufferArrayDynamicIndexing = opts.shaderUniformTexelBufferArrayDynamicIndexing;
    if (opts.shaderStorageTexelBufferArrayDynamicIndexing !== void 0) this.shaderStorageTexelBufferArrayDynamicIndexing = opts.shaderStorageTexelBufferArrayDynamicIndexing;
    if (opts.shaderUniformBufferArrayNonUniformIndexing !== void 0) this.shaderUniformBufferArrayNonUniformIndexing = opts.shaderUniformBufferArrayNonUniformIndexing;
    if (opts.shaderSampledImageArrayNonUniformIndexing !== void 0) this.shaderSampledImageArrayNonUniformIndexing = opts.shaderSampledImageArrayNonUniformIndexing;
    if (opts.shaderStorageBufferArrayNonUniformIndexing !== void 0) this.shaderStorageBufferArrayNonUniformIndexing = opts.shaderStorageBufferArrayNonUniformIndexing;
    if (opts.shaderStorageImageArrayNonUniformIndexing !== void 0) this.shaderStorageImageArrayNonUniformIndexing = opts.shaderStorageImageArrayNonUniformIndexing;
    if (opts.shaderInputAttachmentArrayNonUniformIndexing !== void 0) this.shaderInputAttachmentArrayNonUniformIndexing = opts.shaderInputAttachmentArrayNonUniformIndexing;
    if (opts.shaderUniformTexelBufferArrayNonUniformIndexing !== void 0) this.shaderUniformTexelBufferArrayNonUniformIndexing = opts.shaderUniformTexelBufferArrayNonUniformIndexing;
    if (opts.shaderStorageTexelBufferArrayNonUniformIndexing !== void 0) this.shaderStorageTexelBufferArrayNonUniformIndexing = opts.shaderStorageTexelBufferArrayNonUniformIndexing;
    if (opts.descriptorBindingUniformBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformBufferUpdateAfterBind = opts.descriptorBindingUniformBufferUpdateAfterBind;
    if (opts.descriptorBindingSampledImageUpdateAfterBind !== void 0) this.descriptorBindingSampledImageUpdateAfterBind = opts.descriptorBindingSampledImageUpdateAfterBind;
    if (opts.descriptorBindingStorageImageUpdateAfterBind !== void 0) this.descriptorBindingStorageImageUpdateAfterBind = opts.descriptorBindingStorageImageUpdateAfterBind;
    if (opts.descriptorBindingStorageBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageBufferUpdateAfterBind = opts.descriptorBindingStorageBufferUpdateAfterBind;
    if (opts.descriptorBindingUniformTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformTexelBufferUpdateAfterBind = opts.descriptorBindingUniformTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingStorageTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageTexelBufferUpdateAfterBind = opts.descriptorBindingStorageTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingUpdateUnusedWhilePending !== void 0) this.descriptorBindingUpdateUnusedWhilePending = opts.descriptorBindingUpdateUnusedWhilePending;
    if (opts.descriptorBindingPartiallyBound !== void 0) this.descriptorBindingPartiallyBound = opts.descriptorBindingPartiallyBound;
    if (opts.descriptorBindingVariableDescriptorCount !== void 0) this.descriptorBindingVariableDescriptorCount = opts.descriptorBindingVariableDescriptorCount;
    if (opts.runtimeDescriptorArray !== void 0) this.runtimeDescriptorArray = opts.runtimeDescriptorArray;
    
  }
};

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDescriptorIndexingFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderInputAttachmentArrayDynamicIndexing = original.shaderInputAttachmentArrayDynamicIndexing;
  copy.shaderUniformTexelBufferArrayDynamicIndexing = original.shaderUniformTexelBufferArrayDynamicIndexing;
  copy.shaderStorageTexelBufferArrayDynamicIndexing = original.shaderStorageTexelBufferArrayDynamicIndexing;
  copy.shaderUniformBufferArrayNonUniformIndexing = original.shaderUniformBufferArrayNonUniformIndexing;
  copy.shaderSampledImageArrayNonUniformIndexing = original.shaderSampledImageArrayNonUniformIndexing;
  copy.shaderStorageBufferArrayNonUniformIndexing = original.shaderStorageBufferArrayNonUniformIndexing;
  copy.shaderStorageImageArrayNonUniformIndexing = original.shaderStorageImageArrayNonUniformIndexing;
  copy.shaderInputAttachmentArrayNonUniformIndexing = original.shaderInputAttachmentArrayNonUniformIndexing;
  copy.shaderUniformTexelBufferArrayNonUniformIndexing = original.shaderUniformTexelBufferArrayNonUniformIndexing;
  copy.shaderStorageTexelBufferArrayNonUniformIndexing = original.shaderStorageTexelBufferArrayNonUniformIndexing;
  copy.descriptorBindingUniformBufferUpdateAfterBind = original.descriptorBindingUniformBufferUpdateAfterBind;
  copy.descriptorBindingSampledImageUpdateAfterBind = original.descriptorBindingSampledImageUpdateAfterBind;
  copy.descriptorBindingStorageImageUpdateAfterBind = original.descriptorBindingStorageImageUpdateAfterBind;
  copy.descriptorBindingStorageBufferUpdateAfterBind = original.descriptorBindingStorageBufferUpdateAfterBind;
  copy.descriptorBindingUniformTexelBufferUpdateAfterBind = original.descriptorBindingUniformTexelBufferUpdateAfterBind;
  copy.descriptorBindingStorageTexelBufferUpdateAfterBind = original.descriptorBindingStorageTexelBufferUpdateAfterBind;
  copy.descriptorBindingUpdateUnusedWhilePending = original.descriptorBindingUpdateUnusedWhilePending;
  copy.descriptorBindingPartiallyBound = original.descriptorBindingPartiallyBound;
  copy.descriptorBindingVariableDescriptorCount = original.descriptorBindingVariableDescriptorCount;
  copy.runtimeDescriptorArray = original.runtimeDescriptorArray;
  
  return copy;
};

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInputAttachmentArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformTexelBufferArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageTexelBufferArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSampledImageArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInputAttachmentArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformTexelBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageTexelBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingUniformBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingSampledImageUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingStorageImageUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingStorageBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingUniformTexelBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingStorageTexelBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingUpdateUnusedWhilePending: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingPartiallyBound: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingVariableDescriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  runtimeDescriptorArray: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDescriptorIndexingProperties **/
function VkPhysicalDeviceDescriptorIndexingProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDescriptorIndexingProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDescriptorIndexingProperties, STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDescriptorIndexingProperties, STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDescriptorIndexingProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDescriptorIndexingProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDescriptorIndexingProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDescriptorIndexingProperties.pNext' isn't allowed to be filled");
    }
    },
  "maxUpdateAfterBindDescriptorsInAllPools": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "shaderUniformBufferArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderSampledImageArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderStorageBufferArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderStorageImageArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderInputAttachmentArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "robustBufferAccessUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "quadDivergentImplicitLod": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "maxPerStageDescriptorUpdateAfterBindSamplers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindUniformBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindStorageBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindSampledImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindStorageImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindInputAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageUpdateAfterBindResources": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindSamplers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindUniformBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindSampledImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindInputAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceDescriptorIndexingProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceDescriptorIndexingProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDescriptorIndexingProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceDescriptorIndexingProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDescriptorIndexingProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxUpdateAfterBindDescriptorsInAllPools = original.maxUpdateAfterBindDescriptorsInAllPools;
  copy.shaderUniformBufferArrayNonUniformIndexingNative = original.shaderUniformBufferArrayNonUniformIndexingNative;
  copy.shaderSampledImageArrayNonUniformIndexingNative = original.shaderSampledImageArrayNonUniformIndexingNative;
  copy.shaderStorageBufferArrayNonUniformIndexingNative = original.shaderStorageBufferArrayNonUniformIndexingNative;
  copy.shaderStorageImageArrayNonUniformIndexingNative = original.shaderStorageImageArrayNonUniformIndexingNative;
  copy.shaderInputAttachmentArrayNonUniformIndexingNative = original.shaderInputAttachmentArrayNonUniformIndexingNative;
  copy.robustBufferAccessUpdateAfterBind = original.robustBufferAccessUpdateAfterBind;
  copy.quadDivergentImplicitLod = original.quadDivergentImplicitLod;
  copy.maxPerStageDescriptorUpdateAfterBindSamplers = original.maxPerStageDescriptorUpdateAfterBindSamplers;
  copy.maxPerStageDescriptorUpdateAfterBindUniformBuffers = original.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
  copy.maxPerStageDescriptorUpdateAfterBindStorageBuffers = original.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
  copy.maxPerStageDescriptorUpdateAfterBindSampledImages = original.maxPerStageDescriptorUpdateAfterBindSampledImages;
  copy.maxPerStageDescriptorUpdateAfterBindStorageImages = original.maxPerStageDescriptorUpdateAfterBindStorageImages;
  copy.maxPerStageDescriptorUpdateAfterBindInputAttachments = original.maxPerStageDescriptorUpdateAfterBindInputAttachments;
  copy.maxPerStageUpdateAfterBindResources = original.maxPerStageUpdateAfterBindResources;
  copy.maxDescriptorSetUpdateAfterBindSamplers = original.maxDescriptorSetUpdateAfterBindSamplers;
  copy.maxDescriptorSetUpdateAfterBindUniformBuffers = original.maxDescriptorSetUpdateAfterBindUniformBuffers;
  copy.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = original.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
  copy.maxDescriptorSetUpdateAfterBindStorageBuffers = original.maxDescriptorSetUpdateAfterBindStorageBuffers;
  copy.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = original.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
  copy.maxDescriptorSetUpdateAfterBindSampledImages = original.maxDescriptorSetUpdateAfterBindSampledImages;
  copy.maxDescriptorSetUpdateAfterBindStorageImages = original.maxDescriptorSetUpdateAfterBindStorageImages;
  copy.maxDescriptorSetUpdateAfterBindInputAttachments = original.maxDescriptorSetUpdateAfterBindInputAttachments;
  
  return copy;
};

VkPhysicalDeviceDescriptorIndexingProperties.byteLength = 0x0;

VkPhysicalDeviceDescriptorIndexingProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxUpdateAfterBindDescriptorsInAllPools: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformBufferArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSampledImageArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageBufferArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInputAttachmentArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  robustBufferAccessUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  quadDivergentImplicitLod: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindUniformBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindStorageBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindSampledImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindStorageImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageUpdateAfterBindResources: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindUniformBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindStorageBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindSampledImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindStorageImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDescriptorIndexingPropertiesEXT **/
function VkPhysicalDeviceDescriptorIndexingPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDescriptorIndexingPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDescriptorIndexingPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDescriptorIndexingPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDescriptorIndexingPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDescriptorIndexingPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDescriptorIndexingPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDescriptorIndexingPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxUpdateAfterBindDescriptorsInAllPools": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "shaderUniformBufferArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderSampledImageArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderStorageBufferArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderStorageImageArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderInputAttachmentArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "robustBufferAccessUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "quadDivergentImplicitLod": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "maxPerStageDescriptorUpdateAfterBindSamplers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindUniformBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindStorageBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindSampledImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindStorageImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindInputAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageUpdateAfterBindResources": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindSamplers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindUniformBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindSampledImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindInputAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDescriptorIndexingPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxUpdateAfterBindDescriptorsInAllPools = original.maxUpdateAfterBindDescriptorsInAllPools;
  copy.shaderUniformBufferArrayNonUniformIndexingNative = original.shaderUniformBufferArrayNonUniformIndexingNative;
  copy.shaderSampledImageArrayNonUniformIndexingNative = original.shaderSampledImageArrayNonUniformIndexingNative;
  copy.shaderStorageBufferArrayNonUniformIndexingNative = original.shaderStorageBufferArrayNonUniformIndexingNative;
  copy.shaderStorageImageArrayNonUniformIndexingNative = original.shaderStorageImageArrayNonUniformIndexingNative;
  copy.shaderInputAttachmentArrayNonUniformIndexingNative = original.shaderInputAttachmentArrayNonUniformIndexingNative;
  copy.robustBufferAccessUpdateAfterBind = original.robustBufferAccessUpdateAfterBind;
  copy.quadDivergentImplicitLod = original.quadDivergentImplicitLod;
  copy.maxPerStageDescriptorUpdateAfterBindSamplers = original.maxPerStageDescriptorUpdateAfterBindSamplers;
  copy.maxPerStageDescriptorUpdateAfterBindUniformBuffers = original.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
  copy.maxPerStageDescriptorUpdateAfterBindStorageBuffers = original.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
  copy.maxPerStageDescriptorUpdateAfterBindSampledImages = original.maxPerStageDescriptorUpdateAfterBindSampledImages;
  copy.maxPerStageDescriptorUpdateAfterBindStorageImages = original.maxPerStageDescriptorUpdateAfterBindStorageImages;
  copy.maxPerStageDescriptorUpdateAfterBindInputAttachments = original.maxPerStageDescriptorUpdateAfterBindInputAttachments;
  copy.maxPerStageUpdateAfterBindResources = original.maxPerStageUpdateAfterBindResources;
  copy.maxDescriptorSetUpdateAfterBindSamplers = original.maxDescriptorSetUpdateAfterBindSamplers;
  copy.maxDescriptorSetUpdateAfterBindUniformBuffers = original.maxDescriptorSetUpdateAfterBindUniformBuffers;
  copy.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = original.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
  copy.maxDescriptorSetUpdateAfterBindStorageBuffers = original.maxDescriptorSetUpdateAfterBindStorageBuffers;
  copy.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = original.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
  copy.maxDescriptorSetUpdateAfterBindSampledImages = original.maxDescriptorSetUpdateAfterBindSampledImages;
  copy.maxDescriptorSetUpdateAfterBindStorageImages = original.maxDescriptorSetUpdateAfterBindStorageImages;
  copy.maxDescriptorSetUpdateAfterBindInputAttachments = original.maxDescriptorSetUpdateAfterBindInputAttachments;
  
  return copy;
};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxUpdateAfterBindDescriptorsInAllPools: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformBufferArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSampledImageArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageBufferArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInputAttachmentArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  robustBufferAccessUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  quadDivergentImplicitLod: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindUniformBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindStorageBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindSampledImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindStorageImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageUpdateAfterBindResources: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindUniformBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindStorageBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindSampledImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindStorageImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetLayoutBindingFlagsCreateInfo **/
function VkDescriptorSetLayoutBindingFlagsCreateInfo(opts, byteOffset) {
  if (new.target !== VkDescriptorSetLayoutBindingFlagsCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetLayoutBindingFlagsCreateInfo, STRUCT_CACHE_VkDescriptorSetLayoutBindingFlagsCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetLayoutBindingFlagsCreateInfo, STRUCT_CACHE_VkDescriptorSetLayoutBindingFlagsCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetLayoutBindingFlagsCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pBindingFlags = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bindingCount !== void 0) this.bindingCount = opts.bindingCount;
    if (opts.pBindingFlags !== void 0) this.pBindingFlags = opts.pBindingFlags;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutBindingFlagsCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutBindingFlagsCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorSetLayoutBindingFlagsCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "bindingCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutBindingFlagsCreateInfo.bindingCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pBindingFlags": {
    get() {
    return this._pBindingFlags;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pBindingFlags = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pBindingFlags = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBindingFlagsCreateInfo.pBindingFlags': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDescriptorSetLayoutBindingFlagsCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pBindingFlags = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bindingCount !== void 0) this.bindingCount = opts.bindingCount;
    if (opts.pBindingFlags !== void 0) this.pBindingFlags = opts.pBindingFlags;
    
  }
};

VkDescriptorSetLayoutBindingFlagsCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetLayoutBindingFlagsCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorSetLayoutBindingFlagsCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetLayoutBindingFlagsCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.bindingCount = original.bindingCount;
  if (original.pBindingFlags !== null) {
        copy.pBindingFlags = new Int32Array(original.pBindingFlags);
      }
  
  return copy;
};

VkDescriptorSetLayoutBindingFlagsCreateInfo.byteLength = 0x0;

VkDescriptorSetLayoutBindingFlagsCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bindingCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pBindingFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetLayoutBindingFlagsCreateInfoEXT **/
function VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkDescriptorSetLayoutBindingFlagsCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, STRUCT_CACHE_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, STRUCT_CACHE_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pBindingFlags = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bindingCount !== void 0) this.bindingCount = opts.bindingCount;
    if (opts.pBindingFlags !== void 0) this.pBindingFlags = opts.pBindingFlags;
    
  }
};

Object.defineProperties(VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "bindingCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.bindingCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pBindingFlags": {
    get() {
    return this._pBindingFlags;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pBindingFlags = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pBindingFlags = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pBindingFlags': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pBindingFlags = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bindingCount !== void 0) this.bindingCount = opts.bindingCount;
    if (opts.pBindingFlags !== void 0) this.pBindingFlags = opts.pBindingFlags;
    
  }
};

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetLayoutBindingFlagsCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.bindingCount = original.bindingCount;
  if (original.pBindingFlags !== null) {
        copy.pBindingFlags = new Int32Array(original.pBindingFlags);
      }
  
  return copy;
};

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.byteLength = 0x0;

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bindingCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pBindingFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetVariableDescriptorCountAllocateInfo **/
function VkDescriptorSetVariableDescriptorCountAllocateInfo(opts, byteOffset) {
  if (new.target !== VkDescriptorSetVariableDescriptorCountAllocateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetVariableDescriptorCountAllocateInfo, STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountAllocateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetVariableDescriptorCountAllocateInfo, STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountAllocateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetVariableDescriptorCountAllocateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pDescriptorCounts = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.descriptorSetCount !== void 0) this.descriptorSetCount = opts.descriptorSetCount;
    if (opts.pDescriptorCounts !== void 0) this.pDescriptorCounts = opts.pDescriptorCounts;
    
  }
};

Object.defineProperties(VkDescriptorSetVariableDescriptorCountAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetVariableDescriptorCountAllocateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorSetVariableDescriptorCountAllocateInfo.pNext' isn't allowed to be filled");
    }
    },
  "descriptorSetCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetVariableDescriptorCountAllocateInfo.descriptorSetCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDescriptorCounts": {
    get() {
    return this._pDescriptorCounts;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDescriptorCounts = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDescriptorCounts = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetVariableDescriptorCountAllocateInfo.pDescriptorCounts': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDescriptorSetVariableDescriptorCountAllocateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pDescriptorCounts = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.descriptorSetCount !== void 0) this.descriptorSetCount = opts.descriptorSetCount;
    if (opts.pDescriptorCounts !== void 0) this.pDescriptorCounts = opts.pDescriptorCounts;
    
  }
};

VkDescriptorSetVariableDescriptorCountAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetVariableDescriptorCountAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorSetVariableDescriptorCountAllocateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetVariableDescriptorCountAllocateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.descriptorSetCount = original.descriptorSetCount;
  if (original.pDescriptorCounts !== null) {
        copy.pDescriptorCounts = new Uint32Array(original.pDescriptorCounts);
      }
  
  return copy;
};

VkDescriptorSetVariableDescriptorCountAllocateInfo.byteLength = 0x0;

VkDescriptorSetVariableDescriptorCountAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorSetCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDescriptorCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetVariableDescriptorCountAllocateInfoEXT **/
function VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(opts, byteOffset) {
  if (new.target !== VkDescriptorSetVariableDescriptorCountAllocateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pDescriptorCounts = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.descriptorSetCount !== void 0) this.descriptorSetCount = opts.descriptorSetCount;
    if (opts.pDescriptorCounts !== void 0) this.pDescriptorCounts = opts.pDescriptorCounts;
    
  }
};

Object.defineProperties(VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "descriptorSetCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.descriptorSetCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDescriptorCounts": {
    get() {
    return this._pDescriptorCounts;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDescriptorCounts = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDescriptorCounts = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pDescriptorCounts': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pDescriptorCounts = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.descriptorSetCount !== void 0) this.descriptorSetCount = opts.descriptorSetCount;
    if (opts.pDescriptorCounts !== void 0) this.pDescriptorCounts = opts.pDescriptorCounts;
    
  }
};

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetVariableDescriptorCountAllocateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.descriptorSetCount = original.descriptorSetCount;
  if (original.pDescriptorCounts !== null) {
        copy.pDescriptorCounts = new Uint32Array(original.pDescriptorCounts);
      }
  
  return copy;
};

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.byteLength = 0x0;

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorSetCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDescriptorCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetVariableDescriptorCountLayoutSupport **/
function VkDescriptorSetVariableDescriptorCountLayoutSupport(opts, byteOffset) {
  if (new.target !== VkDescriptorSetVariableDescriptorCountLayoutSupport) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetVariableDescriptorCountLayoutSupport, STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountLayoutSupport);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetVariableDescriptorCountLayoutSupport, STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountLayoutSupport);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetVariableDescriptorCountLayoutSupport'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDescriptorSetVariableDescriptorCountLayoutSupport.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetVariableDescriptorCountLayoutSupport.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorSetVariableDescriptorCountLayoutSupport.pNext' isn't allowed to be filled");
    }
    },
  "maxVariableDescriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkDescriptorSetVariableDescriptorCountLayoutSupport.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDescriptorSetVariableDescriptorCountLayoutSupport.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetVariableDescriptorCountLayoutSupport.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDescriptorSetVariableDescriptorCountLayoutSupport.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetVariableDescriptorCountLayoutSupport();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxVariableDescriptorCount = original.maxVariableDescriptorCount;
  
  return copy;
};

VkDescriptorSetVariableDescriptorCountLayoutSupport.byteLength = 0x0;

VkDescriptorSetVariableDescriptorCountLayoutSupport.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxVariableDescriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDescriptorSetVariableDescriptorCountLayoutSupportEXT **/
function VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(opts, byteOffset) {
  if (new.target !== VkDescriptorSetVariableDescriptorCountLayoutSupportEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDescriptorSetVariableDescriptorCountLayoutSupportEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxVariableDescriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDescriptorSetVariableDescriptorCountLayoutSupportEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxVariableDescriptorCount = original.maxVariableDescriptorCount;
  
  return copy;
};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.byteLength = 0x0;

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxVariableDescriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentDescription2 **/
function VkAttachmentDescription2(opts, byteOffset) {
  if (new.target !== VkAttachmentDescription2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentDescription2, STRUCT_CACHE_VkAttachmentDescription2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentDescription2, STRUCT_CACHE_VkAttachmentDescription2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentDescription2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.loadOp !== void 0) this.loadOp = opts.loadOp;
    if (opts.storeOp !== void 0) this.storeOp = opts.storeOp;
    if (opts.stencilLoadOp !== void 0) this.stencilLoadOp = opts.stencilLoadOp;
    if (opts.stencilStoreOp !== void 0) this.stencilStoreOp = opts.stencilStoreOp;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    if (opts.finalLayout !== void 0) this.finalLayout = opts.finalLayout;
    
  }
};

Object.defineProperties(VkAttachmentDescription2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkAttachmentDescription2.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkAttachmentDescription2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "samples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2.samples");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "loadOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2.loadOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "storeOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2.storeOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stencilLoadOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2.stencilLoadOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stencilStoreOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2.stencilStoreOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "initialLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2.initialLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "finalLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2.finalLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAttachmentDescription2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.loadOp !== void 0) this.loadOp = opts.loadOp;
    if (opts.storeOp !== void 0) this.storeOp = opts.storeOp;
    if (opts.stencilLoadOp !== void 0) this.stencilLoadOp = opts.stencilLoadOp;
    if (opts.stencilStoreOp !== void 0) this.stencilStoreOp = opts.stencilStoreOp;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    if (opts.finalLayout !== void 0) this.finalLayout = opts.finalLayout;
    
  }
};

VkAttachmentDescription2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentDescription2.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentDescription2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentDescription2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.format = original.format;
  copy.samples = original.samples;
  copy.loadOp = original.loadOp;
  copy.storeOp = original.storeOp;
  copy.stencilLoadOp = original.stencilLoadOp;
  copy.stencilStoreOp = original.stencilStoreOp;
  copy.initialLayout = original.initialLayout;
  copy.finalLayout = original.finalLayout;
  
  return copy;
};

VkAttachmentDescription2.byteLength = 0x0;

VkAttachmentDescription2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  loadOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storeOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilLoadOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilStoreOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  initialLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  finalLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentDescription2KHR **/
function VkAttachmentDescription2KHR(opts, byteOffset) {
  if (new.target !== VkAttachmentDescription2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentDescription2KHR, STRUCT_CACHE_VkAttachmentDescription2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentDescription2KHR, STRUCT_CACHE_VkAttachmentDescription2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentDescription2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.loadOp !== void 0) this.loadOp = opts.loadOp;
    if (opts.storeOp !== void 0) this.storeOp = opts.storeOp;
    if (opts.stencilLoadOp !== void 0) this.stencilLoadOp = opts.stencilLoadOp;
    if (opts.stencilStoreOp !== void 0) this.stencilStoreOp = opts.stencilStoreOp;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    if (opts.finalLayout !== void 0) this.finalLayout = opts.finalLayout;
    
  }
};

Object.defineProperties(VkAttachmentDescription2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2KHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2KHR.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "samples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2KHR.samples");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "loadOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2KHR.loadOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "storeOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2KHR.storeOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stencilLoadOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2KHR.stencilLoadOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stencilStoreOp": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2KHR.stencilStoreOp");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "initialLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2KHR.initialLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "finalLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescription2KHR.finalLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAttachmentDescription2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.format !== void 0) this.format = opts.format;
    if (opts.samples !== void 0) this.samples = opts.samples;
    if (opts.loadOp !== void 0) this.loadOp = opts.loadOp;
    if (opts.storeOp !== void 0) this.storeOp = opts.storeOp;
    if (opts.stencilLoadOp !== void 0) this.stencilLoadOp = opts.stencilLoadOp;
    if (opts.stencilStoreOp !== void 0) this.stencilStoreOp = opts.stencilStoreOp;
    if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
    if (opts.finalLayout !== void 0) this.finalLayout = opts.finalLayout;
    
  }
};

VkAttachmentDescription2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentDescription2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentDescription2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentDescription2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.format = original.format;
  copy.samples = original.samples;
  copy.loadOp = original.loadOp;
  copy.storeOp = original.storeOp;
  copy.stencilLoadOp = original.stencilLoadOp;
  copy.stencilStoreOp = original.stencilStoreOp;
  copy.initialLayout = original.initialLayout;
  copy.finalLayout = original.finalLayout;
  
  return copy;
};

VkAttachmentDescription2KHR.byteLength = 0x0;

VkAttachmentDescription2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  loadOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storeOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilLoadOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilStoreOp: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  initialLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  finalLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentReference2 **/
function VkAttachmentReference2(opts, byteOffset) {
  if (new.target !== VkAttachmentReference2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentReference2, STRUCT_CACHE_VkAttachmentReference2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentReference2, STRUCT_CACHE_VkAttachmentReference2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentReference2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachment !== void 0) this.attachment = opts.attachment;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

Object.defineProperties(VkAttachmentReference2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReference2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkAttachmentReference2.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkAttachmentReference2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAttachmentReference2.pNext'");
    }
    
    }
    },
  "attachment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReference2.attachment");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "layout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReference2.layout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "aspectMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReference2.aspectMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAttachmentReference2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachment !== void 0) this.attachment = opts.attachment;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

VkAttachmentReference2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentReference2.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentReference2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentReference2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.attachment = original.attachment;
  copy.layout = original.layout;
  copy.aspectMask = original.aspectMask;
  
  return copy;
};

VkAttachmentReference2.byteLength = 0x0;

VkAttachmentReference2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentReference2KHR **/
function VkAttachmentReference2KHR(opts, byteOffset) {
  if (new.target !== VkAttachmentReference2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentReference2KHR, STRUCT_CACHE_VkAttachmentReference2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentReference2KHR, STRUCT_CACHE_VkAttachmentReference2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentReference2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachment !== void 0) this.attachment = opts.attachment;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

Object.defineProperties(VkAttachmentReference2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReference2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.pNext'");
    }
    
    }
    },
  "attachment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReference2KHR.attachment");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "layout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReference2KHR.layout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "aspectMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReference2KHR.aspectMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAttachmentReference2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachment !== void 0) this.attachment = opts.attachment;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
    
  }
};

VkAttachmentReference2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentReference2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentReference2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentReference2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.attachment = original.attachment;
  copy.layout = original.layout;
  copy.aspectMask = original.aspectMask;
  
  return copy;
};

VkAttachmentReference2KHR.byteLength = 0x0;

VkAttachmentReference2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  aspectMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassDescription2 **/
function VkSubpassDescription2(opts, byteOffset) {
  if (new.target !== VkSubpassDescription2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassDescription2, STRUCT_CACHE_VkSubpassDescription2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassDescription2, STRUCT_CACHE_VkSubpassDescription2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassDescription2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this._pInputAttachments = null;
  this._pInputAttachmentsNative = null;
  
  this._pColorAttachments = null;
  this._pColorAttachmentsNative = null;
  this._pResolveAttachments = null;
  this._pResolveAttachmentsNative = null;
  this._pDepthStencilAttachment = null;
  
  this._pPreserveAttachments = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.viewMask !== void 0) this.viewMask = opts.viewMask;
    if (opts.inputAttachmentCount !== void 0) this.inputAttachmentCount = opts.inputAttachmentCount;
    if (opts.pInputAttachments !== void 0) this.pInputAttachments = opts.pInputAttachments;
    if (opts.colorAttachmentCount !== void 0) this.colorAttachmentCount = opts.colorAttachmentCount;
    if (opts.pColorAttachments !== void 0) this.pColorAttachments = opts.pColorAttachments;
    if (opts.pResolveAttachments !== void 0) this.pResolveAttachments = opts.pResolveAttachments;
    if (opts.pDepthStencilAttachment !== void 0) this.pDepthStencilAttachment = opts.pDepthStencilAttachment;
    if (opts.preserveAttachmentCount !== void 0) this.preserveAttachmentCount = opts.preserveAttachmentCount;
    if (opts.pPreserveAttachments !== void 0) this.pPreserveAttachments = opts.pPreserveAttachments;
    
  }
};

Object.defineProperties(VkSubpassDescription2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSubpassDescription2.pNext'");
      switch (sType) {
          
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkSubpassDescription2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2.pipelineBindPoint");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "viewMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2.viewMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "inputAttachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2.inputAttachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pInputAttachments": {
    get() {
    if (this._pInputAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.inputAttachmentCount, VkAttachmentReference2);
      this._pInputAttachments = array;
      return this.pInputAttachments;
    } else {
      return this._pInputAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pInputAttachments = value;
    } else if (value === null) {
      this._pInputAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2.pInputAttachments': Expected 'Array VkAttachmentReference2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "colorAttachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2.colorAttachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pColorAttachments": {
    get() {
    if (this._pColorAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.colorAttachmentCount, VkAttachmentReference2);
      this._pColorAttachments = array;
      return this.pColorAttachments;
    } else {
      return this._pColorAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pColorAttachments = value;
    } else if (value === null) {
      this._pColorAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2.pColorAttachments': Expected 'Array VkAttachmentReference2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pResolveAttachments": {
    get() {
    if (this._pResolveAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.colorAttachmentCount, VkAttachmentReference2);
      this._pResolveAttachments = array;
      return this.pResolveAttachments;
    } else {
      return this._pResolveAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pResolveAttachments = value;
    } else if (value === null) {
      this._pResolveAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2.pResolveAttachments': Expected 'Array VkAttachmentReference2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pDepthStencilAttachment": {
    get() {
    if (this._pDepthStencilAttachment === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkAttachmentReference2.byteLength));
      this._pDepthStencilAttachment = new VkAttachmentReference2({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pDepthStencilAttachment.memoryAddress, true);
      return this.pDepthStencilAttachment;
    } else {
      return this._pDepthStencilAttachment;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference2) {
      value.flush();
      this._pDepthStencilAttachment = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pDepthStencilAttachment = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2.pDepthStencilAttachment': Expected 'VkAttachmentReference2' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "preserveAttachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2.preserveAttachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPreserveAttachments": {
    get() {
    return this._pPreserveAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pPreserveAttachments = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pPreserveAttachments = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2.pPreserveAttachments': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSubpassDescription2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pInputAttachments = null;
  this._pInputAttachmentsNative = null;
  
  this._pColorAttachments = null;
  this._pColorAttachmentsNative = null;
  this._pResolveAttachments = null;
  this._pResolveAttachmentsNative = null;
  this._pDepthStencilAttachment = null;
  
  this._pPreserveAttachments = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.viewMask !== void 0) this.viewMask = opts.viewMask;
    if (opts.inputAttachmentCount !== void 0) this.inputAttachmentCount = opts.inputAttachmentCount;
    if (opts.pInputAttachments !== void 0) this.pInputAttachments = opts.pInputAttachments;
    if (opts.colorAttachmentCount !== void 0) this.colorAttachmentCount = opts.colorAttachmentCount;
    if (opts.pColorAttachments !== void 0) this.pColorAttachments = opts.pColorAttachments;
    if (opts.pResolveAttachments !== void 0) this.pResolveAttachments = opts.pResolveAttachments;
    if (opts.pDepthStencilAttachment !== void 0) this.pDepthStencilAttachment = opts.pDepthStencilAttachment;
    if (opts.preserveAttachmentCount !== void 0) this.preserveAttachmentCount = opts.preserveAttachmentCount;
    if (opts.pPreserveAttachments !== void 0) this.pPreserveAttachments = opts.pPreserveAttachments;
    
  }
};

VkSubpassDescription2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pInputAttachments !== null) {
    let array = this._pInputAttachments;
    
    if (array.length !== this.inputAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'inputAttachmentCount' for 'VkSubpassDescription2.pInputAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference2)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2.pInputAttachments[" + ii + "]': Expected 'VkAttachmentReference2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pInputAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pInputAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pColorAttachments !== null) {
    let array = this._pColorAttachments;
    
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription2.pColorAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference2)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2.pColorAttachments[" + ii + "]': Expected 'VkAttachmentReference2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pColorAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pColorAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pResolveAttachments !== null) {
    let array = this._pResolveAttachments;
    
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription2.pResolveAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference2)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2.pResolveAttachments[" + ii + "]': Expected 'VkAttachmentReference2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pResolveAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pResolveAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSubpassDescription2.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassDescription2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassDescription2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.pipelineBindPoint = original.pipelineBindPoint;
  copy.viewMask = original.viewMask;
  copy.inputAttachmentCount = original.inputAttachmentCount;
  if (original.pInputAttachments !== null) {
        copy.pInputAttachments = [...Array(original.pInputAttachments.length)].map((v, i) => {
          return original.pInputAttachments[i].constructor.createCopyFrom(original.pInputAttachments[i]);
        });
      }
  copy.colorAttachmentCount = original.colorAttachmentCount;
  if (original.pColorAttachments !== null) {
        copy.pColorAttachments = [...Array(original.pColorAttachments.length)].map((v, i) => {
          return original.pColorAttachments[i].constructor.createCopyFrom(original.pColorAttachments[i]);
        });
      }
  if (original.pResolveAttachments !== null) {
        copy.pResolveAttachments = [...Array(original.pResolveAttachments.length)].map((v, i) => {
          return original.pResolveAttachments[i].constructor.createCopyFrom(original.pResolveAttachments[i]);
        });
      }
  if (original.pDepthStencilAttachment !== null) {
        copy.pDepthStencilAttachment = original.pDepthStencilAttachment.constructor.createCopyFrom(original.pDepthStencilAttachment);
      }
  copy.preserveAttachmentCount = original.preserveAttachmentCount;
  if (original.pPreserveAttachments !== null) {
        copy.pPreserveAttachments = new Uint32Array(original.pPreserveAttachments);
      }
  
  return copy;
};

VkSubpassDescription2.byteLength = 0x0;

VkSubpassDescription2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineBindPoint: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  inputAttachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  colorAttachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pColorAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pResolveAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDepthStencilAttachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  preserveAttachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPreserveAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassDescription2KHR **/
function VkSubpassDescription2KHR(opts, byteOffset) {
  if (new.target !== VkSubpassDescription2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassDescription2KHR, STRUCT_CACHE_VkSubpassDescription2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassDescription2KHR, STRUCT_CACHE_VkSubpassDescription2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassDescription2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this._pInputAttachments = null;
  this._pInputAttachmentsNative = null;
  
  this._pColorAttachments = null;
  this._pColorAttachmentsNative = null;
  this._pResolveAttachments = null;
  this._pResolveAttachmentsNative = null;
  this._pDepthStencilAttachment = null;
  
  this._pPreserveAttachments = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.viewMask !== void 0) this.viewMask = opts.viewMask;
    if (opts.inputAttachmentCount !== void 0) this.inputAttachmentCount = opts.inputAttachmentCount;
    if (opts.pInputAttachments !== void 0) this.pInputAttachments = opts.pInputAttachments;
    if (opts.colorAttachmentCount !== void 0) this.colorAttachmentCount = opts.colorAttachmentCount;
    if (opts.pColorAttachments !== void 0) this.pColorAttachments = opts.pColorAttachments;
    if (opts.pResolveAttachments !== void 0) this.pResolveAttachments = opts.pResolveAttachments;
    if (opts.pDepthStencilAttachment !== void 0) this.pDepthStencilAttachment = opts.pDepthStencilAttachment;
    if (opts.preserveAttachmentCount !== void 0) this.preserveAttachmentCount = opts.preserveAttachmentCount;
    if (opts.pPreserveAttachments !== void 0) this.pPreserveAttachments = opts.pPreserveAttachments;
    
  }
};

Object.defineProperties(VkSubpassDescription2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pNext'");
      switch (sType) {
          
        case :
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2KHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pipelineBindPoint": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2KHR.pipelineBindPoint");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "viewMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2KHR.viewMask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "inputAttachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2KHR.inputAttachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pInputAttachments": {
    get() {
    if (this._pInputAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.inputAttachmentCount, VkAttachmentReference2);
      this._pInputAttachments = array;
      return this.pInputAttachments;
    } else {
      return this._pInputAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pInputAttachments = value;
    } else if (value === null) {
      this._pInputAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pInputAttachments': Expected 'Array VkAttachmentReference2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "colorAttachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2KHR.colorAttachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pColorAttachments": {
    get() {
    if (this._pColorAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.colorAttachmentCount, VkAttachmentReference2);
      this._pColorAttachments = array;
      return this.pColorAttachments;
    } else {
      return this._pColorAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pColorAttachments = value;
    } else if (value === null) {
      this._pColorAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pColorAttachments': Expected 'Array VkAttachmentReference2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pResolveAttachments": {
    get() {
    if (this._pResolveAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.colorAttachmentCount, VkAttachmentReference2);
      this._pResolveAttachments = array;
      return this.pResolveAttachments;
    } else {
      return this._pResolveAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pResolveAttachments = value;
    } else if (value === null) {
      this._pResolveAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pResolveAttachments': Expected 'Array VkAttachmentReference2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pDepthStencilAttachment": {
    get() {
    if (this._pDepthStencilAttachment === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkAttachmentReference2.byteLength));
      this._pDepthStencilAttachment = new VkAttachmentReference2({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pDepthStencilAttachment.memoryAddress, true);
      return this.pDepthStencilAttachment;
    } else {
      return this._pDepthStencilAttachment;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference2) {
      value.flush();
      this._pDepthStencilAttachment = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pDepthStencilAttachment = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pDepthStencilAttachment': Expected 'VkAttachmentReference2' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "preserveAttachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescription2KHR.preserveAttachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPreserveAttachments": {
    get() {
    return this._pPreserveAttachments;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pPreserveAttachments = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pPreserveAttachments = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pPreserveAttachments': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSubpassDescription2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pInputAttachments = null;
  this._pInputAttachmentsNative = null;
  
  this._pColorAttachments = null;
  this._pColorAttachmentsNative = null;
  this._pResolveAttachments = null;
  this._pResolveAttachmentsNative = null;
  this._pDepthStencilAttachment = null;
  
  this._pPreserveAttachments = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
    if (opts.viewMask !== void 0) this.viewMask = opts.viewMask;
    if (opts.inputAttachmentCount !== void 0) this.inputAttachmentCount = opts.inputAttachmentCount;
    if (opts.pInputAttachments !== void 0) this.pInputAttachments = opts.pInputAttachments;
    if (opts.colorAttachmentCount !== void 0) this.colorAttachmentCount = opts.colorAttachmentCount;
    if (opts.pColorAttachments !== void 0) this.pColorAttachments = opts.pColorAttachments;
    if (opts.pResolveAttachments !== void 0) this.pResolveAttachments = opts.pResolveAttachments;
    if (opts.pDepthStencilAttachment !== void 0) this.pDepthStencilAttachment = opts.pDepthStencilAttachment;
    if (opts.preserveAttachmentCount !== void 0) this.preserveAttachmentCount = opts.preserveAttachmentCount;
    if (opts.pPreserveAttachments !== void 0) this.pPreserveAttachments = opts.pPreserveAttachments;
    
  }
};

VkSubpassDescription2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pInputAttachments !== null) {
    let array = this._pInputAttachments;
    
    if (array.length !== this.inputAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'inputAttachmentCount' for 'VkSubpassDescription2KHR.pInputAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference2)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pInputAttachments[" + ii + "]': Expected 'VkAttachmentReference2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pInputAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pInputAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pColorAttachments !== null) {
    let array = this._pColorAttachments;
    
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription2KHR.pColorAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference2)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pColorAttachments[" + ii + "]': Expected 'VkAttachmentReference2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pColorAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pColorAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pResolveAttachments !== null) {
    let array = this._pResolveAttachments;
    
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription2KHR.pResolveAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentReference2)) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pResolveAttachments[" + ii + "]': Expected 'VkAttachmentReference2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pResolveAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pResolveAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSubpassDescription2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassDescription2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassDescription2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.pipelineBindPoint = original.pipelineBindPoint;
  copy.viewMask = original.viewMask;
  copy.inputAttachmentCount = original.inputAttachmentCount;
  if (original.pInputAttachments !== null) {
        copy.pInputAttachments = [...Array(original.pInputAttachments.length)].map((v, i) => {
          return original.pInputAttachments[i].constructor.createCopyFrom(original.pInputAttachments[i]);
        });
      }
  copy.colorAttachmentCount = original.colorAttachmentCount;
  if (original.pColorAttachments !== null) {
        copy.pColorAttachments = [...Array(original.pColorAttachments.length)].map((v, i) => {
          return original.pColorAttachments[i].constructor.createCopyFrom(original.pColorAttachments[i]);
        });
      }
  if (original.pResolveAttachments !== null) {
        copy.pResolveAttachments = [...Array(original.pResolveAttachments.length)].map((v, i) => {
          return original.pResolveAttachments[i].constructor.createCopyFrom(original.pResolveAttachments[i]);
        });
      }
  if (original.pDepthStencilAttachment !== null) {
        copy.pDepthStencilAttachment = original.pDepthStencilAttachment.constructor.createCopyFrom(original.pDepthStencilAttachment);
      }
  copy.preserveAttachmentCount = original.preserveAttachmentCount;
  if (original.pPreserveAttachments !== null) {
        copy.pPreserveAttachments = new Uint32Array(original.pPreserveAttachments);
      }
  
  return copy;
};

VkSubpassDescription2KHR.byteLength = 0x0;

VkSubpassDescription2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineBindPoint: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  inputAttachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  colorAttachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pColorAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pResolveAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDepthStencilAttachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  preserveAttachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPreserveAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassDependency2 **/
function VkSubpassDependency2(opts, byteOffset) {
  if (new.target !== VkSubpassDependency2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassDependency2, STRUCT_CACHE_VkSubpassDependency2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassDependency2, STRUCT_CACHE_VkSubpassDependency2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassDependency2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubpass !== void 0) this.srcSubpass = opts.srcSubpass;
    if (opts.dstSubpass !== void 0) this.dstSubpass = opts.dstSubpass;
    if (opts.srcStageMask !== void 0) this.srcStageMask = opts.srcStageMask;
    if (opts.dstStageMask !== void 0) this.dstStageMask = opts.dstStageMask;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.dependencyFlags !== void 0) this.dependencyFlags = opts.dependencyFlags;
    if (opts.viewOffset !== void 0) this.viewOffset = opts.viewOffset;
    
  }
};

Object.defineProperties(VkSubpassDependency2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassDependency2.pNext' isn't allowed to be filled");
    }
    },
  "srcSubpass": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2.srcSubpass");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "dstSubpass": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2.dstSubpass");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "srcStageMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2.srcStageMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstStageMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2.dstStageMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2.srcAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2.dstAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dependencyFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2.dependencyFlags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "viewOffset": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2.viewOffset");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSubpassDependency2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubpass !== void 0) this.srcSubpass = opts.srcSubpass;
    if (opts.dstSubpass !== void 0) this.dstSubpass = opts.dstSubpass;
    if (opts.srcStageMask !== void 0) this.srcStageMask = opts.srcStageMask;
    if (opts.dstStageMask !== void 0) this.dstStageMask = opts.dstStageMask;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.dependencyFlags !== void 0) this.dependencyFlags = opts.dependencyFlags;
    if (opts.viewOffset !== void 0) this.viewOffset = opts.viewOffset;
    
  }
};

VkSubpassDependency2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassDependency2.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassDependency2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassDependency2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.srcSubpass = original.srcSubpass;
  copy.dstSubpass = original.dstSubpass;
  copy.srcStageMask = original.srcStageMask;
  copy.dstStageMask = original.dstStageMask;
  copy.srcAccessMask = original.srcAccessMask;
  copy.dstAccessMask = original.dstAccessMask;
  copy.dependencyFlags = original.dependencyFlags;
  copy.viewOffset = original.viewOffset;
  
  return copy;
};

VkSubpassDependency2.byteLength = 0x0;

VkSubpassDependency2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcSubpass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSubpass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcStageMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstStageMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dependencyFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassDependency2KHR **/
function VkSubpassDependency2KHR(opts, byteOffset) {
  if (new.target !== VkSubpassDependency2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassDependency2KHR, STRUCT_CACHE_VkSubpassDependency2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassDependency2KHR, STRUCT_CACHE_VkSubpassDependency2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassDependency2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubpass !== void 0) this.srcSubpass = opts.srcSubpass;
    if (opts.dstSubpass !== void 0) this.dstSubpass = opts.dstSubpass;
    if (opts.srcStageMask !== void 0) this.srcStageMask = opts.srcStageMask;
    if (opts.dstStageMask !== void 0) this.dstStageMask = opts.dstStageMask;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.dependencyFlags !== void 0) this.dependencyFlags = opts.dependencyFlags;
    if (opts.viewOffset !== void 0) this.viewOffset = opts.viewOffset;
    
  }
};

Object.defineProperties(VkSubpassDependency2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassDependency2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcSubpass": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2KHR.srcSubpass");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "dstSubpass": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2KHR.dstSubpass");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "srcStageMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2KHR.srcStageMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstStageMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2KHR.dstStageMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "srcAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2KHR.srcAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstAccessMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2KHR.dstAccessMask");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dependencyFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2KHR.dependencyFlags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "viewOffset": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDependency2KHR.viewOffset");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSubpassDependency2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubpass !== void 0) this.srcSubpass = opts.srcSubpass;
    if (opts.dstSubpass !== void 0) this.dstSubpass = opts.dstSubpass;
    if (opts.srcStageMask !== void 0) this.srcStageMask = opts.srcStageMask;
    if (opts.dstStageMask !== void 0) this.dstStageMask = opts.dstStageMask;
    if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
    if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
    if (opts.dependencyFlags !== void 0) this.dependencyFlags = opts.dependencyFlags;
    if (opts.viewOffset !== void 0) this.viewOffset = opts.viewOffset;
    
  }
};

VkSubpassDependency2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassDependency2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassDependency2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassDependency2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.srcSubpass = original.srcSubpass;
  copy.dstSubpass = original.dstSubpass;
  copy.srcStageMask = original.srcStageMask;
  copy.dstStageMask = original.dstStageMask;
  copy.srcAccessMask = original.srcAccessMask;
  copy.dstAccessMask = original.dstAccessMask;
  copy.dependencyFlags = original.dependencyFlags;
  copy.viewOffset = original.viewOffset;
  
  return copy;
};

VkSubpassDependency2KHR.byteLength = 0x0;

VkSubpassDependency2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcSubpass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSubpass: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcStageMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstStageMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstAccessMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dependencyFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassCreateInfo2 **/
function VkRenderPassCreateInfo2(opts, byteOffset) {
  if (new.target !== VkRenderPassCreateInfo2) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassCreateInfo2, STRUCT_CACHE_VkRenderPassCreateInfo2);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassCreateInfo2, STRUCT_CACHE_VkRenderPassCreateInfo2);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassCreateInfo2'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  
  this._pSubpasses = null;
  this._pSubpassesNative = null;
  
  this._pDependencies = null;
  this._pDependenciesNative = null;
  
  this._pCorrelatedViewMasks = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pSubpasses !== void 0) this.pSubpasses = opts.pSubpasses;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pDependencies !== void 0) this.pDependencies = opts.pDependencies;
    if (opts.correlatedViewMaskCount !== void 0) this.correlatedViewMaskCount = opts.correlatedViewMaskCount;
    if (opts.pCorrelatedViewMasks !== void 0) this.pCorrelatedViewMasks = opts.pCorrelatedViewMasks;
    
  }
};

Object.defineProperties(VkRenderPassCreateInfo2.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2.attachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAttachments": {
    get() {
    if (this._pAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.attachmentCount, VkAttachmentDescription2);
      this._pAttachments = array;
      return this.pAttachments;
    } else {
      return this._pAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2.pAttachments': Expected 'Array VkAttachmentDescription2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "subpassCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2.subpassCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSubpasses": {
    get() {
    if (this._pSubpasses === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.subpassCount, VkSubpassDescription2);
      this._pSubpasses = array;
      return this.pSubpasses;
    } else {
      return this._pSubpasses;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSubpasses = value;
    } else if (value === null) {
      this._pSubpasses = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2.pSubpasses': Expected 'Array VkSubpassDescription2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "dependencyCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2.dependencyCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDependencies": {
    get() {
    if (this._pDependencies === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.dependencyCount, VkSubpassDependency2);
      this._pDependencies = array;
      return this.pDependencies;
    } else {
      return this._pDependencies;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDependencies = value;
    } else if (value === null) {
      this._pDependencies = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2.pDependencies': Expected 'Array VkSubpassDependency2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "correlatedViewMaskCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2.correlatedViewMaskCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCorrelatedViewMasks": {
    get() {
    return this._pCorrelatedViewMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCorrelatedViewMasks = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pCorrelatedViewMasks = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2.pCorrelatedViewMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRenderPassCreateInfo2.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  
  this._pSubpasses = null;
  this._pSubpassesNative = null;
  
  this._pDependencies = null;
  this._pDependenciesNative = null;
  
  this._pCorrelatedViewMasks = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pSubpasses !== void 0) this.pSubpasses = opts.pSubpasses;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pDependencies !== void 0) this.pDependencies = opts.pDependencies;
    if (opts.correlatedViewMaskCount !== void 0) this.correlatedViewMaskCount = opts.correlatedViewMaskCount;
    if (opts.pCorrelatedViewMasks !== void 0) this.pCorrelatedViewMasks = opts.pCorrelatedViewMasks;
    
  }
};

VkRenderPassCreateInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkRenderPassCreateInfo2.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentDescription2)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2.pAttachments[" + ii + "]': Expected 'VkAttachmentDescription2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pSubpasses !== null) {
    let array = this._pSubpasses;
    
    if (array.length !== this.subpassCount) {
      throw new RangeError("Invalid array length, expected length of 'subpassCount' for 'VkRenderPassCreateInfo2.pSubpasses'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassDescription2)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2.pSubpasses[" + ii + "]': Expected 'VkSubpassDescription2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSubpassesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSubpassesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pDependencies !== null) {
    let array = this._pDependencies;
    
    if (array.length !== this.dependencyCount) {
      throw new RangeError("Invalid array length, expected length of 'dependencyCount' for 'VkRenderPassCreateInfo2.pDependencies'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassDependency2)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2.pDependencies[" + ii + "]': Expected 'VkSubpassDependency2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDependenciesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pDependenciesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRenderPassCreateInfo2.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassCreateInfo2.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassCreateInfo2();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.attachmentCount = original.attachmentCount;
  if (original.pAttachments !== null) {
        copy.pAttachments = [...Array(original.pAttachments.length)].map((v, i) => {
          return original.pAttachments[i].constructor.createCopyFrom(original.pAttachments[i]);
        });
      }
  copy.subpassCount = original.subpassCount;
  if (original.pSubpasses !== null) {
        copy.pSubpasses = [...Array(original.pSubpasses.length)].map((v, i) => {
          return original.pSubpasses[i].constructor.createCopyFrom(original.pSubpasses[i]);
        });
      }
  copy.dependencyCount = original.dependencyCount;
  if (original.pDependencies !== null) {
        copy.pDependencies = [...Array(original.pDependencies.length)].map((v, i) => {
          return original.pDependencies[i].constructor.createCopyFrom(original.pDependencies[i]);
        });
      }
  copy.correlatedViewMaskCount = original.correlatedViewMaskCount;
  if (original.pCorrelatedViewMasks !== null) {
        copy.pCorrelatedViewMasks = new Uint32Array(original.pCorrelatedViewMasks);
      }
  
  return copy;
};

VkRenderPassCreateInfo2.byteLength = 0x0;

VkRenderPassCreateInfo2.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subpassCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSubpasses: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dependencyCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDependencies: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  correlatedViewMaskCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCorrelatedViewMasks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassCreateInfo2KHR **/
function VkRenderPassCreateInfo2KHR(opts, byteOffset) {
  if (new.target !== VkRenderPassCreateInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassCreateInfo2KHR, STRUCT_CACHE_VkRenderPassCreateInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassCreateInfo2KHR, STRUCT_CACHE_VkRenderPassCreateInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassCreateInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  
  this._pSubpasses = null;
  this._pSubpassesNative = null;
  
  this._pDependencies = null;
  this._pDependenciesNative = null;
  
  this._pCorrelatedViewMasks = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pSubpasses !== void 0) this.pSubpasses = opts.pSubpasses;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pDependencies !== void 0) this.pDependencies = opts.pDependencies;
    if (opts.correlatedViewMaskCount !== void 0) this.correlatedViewMaskCount = opts.correlatedViewMaskCount;
    if (opts.pCorrelatedViewMasks !== void 0) this.pCorrelatedViewMasks = opts.pCorrelatedViewMasks;
    
  }
};

Object.defineProperties(VkRenderPassCreateInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2KHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2KHR.attachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAttachments": {
    get() {
    if (this._pAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.attachmentCount, VkAttachmentDescription2);
      this._pAttachments = array;
      return this.pAttachments;
    } else {
      return this._pAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pAttachments': Expected 'Array VkAttachmentDescription2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "subpassCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2KHR.subpassCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSubpasses": {
    get() {
    if (this._pSubpasses === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.subpassCount, VkSubpassDescription2);
      this._pSubpasses = array;
      return this.pSubpasses;
    } else {
      return this._pSubpasses;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSubpasses = value;
    } else if (value === null) {
      this._pSubpasses = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pSubpasses': Expected 'Array VkSubpassDescription2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "dependencyCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2KHR.dependencyCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDependencies": {
    get() {
    if (this._pDependencies === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.dependencyCount, VkSubpassDependency2);
      this._pDependencies = array;
      return this.pDependencies;
    } else {
      return this._pDependencies;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pDependencies = value;
    } else if (value === null) {
      this._pDependencies = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pDependencies': Expected 'Array VkSubpassDependency2' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "correlatedViewMaskCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassCreateInfo2KHR.correlatedViewMaskCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCorrelatedViewMasks": {
    get() {
    return this._pCorrelatedViewMasks;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCorrelatedViewMasks = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pCorrelatedViewMasks = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pCorrelatedViewMasks': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRenderPassCreateInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  
  this._pSubpasses = null;
  this._pSubpassesNative = null;
  
  this._pDependencies = null;
  this._pDependenciesNative = null;
  
  this._pCorrelatedViewMasks = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
    if (opts.pSubpasses !== void 0) this.pSubpasses = opts.pSubpasses;
    if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
    if (opts.pDependencies !== void 0) this.pDependencies = opts.pDependencies;
    if (opts.correlatedViewMaskCount !== void 0) this.correlatedViewMaskCount = opts.correlatedViewMaskCount;
    if (opts.pCorrelatedViewMasks !== void 0) this.pCorrelatedViewMasks = opts.pCorrelatedViewMasks;
    
  }
};

VkRenderPassCreateInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkRenderPassCreateInfo2KHR.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAttachmentDescription2)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pAttachments[" + ii + "]': Expected 'VkAttachmentDescription2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pSubpasses !== null) {
    let array = this._pSubpasses;
    
    if (array.length !== this.subpassCount) {
      throw new RangeError("Invalid array length, expected length of 'subpassCount' for 'VkRenderPassCreateInfo2KHR.pSubpasses'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassDescription2)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pSubpasses[" + ii + "]': Expected 'VkSubpassDescription2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSubpassesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSubpassesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pDependencies !== null) {
    let array = this._pDependencies;
    
    if (array.length !== this.dependencyCount) {
      throw new RangeError("Invalid array length, expected length of 'dependencyCount' for 'VkRenderPassCreateInfo2KHR.pDependencies'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubpassDependency2)) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pDependencies[" + ii + "]': Expected 'VkSubpassDependency2' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pDependenciesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pDependenciesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRenderPassCreateInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassCreateInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassCreateInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.attachmentCount = original.attachmentCount;
  if (original.pAttachments !== null) {
        copy.pAttachments = [...Array(original.pAttachments.length)].map((v, i) => {
          return original.pAttachments[i].constructor.createCopyFrom(original.pAttachments[i]);
        });
      }
  copy.subpassCount = original.subpassCount;
  if (original.pSubpasses !== null) {
        copy.pSubpasses = [...Array(original.pSubpasses.length)].map((v, i) => {
          return original.pSubpasses[i].constructor.createCopyFrom(original.pSubpasses[i]);
        });
      }
  copy.dependencyCount = original.dependencyCount;
  if (original.pDependencies !== null) {
        copy.pDependencies = [...Array(original.pDependencies.length)].map((v, i) => {
          return original.pDependencies[i].constructor.createCopyFrom(original.pDependencies[i]);
        });
      }
  copy.correlatedViewMaskCount = original.correlatedViewMaskCount;
  if (original.pCorrelatedViewMasks !== null) {
        copy.pCorrelatedViewMasks = new Uint32Array(original.pCorrelatedViewMasks);
      }
  
  return copy;
};

VkRenderPassCreateInfo2KHR.byteLength = 0x0;

VkRenderPassCreateInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subpassCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSubpasses: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dependencyCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDependencies: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  correlatedViewMaskCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCorrelatedViewMasks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassBeginInfo **/
function VkSubpassBeginInfo(opts, byteOffset) {
  if (new.target !== VkSubpassBeginInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassBeginInfo, STRUCT_CACHE_VkSubpassBeginInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassBeginInfo, STRUCT_CACHE_VkSubpassBeginInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassBeginInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.contents !== void 0) this.contents = opts.contents;
    
  }
};

Object.defineProperties(VkSubpassBeginInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassBeginInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassBeginInfo.pNext' isn't allowed to be filled");
    }
    },
  "contents": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassBeginInfo.contents");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSubpassBeginInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.contents !== void 0) this.contents = opts.contents;
    
  }
};

VkSubpassBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassBeginInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassBeginInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.contents = original.contents;
  
  return copy;
};

VkSubpassBeginInfo.byteLength = 0x0;

VkSubpassBeginInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  contents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassBeginInfoKHR **/
function VkSubpassBeginInfoKHR(opts, byteOffset) {
  if (new.target !== VkSubpassBeginInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassBeginInfoKHR, STRUCT_CACHE_VkSubpassBeginInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassBeginInfoKHR, STRUCT_CACHE_VkSubpassBeginInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassBeginInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.contents !== void 0) this.contents = opts.contents;
    
  }
};

Object.defineProperties(VkSubpassBeginInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassBeginInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassBeginInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "contents": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassBeginInfoKHR.contents");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSubpassBeginInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.contents !== void 0) this.contents = opts.contents;
    
  }
};

VkSubpassBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassBeginInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassBeginInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.contents = original.contents;
  
  return copy;
};

VkSubpassBeginInfoKHR.byteLength = 0x0;

VkSubpassBeginInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  contents: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassEndInfo **/
function VkSubpassEndInfo(opts, byteOffset) {
  if (new.target !== VkSubpassEndInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassEndInfo, STRUCT_CACHE_VkSubpassEndInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassEndInfo, STRUCT_CACHE_VkSubpassEndInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassEndInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSubpassEndInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassEndInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassEndInfo.pNext' isn't allowed to be filled");
    }
    },
  
});

VkSubpassEndInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSubpassEndInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassEndInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassEndInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassEndInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  
  return copy;
};

VkSubpassEndInfo.byteLength = 0x0;

VkSubpassEndInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassEndInfoKHR **/
function VkSubpassEndInfoKHR(opts, byteOffset) {
  if (new.target !== VkSubpassEndInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassEndInfoKHR, STRUCT_CACHE_VkSubpassEndInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassEndInfoKHR, STRUCT_CACHE_VkSubpassEndInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassEndInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSubpassEndInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassEndInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassEndInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  
});

VkSubpassEndInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSubpassEndInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassEndInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassEndInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassEndInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  
  return copy;
};

VkSubpassEndInfoKHR.byteLength = 0x0;

VkSubpassEndInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceTimelineSemaphoreFeatures **/
function VkPhysicalDeviceTimelineSemaphoreFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceTimelineSemaphoreFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceTimelineSemaphoreFeatures, STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphoreFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceTimelineSemaphoreFeatures, STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphoreFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceTimelineSemaphoreFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.timelineSemaphore !== void 0) this.timelineSemaphore = opts.timelineSemaphore;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTimelineSemaphoreFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceTimelineSemaphoreFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTimelineSemaphoreFeatures.pNext' isn't allowed to be filled");
    }
    },
  "timelineSemaphore": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceTimelineSemaphoreFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.timelineSemaphore !== void 0) this.timelineSemaphore = opts.timelineSemaphore;
    
  }
};

VkPhysicalDeviceTimelineSemaphoreFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTimelineSemaphoreFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceTimelineSemaphoreFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceTimelineSemaphoreFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.timelineSemaphore = original.timelineSemaphore;
  
  return copy;
};

VkPhysicalDeviceTimelineSemaphoreFeatures.byteLength = 0x0;

VkPhysicalDeviceTimelineSemaphoreFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  timelineSemaphore: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceTimelineSemaphoreFeaturesKHR **/
function VkPhysicalDeviceTimelineSemaphoreFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceTimelineSemaphoreFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceTimelineSemaphoreFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceTimelineSemaphoreFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceTimelineSemaphoreFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.timelineSemaphore !== void 0) this.timelineSemaphore = opts.timelineSemaphore;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "timelineSemaphore": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.timelineSemaphore !== void 0) this.timelineSemaphore = opts.timelineSemaphore;
    
  }
};

VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceTimelineSemaphoreFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.timelineSemaphore = original.timelineSemaphore;
  
  return copy;
};

VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceTimelineSemaphoreFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  timelineSemaphore: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceTimelineSemaphoreProperties **/
function VkPhysicalDeviceTimelineSemaphoreProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceTimelineSemaphoreProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceTimelineSemaphoreProperties, STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphoreProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceTimelineSemaphoreProperties, STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphoreProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceTimelineSemaphoreProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTimelineSemaphoreProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceTimelineSemaphoreProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTimelineSemaphoreProperties.pNext' isn't allowed to be filled");
    }
    },
  "maxTimelineSemaphoreValueDifference": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPhysicalDeviceTimelineSemaphoreProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceTimelineSemaphoreProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTimelineSemaphoreProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceTimelineSemaphoreProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceTimelineSemaphoreProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxTimelineSemaphoreValueDifference = original.maxTimelineSemaphoreValueDifference;
  
  return copy;
};

VkPhysicalDeviceTimelineSemaphoreProperties.byteLength = 0x0;

VkPhysicalDeviceTimelineSemaphoreProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTimelineSemaphoreValueDifference: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceTimelineSemaphorePropertiesKHR **/
function VkPhysicalDeviceTimelineSemaphorePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceTimelineSemaphorePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceTimelineSemaphorePropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphorePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceTimelineSemaphorePropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphorePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceTimelineSemaphorePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTimelineSemaphorePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceTimelineSemaphorePropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTimelineSemaphorePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "maxTimelineSemaphoreValueDifference": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPhysicalDeviceTimelineSemaphorePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceTimelineSemaphorePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTimelineSemaphorePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceTimelineSemaphorePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceTimelineSemaphorePropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxTimelineSemaphoreValueDifference = original.maxTimelineSemaphoreValueDifference;
  
  return copy;
};

VkPhysicalDeviceTimelineSemaphorePropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceTimelineSemaphorePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTimelineSemaphoreValueDifference: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSemaphoreTypeCreateInfo **/
function VkSemaphoreTypeCreateInfo(opts, byteOffset) {
  if (new.target !== VkSemaphoreTypeCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSemaphoreTypeCreateInfo, STRUCT_CACHE_VkSemaphoreTypeCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSemaphoreTypeCreateInfo, STRUCT_CACHE_VkSemaphoreTypeCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSemaphoreTypeCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphoreType !== void 0) this.semaphoreType = opts.semaphoreType;
    if (opts.initialValue !== void 0) this.initialValue = opts.initialValue;
    
  }
};

Object.defineProperties(VkSemaphoreTypeCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreTypeCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSemaphoreTypeCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "semaphoreType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreTypeCreateInfo.semaphoreType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "initialValue": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkSemaphoreTypeCreateInfo.initialValue")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkSemaphoreTypeCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphoreType !== void 0) this.semaphoreType = opts.semaphoreType;
    if (opts.initialValue !== void 0) this.initialValue = opts.initialValue;
    
  }
};

VkSemaphoreTypeCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreTypeCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSemaphoreTypeCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSemaphoreTypeCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.semaphoreType = original.semaphoreType;
  copy.initialValue = original.initialValue;
  
  return copy;
};

VkSemaphoreTypeCreateInfo.byteLength = 0x0;

VkSemaphoreTypeCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphoreType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  initialValue: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSemaphoreTypeCreateInfoKHR **/
function VkSemaphoreTypeCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkSemaphoreTypeCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSemaphoreTypeCreateInfoKHR, STRUCT_CACHE_VkSemaphoreTypeCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSemaphoreTypeCreateInfoKHR, STRUCT_CACHE_VkSemaphoreTypeCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSemaphoreTypeCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphoreType !== void 0) this.semaphoreType = opts.semaphoreType;
    if (opts.initialValue !== void 0) this.initialValue = opts.initialValue;
    
  }
};

Object.defineProperties(VkSemaphoreTypeCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreTypeCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSemaphoreTypeCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "semaphoreType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreTypeCreateInfoKHR.semaphoreType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "initialValue": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkSemaphoreTypeCreateInfoKHR.initialValue")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkSemaphoreTypeCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphoreType !== void 0) this.semaphoreType = opts.semaphoreType;
    if (opts.initialValue !== void 0) this.initialValue = opts.initialValue;
    
  }
};

VkSemaphoreTypeCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreTypeCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSemaphoreTypeCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSemaphoreTypeCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.semaphoreType = original.semaphoreType;
  copy.initialValue = original.initialValue;
  
  return copy;
};

VkSemaphoreTypeCreateInfoKHR.byteLength = 0x0;

VkSemaphoreTypeCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphoreType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  initialValue: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkTimelineSemaphoreSubmitInfo **/
function VkTimelineSemaphoreSubmitInfo(opts, byteOffset) {
  if (new.target !== VkTimelineSemaphoreSubmitInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkTimelineSemaphoreSubmitInfo, STRUCT_CACHE_VkTimelineSemaphoreSubmitInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkTimelineSemaphoreSubmitInfo, STRUCT_CACHE_VkTimelineSemaphoreSubmitInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkTimelineSemaphoreSubmitInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphoreValues = null;
  
  this._pSignalSemaphoreValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreValueCount !== void 0) this.waitSemaphoreValueCount = opts.waitSemaphoreValueCount;
    if (opts.pWaitSemaphoreValues !== void 0) this.pWaitSemaphoreValues = opts.pWaitSemaphoreValues;
    if (opts.signalSemaphoreValueCount !== void 0) this.signalSemaphoreValueCount = opts.signalSemaphoreValueCount;
    if (opts.pSignalSemaphoreValues !== void 0) this.pSignalSemaphoreValues = opts.pSignalSemaphoreValues;
    
  }
};

Object.defineProperties(VkTimelineSemaphoreSubmitInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkTimelineSemaphoreSubmitInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkTimelineSemaphoreSubmitInfo.pNext' isn't allowed to be filled");
    }
    },
  "waitSemaphoreValueCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkTimelineSemaphoreSubmitInfo.waitSemaphoreValueCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pWaitSemaphoreValues": {
    get() {
    return this._pWaitSemaphoreValues;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pWaitSemaphoreValues = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pWaitSemaphoreValues = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkTimelineSemaphoreSubmitInfo.pWaitSemaphoreValues': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "signalSemaphoreValueCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkTimelineSemaphoreSubmitInfo.signalSemaphoreValueCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSignalSemaphoreValues": {
    get() {
    return this._pSignalSemaphoreValues;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pSignalSemaphoreValues = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pSignalSemaphoreValues = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkTimelineSemaphoreSubmitInfo.pSignalSemaphoreValues': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkTimelineSemaphoreSubmitInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphoreValues = null;
  
  this._pSignalSemaphoreValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreValueCount !== void 0) this.waitSemaphoreValueCount = opts.waitSemaphoreValueCount;
    if (opts.pWaitSemaphoreValues !== void 0) this.pWaitSemaphoreValues = opts.pWaitSemaphoreValues;
    if (opts.signalSemaphoreValueCount !== void 0) this.signalSemaphoreValueCount = opts.signalSemaphoreValueCount;
    if (opts.pSignalSemaphoreValues !== void 0) this.pSignalSemaphoreValues = opts.pSignalSemaphoreValues;
    
  }
};

VkTimelineSemaphoreSubmitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkTimelineSemaphoreSubmitInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkTimelineSemaphoreSubmitInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkTimelineSemaphoreSubmitInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.waitSemaphoreValueCount = original.waitSemaphoreValueCount;
  if (original.pWaitSemaphoreValues !== null) {
        copy.pWaitSemaphoreValues = new BigUint64Array(original.pWaitSemaphoreValues);
      }
  copy.signalSemaphoreValueCount = original.signalSemaphoreValueCount;
  if (original.pSignalSemaphoreValues !== null) {
        copy.pSignalSemaphoreValues = new BigUint64Array(original.pSignalSemaphoreValues);
      }
  
  return copy;
};

VkTimelineSemaphoreSubmitInfo.byteLength = 0x0;

VkTimelineSemaphoreSubmitInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  waitSemaphoreValueCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pWaitSemaphoreValues: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  signalSemaphoreValueCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSignalSemaphoreValues: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkTimelineSemaphoreSubmitInfoKHR **/
function VkTimelineSemaphoreSubmitInfoKHR(opts, byteOffset) {
  if (new.target !== VkTimelineSemaphoreSubmitInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkTimelineSemaphoreSubmitInfoKHR, STRUCT_CACHE_VkTimelineSemaphoreSubmitInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkTimelineSemaphoreSubmitInfoKHR, STRUCT_CACHE_VkTimelineSemaphoreSubmitInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkTimelineSemaphoreSubmitInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pWaitSemaphoreValues = null;
  
  this._pSignalSemaphoreValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreValueCount !== void 0) this.waitSemaphoreValueCount = opts.waitSemaphoreValueCount;
    if (opts.pWaitSemaphoreValues !== void 0) this.pWaitSemaphoreValues = opts.pWaitSemaphoreValues;
    if (opts.signalSemaphoreValueCount !== void 0) this.signalSemaphoreValueCount = opts.signalSemaphoreValueCount;
    if (opts.pSignalSemaphoreValues !== void 0) this.pSignalSemaphoreValues = opts.pSignalSemaphoreValues;
    
  }
};

Object.defineProperties(VkTimelineSemaphoreSubmitInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkTimelineSemaphoreSubmitInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkTimelineSemaphoreSubmitInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "waitSemaphoreValueCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkTimelineSemaphoreSubmitInfoKHR.waitSemaphoreValueCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pWaitSemaphoreValues": {
    get() {
    return this._pWaitSemaphoreValues;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pWaitSemaphoreValues = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pWaitSemaphoreValues = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkTimelineSemaphoreSubmitInfoKHR.pWaitSemaphoreValues': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "signalSemaphoreValueCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkTimelineSemaphoreSubmitInfoKHR.signalSemaphoreValueCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSignalSemaphoreValues": {
    get() {
    return this._pSignalSemaphoreValues;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pSignalSemaphoreValues = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pSignalSemaphoreValues = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkTimelineSemaphoreSubmitInfoKHR.pSignalSemaphoreValues': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkTimelineSemaphoreSubmitInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pWaitSemaphoreValues = null;
  
  this._pSignalSemaphoreValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.waitSemaphoreValueCount !== void 0) this.waitSemaphoreValueCount = opts.waitSemaphoreValueCount;
    if (opts.pWaitSemaphoreValues !== void 0) this.pWaitSemaphoreValues = opts.pWaitSemaphoreValues;
    if (opts.signalSemaphoreValueCount !== void 0) this.signalSemaphoreValueCount = opts.signalSemaphoreValueCount;
    if (opts.pSignalSemaphoreValues !== void 0) this.pSignalSemaphoreValues = opts.pSignalSemaphoreValues;
    
  }
};

VkTimelineSemaphoreSubmitInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkTimelineSemaphoreSubmitInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkTimelineSemaphoreSubmitInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkTimelineSemaphoreSubmitInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.waitSemaphoreValueCount = original.waitSemaphoreValueCount;
  if (original.pWaitSemaphoreValues !== null) {
        copy.pWaitSemaphoreValues = new BigUint64Array(original.pWaitSemaphoreValues);
      }
  copy.signalSemaphoreValueCount = original.signalSemaphoreValueCount;
  if (original.pSignalSemaphoreValues !== null) {
        copy.pSignalSemaphoreValues = new BigUint64Array(original.pSignalSemaphoreValues);
      }
  
  return copy;
};

VkTimelineSemaphoreSubmitInfoKHR.byteLength = 0x0;

VkTimelineSemaphoreSubmitInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  waitSemaphoreValueCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pWaitSemaphoreValues: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  signalSemaphoreValueCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSignalSemaphoreValues: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSemaphoreWaitInfo **/
function VkSemaphoreWaitInfo(opts, byteOffset) {
  if (new.target !== VkSemaphoreWaitInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSemaphoreWaitInfo, STRUCT_CACHE_VkSemaphoreWaitInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSemaphoreWaitInfo, STRUCT_CACHE_VkSemaphoreWaitInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSemaphoreWaitInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pSemaphores = null;
  this._pSemaphoresNative = null;
  this._pValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.semaphoreCount !== void 0) this.semaphoreCount = opts.semaphoreCount;
    if (opts.pSemaphores !== void 0) this.pSemaphores = opts.pSemaphores;
    if (opts.pValues !== void 0) this.pValues = opts.pValues;
    
  }
};

Object.defineProperties(VkSemaphoreWaitInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreWaitInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSemaphoreWaitInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreWaitInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "semaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreWaitInfo.semaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSemaphores": {
    get() {
    if (this._pSemaphores === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.semaphoreCount, VkSemaphore);
      this._pSemaphores = array;
      return this.pSemaphores;
    } else {
      return this._pSemaphores;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSemaphores = value;
    } else if (value === null) {
      this._pSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreWaitInfo.pSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pValues": {
    get() {
    return this._pValues;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pValues = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pValues = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreWaitInfo.pValues': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSemaphoreWaitInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pSemaphores = null;
  this._pSemaphoresNative = null;
  this._pValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.semaphoreCount !== void 0) this.semaphoreCount = opts.semaphoreCount;
    if (opts.pSemaphores !== void 0) this.pSemaphores = opts.pSemaphores;
    if (opts.pValues !== void 0) this.pValues = opts.pValues;
    
  }
};

VkSemaphoreWaitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSemaphores !== null) {
    let array = this._pSemaphores;
    
    if (array.length !== this.semaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'semaphoreCount' for 'VkSemaphoreWaitInfo.pSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkSemaphoreWaitInfo.pSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSemaphoresNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSemaphoresNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSemaphoreWaitInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSemaphoreWaitInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSemaphoreWaitInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.semaphoreCount = original.semaphoreCount;
  if (original.pSemaphores !== null) {
        copy.pSemaphores = [...Array(original.pSemaphores.length)].map((v, i) => {
          return original.pSemaphores[i].constructor.createCopyFrom(original.pSemaphores[i]);
        });
      }
  if (original.pValues !== null) {
        copy.pValues = new BigUint64Array(original.pValues);
      }
  
  return copy;
};

VkSemaphoreWaitInfo.byteLength = 0x0;

VkSemaphoreWaitInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSemaphores: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pValues: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSemaphoreWaitInfoKHR **/
function VkSemaphoreWaitInfoKHR(opts, byteOffset) {
  if (new.target !== VkSemaphoreWaitInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSemaphoreWaitInfoKHR, STRUCT_CACHE_VkSemaphoreWaitInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSemaphoreWaitInfoKHR, STRUCT_CACHE_VkSemaphoreWaitInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSemaphoreWaitInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pSemaphores = null;
  this._pSemaphoresNative = null;
  this._pValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.semaphoreCount !== void 0) this.semaphoreCount = opts.semaphoreCount;
    if (opts.pSemaphores !== void 0) this.pSemaphores = opts.pSemaphores;
    if (opts.pValues !== void 0) this.pValues = opts.pValues;
    
  }
};

Object.defineProperties(VkSemaphoreWaitInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreWaitInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSemaphoreWaitInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreWaitInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "semaphoreCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreWaitInfoKHR.semaphoreCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSemaphores": {
    get() {
    if (this._pSemaphores === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.semaphoreCount, VkSemaphore);
      this._pSemaphores = array;
      return this.pSemaphores;
    } else {
      return this._pSemaphores;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSemaphores = value;
    } else if (value === null) {
      this._pSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreWaitInfoKHR.pSemaphores': Expected 'Array VkSemaphore' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "pValues": {
    get() {
    return this._pValues;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pValues = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pValues = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreWaitInfoKHR.pValues': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSemaphoreWaitInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pSemaphores = null;
  this._pSemaphoresNative = null;
  this._pValues = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.semaphoreCount !== void 0) this.semaphoreCount = opts.semaphoreCount;
    if (opts.pSemaphores !== void 0) this.pSemaphores = opts.pSemaphores;
    if (opts.pValues !== void 0) this.pValues = opts.pValues;
    
  }
};

VkSemaphoreWaitInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSemaphores !== null) {
    let array = this._pSemaphores;
    
    if (array.length !== this.semaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'semaphoreCount' for 'VkSemaphoreWaitInfoKHR.pSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSemaphore)) {
        throw new TypeError("Invalid type for 'VkSemaphoreWaitInfoKHR.pSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSemaphoresNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSemaphoresNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkSemaphoreWaitInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSemaphoreWaitInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSemaphoreWaitInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.semaphoreCount = original.semaphoreCount;
  if (original.pSemaphores !== null) {
        copy.pSemaphores = [...Array(original.pSemaphores.length)].map((v, i) => {
          return original.pSemaphores[i].constructor.createCopyFrom(original.pSemaphores[i]);
        });
      }
  if (original.pValues !== null) {
        copy.pValues = new BigUint64Array(original.pValues);
      }
  
  return copy;
};

VkSemaphoreWaitInfoKHR.byteLength = 0x0;

VkSemaphoreWaitInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphoreCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSemaphores: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pValues: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSemaphoreSignalInfo **/
function VkSemaphoreSignalInfo(opts, byteOffset) {
  if (new.target !== VkSemaphoreSignalInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSemaphoreSignalInfo, STRUCT_CACHE_VkSemaphoreSignalInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSemaphoreSignalInfo, STRUCT_CACHE_VkSemaphoreSignalInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSemaphoreSignalInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.value !== void 0) this.value = opts.value;
    
  }
};

Object.defineProperties(VkSemaphoreSignalInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreSignalInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSemaphoreSignalInfo.pNext' isn't allowed to be filled");
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._semaphore = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreSignalInfo.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "value": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkSemaphoreSignalInfo.value")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkSemaphoreSignalInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.value !== void 0) this.value = opts.value;
    
  }
};

VkSemaphoreSignalInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreSignalInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkSemaphoreSignalInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSemaphoreSignalInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.semaphore !== null) {
        copy.semaphore = original.semaphore.constructor.createCopyFrom(original.semaphore);
      }
  copy.value = original.value;
  
  return copy;
};

VkSemaphoreSignalInfo.byteLength = 0x0;

VkSemaphoreSignalInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphore: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  value: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSemaphoreSignalInfoKHR **/
function VkSemaphoreSignalInfoKHR(opts, byteOffset) {
  if (new.target !== VkSemaphoreSignalInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSemaphoreSignalInfoKHR, STRUCT_CACHE_VkSemaphoreSignalInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSemaphoreSignalInfoKHR, STRUCT_CACHE_VkSemaphoreSignalInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSemaphoreSignalInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.value !== void 0) this.value = opts.value;
    
  }
};

Object.defineProperties(VkSemaphoreSignalInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSemaphoreSignalInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSemaphoreSignalInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "semaphore": {
    get() {
    return this._semaphore;
    },
    set(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._semaphore = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreSignalInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "value": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkSemaphoreSignalInfoKHR.value")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkSemaphoreSignalInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._semaphore = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
    if (opts.value !== void 0) this.value = opts.value;
    
  }
};

VkSemaphoreSignalInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreSignalInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSemaphoreSignalInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSemaphoreSignalInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.semaphore !== null) {
        copy.semaphore = original.semaphore.constructor.createCopyFrom(original.semaphore);
      }
  copy.value = original.value;
  
  return copy;
};

VkSemaphoreSignalInfoKHR.byteLength = 0x0;

VkSemaphoreSignalInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  semaphore: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  value: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkVertexInputBindingDivisorDescriptionEXT **/
function VkVertexInputBindingDivisorDescriptionEXT(opts, byteOffset) {
  if (new.target !== VkVertexInputBindingDivisorDescriptionEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkVertexInputBindingDivisorDescriptionEXT, STRUCT_CACHE_VkVertexInputBindingDivisorDescriptionEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkVertexInputBindingDivisorDescriptionEXT, STRUCT_CACHE_VkVertexInputBindingDivisorDescriptionEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkVertexInputBindingDivisorDescriptionEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.divisor !== void 0) this.divisor = opts.divisor;
    
  }
};

Object.defineProperties(VkVertexInputBindingDivisorDescriptionEXT.prototype, {
  "binding": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkVertexInputBindingDivisorDescriptionEXT.binding");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "divisor": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkVertexInputBindingDivisorDescriptionEXT.divisor");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkVertexInputBindingDivisorDescriptionEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.binding !== void 0) this.binding = opts.binding;
    if (opts.divisor !== void 0) this.divisor = opts.divisor;
    
  }
};

VkVertexInputBindingDivisorDescriptionEXT.prototype.flush = function flush() {
  
  return true;
};

VkVertexInputBindingDivisorDescriptionEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkVertexInputBindingDivisorDescriptionEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkVertexInputBindingDivisorDescriptionEXT();
  copy.binding = original.binding;
  copy.divisor = original.divisor;
  
  return copy;
};

VkVertexInputBindingDivisorDescriptionEXT.byteLength = 0x0;

VkVertexInputBindingDivisorDescriptionEXT.memoryLayout = {
  binding: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  divisor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineVertexInputDivisorStateCreateInfoEXT **/
function VkPipelineVertexInputDivisorStateCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPipelineVertexInputDivisorStateCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineVertexInputDivisorStateCreateInfoEXT, STRUCT_CACHE_VkPipelineVertexInputDivisorStateCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineVertexInputDivisorStateCreateInfoEXT, STRUCT_CACHE_VkPipelineVertexInputDivisorStateCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineVertexInputDivisorStateCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pVertexBindingDivisors = null;
  this._pVertexBindingDivisorsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexBindingDivisorCount !== void 0) this.vertexBindingDivisorCount = opts.vertexBindingDivisorCount;
    if (opts.pVertexBindingDivisors !== void 0) this.pVertexBindingDivisors = opts.pVertexBindingDivisors;
    
  }
};

Object.defineProperties(VkPipelineVertexInputDivisorStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineVertexInputDivisorStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "vertexBindingDivisorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.vertexBindingDivisorCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pVertexBindingDivisors": {
    get() {
    if (this._pVertexBindingDivisors === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.vertexBindingDivisorCount, VkVertexInputBindingDivisorDescriptionEXT);
      this._pVertexBindingDivisors = array;
      return this.pVertexBindingDivisors;
    } else {
      return this._pVertexBindingDivisors;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pVertexBindingDivisors = value;
    } else if (value === null) {
      this._pVertexBindingDivisors = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors': Expected 'Array VkVertexInputBindingDivisorDescriptionEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineVertexInputDivisorStateCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pVertexBindingDivisors = null;
  this._pVertexBindingDivisorsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexBindingDivisorCount !== void 0) this.vertexBindingDivisorCount = opts.vertexBindingDivisorCount;
    if (opts.pVertexBindingDivisors !== void 0) this.pVertexBindingDivisors = opts.pVertexBindingDivisors;
    
  }
};

VkPipelineVertexInputDivisorStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pVertexBindingDivisors !== null) {
    let array = this._pVertexBindingDivisors;
    
    if (array.length !== this.vertexBindingDivisorCount) {
      throw new RangeError("Invalid array length, expected length of 'vertexBindingDivisorCount' for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkVertexInputBindingDivisorDescriptionEXT)) {
        throw new TypeError("Invalid type for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors[" + ii + "]': Expected 'VkVertexInputBindingDivisorDescriptionEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pVertexBindingDivisorsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pVertexBindingDivisorsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineVertexInputDivisorStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineVertexInputDivisorStateCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineVertexInputDivisorStateCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.vertexBindingDivisorCount = original.vertexBindingDivisorCount;
  if (original.pVertexBindingDivisors !== null) {
        copy.pVertexBindingDivisors = [...Array(original.pVertexBindingDivisors.length)].map((v, i) => {
          return original.pVertexBindingDivisors[i].constructor.createCopyFrom(original.pVertexBindingDivisors[i]);
        });
      }
  
  return copy;
};

VkPipelineVertexInputDivisorStateCreateInfoEXT.byteLength = 0x0;

VkPipelineVertexInputDivisorStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexBindingDivisorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pVertexBindingDivisors: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT **/
function VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxVertexAttribDivisor": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxVertexAttribDivisor = original.maxVertexAttribDivisor;
  
  return copy;
};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxVertexAttribDivisor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevicePCIBusInfoPropertiesEXT **/
function VkPhysicalDevicePCIBusInfoPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDevicePCIBusInfoPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevicePCIBusInfoPropertiesEXT, STRUCT_CACHE_VkPhysicalDevicePCIBusInfoPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevicePCIBusInfoPropertiesEXT, STRUCT_CACHE_VkPhysicalDevicePCIBusInfoPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevicePCIBusInfoPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDevicePCIBusInfoPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevicePCIBusInfoPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePCIBusInfoPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "pciDomain": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "pciBus": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "pciDevice": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "pciFunction": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDevicePCIBusInfoPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDevicePCIBusInfoPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePCIBusInfoPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDevicePCIBusInfoPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevicePCIBusInfoPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pciDomain = original.pciDomain;
  copy.pciBus = original.pciBus;
  copy.pciDevice = original.pciDevice;
  copy.pciFunction = original.pciFunction;
  
  return copy;
};

VkPhysicalDevicePCIBusInfoPropertiesEXT.byteLength = 0x0;

VkPhysicalDevicePCIBusInfoPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pciDomain: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pciBus: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pciDevice: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pciFunction: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCommandBufferInheritanceConditionalRenderingInfoEXT **/
function VkCommandBufferInheritanceConditionalRenderingInfoEXT(opts, byteOffset) {
  if (new.target !== VkCommandBufferInheritanceConditionalRenderingInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCommandBufferInheritanceConditionalRenderingInfoEXT, STRUCT_CACHE_VkCommandBufferInheritanceConditionalRenderingInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCommandBufferInheritanceConditionalRenderingInfoEXT, STRUCT_CACHE_VkCommandBufferInheritanceConditionalRenderingInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCommandBufferInheritanceConditionalRenderingInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conditionalRenderingEnable !== void 0) this.conditionalRenderingEnable = opts.conditionalRenderingEnable;
    
  }
};

Object.defineProperties(VkCommandBufferInheritanceConditionalRenderingInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferInheritanceConditionalRenderingInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCommandBufferInheritanceConditionalRenderingInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "conditionalRenderingEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkCommandBufferInheritanceConditionalRenderingInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conditionalRenderingEnable !== void 0) this.conditionalRenderingEnable = opts.conditionalRenderingEnable;
    
  }
};

VkCommandBufferInheritanceConditionalRenderingInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferInheritanceConditionalRenderingInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkCommandBufferInheritanceConditionalRenderingInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCommandBufferInheritanceConditionalRenderingInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.conditionalRenderingEnable = original.conditionalRenderingEnable;
  
  return copy;
};

VkCommandBufferInheritanceConditionalRenderingInfoEXT.byteLength = 0x0;

VkCommandBufferInheritanceConditionalRenderingInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  conditionalRenderingEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevice8BitStorageFeatures **/
function VkPhysicalDevice8BitStorageFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDevice8BitStorageFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevice8BitStorageFeatures, STRUCT_CACHE_VkPhysicalDevice8BitStorageFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevice8BitStorageFeatures, STRUCT_CACHE_VkPhysicalDevice8BitStorageFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevice8BitStorageFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer8BitAccess !== void 0) this.storageBuffer8BitAccess = opts.storageBuffer8BitAccess;
    if (opts.uniformAndStorageBuffer8BitAccess !== void 0) this.uniformAndStorageBuffer8BitAccess = opts.uniformAndStorageBuffer8BitAccess;
    if (opts.storagePushConstant8 !== void 0) this.storagePushConstant8 = opts.storagePushConstant8;
    
  }
};

Object.defineProperties(VkPhysicalDevice8BitStorageFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevice8BitStorageFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevice8BitStorageFeatures.pNext' isn't allowed to be filled");
    }
    },
  "storageBuffer8BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "uniformAndStorageBuffer8BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "storagePushConstant8": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDevice8BitStorageFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer8BitAccess !== void 0) this.storageBuffer8BitAccess = opts.storageBuffer8BitAccess;
    if (opts.uniformAndStorageBuffer8BitAccess !== void 0) this.uniformAndStorageBuffer8BitAccess = opts.uniformAndStorageBuffer8BitAccess;
    if (opts.storagePushConstant8 !== void 0) this.storagePushConstant8 = opts.storagePushConstant8;
    
  }
};

VkPhysicalDevice8BitStorageFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice8BitStorageFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDevice8BitStorageFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevice8BitStorageFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.storageBuffer8BitAccess = original.storageBuffer8BitAccess;
  copy.uniformAndStorageBuffer8BitAccess = original.uniformAndStorageBuffer8BitAccess;
  copy.storagePushConstant8 = original.storagePushConstant8;
  
  return copy;
};

VkPhysicalDevice8BitStorageFeatures.byteLength = 0x0;

VkPhysicalDevice8BitStorageFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageBuffer8BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformAndStorageBuffer8BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storagePushConstant8: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevice8BitStorageFeaturesKHR **/
function VkPhysicalDevice8BitStorageFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDevice8BitStorageFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevice8BitStorageFeaturesKHR, STRUCT_CACHE_VkPhysicalDevice8BitStorageFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevice8BitStorageFeaturesKHR, STRUCT_CACHE_VkPhysicalDevice8BitStorageFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevice8BitStorageFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer8BitAccess !== void 0) this.storageBuffer8BitAccess = opts.storageBuffer8BitAccess;
    if (opts.uniformAndStorageBuffer8BitAccess !== void 0) this.uniformAndStorageBuffer8BitAccess = opts.uniformAndStorageBuffer8BitAccess;
    if (opts.storagePushConstant8 !== void 0) this.storagePushConstant8 = opts.storagePushConstant8;
    
  }
};

Object.defineProperties(VkPhysicalDevice8BitStorageFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevice8BitStorageFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevice8BitStorageFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "storageBuffer8BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "uniformAndStorageBuffer8BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "storagePushConstant8": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDevice8BitStorageFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer8BitAccess !== void 0) this.storageBuffer8BitAccess = opts.storageBuffer8BitAccess;
    if (opts.uniformAndStorageBuffer8BitAccess !== void 0) this.uniformAndStorageBuffer8BitAccess = opts.uniformAndStorageBuffer8BitAccess;
    if (opts.storagePushConstant8 !== void 0) this.storagePushConstant8 = opts.storagePushConstant8;
    
  }
};

VkPhysicalDevice8BitStorageFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice8BitStorageFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDevice8BitStorageFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevice8BitStorageFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.storageBuffer8BitAccess = original.storageBuffer8BitAccess;
  copy.uniformAndStorageBuffer8BitAccess = original.uniformAndStorageBuffer8BitAccess;
  copy.storagePushConstant8 = original.storagePushConstant8;
  
  return copy;
};

VkPhysicalDevice8BitStorageFeaturesKHR.byteLength = 0x0;

VkPhysicalDevice8BitStorageFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageBuffer8BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformAndStorageBuffer8BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storagePushConstant8: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceConditionalRenderingFeaturesEXT **/
function VkPhysicalDeviceConditionalRenderingFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceConditionalRenderingFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceConditionalRenderingFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceConditionalRenderingFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceConditionalRenderingFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceConditionalRenderingFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceConditionalRenderingFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conditionalRendering !== void 0) this.conditionalRendering = opts.conditionalRendering;
    if (opts.inheritedConditionalRendering !== void 0) this.inheritedConditionalRendering = opts.inheritedConditionalRendering;
    
  }
};

Object.defineProperties(VkPhysicalDeviceConditionalRenderingFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceConditionalRenderingFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceConditionalRenderingFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "conditionalRendering": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "inheritedConditionalRendering": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceConditionalRenderingFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.conditionalRendering !== void 0) this.conditionalRendering = opts.conditionalRendering;
    if (opts.inheritedConditionalRendering !== void 0) this.inheritedConditionalRendering = opts.inheritedConditionalRendering;
    
  }
};

VkPhysicalDeviceConditionalRenderingFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceConditionalRenderingFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceConditionalRenderingFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceConditionalRenderingFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.conditionalRendering = original.conditionalRendering;
  copy.inheritedConditionalRendering = original.inheritedConditionalRendering;
  
  return copy;
};

VkPhysicalDeviceConditionalRenderingFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceConditionalRenderingFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  conditionalRendering: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  inheritedConditionalRendering: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVulkanMemoryModelFeatures **/
function VkPhysicalDeviceVulkanMemoryModelFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVulkanMemoryModelFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVulkanMemoryModelFeatures, STRUCT_CACHE_VkPhysicalDeviceVulkanMemoryModelFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVulkanMemoryModelFeatures, STRUCT_CACHE_VkPhysicalDeviceVulkanMemoryModelFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVulkanMemoryModelFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vulkanMemoryModel !== void 0) this.vulkanMemoryModel = opts.vulkanMemoryModel;
    if (opts.vulkanMemoryModelDeviceScope !== void 0) this.vulkanMemoryModelDeviceScope = opts.vulkanMemoryModelDeviceScope;
    if (opts.vulkanMemoryModelAvailabilityVisibilityChains !== void 0) this.vulkanMemoryModelAvailabilityVisibilityChains = opts.vulkanMemoryModelAvailabilityVisibilityChains;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVulkanMemoryModelFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVulkanMemoryModelFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVulkanMemoryModelFeatures.pNext' isn't allowed to be filled");
    }
    },
  "vulkanMemoryModel": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "vulkanMemoryModelDeviceScope": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "vulkanMemoryModelAvailabilityVisibilityChains": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceVulkanMemoryModelFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vulkanMemoryModel !== void 0) this.vulkanMemoryModel = opts.vulkanMemoryModel;
    if (opts.vulkanMemoryModelDeviceScope !== void 0) this.vulkanMemoryModelDeviceScope = opts.vulkanMemoryModelDeviceScope;
    if (opts.vulkanMemoryModelAvailabilityVisibilityChains !== void 0) this.vulkanMemoryModelAvailabilityVisibilityChains = opts.vulkanMemoryModelAvailabilityVisibilityChains;
    
  }
};

VkPhysicalDeviceVulkanMemoryModelFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVulkanMemoryModelFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceVulkanMemoryModelFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVulkanMemoryModelFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.vulkanMemoryModel = original.vulkanMemoryModel;
  copy.vulkanMemoryModelDeviceScope = original.vulkanMemoryModelDeviceScope;
  copy.vulkanMemoryModelAvailabilityVisibilityChains = original.vulkanMemoryModelAvailabilityVisibilityChains;
  
  return copy;
};

VkPhysicalDeviceVulkanMemoryModelFeatures.byteLength = 0x0;

VkPhysicalDeviceVulkanMemoryModelFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vulkanMemoryModel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vulkanMemoryModelDeviceScope: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vulkanMemoryModelAvailabilityVisibilityChains: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVulkanMemoryModelFeaturesKHR **/
function VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVulkanMemoryModelFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVulkanMemoryModelFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vulkanMemoryModel !== void 0) this.vulkanMemoryModel = opts.vulkanMemoryModel;
    if (opts.vulkanMemoryModelDeviceScope !== void 0) this.vulkanMemoryModelDeviceScope = opts.vulkanMemoryModelDeviceScope;
    if (opts.vulkanMemoryModelAvailabilityVisibilityChains !== void 0) this.vulkanMemoryModelAvailabilityVisibilityChains = opts.vulkanMemoryModelAvailabilityVisibilityChains;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "vulkanMemoryModel": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "vulkanMemoryModelDeviceScope": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "vulkanMemoryModelAvailabilityVisibilityChains": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vulkanMemoryModel !== void 0) this.vulkanMemoryModel = opts.vulkanMemoryModel;
    if (opts.vulkanMemoryModelDeviceScope !== void 0) this.vulkanMemoryModelDeviceScope = opts.vulkanMemoryModelDeviceScope;
    if (opts.vulkanMemoryModelAvailabilityVisibilityChains !== void 0) this.vulkanMemoryModelAvailabilityVisibilityChains = opts.vulkanMemoryModelAvailabilityVisibilityChains;
    
  }
};

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVulkanMemoryModelFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.vulkanMemoryModel = original.vulkanMemoryModel;
  copy.vulkanMemoryModelDeviceScope = original.vulkanMemoryModelDeviceScope;
  copy.vulkanMemoryModelAvailabilityVisibilityChains = original.vulkanMemoryModelAvailabilityVisibilityChains;
  
  return copy;
};

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vulkanMemoryModel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vulkanMemoryModelDeviceScope: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vulkanMemoryModelAvailabilityVisibilityChains: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderAtomicInt64Features **/
function VkPhysicalDeviceShaderAtomicInt64Features(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderAtomicInt64Features) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderAtomicInt64Features, STRUCT_CACHE_VkPhysicalDeviceShaderAtomicInt64Features);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderAtomicInt64Features, STRUCT_CACHE_VkPhysicalDeviceShaderAtomicInt64Features);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderAtomicInt64Features'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderBufferInt64Atomics !== void 0) this.shaderBufferInt64Atomics = opts.shaderBufferInt64Atomics;
    if (opts.shaderSharedInt64Atomics !== void 0) this.shaderSharedInt64Atomics = opts.shaderSharedInt64Atomics;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderAtomicInt64Features.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderAtomicInt64Features.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderAtomicInt64Features.pNext' isn't allowed to be filled");
    }
    },
  "shaderBufferInt64Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSharedInt64Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderAtomicInt64Features.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderBufferInt64Atomics !== void 0) this.shaderBufferInt64Atomics = opts.shaderBufferInt64Atomics;
    if (opts.shaderSharedInt64Atomics !== void 0) this.shaderSharedInt64Atomics = opts.shaderSharedInt64Atomics;
    
  }
};

VkPhysicalDeviceShaderAtomicInt64Features.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderAtomicInt64Features.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderAtomicInt64Features.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderAtomicInt64Features();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderBufferInt64Atomics = original.shaderBufferInt64Atomics;
  copy.shaderSharedInt64Atomics = original.shaderSharedInt64Atomics;
  
  return copy;
};

VkPhysicalDeviceShaderAtomicInt64Features.byteLength = 0x0;

VkPhysicalDeviceShaderAtomicInt64Features.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderBufferInt64Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSharedInt64Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderAtomicInt64FeaturesKHR **/
function VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderAtomicInt64FeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderAtomicInt64FeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderBufferInt64Atomics !== void 0) this.shaderBufferInt64Atomics = opts.shaderBufferInt64Atomics;
    if (opts.shaderSharedInt64Atomics !== void 0) this.shaderSharedInt64Atomics = opts.shaderSharedInt64Atomics;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "shaderBufferInt64Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSharedInt64Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderBufferInt64Atomics !== void 0) this.shaderBufferInt64Atomics = opts.shaderBufferInt64Atomics;
    if (opts.shaderSharedInt64Atomics !== void 0) this.shaderSharedInt64Atomics = opts.shaderSharedInt64Atomics;
    
  }
};

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderAtomicInt64FeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderBufferInt64Atomics = original.shaderBufferInt64Atomics;
  copy.shaderSharedInt64Atomics = original.shaderSharedInt64Atomics;
  
  return copy;
};

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderBufferInt64Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSharedInt64Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderAtomicFloatFeaturesEXT **/
function VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderAtomicFloatFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderAtomicFloatFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderBufferFloat32Atomics !== void 0) this.shaderBufferFloat32Atomics = opts.shaderBufferFloat32Atomics;
    if (opts.shaderBufferFloat32AtomicAdd !== void 0) this.shaderBufferFloat32AtomicAdd = opts.shaderBufferFloat32AtomicAdd;
    if (opts.shaderBufferFloat64Atomics !== void 0) this.shaderBufferFloat64Atomics = opts.shaderBufferFloat64Atomics;
    if (opts.shaderBufferFloat64AtomicAdd !== void 0) this.shaderBufferFloat64AtomicAdd = opts.shaderBufferFloat64AtomicAdd;
    if (opts.shaderSharedFloat32Atomics !== void 0) this.shaderSharedFloat32Atomics = opts.shaderSharedFloat32Atomics;
    if (opts.shaderSharedFloat32AtomicAdd !== void 0) this.shaderSharedFloat32AtomicAdd = opts.shaderSharedFloat32AtomicAdd;
    if (opts.shaderSharedFloat64Atomics !== void 0) this.shaderSharedFloat64Atomics = opts.shaderSharedFloat64Atomics;
    if (opts.shaderSharedFloat64AtomicAdd !== void 0) this.shaderSharedFloat64AtomicAdd = opts.shaderSharedFloat64AtomicAdd;
    if (opts.shaderImageFloat32Atomics !== void 0) this.shaderImageFloat32Atomics = opts.shaderImageFloat32Atomics;
    if (opts.shaderImageFloat32AtomicAdd !== void 0) this.shaderImageFloat32AtomicAdd = opts.shaderImageFloat32AtomicAdd;
    if (opts.sparseImageFloat32Atomics !== void 0) this.sparseImageFloat32Atomics = opts.sparseImageFloat32Atomics;
    if (opts.sparseImageFloat32AtomicAdd !== void 0) this.sparseImageFloat32AtomicAdd = opts.sparseImageFloat32AtomicAdd;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "shaderBufferFloat32Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderBufferFloat32AtomicAdd": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderBufferFloat64Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderBufferFloat64AtomicAdd": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSharedFloat32Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSharedFloat32AtomicAdd": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSharedFloat64Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSharedFloat64AtomicAdd": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderImageFloat32Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderImageFloat32AtomicAdd": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseImageFloat32Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseImageFloat32AtomicAdd": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderBufferFloat32Atomics !== void 0) this.shaderBufferFloat32Atomics = opts.shaderBufferFloat32Atomics;
    if (opts.shaderBufferFloat32AtomicAdd !== void 0) this.shaderBufferFloat32AtomicAdd = opts.shaderBufferFloat32AtomicAdd;
    if (opts.shaderBufferFloat64Atomics !== void 0) this.shaderBufferFloat64Atomics = opts.shaderBufferFloat64Atomics;
    if (opts.shaderBufferFloat64AtomicAdd !== void 0) this.shaderBufferFloat64AtomicAdd = opts.shaderBufferFloat64AtomicAdd;
    if (opts.shaderSharedFloat32Atomics !== void 0) this.shaderSharedFloat32Atomics = opts.shaderSharedFloat32Atomics;
    if (opts.shaderSharedFloat32AtomicAdd !== void 0) this.shaderSharedFloat32AtomicAdd = opts.shaderSharedFloat32AtomicAdd;
    if (opts.shaderSharedFloat64Atomics !== void 0) this.shaderSharedFloat64Atomics = opts.shaderSharedFloat64Atomics;
    if (opts.shaderSharedFloat64AtomicAdd !== void 0) this.shaderSharedFloat64AtomicAdd = opts.shaderSharedFloat64AtomicAdd;
    if (opts.shaderImageFloat32Atomics !== void 0) this.shaderImageFloat32Atomics = opts.shaderImageFloat32Atomics;
    if (opts.shaderImageFloat32AtomicAdd !== void 0) this.shaderImageFloat32AtomicAdd = opts.shaderImageFloat32AtomicAdd;
    if (opts.sparseImageFloat32Atomics !== void 0) this.sparseImageFloat32Atomics = opts.sparseImageFloat32Atomics;
    if (opts.sparseImageFloat32AtomicAdd !== void 0) this.sparseImageFloat32AtomicAdd = opts.sparseImageFloat32AtomicAdd;
    
  }
};

VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderAtomicFloatFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderBufferFloat32Atomics = original.shaderBufferFloat32Atomics;
  copy.shaderBufferFloat32AtomicAdd = original.shaderBufferFloat32AtomicAdd;
  copy.shaderBufferFloat64Atomics = original.shaderBufferFloat64Atomics;
  copy.shaderBufferFloat64AtomicAdd = original.shaderBufferFloat64AtomicAdd;
  copy.shaderSharedFloat32Atomics = original.shaderSharedFloat32Atomics;
  copy.shaderSharedFloat32AtomicAdd = original.shaderSharedFloat32AtomicAdd;
  copy.shaderSharedFloat64Atomics = original.shaderSharedFloat64Atomics;
  copy.shaderSharedFloat64AtomicAdd = original.shaderSharedFloat64AtomicAdd;
  copy.shaderImageFloat32Atomics = original.shaderImageFloat32Atomics;
  copy.shaderImageFloat32AtomicAdd = original.shaderImageFloat32AtomicAdd;
  copy.sparseImageFloat32Atomics = original.sparseImageFloat32Atomics;
  copy.sparseImageFloat32AtomicAdd = original.sparseImageFloat32AtomicAdd;
  
  return copy;
};

VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderBufferFloat32Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderBufferFloat32AtomicAdd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderBufferFloat64Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderBufferFloat64AtomicAdd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSharedFloat32Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSharedFloat32AtomicAdd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSharedFloat64Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSharedFloat64AtomicAdd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderImageFloat32Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderImageFloat32AtomicAdd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseImageFloat32Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseImageFloat32AtomicAdd: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT **/
function VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexAttributeInstanceRateDivisor !== void 0) this.vertexAttributeInstanceRateDivisor = opts.vertexAttributeInstanceRateDivisor;
    if (opts.vertexAttributeInstanceRateZeroDivisor !== void 0) this.vertexAttributeInstanceRateZeroDivisor = opts.vertexAttributeInstanceRateZeroDivisor;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "vertexAttributeInstanceRateDivisor": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "vertexAttributeInstanceRateZeroDivisor": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexAttributeInstanceRateDivisor !== void 0) this.vertexAttributeInstanceRateDivisor = opts.vertexAttributeInstanceRateDivisor;
    if (opts.vertexAttributeInstanceRateZeroDivisor !== void 0) this.vertexAttributeInstanceRateZeroDivisor = opts.vertexAttributeInstanceRateZeroDivisor;
    
  }
};

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.vertexAttributeInstanceRateDivisor = original.vertexAttributeInstanceRateDivisor;
  copy.vertexAttributeInstanceRateZeroDivisor = original.vertexAttributeInstanceRateZeroDivisor;
  
  return copy;
};

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexAttributeInstanceRateDivisor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexAttributeInstanceRateZeroDivisor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkQueueFamilyCheckpointPropertiesNV **/
function VkQueueFamilyCheckpointPropertiesNV(opts, byteOffset) {
  if (new.target !== VkQueueFamilyCheckpointPropertiesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkQueueFamilyCheckpointPropertiesNV, STRUCT_CACHE_VkQueueFamilyCheckpointPropertiesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkQueueFamilyCheckpointPropertiesNV, STRUCT_CACHE_VkQueueFamilyCheckpointPropertiesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkQueueFamilyCheckpointPropertiesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkQueueFamilyCheckpointPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueueFamilyCheckpointPropertiesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkQueueFamilyCheckpointPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "checkpointExecutionStageMask": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkQueueFamilyCheckpointPropertiesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkQueueFamilyCheckpointPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueueFamilyCheckpointPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkQueueFamilyCheckpointPropertiesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkQueueFamilyCheckpointPropertiesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.checkpointExecutionStageMask = original.checkpointExecutionStageMask;
  
  return copy;
};

VkQueueFamilyCheckpointPropertiesNV.byteLength = 0x0;

VkQueueFamilyCheckpointPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  checkpointExecutionStageMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCheckpointDataNV **/
function VkCheckpointDataNV(opts, byteOffset) {
  if (new.target !== VkCheckpointDataNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCheckpointDataNV, STRUCT_CACHE_VkCheckpointDataNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCheckpointDataNV, STRUCT_CACHE_VkCheckpointDataNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCheckpointDataNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pCheckpointMarker = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pCheckpointMarker !== void 0) this.pCheckpointMarker = opts.pCheckpointMarker;
    
  }
};

Object.defineProperties(VkCheckpointDataNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCheckpointDataNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCheckpointDataNV.pNext' isn't allowed to be filled");
    }
    },
  "stage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "pCheckpointMarker": {
    get() {
    return this._pCheckpointMarker;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pCheckpointMarker = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pCheckpointMarker = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCheckpointDataNV.pCheckpointMarker': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkCheckpointDataNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pCheckpointMarker = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pCheckpointMarker !== void 0) this.pCheckpointMarker = opts.pCheckpointMarker;
    
  }
};

VkCheckpointDataNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCheckpointDataNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkCheckpointDataNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCheckpointDataNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.stage = original.stage;
  if (original.pCheckpointMarker !== null) {
      let buf = new ArrayBuffer(original.pCheckpointMarker.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pCheckpointMarker), 0x0);
      copy.pCheckpointMarker = buf;
    }
  
  return copy;
};

VkCheckpointDataNV.byteLength = 0x0;

VkCheckpointDataNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCheckpointMarker: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDepthStencilResolveProperties **/
function VkPhysicalDeviceDepthStencilResolveProperties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDepthStencilResolveProperties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDepthStencilResolveProperties, STRUCT_CACHE_VkPhysicalDeviceDepthStencilResolveProperties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDepthStencilResolveProperties, STRUCT_CACHE_VkPhysicalDeviceDepthStencilResolveProperties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDepthStencilResolveProperties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDepthStencilResolveProperties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDepthStencilResolveProperties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDepthStencilResolveProperties.pNext' isn't allowed to be filled");
    }
    },
  "supportedDepthResolveModes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "supportedStencilResolveModes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "independentResolveNone": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "independentResolve": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceDepthStencilResolveProperties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceDepthStencilResolveProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDepthStencilResolveProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceDepthStencilResolveProperties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDepthStencilResolveProperties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.supportedDepthResolveModes = original.supportedDepthResolveModes;
  copy.supportedStencilResolveModes = original.supportedStencilResolveModes;
  copy.independentResolveNone = original.independentResolveNone;
  copy.independentResolve = original.independentResolve;
  
  return copy;
};

VkPhysicalDeviceDepthStencilResolveProperties.byteLength = 0x0;

VkPhysicalDeviceDepthStencilResolveProperties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedDepthResolveModes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedStencilResolveModes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  independentResolveNone: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  independentResolve: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDepthStencilResolvePropertiesKHR **/
function VkPhysicalDeviceDepthStencilResolvePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDepthStencilResolvePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDepthStencilResolvePropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceDepthStencilResolvePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDepthStencilResolvePropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceDepthStencilResolvePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDepthStencilResolvePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDepthStencilResolvePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDepthStencilResolvePropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDepthStencilResolvePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "supportedDepthResolveModes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "supportedStencilResolveModes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "independentResolveNone": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "independentResolve": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDepthStencilResolvePropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.supportedDepthResolveModes = original.supportedDepthResolveModes;
  copy.supportedStencilResolveModes = original.supportedStencilResolveModes;
  copy.independentResolveNone = original.independentResolveNone;
  copy.independentResolve = original.independentResolve;
  
  return copy;
};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedDepthResolveModes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedStencilResolveModes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  independentResolveNone: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  independentResolve: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassDescriptionDepthStencilResolve **/
function VkSubpassDescriptionDepthStencilResolve(opts, byteOffset) {
  if (new.target !== VkSubpassDescriptionDepthStencilResolve) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassDescriptionDepthStencilResolve, STRUCT_CACHE_VkSubpassDescriptionDepthStencilResolve);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassDescriptionDepthStencilResolve, STRUCT_CACHE_VkSubpassDescriptionDepthStencilResolve);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassDescriptionDepthStencilResolve'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pDepthStencilResolveAttachment = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.depthResolveMode !== void 0) this.depthResolveMode = opts.depthResolveMode;
    if (opts.stencilResolveMode !== void 0) this.stencilResolveMode = opts.stencilResolveMode;
    if (opts.pDepthStencilResolveAttachment !== void 0) this.pDepthStencilResolveAttachment = opts.pDepthStencilResolveAttachment;
    
  }
};

Object.defineProperties(VkSubpassDescriptionDepthStencilResolve.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescriptionDepthStencilResolve.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassDescriptionDepthStencilResolve.pNext' isn't allowed to be filled");
    }
    },
  "depthResolveMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescriptionDepthStencilResolve.depthResolveMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stencilResolveMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescriptionDepthStencilResolve.stencilResolveMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pDepthStencilResolveAttachment": {
    get() {
    if (this._pDepthStencilResolveAttachment === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkAttachmentReference2.byteLength));
      this._pDepthStencilResolveAttachment = new VkAttachmentReference2({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pDepthStencilResolveAttachment.memoryAddress, true);
      return this.pDepthStencilResolveAttachment;
    } else {
      return this._pDepthStencilResolveAttachment;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference2) {
      value.flush();
      this._pDepthStencilResolveAttachment = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pDepthStencilResolveAttachment = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescriptionDepthStencilResolve.pDepthStencilResolveAttachment': Expected 'VkAttachmentReference2' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSubpassDescriptionDepthStencilResolve.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pDepthStencilResolveAttachment = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.depthResolveMode !== void 0) this.depthResolveMode = opts.depthResolveMode;
    if (opts.stencilResolveMode !== void 0) this.stencilResolveMode = opts.stencilResolveMode;
    if (opts.pDepthStencilResolveAttachment !== void 0) this.pDepthStencilResolveAttachment = opts.pDepthStencilResolveAttachment;
    
  }
};

VkSubpassDescriptionDepthStencilResolve.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassDescriptionDepthStencilResolve.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassDescriptionDepthStencilResolve.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassDescriptionDepthStencilResolve();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.depthResolveMode = original.depthResolveMode;
  copy.stencilResolveMode = original.stencilResolveMode;
  if (original.pDepthStencilResolveAttachment !== null) {
        copy.pDepthStencilResolveAttachment = original.pDepthStencilResolveAttachment.constructor.createCopyFrom(original.pDepthStencilResolveAttachment);
      }
  
  return copy;
};

VkSubpassDescriptionDepthStencilResolve.byteLength = 0x0;

VkSubpassDescriptionDepthStencilResolve.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthResolveMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilResolveMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDepthStencilResolveAttachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSubpassDescriptionDepthStencilResolveKHR **/
function VkSubpassDescriptionDepthStencilResolveKHR(opts, byteOffset) {
  if (new.target !== VkSubpassDescriptionDepthStencilResolveKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSubpassDescriptionDepthStencilResolveKHR, STRUCT_CACHE_VkSubpassDescriptionDepthStencilResolveKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSubpassDescriptionDepthStencilResolveKHR, STRUCT_CACHE_VkSubpassDescriptionDepthStencilResolveKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSubpassDescriptionDepthStencilResolveKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pDepthStencilResolveAttachment = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.depthResolveMode !== void 0) this.depthResolveMode = opts.depthResolveMode;
    if (opts.stencilResolveMode !== void 0) this.stencilResolveMode = opts.stencilResolveMode;
    if (opts.pDepthStencilResolveAttachment !== void 0) this.pDepthStencilResolveAttachment = opts.pDepthStencilResolveAttachment;
    
  }
};

Object.defineProperties(VkSubpassDescriptionDepthStencilResolveKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescriptionDepthStencilResolveKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSubpassDescriptionDepthStencilResolveKHR.pNext' isn't allowed to be filled");
    }
    },
  "depthResolveMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescriptionDepthStencilResolveKHR.depthResolveMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stencilResolveMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSubpassDescriptionDepthStencilResolveKHR.stencilResolveMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pDepthStencilResolveAttachment": {
    get() {
    if (this._pDepthStencilResolveAttachment === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkAttachmentReference2.byteLength));
      this._pDepthStencilResolveAttachment = new VkAttachmentReference2({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pDepthStencilResolveAttachment.memoryAddress, true);
      return this.pDepthStencilResolveAttachment;
    } else {
      return this._pDepthStencilResolveAttachment;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference2) {
      value.flush();
      this._pDepthStencilResolveAttachment = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pDepthStencilResolveAttachment = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescriptionDepthStencilResolveKHR.pDepthStencilResolveAttachment': Expected 'VkAttachmentReference2' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkSubpassDescriptionDepthStencilResolveKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pDepthStencilResolveAttachment = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.depthResolveMode !== void 0) this.depthResolveMode = opts.depthResolveMode;
    if (opts.stencilResolveMode !== void 0) this.stencilResolveMode = opts.stencilResolveMode;
    if (opts.pDepthStencilResolveAttachment !== void 0) this.pDepthStencilResolveAttachment = opts.pDepthStencilResolveAttachment;
    
  }
};

VkSubpassDescriptionDepthStencilResolveKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassDescriptionDepthStencilResolveKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSubpassDescriptionDepthStencilResolveKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSubpassDescriptionDepthStencilResolveKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.depthResolveMode = original.depthResolveMode;
  copy.stencilResolveMode = original.stencilResolveMode;
  if (original.pDepthStencilResolveAttachment !== null) {
        copy.pDepthStencilResolveAttachment = original.pDepthStencilResolveAttachment.constructor.createCopyFrom(original.pDepthStencilResolveAttachment);
      }
  
  return copy;
};

VkSubpassDescriptionDepthStencilResolveKHR.byteLength = 0x0;

VkSubpassDescriptionDepthStencilResolveKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthResolveMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilResolveMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDepthStencilResolveAttachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageViewASTCDecodeModeEXT **/
function VkImageViewASTCDecodeModeEXT(opts, byteOffset) {
  if (new.target !== VkImageViewASTCDecodeModeEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageViewASTCDecodeModeEXT, STRUCT_CACHE_VkImageViewASTCDecodeModeEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageViewASTCDecodeModeEXT, STRUCT_CACHE_VkImageViewASTCDecodeModeEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageViewASTCDecodeModeEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.decodeMode !== void 0) this.decodeMode = opts.decodeMode;
    
  }
};

Object.defineProperties(VkImageViewASTCDecodeModeEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewASTCDecodeModeEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageViewASTCDecodeModeEXT.pNext' isn't allowed to be filled");
    }
    },
  "decodeMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewASTCDecodeModeEXT.decodeMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImageViewASTCDecodeModeEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.decodeMode !== void 0) this.decodeMode = opts.decodeMode;
    
  }
};

VkImageViewASTCDecodeModeEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewASTCDecodeModeEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageViewASTCDecodeModeEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageViewASTCDecodeModeEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.decodeMode = original.decodeMode;
  
  return copy;
};

VkImageViewASTCDecodeModeEXT.byteLength = 0x0;

VkImageViewASTCDecodeModeEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  decodeMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceASTCDecodeFeaturesEXT **/
function VkPhysicalDeviceASTCDecodeFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceASTCDecodeFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceASTCDecodeFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceASTCDecodeFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceASTCDecodeFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceASTCDecodeFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceASTCDecodeFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.decodeModeSharedExponent !== void 0) this.decodeModeSharedExponent = opts.decodeModeSharedExponent;
    
  }
};

Object.defineProperties(VkPhysicalDeviceASTCDecodeFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceASTCDecodeFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceASTCDecodeFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "decodeModeSharedExponent": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceASTCDecodeFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.decodeModeSharedExponent !== void 0) this.decodeModeSharedExponent = opts.decodeModeSharedExponent;
    
  }
};

VkPhysicalDeviceASTCDecodeFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceASTCDecodeFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceASTCDecodeFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceASTCDecodeFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.decodeModeSharedExponent = original.decodeModeSharedExponent;
  
  return copy;
};

VkPhysicalDeviceASTCDecodeFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceASTCDecodeFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  decodeModeSharedExponent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceTransformFeedbackFeaturesEXT **/
function VkPhysicalDeviceTransformFeedbackFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceTransformFeedbackFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceTransformFeedbackFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceTransformFeedbackFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceTransformFeedbackFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceTransformFeedbackFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceTransformFeedbackFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.transformFeedback !== void 0) this.transformFeedback = opts.transformFeedback;
    if (opts.geometryStreams !== void 0) this.geometryStreams = opts.geometryStreams;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTransformFeedbackFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceTransformFeedbackFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTransformFeedbackFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "transformFeedback": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "geometryStreams": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceTransformFeedbackFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.transformFeedback !== void 0) this.transformFeedback = opts.transformFeedback;
    if (opts.geometryStreams !== void 0) this.geometryStreams = opts.geometryStreams;
    
  }
};

VkPhysicalDeviceTransformFeedbackFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTransformFeedbackFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceTransformFeedbackFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceTransformFeedbackFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.transformFeedback = original.transformFeedback;
  copy.geometryStreams = original.geometryStreams;
  
  return copy;
};

VkPhysicalDeviceTransformFeedbackFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceTransformFeedbackFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transformFeedback: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  geometryStreams: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceTransformFeedbackPropertiesEXT **/
function VkPhysicalDeviceTransformFeedbackPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceTransformFeedbackPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceTransformFeedbackPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceTransformFeedbackPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceTransformFeedbackPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceTransformFeedbackPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceTransformFeedbackPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTransformFeedbackPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceTransformFeedbackPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTransformFeedbackPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxTransformFeedbackStreams": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTransformFeedbackBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTransformFeedbackBufferSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "maxTransformFeedbackStreamDataSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTransformFeedbackBufferDataSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTransformFeedbackBufferDataStride": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "transformFeedbackQueries": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "transformFeedbackStreamsLinesTriangles": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "transformFeedbackRasterizationStreamSelect": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "transformFeedbackDraw": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceTransformFeedbackPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceTransformFeedbackPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTransformFeedbackPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceTransformFeedbackPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceTransformFeedbackPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxTransformFeedbackStreams = original.maxTransformFeedbackStreams;
  copy.maxTransformFeedbackBuffers = original.maxTransformFeedbackBuffers;
  copy.maxTransformFeedbackBufferSize = original.maxTransformFeedbackBufferSize;
  copy.maxTransformFeedbackStreamDataSize = original.maxTransformFeedbackStreamDataSize;
  copy.maxTransformFeedbackBufferDataSize = original.maxTransformFeedbackBufferDataSize;
  copy.maxTransformFeedbackBufferDataStride = original.maxTransformFeedbackBufferDataStride;
  copy.transformFeedbackQueries = original.transformFeedbackQueries;
  copy.transformFeedbackStreamsLinesTriangles = original.transformFeedbackStreamsLinesTriangles;
  copy.transformFeedbackRasterizationStreamSelect = original.transformFeedbackRasterizationStreamSelect;
  copy.transformFeedbackDraw = original.transformFeedbackDraw;
  
  return copy;
};

VkPhysicalDeviceTransformFeedbackPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceTransformFeedbackPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTransformFeedbackStreams: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTransformFeedbackBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTransformFeedbackBufferSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTransformFeedbackStreamDataSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTransformFeedbackBufferDataSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTransformFeedbackBufferDataStride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transformFeedbackQueries: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transformFeedbackStreamsLinesTriangles: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transformFeedbackRasterizationStreamSelect: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transformFeedbackDraw: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineRasterizationStateStreamCreateInfoEXT **/
function VkPipelineRasterizationStateStreamCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPipelineRasterizationStateStreamCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineRasterizationStateStreamCreateInfoEXT, STRUCT_CACHE_VkPipelineRasterizationStateStreamCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineRasterizationStateStreamCreateInfoEXT, STRUCT_CACHE_VkPipelineRasterizationStateStreamCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineRasterizationStateStreamCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.rasterizationStream !== void 0) this.rasterizationStream = opts.rasterizationStream;
    
  }
};

Object.defineProperties(VkPipelineRasterizationStateStreamCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateStreamCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRasterizationStateStreamCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateStreamCreateInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "rasterizationStream": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationStateStreamCreateInfoEXT.rasterizationStream");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkPipelineRasterizationStateStreamCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.rasterizationStream !== void 0) this.rasterizationStream = opts.rasterizationStream;
    
  }
};

VkPipelineRasterizationStateStreamCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationStateStreamCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineRasterizationStateStreamCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineRasterizationStateStreamCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.rasterizationStream = original.rasterizationStream;
  
  return copy;
};

VkPipelineRasterizationStateStreamCreateInfoEXT.byteLength = 0x0;

VkPipelineRasterizationStateStreamCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rasterizationStream: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV **/
function VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.representativeFragmentTest !== void 0) this.representativeFragmentTest = opts.representativeFragmentTest;
    
  }
};

Object.defineProperties(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "representativeFragmentTest": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.representativeFragmentTest !== void 0) this.representativeFragmentTest = opts.representativeFragmentTest;
    
  }
};

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.representativeFragmentTest = original.representativeFragmentTest;
  
  return copy;
};

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  representativeFragmentTest: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineRepresentativeFragmentTestStateCreateInfoNV **/
function VkPipelineRepresentativeFragmentTestStateCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkPipelineRepresentativeFragmentTestStateCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineRepresentativeFragmentTestStateCreateInfoNV, STRUCT_CACHE_VkPipelineRepresentativeFragmentTestStateCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineRepresentativeFragmentTestStateCreateInfoNV, STRUCT_CACHE_VkPipelineRepresentativeFragmentTestStateCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineRepresentativeFragmentTestStateCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.representativeFragmentTestEnable !== void 0) this.representativeFragmentTestEnable = opts.representativeFragmentTestEnable;
    
  }
};

Object.defineProperties(VkPipelineRepresentativeFragmentTestStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRepresentativeFragmentTestStateCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRepresentativeFragmentTestStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "representativeFragmentTestEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.representativeFragmentTestEnable !== void 0) this.representativeFragmentTestEnable = opts.representativeFragmentTestEnable;
    
  }
};

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineRepresentativeFragmentTestStateCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.representativeFragmentTestEnable = original.representativeFragmentTestEnable;
  
  return copy;
};

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.byteLength = 0x0;

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  representativeFragmentTestEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExclusiveScissorFeaturesNV **/
function VkPhysicalDeviceExclusiveScissorFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExclusiveScissorFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExclusiveScissorFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceExclusiveScissorFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExclusiveScissorFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceExclusiveScissorFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExclusiveScissorFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.exclusiveScissor !== void 0) this.exclusiveScissor = opts.exclusiveScissor;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExclusiveScissorFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExclusiveScissorFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExclusiveScissorFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "exclusiveScissor": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceExclusiveScissorFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.exclusiveScissor !== void 0) this.exclusiveScissor = opts.exclusiveScissor;
    
  }
};

VkPhysicalDeviceExclusiveScissorFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExclusiveScissorFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceExclusiveScissorFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExclusiveScissorFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.exclusiveScissor = original.exclusiveScissor;
  
  return copy;
};

VkPhysicalDeviceExclusiveScissorFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceExclusiveScissorFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  exclusiveScissor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineViewportExclusiveScissorStateCreateInfoNV **/
function VkPipelineViewportExclusiveScissorStateCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkPipelineViewportExclusiveScissorStateCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineViewportExclusiveScissorStateCreateInfoNV, STRUCT_CACHE_VkPipelineViewportExclusiveScissorStateCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineViewportExclusiveScissorStateCreateInfoNV, STRUCT_CACHE_VkPipelineViewportExclusiveScissorStateCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pExclusiveScissors = null;
  this._pExclusiveScissorsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.exclusiveScissorCount !== void 0) this.exclusiveScissorCount = opts.exclusiveScissorCount;
    if (opts.pExclusiveScissors !== void 0) this.pExclusiveScissors = opts.pExclusiveScissors;
    
  }
};

Object.defineProperties(VkPipelineViewportExclusiveScissorStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportExclusiveScissorStateCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "exclusiveScissorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportExclusiveScissorStateCreateInfoNV.exclusiveScissorCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pExclusiveScissors": {
    get() {
    if (this._pExclusiveScissors === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.exclusiveScissorCount, VkRect2D);
      this._pExclusiveScissors = array;
      return this.pExclusiveScissors;
    } else {
      return this._pExclusiveScissors;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pExclusiveScissors = value;
    } else if (value === null) {
      this._pExclusiveScissors = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors': Expected 'Array VkRect2D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportExclusiveScissorStateCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pExclusiveScissors = null;
  this._pExclusiveScissorsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.exclusiveScissorCount !== void 0) this.exclusiveScissorCount = opts.exclusiveScissorCount;
    if (opts.pExclusiveScissors !== void 0) this.pExclusiveScissors = opts.pExclusiveScissors;
    
  }
};

VkPipelineViewportExclusiveScissorStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pExclusiveScissors !== null) {
    let array = this._pExclusiveScissors;
    
    if (array.length !== this.exclusiveScissorCount) {
      throw new RangeError("Invalid array length, expected length of 'exclusiveScissorCount' for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRect2D)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors[" + ii + "]': Expected 'VkRect2D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pExclusiveScissorsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pExclusiveScissorsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineViewportExclusiveScissorStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineViewportExclusiveScissorStateCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineViewportExclusiveScissorStateCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.exclusiveScissorCount = original.exclusiveScissorCount;
  if (original.pExclusiveScissors !== null) {
        copy.pExclusiveScissors = [...Array(original.pExclusiveScissors.length)].map((v, i) => {
          return original.pExclusiveScissors[i].constructor.createCopyFrom(original.pExclusiveScissors[i]);
        });
      }
  
  return copy;
};

VkPipelineViewportExclusiveScissorStateCreateInfoNV.byteLength = 0x0;

VkPipelineViewportExclusiveScissorStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  exclusiveScissorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pExclusiveScissors: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceCornerSampledImageFeaturesNV **/
function VkPhysicalDeviceCornerSampledImageFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceCornerSampledImageFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceCornerSampledImageFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceCornerSampledImageFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceCornerSampledImageFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceCornerSampledImageFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceCornerSampledImageFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.cornerSampledImage !== void 0) this.cornerSampledImage = opts.cornerSampledImage;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCornerSampledImageFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceCornerSampledImageFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCornerSampledImageFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "cornerSampledImage": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceCornerSampledImageFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.cornerSampledImage !== void 0) this.cornerSampledImage = opts.cornerSampledImage;
    
  }
};

VkPhysicalDeviceCornerSampledImageFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCornerSampledImageFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceCornerSampledImageFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceCornerSampledImageFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.cornerSampledImage = original.cornerSampledImage;
  
  return copy;
};

VkPhysicalDeviceCornerSampledImageFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceCornerSampledImageFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  cornerSampledImage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceComputeShaderDerivativesFeaturesNV **/
function VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceComputeShaderDerivativesFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceComputeShaderDerivativesFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.computeDerivativeGroupQuads !== void 0) this.computeDerivativeGroupQuads = opts.computeDerivativeGroupQuads;
    if (opts.computeDerivativeGroupLinear !== void 0) this.computeDerivativeGroupLinear = opts.computeDerivativeGroupLinear;
    
  }
};

Object.defineProperties(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "computeDerivativeGroupQuads": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "computeDerivativeGroupLinear": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.computeDerivativeGroupQuads !== void 0) this.computeDerivativeGroupQuads = opts.computeDerivativeGroupQuads;
    if (opts.computeDerivativeGroupLinear !== void 0) this.computeDerivativeGroupLinear = opts.computeDerivativeGroupLinear;
    
  }
};

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceComputeShaderDerivativesFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.computeDerivativeGroupQuads = original.computeDerivativeGroupQuads;
  copy.computeDerivativeGroupLinear = original.computeDerivativeGroupLinear;
  
  return copy;
};

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  computeDerivativeGroupQuads: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  computeDerivativeGroupLinear: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV **/
function VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentShaderBarycentric !== void 0) this.fragmentShaderBarycentric = opts.fragmentShaderBarycentric;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "fragmentShaderBarycentric": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentShaderBarycentric !== void 0) this.fragmentShaderBarycentric = opts.fragmentShaderBarycentric;
    
  }
};

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.fragmentShaderBarycentric = original.fragmentShaderBarycentric;
  
  return copy;
};

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShaderBarycentric: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderImageFootprintFeaturesNV **/
function VkPhysicalDeviceShaderImageFootprintFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderImageFootprintFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderImageFootprintFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceShaderImageFootprintFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderImageFootprintFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceShaderImageFootprintFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderImageFootprintFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imageFootprint !== void 0) this.imageFootprint = opts.imageFootprint;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderImageFootprintFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderImageFootprintFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderImageFootprintFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "imageFootprint": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderImageFootprintFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imageFootprint !== void 0) this.imageFootprint = opts.imageFootprint;
    
  }
};

VkPhysicalDeviceShaderImageFootprintFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderImageFootprintFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderImageFootprintFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderImageFootprintFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.imageFootprint = original.imageFootprint;
  
  return copy;
};

VkPhysicalDeviceShaderImageFootprintFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceShaderImageFootprintFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageFootprint: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV **/
function VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dedicatedAllocationImageAliasing !== void 0) this.dedicatedAllocationImageAliasing = opts.dedicatedAllocationImageAliasing;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "dedicatedAllocationImageAliasing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.dedicatedAllocationImageAliasing !== void 0) this.dedicatedAllocationImageAliasing = opts.dedicatedAllocationImageAliasing;
    
  }
};

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.dedicatedAllocationImageAliasing = original.dedicatedAllocationImageAliasing;
  
  return copy;
};

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dedicatedAllocationImageAliasing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkShadingRatePaletteNV **/
function VkShadingRatePaletteNV(opts, byteOffset) {
  if (new.target !== VkShadingRatePaletteNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkShadingRatePaletteNV, STRUCT_CACHE_VkShadingRatePaletteNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkShadingRatePaletteNV, STRUCT_CACHE_VkShadingRatePaletteNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkShadingRatePaletteNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pShadingRatePaletteEntries = null;
  
  if (typeof opts === "object") {
    if (opts.shadingRatePaletteEntryCount !== void 0) this.shadingRatePaletteEntryCount = opts.shadingRatePaletteEntryCount;
    if (opts.pShadingRatePaletteEntries !== void 0) this.pShadingRatePaletteEntries = opts.pShadingRatePaletteEntries;
    
  }
};

Object.defineProperties(VkShadingRatePaletteNV.prototype, {
  "shadingRatePaletteEntryCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkShadingRatePaletteNV.shadingRatePaletteEntryCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pShadingRatePaletteEntries": {
    get() {
    return this._pShadingRatePaletteEntries;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pShadingRatePaletteEntries = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pShadingRatePaletteEntries = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkShadingRatePaletteNV.pShadingRatePaletteEntries': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkShadingRatePaletteNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pShadingRatePaletteEntries = null;
  
  if (typeof opts === "object") {
    if (opts.shadingRatePaletteEntryCount !== void 0) this.shadingRatePaletteEntryCount = opts.shadingRatePaletteEntryCount;
    if (opts.pShadingRatePaletteEntries !== void 0) this.pShadingRatePaletteEntries = opts.pShadingRatePaletteEntries;
    
  }
};

VkShadingRatePaletteNV.prototype.flush = function flush() {
  
  return true;
};

VkShadingRatePaletteNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkShadingRatePaletteNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkShadingRatePaletteNV();
  copy.shadingRatePaletteEntryCount = original.shadingRatePaletteEntryCount;
  if (original.pShadingRatePaletteEntries !== null) {
        copy.pShadingRatePaletteEntries = new Int32Array(original.pShadingRatePaletteEntries);
      }
  
  return copy;
};

VkShadingRatePaletteNV.byteLength = 0x0;

VkShadingRatePaletteNV.memoryLayout = {
  shadingRatePaletteEntryCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pShadingRatePaletteEntries: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineViewportShadingRateImageStateCreateInfoNV **/
function VkPipelineViewportShadingRateImageStateCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkPipelineViewportShadingRateImageStateCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineViewportShadingRateImageStateCreateInfoNV, STRUCT_CACHE_VkPipelineViewportShadingRateImageStateCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineViewportShadingRateImageStateCreateInfoNV, STRUCT_CACHE_VkPipelineViewportShadingRateImageStateCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineViewportShadingRateImageStateCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pShadingRatePalettes = null;
  this._pShadingRatePalettesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shadingRateImageEnable !== void 0) this.shadingRateImageEnable = opts.shadingRateImageEnable;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pShadingRatePalettes !== void 0) this.pShadingRatePalettes = opts.pShadingRatePalettes;
    
  }
};

Object.defineProperties(VkPipelineViewportShadingRateImageStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportShadingRateImageStateCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineViewportShadingRateImageStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "shadingRateImageEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "viewportCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportShadingRateImageStateCreateInfoNV.viewportCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pShadingRatePalettes": {
    get() {
    if (this._pShadingRatePalettes === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.viewportCount, VkShadingRatePaletteNV);
      this._pShadingRatePalettes = array;
      return this.pShadingRatePalettes;
    } else {
      return this._pShadingRatePalettes;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pShadingRatePalettes = value;
    } else if (value === null) {
      this._pShadingRatePalettes = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes': Expected 'Array VkShadingRatePaletteNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportShadingRateImageStateCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pShadingRatePalettes = null;
  this._pShadingRatePalettesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shadingRateImageEnable !== void 0) this.shadingRateImageEnable = opts.shadingRateImageEnable;
    if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
    if (opts.pShadingRatePalettes !== void 0) this.pShadingRatePalettes = opts.pShadingRatePalettes;
    
  }
};

VkPipelineViewportShadingRateImageStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pShadingRatePalettes !== null) {
    let array = this._pShadingRatePalettes;
    
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkShadingRatePaletteNV)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes[" + ii + "]': Expected 'VkShadingRatePaletteNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pShadingRatePalettesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pShadingRatePalettesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineViewportShadingRateImageStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineViewportShadingRateImageStateCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineViewportShadingRateImageStateCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shadingRateImageEnable = original.shadingRateImageEnable;
  copy.viewportCount = original.viewportCount;
  if (original.pShadingRatePalettes !== null) {
        copy.pShadingRatePalettes = [...Array(original.pShadingRatePalettes.length)].map((v, i) => {
          return original.pShadingRatePalettes[i].constructor.createCopyFrom(original.pShadingRatePalettes[i]);
        });
      }
  
  return copy;
};

VkPipelineViewportShadingRateImageStateCreateInfoNV.byteLength = 0x0;

VkPipelineViewportShadingRateImageStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shadingRateImageEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewportCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pShadingRatePalettes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShadingRateImageFeaturesNV **/
function VkPhysicalDeviceShadingRateImageFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShadingRateImageFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShadingRateImageFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceShadingRateImageFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShadingRateImageFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceShadingRateImageFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShadingRateImageFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shadingRateImage !== void 0) this.shadingRateImage = opts.shadingRateImage;
    if (opts.shadingRateCoarseSampleOrder !== void 0) this.shadingRateCoarseSampleOrder = opts.shadingRateCoarseSampleOrder;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShadingRateImageFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShadingRateImageFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShadingRateImageFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "shadingRateImage": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shadingRateCoarseSampleOrder": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShadingRateImageFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shadingRateImage !== void 0) this.shadingRateImage = opts.shadingRateImage;
    if (opts.shadingRateCoarseSampleOrder !== void 0) this.shadingRateCoarseSampleOrder = opts.shadingRateCoarseSampleOrder;
    
  }
};

VkPhysicalDeviceShadingRateImageFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShadingRateImageFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShadingRateImageFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShadingRateImageFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shadingRateImage = original.shadingRateImage;
  copy.shadingRateCoarseSampleOrder = original.shadingRateCoarseSampleOrder;
  
  return copy;
};

VkPhysicalDeviceShadingRateImageFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceShadingRateImageFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shadingRateImage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shadingRateCoarseSampleOrder: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShadingRateImagePropertiesNV **/
function VkPhysicalDeviceShadingRateImagePropertiesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShadingRateImagePropertiesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShadingRateImagePropertiesNV, STRUCT_CACHE_VkPhysicalDeviceShadingRateImagePropertiesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShadingRateImagePropertiesNV, STRUCT_CACHE_VkPhysicalDeviceShadingRateImagePropertiesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShadingRateImagePropertiesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._shadingRateTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShadingRateImagePropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShadingRateImagePropertiesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShadingRateImagePropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "shadingRateTexelSize": {
    get() {
    return this._shadingRateTexelSize;
    },
    },
  "shadingRatePaletteSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "shadingRateMaxCoarseSamples": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceShadingRateImagePropertiesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._shadingRateTexelSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._shadingRateTexelSize.memoryBuffer) this._shadingRateTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._shadingRateTexelSize.reset();
  }
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceShadingRateImagePropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShadingRateImagePropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceShadingRateImagePropertiesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShadingRateImagePropertiesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.shadingRateTexelSize !== null) {
        copy.shadingRateTexelSize = original.shadingRateTexelSize.constructor.createCopyFrom(original.shadingRateTexelSize);
      }
  copy.shadingRatePaletteSize = original.shadingRatePaletteSize;
  copy.shadingRateMaxCoarseSamples = original.shadingRateMaxCoarseSamples;
  
  return copy;
};

VkPhysicalDeviceShadingRateImagePropertiesNV.byteLength = 0x0;

VkPhysicalDeviceShadingRateImagePropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shadingRateTexelSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shadingRatePaletteSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shadingRateMaxCoarseSamples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCoarseSampleLocationNV **/
function VkCoarseSampleLocationNV(opts, byteOffset) {
  if (new.target !== VkCoarseSampleLocationNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCoarseSampleLocationNV, STRUCT_CACHE_VkCoarseSampleLocationNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCoarseSampleLocationNV, STRUCT_CACHE_VkCoarseSampleLocationNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCoarseSampleLocationNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.pixelX !== void 0) this.pixelX = opts.pixelX;
    if (opts.pixelY !== void 0) this.pixelY = opts.pixelY;
    if (opts.sample !== void 0) this.sample = opts.sample;
    
  }
};

Object.defineProperties(VkCoarseSampleLocationNV.prototype, {
  "pixelX": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCoarseSampleLocationNV.pixelX");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pixelY": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCoarseSampleLocationNV.pixelY");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "sample": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCoarseSampleLocationNV.sample");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkCoarseSampleLocationNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.pixelX !== void 0) this.pixelX = opts.pixelX;
    if (opts.pixelY !== void 0) this.pixelY = opts.pixelY;
    if (opts.sample !== void 0) this.sample = opts.sample;
    
  }
};

VkCoarseSampleLocationNV.prototype.flush = function flush() {
  
  return true;
};

VkCoarseSampleLocationNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkCoarseSampleLocationNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCoarseSampleLocationNV();
  copy.pixelX = original.pixelX;
  copy.pixelY = original.pixelY;
  copy.sample = original.sample;
  
  return copy;
};

VkCoarseSampleLocationNV.byteLength = 0x0;

VkCoarseSampleLocationNV.memoryLayout = {
  pixelX: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pixelY: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sample: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCoarseSampleOrderCustomNV **/
function VkCoarseSampleOrderCustomNV(opts, byteOffset) {
  if (new.target !== VkCoarseSampleOrderCustomNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCoarseSampleOrderCustomNV, STRUCT_CACHE_VkCoarseSampleOrderCustomNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCoarseSampleOrderCustomNV, STRUCT_CACHE_VkCoarseSampleOrderCustomNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCoarseSampleOrderCustomNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  this._pSampleLocations = null;
  this._pSampleLocationsNative = null;
  
  if (typeof opts === "object") {
    if (opts.shadingRate !== void 0) this.shadingRate = opts.shadingRate;
    if (opts.sampleCount !== void 0) this.sampleCount = opts.sampleCount;
    if (opts.sampleLocationCount !== void 0) this.sampleLocationCount = opts.sampleLocationCount;
    if (opts.pSampleLocations !== void 0) this.pSampleLocations = opts.pSampleLocations;
    
  }
};

Object.defineProperties(VkCoarseSampleOrderCustomNV.prototype, {
  "shadingRate": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCoarseSampleOrderCustomNV.shadingRate");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "sampleCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCoarseSampleOrderCustomNV.sampleCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "sampleLocationCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCoarseSampleOrderCustomNV.sampleLocationCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pSampleLocations": {
    get() {
    if (this._pSampleLocations === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.sampleLocationCount, VkCoarseSampleLocationNV);
      this._pSampleLocations = array;
      return this.pSampleLocations;
    } else {
      return this._pSampleLocations;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pSampleLocations = value;
    } else if (value === null) {
      this._pSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.pSampleLocations': Expected 'Array VkCoarseSampleLocationNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkCoarseSampleOrderCustomNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  this._pSampleLocations = null;
  this._pSampleLocationsNative = null;
  
  if (typeof opts === "object") {
    if (opts.shadingRate !== void 0) this.shadingRate = opts.shadingRate;
    if (opts.sampleCount !== void 0) this.sampleCount = opts.sampleCount;
    if (opts.sampleLocationCount !== void 0) this.sampleLocationCount = opts.sampleLocationCount;
    if (opts.pSampleLocations !== void 0) this.pSampleLocations = opts.pSampleLocations;
    
  }
};

VkCoarseSampleOrderCustomNV.prototype.flush = function flush() {
  
  
  if (this._pSampleLocations !== null) {
    let array = this._pSampleLocations;
    
    if (array.length !== this.sampleLocationCount) {
      throw new RangeError("Invalid array length, expected length of 'sampleLocationCount' for 'VkCoarseSampleOrderCustomNV.pSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkCoarseSampleLocationNV)) {
        throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.pSampleLocations[" + ii + "]': Expected 'VkCoarseSampleLocationNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pSampleLocationsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pSampleLocationsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkCoarseSampleOrderCustomNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkCoarseSampleOrderCustomNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCoarseSampleOrderCustomNV();
  copy.shadingRate = original.shadingRate;
  copy.sampleCount = original.sampleCount;
  copy.sampleLocationCount = original.sampleLocationCount;
  if (original.pSampleLocations !== null) {
        copy.pSampleLocations = [...Array(original.pSampleLocations.length)].map((v, i) => {
          return original.pSampleLocations[i].constructor.createCopyFrom(original.pSampleLocations[i]);
        });
      }
  
  return copy;
};

VkCoarseSampleOrderCustomNV.byteLength = 0x0;

VkCoarseSampleOrderCustomNV.memoryLayout = {
  shadingRate: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleLocationCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pSampleLocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineViewportCoarseSampleOrderStateCreateInfoNV **/
function VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkPipelineViewportCoarseSampleOrderStateCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, STRUCT_CACHE_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, STRUCT_CACHE_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pCustomSampleOrders = null;
  this._pCustomSampleOrdersNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.sampleOrderType !== void 0) this.sampleOrderType = opts.sampleOrderType;
    if (opts.customSampleOrderCount !== void 0) this.customSampleOrderCount = opts.customSampleOrderCount;
    if (opts.pCustomSampleOrders !== void 0) this.pCustomSampleOrders = opts.pCustomSampleOrders;
    
  }
};

Object.defineProperties(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "sampleOrderType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.sampleOrderType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "customSampleOrderCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.customSampleOrderCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCustomSampleOrders": {
    get() {
    if (this._pCustomSampleOrders === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.customSampleOrderCount, VkCoarseSampleOrderCustomNV);
      this._pCustomSampleOrders = array;
      return this.pCustomSampleOrders;
    } else {
      return this._pCustomSampleOrders;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pCustomSampleOrders = value;
    } else if (value === null) {
      this._pCustomSampleOrders = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders': Expected 'Array VkCoarseSampleOrderCustomNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pCustomSampleOrders = null;
  this._pCustomSampleOrdersNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.sampleOrderType !== void 0) this.sampleOrderType = opts.sampleOrderType;
    if (opts.customSampleOrderCount !== void 0) this.customSampleOrderCount = opts.customSampleOrderCount;
    if (opts.pCustomSampleOrders !== void 0) this.pCustomSampleOrders = opts.pCustomSampleOrders;
    
  }
};

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pCustomSampleOrders !== null) {
    let array = this._pCustomSampleOrders;
    
    if (array.length !== this.customSampleOrderCount) {
      throw new RangeError("Invalid array length, expected length of 'customSampleOrderCount' for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkCoarseSampleOrderCustomNV)) {
        throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders[" + ii + "]': Expected 'VkCoarseSampleOrderCustomNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pCustomSampleOrdersNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pCustomSampleOrdersNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineViewportCoarseSampleOrderStateCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.sampleOrderType = original.sampleOrderType;
  copy.customSampleOrderCount = original.customSampleOrderCount;
  if (original.pCustomSampleOrders !== null) {
        copy.pCustomSampleOrders = [...Array(original.pCustomSampleOrders.length)].map((v, i) => {
          return original.pCustomSampleOrders[i].constructor.createCopyFrom(original.pCustomSampleOrders[i]);
        });
      }
  
  return copy;
};

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.byteLength = 0x0;

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleOrderType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  customSampleOrderCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCustomSampleOrders: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMeshShaderFeaturesNV **/
function VkPhysicalDeviceMeshShaderFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMeshShaderFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMeshShaderFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceMeshShaderFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMeshShaderFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceMeshShaderFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMeshShaderFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.taskShader !== void 0) this.taskShader = opts.taskShader;
    if (opts.meshShader !== void 0) this.meshShader = opts.meshShader;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMeshShaderFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMeshShaderFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMeshShaderFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "taskShader": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "meshShader": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceMeshShaderFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.taskShader !== void 0) this.taskShader = opts.taskShader;
    if (opts.meshShader !== void 0) this.meshShader = opts.meshShader;
    
  }
};

VkPhysicalDeviceMeshShaderFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMeshShaderFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceMeshShaderFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMeshShaderFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.taskShader = original.taskShader;
  copy.meshShader = original.meshShader;
  
  return copy;
};

VkPhysicalDeviceMeshShaderFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceMeshShaderFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  taskShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  meshShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMeshShaderPropertiesNV **/
function VkPhysicalDeviceMeshShaderPropertiesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMeshShaderPropertiesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMeshShaderPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceMeshShaderPropertiesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMeshShaderPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceMeshShaderPropertiesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMeshShaderPropertiesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._maxTaskWorkGroupSize = [...Array(3)].fill(0x0);
  
  
  
  this._maxMeshWorkGroupSize = [...Array(3)].fill(0x0);
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMeshShaderPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMeshShaderPropertiesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMeshShaderPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "maxDrawMeshTasksCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTaskWorkGroupInvocations": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTaskWorkGroupSize": {
    get() {
    return [
      this.memoryView.getUint32(0x0, true),
      this.memoryView.getUint32(0x4, true),
      this.memoryView.getUint32(0x8, true)
    ];
    },
    },
  "maxTaskTotalMemorySize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxTaskOutputCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMeshWorkGroupInvocations": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMeshWorkGroupSize": {
    get() {
    return [
      this.memoryView.getUint32(0x0, true),
      this.memoryView.getUint32(0x4, true),
      this.memoryView.getUint32(0x8, true)
    ];
    },
    },
  "maxMeshTotalMemorySize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMeshOutputVertices": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMeshOutputPrimitives": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMeshMultiviewViewCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "meshOutputPerVertexGranularity": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "meshOutputPerPrimitiveGranularity": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceMeshShaderPropertiesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  if (this._maxTaskWorkGroupSize !== null) this._maxTaskWorkGroupSize.fill(0x0);
      else this._maxTaskWorkGroupSize = [...Array(3)].fill(0x0);
  
  
  
  if (this._maxMeshWorkGroupSize !== null) this._maxMeshWorkGroupSize.fill(0x0);
      else this._maxMeshWorkGroupSize = [...Array(3)].fill(0x0);
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceMeshShaderPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMeshShaderPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceMeshShaderPropertiesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMeshShaderPropertiesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxDrawMeshTasksCount = original.maxDrawMeshTasksCount;
  copy.maxTaskWorkGroupInvocations = original.maxTaskWorkGroupInvocations;
  if (original.maxTaskWorkGroupSize !== null) {
        copy.maxTaskWorkGroupSize = [...Array(original.maxTaskWorkGroupSize.length)].map((v, i) => {
          return original.maxTaskWorkGroupSize[i];
        });
      }
  copy.maxTaskTotalMemorySize = original.maxTaskTotalMemorySize;
  copy.maxTaskOutputCount = original.maxTaskOutputCount;
  copy.maxMeshWorkGroupInvocations = original.maxMeshWorkGroupInvocations;
  if (original.maxMeshWorkGroupSize !== null) {
        copy.maxMeshWorkGroupSize = [...Array(original.maxMeshWorkGroupSize.length)].map((v, i) => {
          return original.maxMeshWorkGroupSize[i];
        });
      }
  copy.maxMeshTotalMemorySize = original.maxMeshTotalMemorySize;
  copy.maxMeshOutputVertices = original.maxMeshOutputVertices;
  copy.maxMeshOutputPrimitives = original.maxMeshOutputPrimitives;
  copy.maxMeshMultiviewViewCount = original.maxMeshMultiviewViewCount;
  copy.meshOutputPerVertexGranularity = original.meshOutputPerVertexGranularity;
  copy.meshOutputPerPrimitiveGranularity = original.meshOutputPerPrimitiveGranularity;
  
  return copy;
};

VkPhysicalDeviceMeshShaderPropertiesNV.byteLength = 0x0;

VkPhysicalDeviceMeshShaderPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDrawMeshTasksCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTaskWorkGroupInvocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTaskWorkGroupSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTaskTotalMemorySize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTaskOutputCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMeshWorkGroupInvocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMeshWorkGroupSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMeshTotalMemorySize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMeshOutputVertices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMeshOutputPrimitives: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMeshMultiviewViewCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  meshOutputPerVertexGranularity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  meshOutputPerPrimitiveGranularity: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDrawMeshTasksIndirectCommandNV **/
function VkDrawMeshTasksIndirectCommandNV(opts, byteOffset) {
  if (new.target !== VkDrawMeshTasksIndirectCommandNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDrawMeshTasksIndirectCommandNV, STRUCT_CACHE_VkDrawMeshTasksIndirectCommandNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDrawMeshTasksIndirectCommandNV, STRUCT_CACHE_VkDrawMeshTasksIndirectCommandNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDrawMeshTasksIndirectCommandNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    if (opts.taskCount !== void 0) this.taskCount = opts.taskCount;
    if (opts.firstTask !== void 0) this.firstTask = opts.firstTask;
    
  }
};

Object.defineProperties(VkDrawMeshTasksIndirectCommandNV.prototype, {
  "taskCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawMeshTasksIndirectCommandNV.taskCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "firstTask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrawMeshTasksIndirectCommandNV.firstTask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkDrawMeshTasksIndirectCommandNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    if (opts.taskCount !== void 0) this.taskCount = opts.taskCount;
    if (opts.firstTask !== void 0) this.firstTask = opts.firstTask;
    
  }
};

VkDrawMeshTasksIndirectCommandNV.prototype.flush = function flush() {
  
  return true;
};

VkDrawMeshTasksIndirectCommandNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkDrawMeshTasksIndirectCommandNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDrawMeshTasksIndirectCommandNV();
  copy.taskCount = original.taskCount;
  copy.firstTask = original.firstTask;
  
  return copy;
};

VkDrawMeshTasksIndirectCommandNV.byteLength = 0x0;

VkDrawMeshTasksIndirectCommandNV.memoryLayout = {
  taskCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  firstTask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRayTracingShaderGroupCreateInfoNV **/
function VkRayTracingShaderGroupCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkRayTracingShaderGroupCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRayTracingShaderGroupCreateInfoNV, STRUCT_CACHE_VkRayTracingShaderGroupCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRayTracingShaderGroupCreateInfoNV, STRUCT_CACHE_VkRayTracingShaderGroupCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRayTracingShaderGroupCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.generalShader !== void 0) this.generalShader = opts.generalShader;
    if (opts.closestHitShader !== void 0) this.closestHitShader = opts.closestHitShader;
    if (opts.anyHitShader !== void 0) this.anyHitShader = opts.anyHitShader;
    if (opts.intersectionShader !== void 0) this.intersectionShader = opts.intersectionShader;
    
  }
};

Object.defineProperties(VkRayTracingShaderGroupCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRayTracingShaderGroupCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoNV.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "generalShader": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoNV.generalShader");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "closestHitShader": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoNV.closestHitShader");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "anyHitShader": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoNV.anyHitShader");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "intersectionShader": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoNV.intersectionShader");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkRayTracingShaderGroupCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.generalShader !== void 0) this.generalShader = opts.generalShader;
    if (opts.closestHitShader !== void 0) this.closestHitShader = opts.closestHitShader;
    if (opts.anyHitShader !== void 0) this.anyHitShader = opts.anyHitShader;
    if (opts.intersectionShader !== void 0) this.intersectionShader = opts.intersectionShader;
    
  }
};

VkRayTracingShaderGroupCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRayTracingShaderGroupCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkRayTracingShaderGroupCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRayTracingShaderGroupCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.type = original.type;
  copy.generalShader = original.generalShader;
  copy.closestHitShader = original.closestHitShader;
  copy.anyHitShader = original.anyHitShader;
  copy.intersectionShader = original.intersectionShader;
  
  return copy;
};

VkRayTracingShaderGroupCreateInfoNV.byteLength = 0x0;

VkRayTracingShaderGroupCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  generalShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  closestHitShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  anyHitShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  intersectionShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRayTracingShaderGroupCreateInfoKHR **/
function VkRayTracingShaderGroupCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkRayTracingShaderGroupCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRayTracingShaderGroupCreateInfoKHR, STRUCT_CACHE_VkRayTracingShaderGroupCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRayTracingShaderGroupCreateInfoKHR, STRUCT_CACHE_VkRayTracingShaderGroupCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRayTracingShaderGroupCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this._pShaderGroupCaptureReplayHandle = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.generalShader !== void 0) this.generalShader = opts.generalShader;
    if (opts.closestHitShader !== void 0) this.closestHitShader = opts.closestHitShader;
    if (opts.anyHitShader !== void 0) this.anyHitShader = opts.anyHitShader;
    if (opts.intersectionShader !== void 0) this.intersectionShader = opts.intersectionShader;
    if (opts.pShaderGroupCaptureReplayHandle !== void 0) this.pShaderGroupCaptureReplayHandle = opts.pShaderGroupCaptureReplayHandle;
    
  }
};

Object.defineProperties(VkRayTracingShaderGroupCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRayTracingShaderGroupCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoKHR.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "generalShader": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoKHR.generalShader");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "closestHitShader": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoKHR.closestHitShader");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "anyHitShader": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoKHR.anyHitShader");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "intersectionShader": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingShaderGroupCreateInfoKHR.intersectionShader");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pShaderGroupCaptureReplayHandle": {
    get() {
    return this._pShaderGroupCaptureReplayHandle;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pShaderGroupCaptureReplayHandle = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pShaderGroupCaptureReplayHandle = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoKHR.pShaderGroupCaptureReplayHandle': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRayTracingShaderGroupCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this._pShaderGroupCaptureReplayHandle = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.generalShader !== void 0) this.generalShader = opts.generalShader;
    if (opts.closestHitShader !== void 0) this.closestHitShader = opts.closestHitShader;
    if (opts.anyHitShader !== void 0) this.anyHitShader = opts.anyHitShader;
    if (opts.intersectionShader !== void 0) this.intersectionShader = opts.intersectionShader;
    if (opts.pShaderGroupCaptureReplayHandle !== void 0) this.pShaderGroupCaptureReplayHandle = opts.pShaderGroupCaptureReplayHandle;
    
  }
};

VkRayTracingShaderGroupCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRayTracingShaderGroupCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkRayTracingShaderGroupCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRayTracingShaderGroupCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.type = original.type;
  copy.generalShader = original.generalShader;
  copy.closestHitShader = original.closestHitShader;
  copy.anyHitShader = original.anyHitShader;
  copy.intersectionShader = original.intersectionShader;
  if (original.pShaderGroupCaptureReplayHandle !== null) {
      let buf = new ArrayBuffer(original.pShaderGroupCaptureReplayHandle.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pShaderGroupCaptureReplayHandle), 0x0);
      copy.pShaderGroupCaptureReplayHandle = buf;
    }
  
  return copy;
};

VkRayTracingShaderGroupCreateInfoKHR.byteLength = 0x0;

VkRayTracingShaderGroupCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  generalShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  closestHitShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  anyHitShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  intersectionShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pShaderGroupCaptureReplayHandle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRayTracingPipelineCreateInfoNV **/
function VkRayTracingPipelineCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkRayTracingPipelineCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRayTracingPipelineCreateInfoNV, STRUCT_CACHE_VkRayTracingPipelineCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRayTracingPipelineCreateInfoNV, STRUCT_CACHE_VkRayTracingPipelineCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRayTracingPipelineCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pStages = null;
  this._pStagesNative = null;
  
  this._pGroups = null;
  this._pGroupsNative = null;
  
  this._layout = null;
  this._basePipelineHandle = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
    if (opts.pStages !== void 0) this.pStages = opts.pStages;
    if (opts.groupCount !== void 0) this.groupCount = opts.groupCount;
    if (opts.pGroups !== void 0) this.pGroups = opts.pGroups;
    if (opts.maxRecursionDepth !== void 0) this.maxRecursionDepth = opts.maxRecursionDepth;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

Object.defineProperties(VkRayTracingPipelineCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoNV.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stageCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoNV.stageCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pStages": {
    get() {
    if (this._pStages === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.stageCount, VkPipelineShaderStageCreateInfo);
      this._pStages = array;
      return this.pStages;
    } else {
      return this._pStages;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pStages = value;
    } else if (value === null) {
      this._pStages = null;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pStages': Expected 'Array VkPipelineShaderStageCreateInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "groupCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoNV.groupCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pGroups": {
    get() {
    if (this._pGroups === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.groupCount, VkRayTracingShaderGroupCreateInfoNV);
      this._pGroups = array;
      return this.pGroups;
    } else {
      return this._pGroups;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pGroups = value;
    } else if (value === null) {
      this._pGroups = null;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pGroups': Expected 'Array VkRayTracingShaderGroupCreateInfoNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "maxRecursionDepth": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoNV.maxRecursionDepth");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "layout": {
    get() {
    return this._layout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._layout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._layout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.layout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineHandle": {
    get() {
    return this._basePipelineHandle;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._basePipelineHandle = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._basePipelineHandle = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.basePipelineHandle': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineIndex": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoNV.basePipelineIndex");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkRayTracingPipelineCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pStages = null;
  this._pStagesNative = null;
  
  this._pGroups = null;
  this._pGroupsNative = null;
  
  this._layout = null;
  this._basePipelineHandle = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
    if (opts.pStages !== void 0) this.pStages = opts.pStages;
    if (opts.groupCount !== void 0) this.groupCount = opts.groupCount;
    if (opts.pGroups !== void 0) this.pGroups = opts.pGroups;
    if (opts.maxRecursionDepth !== void 0) this.maxRecursionDepth = opts.maxRecursionDepth;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

VkRayTracingPipelineCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pStages !== null) {
    let array = this._pStages;
    
    if (array.length !== this.stageCount) {
      throw new RangeError("Invalid array length, expected length of 'stageCount' for 'VkRayTracingPipelineCreateInfoNV.pStages'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipelineShaderStageCreateInfo)) {
        throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pStages[" + ii + "]': Expected 'VkPipelineShaderStageCreateInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pStagesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pStagesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pGroups !== null) {
    let array = this._pGroups;
    
    if (array.length !== this.groupCount) {
      throw new RangeError("Invalid array length, expected length of 'groupCount' for 'VkRayTracingPipelineCreateInfoNV.pGroups'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRayTracingShaderGroupCreateInfoNV)) {
        throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pGroups[" + ii + "]': Expected 'VkRayTracingShaderGroupCreateInfoNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pGroupsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pGroupsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRayTracingPipelineCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkRayTracingPipelineCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRayTracingPipelineCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.stageCount = original.stageCount;
  if (original.pStages !== null) {
        copy.pStages = [...Array(original.pStages.length)].map((v, i) => {
          return original.pStages[i].constructor.createCopyFrom(original.pStages[i]);
        });
      }
  copy.groupCount = original.groupCount;
  if (original.pGroups !== null) {
        copy.pGroups = [...Array(original.pGroups.length)].map((v, i) => {
          return original.pGroups[i].constructor.createCopyFrom(original.pGroups[i]);
        });
      }
  copy.maxRecursionDepth = original.maxRecursionDepth;
  if (original.layout !== null) {
        copy.layout = original.layout.constructor.createCopyFrom(original.layout);
      }
  if (original.basePipelineHandle !== null) {
        copy.basePipelineHandle = original.basePipelineHandle.constructor.createCopyFrom(original.basePipelineHandle);
      }
  copy.basePipelineIndex = original.basePipelineIndex;
  
  return copy;
};

VkRayTracingPipelineCreateInfoNV.byteLength = 0x0;

VkRayTracingPipelineCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stageCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pStages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  groupCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pGroups: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxRecursionDepth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  basePipelineHandle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  basePipelineIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRayTracingPipelineCreateInfoKHR **/
function VkRayTracingPipelineCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkRayTracingPipelineCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRayTracingPipelineCreateInfoKHR, STRUCT_CACHE_VkRayTracingPipelineCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRayTracingPipelineCreateInfoKHR, STRUCT_CACHE_VkRayTracingPipelineCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRayTracingPipelineCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pStages = null;
  this._pStagesNative = null;
  
  this._pGroups = null;
  this._pGroupsNative = null;
  
  this._pLibraryInfo = null;
  this._pLibraryInterface = null;
  this._pDynamicState = null;
  this._layout = null;
  this._basePipelineHandle = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
    if (opts.pStages !== void 0) this.pStages = opts.pStages;
    if (opts.groupCount !== void 0) this.groupCount = opts.groupCount;
    if (opts.pGroups !== void 0) this.pGroups = opts.pGroups;
    if (opts.maxPipelineRayRecursionDepth !== void 0) this.maxPipelineRayRecursionDepth = opts.maxPipelineRayRecursionDepth;
    if (opts.pLibraryInfo !== void 0) this.pLibraryInfo = opts.pLibraryInfo;
    if (opts.pLibraryInterface !== void 0) this.pLibraryInterface = opts.pLibraryInterface;
    if (opts.pDynamicState !== void 0) this.pDynamicState = opts.pDynamicState;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

Object.defineProperties(VkRayTracingPipelineCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.pNext'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stageCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoKHR.stageCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pStages": {
    get() {
    if (this._pStages === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.stageCount, VkPipelineShaderStageCreateInfo);
      this._pStages = array;
      return this.pStages;
    } else {
      return this._pStages;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pStages = value;
    } else if (value === null) {
      this._pStages = null;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.pStages': Expected 'Array VkPipelineShaderStageCreateInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "groupCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoKHR.groupCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pGroups": {
    get() {
    if (this._pGroups === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.groupCount, VkRayTracingShaderGroupCreateInfoKHR);
      this._pGroups = array;
      return this.pGroups;
    } else {
      return this._pGroups;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pGroups = value;
    } else if (value === null) {
      this._pGroups = null;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.pGroups': Expected 'Array VkRayTracingShaderGroupCreateInfoKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "maxPipelineRayRecursionDepth": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoKHR.maxPipelineRayRecursionDepth");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pLibraryInfo": {
    get() {
    if (this._pLibraryInfo === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineLibraryCreateInfoKHR.byteLength));
      this._pLibraryInfo = new VkPipelineLibraryCreateInfoKHR({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pLibraryInfo.memoryAddress, true);
      return this.pLibraryInfo;
    } else {
      return this._pLibraryInfo;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLibraryCreateInfoKHR) {
      value.flush();
      this._pLibraryInfo = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pLibraryInfo = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.pLibraryInfo': Expected 'VkPipelineLibraryCreateInfoKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pLibraryInterface": {
    get() {
    if (this._pLibraryInterface === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkRayTracingPipelineInterfaceCreateInfoKHR.byteLength));
      this._pLibraryInterface = new VkRayTracingPipelineInterfaceCreateInfoKHR({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pLibraryInterface.memoryAddress, true);
      return this.pLibraryInterface;
    } else {
      return this._pLibraryInterface;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkRayTracingPipelineInterfaceCreateInfoKHR) {
      value.flush();
      this._pLibraryInterface = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pLibraryInterface = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.pLibraryInterface': Expected 'VkRayTracingPipelineInterfaceCreateInfoKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pDynamicState": {
    get() {
    if (this._pDynamicState === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineDynamicStateCreateInfo.byteLength));
      this._pDynamicState = new VkPipelineDynamicStateCreateInfo({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pDynamicState.memoryAddress, true);
      return this.pDynamicState;
    } else {
      return this._pDynamicState;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineDynamicStateCreateInfo) {
      value.flush();
      this._pDynamicState = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pDynamicState = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.pDynamicState': Expected 'VkPipelineDynamicStateCreateInfo' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "layout": {
    get() {
    return this._layout;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._layout = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._layout = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.layout': Expected 'VkPipelineLayout' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineHandle": {
    get() {
    return this._basePipelineHandle;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._basePipelineHandle = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._basePipelineHandle = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.basePipelineHandle': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "basePipelineIndex": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineCreateInfoKHR.basePipelineIndex");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkRayTracingPipelineCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pStages = null;
  this._pStagesNative = null;
  
  this._pGroups = null;
  this._pGroupsNative = null;
  
  this._pLibraryInfo = null;
  this._pLibraryInterface = null;
  this._pDynamicState = null;
  this._layout = null;
  this._basePipelineHandle = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
    if (opts.pStages !== void 0) this.pStages = opts.pStages;
    if (opts.groupCount !== void 0) this.groupCount = opts.groupCount;
    if (opts.pGroups !== void 0) this.pGroups = opts.pGroups;
    if (opts.maxPipelineRayRecursionDepth !== void 0) this.maxPipelineRayRecursionDepth = opts.maxPipelineRayRecursionDepth;
    if (opts.pLibraryInfo !== void 0) this.pLibraryInfo = opts.pLibraryInfo;
    if (opts.pLibraryInterface !== void 0) this.pLibraryInterface = opts.pLibraryInterface;
    if (opts.pDynamicState !== void 0) this.pDynamicState = opts.pDynamicState;
    if (opts.layout !== void 0) this.layout = opts.layout;
    if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
    if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
    
  }
};

VkRayTracingPipelineCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pStages !== null) {
    let array = this._pStages;
    
    if (array.length !== this.stageCount) {
      throw new RangeError("Invalid array length, expected length of 'stageCount' for 'VkRayTracingPipelineCreateInfoKHR.pStages'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipelineShaderStageCreateInfo)) {
        throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.pStages[" + ii + "]': Expected 'VkPipelineShaderStageCreateInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pStagesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pStagesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._pGroups !== null) {
    let array = this._pGroups;
    
    if (array.length !== this.groupCount) {
      throw new RangeError("Invalid array length, expected length of 'groupCount' for 'VkRayTracingPipelineCreateInfoKHR.pGroups'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkRayTracingShaderGroupCreateInfoKHR)) {
        throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoKHR.pGroups[" + ii + "]': Expected 'VkRayTracingShaderGroupCreateInfoKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pGroupsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pGroupsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRayTracingPipelineCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkRayTracingPipelineCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRayTracingPipelineCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.stageCount = original.stageCount;
  if (original.pStages !== null) {
        copy.pStages = [...Array(original.pStages.length)].map((v, i) => {
          return original.pStages[i].constructor.createCopyFrom(original.pStages[i]);
        });
      }
  copy.groupCount = original.groupCount;
  if (original.pGroups !== null) {
        copy.pGroups = [...Array(original.pGroups.length)].map((v, i) => {
          return original.pGroups[i].constructor.createCopyFrom(original.pGroups[i]);
        });
      }
  copy.maxPipelineRayRecursionDepth = original.maxPipelineRayRecursionDepth;
  if (original.pLibraryInfo !== null) {
        copy.pLibraryInfo = original.pLibraryInfo.constructor.createCopyFrom(original.pLibraryInfo);
      }
  if (original.pLibraryInterface !== null) {
        copy.pLibraryInterface = original.pLibraryInterface.constructor.createCopyFrom(original.pLibraryInterface);
      }
  if (original.pDynamicState !== null) {
        copy.pDynamicState = original.pDynamicState.constructor.createCopyFrom(original.pDynamicState);
      }
  if (original.layout !== null) {
        copy.layout = original.layout.constructor.createCopyFrom(original.layout);
      }
  if (original.basePipelineHandle !== null) {
        copy.basePipelineHandle = original.basePipelineHandle.constructor.createCopyFrom(original.basePipelineHandle);
      }
  copy.basePipelineIndex = original.basePipelineIndex;
  
  return copy;
};

VkRayTracingPipelineCreateInfoKHR.byteLength = 0x0;

VkRayTracingPipelineCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stageCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pStages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  groupCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pGroups: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPipelineRayRecursionDepth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pLibraryInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pLibraryInterface: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDynamicState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  basePipelineHandle: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  basePipelineIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkGeometryTrianglesNV **/
function VkGeometryTrianglesNV(opts, byteOffset) {
  if (new.target !== VkGeometryTrianglesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkGeometryTrianglesNV, STRUCT_CACHE_VkGeometryTrianglesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkGeometryTrianglesNV, STRUCT_CACHE_VkGeometryTrianglesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkGeometryTrianglesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._vertexData = null;
  
  
  
  
  this._indexData = null;
  
  
  
  this._transformData = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexData !== void 0) this.vertexData = opts.vertexData;
    if (opts.vertexOffset !== void 0) this.vertexOffset = opts.vertexOffset;
    if (opts.vertexCount !== void 0) this.vertexCount = opts.vertexCount;
    if (opts.vertexStride !== void 0) this.vertexStride = opts.vertexStride;
    if (opts.vertexFormat !== void 0) this.vertexFormat = opts.vertexFormat;
    if (opts.indexData !== void 0) this.indexData = opts.indexData;
    if (opts.indexOffset !== void 0) this.indexOffset = opts.indexOffset;
    if (opts.indexCount !== void 0) this.indexCount = opts.indexCount;
    if (opts.indexType !== void 0) this.indexType = opts.indexType;
    if (opts.transformData !== void 0) this.transformData = opts.transformData;
    if (opts.transformOffset !== void 0) this.transformOffset = opts.transformOffset;
    
  }
};

Object.defineProperties(VkGeometryTrianglesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryTrianglesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkGeometryTrianglesNV.pNext' isn't allowed to be filled");
    }
    },
  "vertexData": {
    get() {
    return this._vertexData;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._vertexData = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._vertexData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexData': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "vertexOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkGeometryTrianglesNV.vertexOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "vertexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryTrianglesNV.vertexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "vertexStride": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkGeometryTrianglesNV.vertexStride")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "vertexFormat": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryTrianglesNV.vertexFormat");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "indexData": {
    get() {
    return this._indexData;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._indexData = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._indexData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.indexData': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "indexOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkGeometryTrianglesNV.indexOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "indexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryTrianglesNV.indexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "indexType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryTrianglesNV.indexType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "transformData": {
    get() {
    return this._transformData;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._transformData = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._transformData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.transformData': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "transformOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkGeometryTrianglesNV.transformOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkGeometryTrianglesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._vertexData = null;
  
  
  
  
  this._indexData = null;
  
  
  
  this._transformData = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexData !== void 0) this.vertexData = opts.vertexData;
    if (opts.vertexOffset !== void 0) this.vertexOffset = opts.vertexOffset;
    if (opts.vertexCount !== void 0) this.vertexCount = opts.vertexCount;
    if (opts.vertexStride !== void 0) this.vertexStride = opts.vertexStride;
    if (opts.vertexFormat !== void 0) this.vertexFormat = opts.vertexFormat;
    if (opts.indexData !== void 0) this.indexData = opts.indexData;
    if (opts.indexOffset !== void 0) this.indexOffset = opts.indexOffset;
    if (opts.indexCount !== void 0) this.indexCount = opts.indexCount;
    if (opts.indexType !== void 0) this.indexType = opts.indexType;
    if (opts.transformData !== void 0) this.transformData = opts.transformData;
    if (opts.transformOffset !== void 0) this.transformOffset = opts.transformOffset;
    
  }
};

VkGeometryTrianglesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkGeometryTrianglesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkGeometryTrianglesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkGeometryTrianglesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.vertexData !== null) {
        copy.vertexData = original.vertexData.constructor.createCopyFrom(original.vertexData);
      }
  copy.vertexOffset = original.vertexOffset;
  copy.vertexCount = original.vertexCount;
  copy.vertexStride = original.vertexStride;
  copy.vertexFormat = original.vertexFormat;
  if (original.indexData !== null) {
        copy.indexData = original.indexData.constructor.createCopyFrom(original.indexData);
      }
  copy.indexOffset = original.indexOffset;
  copy.indexCount = original.indexCount;
  copy.indexType = original.indexType;
  if (original.transformData !== null) {
        copy.transformData = original.transformData.constructor.createCopyFrom(original.transformData);
      }
  copy.transformOffset = original.transformOffset;
  
  return copy;
};

VkGeometryTrianglesNV.byteLength = 0x0;

VkGeometryTrianglesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexStride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexFormat: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indexData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indexOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indexType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transformData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transformOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkGeometryAABBNV **/
function VkGeometryAABBNV(opts, byteOffset) {
  if (new.target !== VkGeometryAABBNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkGeometryAABBNV, STRUCT_CACHE_VkGeometryAABBNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkGeometryAABBNV, STRUCT_CACHE_VkGeometryAABBNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkGeometryAABBNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._aabbData = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.aabbData !== void 0) this.aabbData = opts.aabbData;
    if (opts.numAABBs !== void 0) this.numAABBs = opts.numAABBs;
    if (opts.stride !== void 0) this.stride = opts.stride;
    if (opts.offset !== void 0) this.offset = opts.offset;
    
  }
};

Object.defineProperties(VkGeometryAABBNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryAABBNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkGeometryAABBNV.pNext' isn't allowed to be filled");
    }
    },
  "aabbData": {
    get() {
    return this._aabbData;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._aabbData = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._aabbData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.aabbData': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "numAABBs": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryAABBNV.numAABBs");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "stride": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryAABBNV.stride");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "offset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkGeometryAABBNV.offset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkGeometryAABBNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._aabbData = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.aabbData !== void 0) this.aabbData = opts.aabbData;
    if (opts.numAABBs !== void 0) this.numAABBs = opts.numAABBs;
    if (opts.stride !== void 0) this.stride = opts.stride;
    if (opts.offset !== void 0) this.offset = opts.offset;
    
  }
};

VkGeometryAABBNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkGeometryAABBNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkGeometryAABBNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkGeometryAABBNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.aabbData !== null) {
        copy.aabbData = original.aabbData.constructor.createCopyFrom(original.aabbData);
      }
  copy.numAABBs = original.numAABBs;
  copy.stride = original.stride;
  copy.offset = original.offset;
  
  return copy;
};

VkGeometryAABBNV.byteLength = 0x0;

VkGeometryAABBNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  aabbData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  numAABBs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkGeometryDataNV **/
function VkGeometryDataNV(opts, byteOffset) {
  if (new.target !== VkGeometryDataNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkGeometryDataNV, STRUCT_CACHE_VkGeometryDataNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkGeometryDataNV, STRUCT_CACHE_VkGeometryDataNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkGeometryDataNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._triangles = new VkGeometryTrianglesNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._aabbs = new VkGeometryAABBNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.triangles !== void 0) this.triangles = opts.triangles;
    if (opts.aabbs !== void 0) this.aabbs = opts.aabbs;
    
  }
};

Object.defineProperties(VkGeometryDataNV.prototype, {
  "triangles": {
    get() {
    return this._triangles;
    },
    set(value) {
    if (value !== null && value.constructor === VkGeometryTrianglesNV) {
      value.flush();
      this._triangles = value;
      
      
    } else if (value === null) {
      this._triangles = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkGeometryDataNV.triangles': Expected 'VkGeometryTrianglesNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "aabbs": {
    get() {
    return this._aabbs;
    },
    set(value) {
    if (value !== null && value.constructor === VkGeometryAABBNV) {
      value.flush();
      this._aabbs = value;
      
      
    } else if (value === null) {
      this._aabbs = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkGeometryDataNV.aabbs': Expected 'VkGeometryAABBNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkGeometryDataNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._triangles !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._triangles.memoryBuffer) this._triangles = new VkGeometryTrianglesNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._triangles.reset();
  }
  if (this._aabbs !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._aabbs.memoryBuffer) this._aabbs = new VkGeometryAABBNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._aabbs.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.triangles !== void 0) this.triangles = opts.triangles;
    if (opts.aabbs !== void 0) this.aabbs = opts.aabbs;
    
  }
};

VkGeometryDataNV.prototype.flush = function flush() {
  
  
  if (this._triangles !== null) {
    let triangles = this._triangles;
    triangles.flush();
    if (this.memoryBuffer !== triangles.memoryBuffer) {
      let srcView = new Uint8Array(triangles.memoryBuffer, triangles.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkGeometryDataNV.triangles' isn't used as shared-memory");
    }
  }
  
  
  if (this._aabbs !== null) {
    let aabbs = this._aabbs;
    aabbs.flush();
    if (this.memoryBuffer !== aabbs.memoryBuffer) {
      let srcView = new Uint8Array(aabbs.memoryBuffer, aabbs.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkGeometryDataNV.aabbs' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkGeometryDataNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkGeometryDataNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkGeometryDataNV();
  if (original.triangles !== null) {
        copy.triangles = original.triangles.constructor.createCopyFrom(original.triangles);
      }
  if (original.aabbs !== null) {
        copy.aabbs = original.aabbs.constructor.createCopyFrom(original.aabbs);
      }
  
  return copy;
};

VkGeometryDataNV.byteLength = 0x0;

VkGeometryDataNV.memoryLayout = {
  triangles: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  aabbs: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkGeometryNV **/
function VkGeometryNV(opts, byteOffset) {
  if (new.target !== VkGeometryNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkGeometryNV, STRUCT_CACHE_VkGeometryNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkGeometryNV, STRUCT_CACHE_VkGeometryNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkGeometryNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._geometry = new VkGeometryDataNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.geometryType !== void 0) this.geometryType = opts.geometryType;
    if (opts.geometry !== void 0) this.geometry = opts.geometry;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkGeometryNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkGeometryNV.pNext' isn't allowed to be filled");
    }
    },
  "geometryType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryNV.geometryType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "geometry": {
    get() {
    return this._geometry;
    },
    set(value) {
    if (value !== null && value.constructor === VkGeometryDataNV) {
      value.flush();
      this._geometry = value;
      
      
    } else if (value === null) {
      this._geometry = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkGeometryNV.geometry': Expected 'VkGeometryDataNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkGeometryNV.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkGeometryNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._geometry !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._geometry.memoryBuffer) this._geometry = new VkGeometryDataNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._geometry.reset();
  }
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.geometryType !== void 0) this.geometryType = opts.geometryType;
    if (opts.geometry !== void 0) this.geometry = opts.geometry;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkGeometryNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._geometry !== null) {
    let geometry = this._geometry;
    geometry.flush();
    if (this.memoryBuffer !== geometry.memoryBuffer) {
      let srcView = new Uint8Array(geometry.memoryBuffer, geometry.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkGeometryNV.geometry' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkGeometryNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkGeometryNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkGeometryNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.geometryType = original.geometryType;
  if (original.geometry !== null) {
        copy.geometry = original.geometry.constructor.createCopyFrom(original.geometry);
      }
  copy.flags = original.flags;
  
  return copy;
};

VkGeometryNV.byteLength = 0x0;

VkGeometryNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  geometryType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  geometry: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureInfoNV **/
function VkAccelerationStructureInfoNV(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureInfoNV, STRUCT_CACHE_VkAccelerationStructureInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureInfoNV, STRUCT_CACHE_VkAccelerationStructureInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this._pGeometries = null;
  this._pGeometriesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
    if (opts.geometryCount !== void 0) this.geometryCount = opts.geometryCount;
    if (opts.pGeometries !== void 0) this.pGeometries = opts.pGeometries;
    
  }
};

Object.defineProperties(VkAccelerationStructureInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInfoNV.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInfoNV.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "instanceCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInfoNV.instanceCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "geometryCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInfoNV.geometryCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pGeometries": {
    get() {
    if (this._pGeometries === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.geometryCount, VkGeometryNV);
      this._pGeometries = array;
      return this.pGeometries;
    } else {
      return this._pGeometries;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pGeometries = value;
    } else if (value === null) {
      this._pGeometries = null;
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.pGeometries': Expected 'Array VkGeometryNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkAccelerationStructureInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pGeometries = null;
  this._pGeometriesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
    if (opts.geometryCount !== void 0) this.geometryCount = opts.geometryCount;
    if (opts.pGeometries !== void 0) this.pGeometries = opts.pGeometries;
    
  }
};

VkAccelerationStructureInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pGeometries !== null) {
    let array = this._pGeometries;
    
    if (array.length !== this.geometryCount) {
      throw new RangeError("Invalid array length, expected length of 'geometryCount' for 'VkAccelerationStructureInfoNV.pGeometries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkGeometryNV)) {
        throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.pGeometries[" + ii + "]': Expected 'VkGeometryNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pGeometriesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pGeometriesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkAccelerationStructureInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.type = original.type;
  copy.flags = original.flags;
  copy.instanceCount = original.instanceCount;
  copy.geometryCount = original.geometryCount;
  if (original.pGeometries !== null) {
        copy.pGeometries = [...Array(original.pGeometries.length)].map((v, i) => {
          return original.pGeometries[i].constructor.createCopyFrom(original.pGeometries[i]);
        });
      }
  
  return copy;
};

VkAccelerationStructureInfoNV.byteLength = 0x0;

VkAccelerationStructureInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  instanceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  geometryCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pGeometries: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureCreateInfoNV **/
function VkAccelerationStructureCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureCreateInfoNV, STRUCT_CACHE_VkAccelerationStructureCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureCreateInfoNV, STRUCT_CACHE_VkAccelerationStructureCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._info = new VkAccelerationStructureInfoNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.compactedSize !== void 0) this.compactedSize = opts.compactedSize;
    if (opts.info !== void 0) this.info = opts.info;
    
  }
};

Object.defineProperties(VkAccelerationStructureCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "compactedSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureCreateInfoNV.compactedSize")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "info": {
    get() {
    return this._info;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureInfoNV) {
      value.flush();
      this._info = value;
      
      
    } else if (value === null) {
      this._info = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureCreateInfoNV.info': Expected 'VkAccelerationStructureInfoNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAccelerationStructureCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._info !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._info.memoryBuffer) this._info = new VkAccelerationStructureInfoNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._info.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.compactedSize !== void 0) this.compactedSize = opts.compactedSize;
    if (opts.info !== void 0) this.info = opts.info;
    
  }
};

VkAccelerationStructureCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._info !== null) {
    let info = this._info;
    info.flush();
    if (this.memoryBuffer !== info.memoryBuffer) {
      let srcView = new Uint8Array(info.memoryBuffer, info.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureCreateInfoNV.info' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAccelerationStructureCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.compactedSize = original.compactedSize;
  if (original.info !== null) {
        copy.info = original.info.constructor.createCopyFrom(original.info);
      }
  
  return copy;
};

VkAccelerationStructureCreateInfoNV.byteLength = 0x0;

VkAccelerationStructureCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compactedSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  info: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBindAccelerationStructureMemoryInfoNV **/
function VkBindAccelerationStructureMemoryInfoNV(opts, byteOffset) {
  if (new.target !== VkBindAccelerationStructureMemoryInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBindAccelerationStructureMemoryInfoNV, STRUCT_CACHE_VkBindAccelerationStructureMemoryInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBindAccelerationStructureMemoryInfoNV, STRUCT_CACHE_VkBindAccelerationStructureMemoryInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBindAccelerationStructureMemoryInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._accelerationStructure = null;
  this._memory = null;
  
  
  this._pDeviceIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    
  }
};

Object.defineProperties(VkBindAccelerationStructureMemoryInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindAccelerationStructureMemoryInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBindAccelerationStructureMemoryInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "accelerationStructure": {
    get() {
    return this._accelerationStructure;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureNV) {
      
      this._accelerationStructure = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._accelerationStructure = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.accelerationStructure': Expected 'VkAccelerationStructureNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "memoryOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBindAccelerationStructureMemoryInfoNV.memoryOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "deviceIndexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBindAccelerationStructureMemoryInfoNV.deviceIndexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDeviceIndices": {
    get() {
    return this._pDeviceIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.pDeviceIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBindAccelerationStructureMemoryInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._accelerationStructure = null;
  this._memory = null;
  
  
  this._pDeviceIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
    if (opts.memory !== void 0) this.memory = opts.memory;
    if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
    if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
    if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
    
  }
};

VkBindAccelerationStructureMemoryInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindAccelerationStructureMemoryInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkBindAccelerationStructureMemoryInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBindAccelerationStructureMemoryInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.accelerationStructure !== null) {
        copy.accelerationStructure = original.accelerationStructure.constructor.createCopyFrom(original.accelerationStructure);
      }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  copy.memoryOffset = original.memoryOffset;
  copy.deviceIndexCount = original.deviceIndexCount;
  if (original.pDeviceIndices !== null) {
        copy.pDeviceIndices = new Uint32Array(original.pDeviceIndices);
      }
  
  return copy;
};

VkBindAccelerationStructureMemoryInfoNV.byteLength = 0x0;

VkBindAccelerationStructureMemoryInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructure: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceIndexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDeviceIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkWriteDescriptorSetAccelerationStructureKHR **/
function VkWriteDescriptorSetAccelerationStructureKHR(opts, byteOffset) {
  if (new.target !== VkWriteDescriptorSetAccelerationStructureKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkWriteDescriptorSetAccelerationStructureKHR, STRUCT_CACHE_VkWriteDescriptorSetAccelerationStructureKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkWriteDescriptorSetAccelerationStructureKHR, STRUCT_CACHE_VkWriteDescriptorSetAccelerationStructureKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkWriteDescriptorSetAccelerationStructureKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAccelerationStructures = null;
  this._pAccelerationStructuresNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructureCount !== void 0) this.accelerationStructureCount = opts.accelerationStructureCount;
    if (opts.pAccelerationStructures !== void 0) this.pAccelerationStructures = opts.pAccelerationStructures;
    
  }
};

Object.defineProperties(VkWriteDescriptorSetAccelerationStructureKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSetAccelerationStructureKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWriteDescriptorSetAccelerationStructureKHR.pNext' isn't allowed to be filled");
    }
    },
  "accelerationStructureCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSetAccelerationStructureKHR.accelerationStructureCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAccelerationStructures": {
    get() {
    if (this._pAccelerationStructures === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.accelerationStructureCount, VkAccelerationStructureKHR);
      this._pAccelerationStructures = array;
      return this.pAccelerationStructures;
    } else {
      return this._pAccelerationStructures;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAccelerationStructures = value;
    } else if (value === null) {
      this._pAccelerationStructures = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureKHR.pAccelerationStructures': Expected 'Array VkAccelerationStructureKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkWriteDescriptorSetAccelerationStructureKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAccelerationStructures = null;
  this._pAccelerationStructuresNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructureCount !== void 0) this.accelerationStructureCount = opts.accelerationStructureCount;
    if (opts.pAccelerationStructures !== void 0) this.pAccelerationStructures = opts.pAccelerationStructures;
    
  }
};

VkWriteDescriptorSetAccelerationStructureKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAccelerationStructures !== null) {
    let array = this._pAccelerationStructures;
    
    if (array.length !== this.accelerationStructureCount) {
      throw new RangeError("Invalid array length, expected length of 'accelerationStructureCount' for 'VkWriteDescriptorSetAccelerationStructureKHR.pAccelerationStructures'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAccelerationStructureKHR)) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureKHR.pAccelerationStructures[" + ii + "]': Expected 'VkAccelerationStructureKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAccelerationStructuresNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAccelerationStructuresNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkWriteDescriptorSetAccelerationStructureKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkWriteDescriptorSetAccelerationStructureKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkWriteDescriptorSetAccelerationStructureKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.accelerationStructureCount = original.accelerationStructureCount;
  if (original.pAccelerationStructures !== null) {
        copy.pAccelerationStructures = [...Array(original.pAccelerationStructures.length)].map((v, i) => {
          return original.pAccelerationStructures[i].constructor.createCopyFrom(original.pAccelerationStructures[i]);
        });
      }
  
  return copy;
};

VkWriteDescriptorSetAccelerationStructureKHR.byteLength = 0x0;

VkWriteDescriptorSetAccelerationStructureKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructureCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAccelerationStructures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkWriteDescriptorSetAccelerationStructureNV **/
function VkWriteDescriptorSetAccelerationStructureNV(opts, byteOffset) {
  if (new.target !== VkWriteDescriptorSetAccelerationStructureNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkWriteDescriptorSetAccelerationStructureNV, STRUCT_CACHE_VkWriteDescriptorSetAccelerationStructureNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkWriteDescriptorSetAccelerationStructureNV, STRUCT_CACHE_VkWriteDescriptorSetAccelerationStructureNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkWriteDescriptorSetAccelerationStructureNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAccelerationStructures = null;
  this._pAccelerationStructuresNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructureCount !== void 0) this.accelerationStructureCount = opts.accelerationStructureCount;
    if (opts.pAccelerationStructures !== void 0) this.pAccelerationStructures = opts.pAccelerationStructures;
    
  }
};

Object.defineProperties(VkWriteDescriptorSetAccelerationStructureNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSetAccelerationStructureNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkWriteDescriptorSetAccelerationStructureNV.pNext' isn't allowed to be filled");
    }
    },
  "accelerationStructureCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkWriteDescriptorSetAccelerationStructureNV.accelerationStructureCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAccelerationStructures": {
    get() {
    if (this._pAccelerationStructures === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.accelerationStructureCount, VkAccelerationStructureNV);
      this._pAccelerationStructures = array;
      return this.pAccelerationStructures;
    } else {
      return this._pAccelerationStructures;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAccelerationStructures = value;
    } else if (value === null) {
      this._pAccelerationStructures = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures': Expected 'Array VkAccelerationStructureNV' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkWriteDescriptorSetAccelerationStructureNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAccelerationStructures = null;
  this._pAccelerationStructuresNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructureCount !== void 0) this.accelerationStructureCount = opts.accelerationStructureCount;
    if (opts.pAccelerationStructures !== void 0) this.pAccelerationStructures = opts.pAccelerationStructures;
    
  }
};

VkWriteDescriptorSetAccelerationStructureNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAccelerationStructures !== null) {
    let array = this._pAccelerationStructures;
    
    if (array.length !== this.accelerationStructureCount) {
      throw new RangeError("Invalid array length, expected length of 'accelerationStructureCount' for 'VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAccelerationStructureNV)) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures[" + ii + "]': Expected 'VkAccelerationStructureNV' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAccelerationStructuresNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAccelerationStructuresNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkWriteDescriptorSetAccelerationStructureNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkWriteDescriptorSetAccelerationStructureNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkWriteDescriptorSetAccelerationStructureNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.accelerationStructureCount = original.accelerationStructureCount;
  if (original.pAccelerationStructures !== null) {
        copy.pAccelerationStructures = [...Array(original.pAccelerationStructures.length)].map((v, i) => {
          return original.pAccelerationStructures[i].constructor.createCopyFrom(original.pAccelerationStructures[i]);
        });
      }
  
  return copy;
};

VkWriteDescriptorSetAccelerationStructureNV.byteLength = 0x0;

VkWriteDescriptorSetAccelerationStructureNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructureCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAccelerationStructures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureMemoryRequirementsInfoNV **/
function VkAccelerationStructureMemoryRequirementsInfoNV(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureMemoryRequirementsInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureMemoryRequirementsInfoNV, STRUCT_CACHE_VkAccelerationStructureMemoryRequirementsInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureMemoryRequirementsInfoNV, STRUCT_CACHE_VkAccelerationStructureMemoryRequirementsInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureMemoryRequirementsInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._accelerationStructure = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
    
  }
};

Object.defineProperties(VkAccelerationStructureMemoryRequirementsInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureMemoryRequirementsInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureMemoryRequirementsInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureMemoryRequirementsInfoNV.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "accelerationStructure": {
    get() {
    return this._accelerationStructure;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureNV) {
      
      this._accelerationStructure = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._accelerationStructure = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureMemoryRequirementsInfoNV.accelerationStructure': Expected 'VkAccelerationStructureNV' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAccelerationStructureMemoryRequirementsInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._accelerationStructure = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
    
  }
};

VkAccelerationStructureMemoryRequirementsInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAccelerationStructureMemoryRequirementsInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureMemoryRequirementsInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureMemoryRequirementsInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.type = original.type;
  if (original.accelerationStructure !== null) {
        copy.accelerationStructure = original.accelerationStructure.constructor.createCopyFrom(original.accelerationStructure);
      }
  
  return copy;
};

VkAccelerationStructureMemoryRequirementsInfoNV.byteLength = 0x0;

VkAccelerationStructureMemoryRequirementsInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructure: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceAccelerationStructureFeaturesKHR **/
function VkPhysicalDeviceAccelerationStructureFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceAccelerationStructureFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceAccelerationStructureFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceAccelerationStructureFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceAccelerationStructureFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceAccelerationStructureFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceAccelerationStructureFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
    if (opts.accelerationStructureCaptureReplay !== void 0) this.accelerationStructureCaptureReplay = opts.accelerationStructureCaptureReplay;
    if (opts.accelerationStructureIndirectBuild !== void 0) this.accelerationStructureIndirectBuild = opts.accelerationStructureIndirectBuild;
    if (opts.accelerationStructureHostCommands !== void 0) this.accelerationStructureHostCommands = opts.accelerationStructureHostCommands;
    if (opts.descriptorBindingAccelerationStructureUpdateAfterBind !== void 0) this.descriptorBindingAccelerationStructureUpdateAfterBind = opts.descriptorBindingAccelerationStructureUpdateAfterBind;
    
  }
};

Object.defineProperties(VkPhysicalDeviceAccelerationStructureFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceAccelerationStructureFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceAccelerationStructureFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "accelerationStructure": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "accelerationStructureCaptureReplay": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "accelerationStructureIndirectBuild": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "accelerationStructureHostCommands": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingAccelerationStructureUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceAccelerationStructureFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
    if (opts.accelerationStructureCaptureReplay !== void 0) this.accelerationStructureCaptureReplay = opts.accelerationStructureCaptureReplay;
    if (opts.accelerationStructureIndirectBuild !== void 0) this.accelerationStructureIndirectBuild = opts.accelerationStructureIndirectBuild;
    if (opts.accelerationStructureHostCommands !== void 0) this.accelerationStructureHostCommands = opts.accelerationStructureHostCommands;
    if (opts.descriptorBindingAccelerationStructureUpdateAfterBind !== void 0) this.descriptorBindingAccelerationStructureUpdateAfterBind = opts.descriptorBindingAccelerationStructureUpdateAfterBind;
    
  }
};

VkPhysicalDeviceAccelerationStructureFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceAccelerationStructureFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceAccelerationStructureFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceAccelerationStructureFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.accelerationStructure = original.accelerationStructure;
  copy.accelerationStructureCaptureReplay = original.accelerationStructureCaptureReplay;
  copy.accelerationStructureIndirectBuild = original.accelerationStructureIndirectBuild;
  copy.accelerationStructureHostCommands = original.accelerationStructureHostCommands;
  copy.descriptorBindingAccelerationStructureUpdateAfterBind = original.descriptorBindingAccelerationStructureUpdateAfterBind;
  
  return copy;
};

VkPhysicalDeviceAccelerationStructureFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceAccelerationStructureFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructure: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructureCaptureReplay: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructureIndirectBuild: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructureHostCommands: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingAccelerationStructureUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceRayTracingPipelineFeaturesKHR **/
function VkPhysicalDeviceRayTracingPipelineFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceRayTracingPipelineFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceRayTracingPipelineFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceRayTracingPipelineFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceRayTracingPipelineFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceRayTracingPipelineFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceRayTracingPipelineFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.rayTracingPipeline !== void 0) this.rayTracingPipeline = opts.rayTracingPipeline;
    if (opts.rayTracingPipelineShaderGroupHandleCaptureReplay !== void 0) this.rayTracingPipelineShaderGroupHandleCaptureReplay = opts.rayTracingPipelineShaderGroupHandleCaptureReplay;
    if (opts.rayTracingPipelineShaderGroupHandleCaptureReplayMixed !== void 0) this.rayTracingPipelineShaderGroupHandleCaptureReplayMixed = opts.rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
    if (opts.rayTracingPipelineTraceRaysIndirect !== void 0) this.rayTracingPipelineTraceRaysIndirect = opts.rayTracingPipelineTraceRaysIndirect;
    if (opts.rayTraversalPrimitiveCulling !== void 0) this.rayTraversalPrimitiveCulling = opts.rayTraversalPrimitiveCulling;
    
  }
};

Object.defineProperties(VkPhysicalDeviceRayTracingPipelineFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceRayTracingPipelineFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceRayTracingPipelineFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "rayTracingPipeline": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "rayTracingPipelineShaderGroupHandleCaptureReplay": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "rayTracingPipelineShaderGroupHandleCaptureReplayMixed": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "rayTracingPipelineTraceRaysIndirect": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "rayTraversalPrimitiveCulling": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceRayTracingPipelineFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.rayTracingPipeline !== void 0) this.rayTracingPipeline = opts.rayTracingPipeline;
    if (opts.rayTracingPipelineShaderGroupHandleCaptureReplay !== void 0) this.rayTracingPipelineShaderGroupHandleCaptureReplay = opts.rayTracingPipelineShaderGroupHandleCaptureReplay;
    if (opts.rayTracingPipelineShaderGroupHandleCaptureReplayMixed !== void 0) this.rayTracingPipelineShaderGroupHandleCaptureReplayMixed = opts.rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
    if (opts.rayTracingPipelineTraceRaysIndirect !== void 0) this.rayTracingPipelineTraceRaysIndirect = opts.rayTracingPipelineTraceRaysIndirect;
    if (opts.rayTraversalPrimitiveCulling !== void 0) this.rayTraversalPrimitiveCulling = opts.rayTraversalPrimitiveCulling;
    
  }
};

VkPhysicalDeviceRayTracingPipelineFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRayTracingPipelineFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceRayTracingPipelineFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceRayTracingPipelineFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.rayTracingPipeline = original.rayTracingPipeline;
  copy.rayTracingPipelineShaderGroupHandleCaptureReplay = original.rayTracingPipelineShaderGroupHandleCaptureReplay;
  copy.rayTracingPipelineShaderGroupHandleCaptureReplayMixed = original.rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
  copy.rayTracingPipelineTraceRaysIndirect = original.rayTracingPipelineTraceRaysIndirect;
  copy.rayTraversalPrimitiveCulling = original.rayTraversalPrimitiveCulling;
  
  return copy;
};

VkPhysicalDeviceRayTracingPipelineFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceRayTracingPipelineFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rayTracingPipeline: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rayTracingPipelineShaderGroupHandleCaptureReplay: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rayTracingPipelineShaderGroupHandleCaptureReplayMixed: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rayTracingPipelineTraceRaysIndirect: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rayTraversalPrimitiveCulling: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceRayQueryFeaturesKHR **/
function VkPhysicalDeviceRayQueryFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceRayQueryFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceRayQueryFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceRayQueryFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceRayQueryFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceRayQueryFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceRayQueryFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.rayQuery !== void 0) this.rayQuery = opts.rayQuery;
    
  }
};

Object.defineProperties(VkPhysicalDeviceRayQueryFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceRayQueryFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceRayQueryFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "rayQuery": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceRayQueryFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.rayQuery !== void 0) this.rayQuery = opts.rayQuery;
    
  }
};

VkPhysicalDeviceRayQueryFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRayQueryFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceRayQueryFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceRayQueryFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.rayQuery = original.rayQuery;
  
  return copy;
};

VkPhysicalDeviceRayQueryFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceRayQueryFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rayQuery: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceAccelerationStructurePropertiesKHR **/
function VkPhysicalDeviceAccelerationStructurePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceAccelerationStructurePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceAccelerationStructurePropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceAccelerationStructurePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceAccelerationStructurePropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceAccelerationStructurePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceAccelerationStructurePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceAccelerationStructurePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceAccelerationStructurePropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceAccelerationStructurePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "maxGeometryCount": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "maxInstanceCount": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "maxPrimitiveCount": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "maxPerStageDescriptorAccelerationStructures": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindAccelerationStructures": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetAccelerationStructures": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindAccelerationStructures": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "minAccelerationStructureScratchOffsetAlignment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceAccelerationStructurePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceAccelerationStructurePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceAccelerationStructurePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceAccelerationStructurePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceAccelerationStructurePropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxGeometryCount = original.maxGeometryCount;
  copy.maxInstanceCount = original.maxInstanceCount;
  copy.maxPrimitiveCount = original.maxPrimitiveCount;
  copy.maxPerStageDescriptorAccelerationStructures = original.maxPerStageDescriptorAccelerationStructures;
  copy.maxPerStageDescriptorUpdateAfterBindAccelerationStructures = original.maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
  copy.maxDescriptorSetAccelerationStructures = original.maxDescriptorSetAccelerationStructures;
  copy.maxDescriptorSetUpdateAfterBindAccelerationStructures = original.maxDescriptorSetUpdateAfterBindAccelerationStructures;
  copy.minAccelerationStructureScratchOffsetAlignment = original.minAccelerationStructureScratchOffsetAlignment;
  
  return copy;
};

VkPhysicalDeviceAccelerationStructurePropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceAccelerationStructurePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxGeometryCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxInstanceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPrimitiveCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorAccelerationStructures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindAccelerationStructures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetAccelerationStructures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindAccelerationStructures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minAccelerationStructureScratchOffsetAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceRayTracingPipelinePropertiesKHR **/
function VkPhysicalDeviceRayTracingPipelinePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceRayTracingPipelinePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceRayTracingPipelinePropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceRayTracingPipelinePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceRayTracingPipelinePropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceRayTracingPipelinePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceRayTracingPipelinePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceRayTracingPipelinePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceRayTracingPipelinePropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceRayTracingPipelinePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "shaderGroupHandleSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxRayRecursionDepth": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxShaderGroupStride": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "shaderGroupBaseAlignment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "shaderGroupHandleCaptureReplaySize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxRayDispatchInvocationCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "shaderGroupHandleAlignment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxRayHitAttributeSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceRayTracingPipelinePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceRayTracingPipelinePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRayTracingPipelinePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceRayTracingPipelinePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceRayTracingPipelinePropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderGroupHandleSize = original.shaderGroupHandleSize;
  copy.maxRayRecursionDepth = original.maxRayRecursionDepth;
  copy.maxShaderGroupStride = original.maxShaderGroupStride;
  copy.shaderGroupBaseAlignment = original.shaderGroupBaseAlignment;
  copy.shaderGroupHandleCaptureReplaySize = original.shaderGroupHandleCaptureReplaySize;
  copy.maxRayDispatchInvocationCount = original.maxRayDispatchInvocationCount;
  copy.shaderGroupHandleAlignment = original.shaderGroupHandleAlignment;
  copy.maxRayHitAttributeSize = original.maxRayHitAttributeSize;
  
  return copy;
};

VkPhysicalDeviceRayTracingPipelinePropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceRayTracingPipelinePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderGroupHandleSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxRayRecursionDepth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxShaderGroupStride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderGroupBaseAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderGroupHandleCaptureReplaySize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxRayDispatchInvocationCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderGroupHandleAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxRayHitAttributeSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceRayTracingPropertiesNV **/
function VkPhysicalDeviceRayTracingPropertiesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceRayTracingPropertiesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceRayTracingPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceRayTracingPropertiesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceRayTracingPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceRayTracingPropertiesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceRayTracingPropertiesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceRayTracingPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceRayTracingPropertiesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceRayTracingPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "shaderGroupHandleSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxRecursionDepth": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxShaderGroupStride": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "shaderGroupBaseAlignment": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxGeometryCount": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "maxInstanceCount": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "maxTriangleCount": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "maxDescriptorSetAccelerationStructures": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceRayTracingPropertiesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceRayTracingPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRayTracingPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceRayTracingPropertiesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceRayTracingPropertiesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderGroupHandleSize = original.shaderGroupHandleSize;
  copy.maxRecursionDepth = original.maxRecursionDepth;
  copy.maxShaderGroupStride = original.maxShaderGroupStride;
  copy.shaderGroupBaseAlignment = original.shaderGroupBaseAlignment;
  copy.maxGeometryCount = original.maxGeometryCount;
  copy.maxInstanceCount = original.maxInstanceCount;
  copy.maxTriangleCount = original.maxTriangleCount;
  copy.maxDescriptorSetAccelerationStructures = original.maxDescriptorSetAccelerationStructures;
  
  return copy;
};

VkPhysicalDeviceRayTracingPropertiesNV.byteLength = 0x0;

VkPhysicalDeviceRayTracingPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderGroupHandleSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxRecursionDepth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxShaderGroupStride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderGroupBaseAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxGeometryCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxInstanceCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTriangleCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetAccelerationStructures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkStridedDeviceAddressRegionKHR **/
function VkStridedDeviceAddressRegionKHR(opts, byteOffset) {
  if (new.target !== VkStridedDeviceAddressRegionKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkStridedDeviceAddressRegionKHR, STRUCT_CACHE_VkStridedDeviceAddressRegionKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkStridedDeviceAddressRegionKHR, STRUCT_CACHE_VkStridedDeviceAddressRegionKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkStridedDeviceAddressRegionKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    if (opts.stride !== void 0) this.stride = opts.stride;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkStridedDeviceAddressRegionKHR.prototype, {
  "deviceAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkStridedDeviceAddressRegionKHR.deviceAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "stride": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkStridedDeviceAddressRegionKHR.stride")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkStridedDeviceAddressRegionKHR.size")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkStridedDeviceAddressRegionKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    if (opts.stride !== void 0) this.stride = opts.stride;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

VkStridedDeviceAddressRegionKHR.prototype.flush = function flush() {
  
  return true;
};

VkStridedDeviceAddressRegionKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkStridedDeviceAddressRegionKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkStridedDeviceAddressRegionKHR();
  copy.deviceAddress = original.deviceAddress;
  copy.stride = original.stride;
  copy.size = original.size;
  
  return copy;
};

VkStridedDeviceAddressRegionKHR.byteLength = 0x0;

VkStridedDeviceAddressRegionKHR.memoryLayout = {
  deviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkTraceRaysIndirectCommandKHR **/
function VkTraceRaysIndirectCommandKHR(opts, byteOffset) {
  if (new.target !== VkTraceRaysIndirectCommandKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkTraceRaysIndirectCommandKHR, STRUCT_CACHE_VkTraceRaysIndirectCommandKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkTraceRaysIndirectCommandKHR, STRUCT_CACHE_VkTraceRaysIndirectCommandKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkTraceRaysIndirectCommandKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.depth !== void 0) this.depth = opts.depth;
    
  }
};

Object.defineProperties(VkTraceRaysIndirectCommandKHR.prototype, {
  "width": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkTraceRaysIndirectCommandKHR.width");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "height": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkTraceRaysIndirectCommandKHR.height");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "depth": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkTraceRaysIndirectCommandKHR.depth");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkTraceRaysIndirectCommandKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.depth !== void 0) this.depth = opts.depth;
    
  }
};

VkTraceRaysIndirectCommandKHR.prototype.flush = function flush() {
  
  return true;
};

VkTraceRaysIndirectCommandKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkTraceRaysIndirectCommandKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkTraceRaysIndirectCommandKHR();
  copy.width = original.width;
  copy.height = original.height;
  copy.depth = original.depth;
  
  return copy;
};

VkTraceRaysIndirectCommandKHR.byteLength = 0x0;

VkTraceRaysIndirectCommandKHR.memoryLayout = {
  width: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  height: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depth: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDrmFormatModifierPropertiesListEXT **/
function VkDrmFormatModifierPropertiesListEXT(opts, byteOffset) {
  if (new.target !== VkDrmFormatModifierPropertiesListEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDrmFormatModifierPropertiesListEXT, STRUCT_CACHE_VkDrmFormatModifierPropertiesListEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDrmFormatModifierPropertiesListEXT, STRUCT_CACHE_VkDrmFormatModifierPropertiesListEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDrmFormatModifierPropertiesListEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pDrmFormatModifierProperties = null;
  this._pDrmFormatModifierPropertiesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkDrmFormatModifierPropertiesListEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDrmFormatModifierPropertiesListEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDrmFormatModifierPropertiesListEXT.pNext' isn't allowed to be filled");
    }
    },
  "drmFormatModifierCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "pDrmFormatModifierProperties": {
    get() {
    if (this._pDrmFormatModifierProperties === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.drmFormatModifierCount, VkDrmFormatModifierPropertiesEXT);
      this._pDrmFormatModifierProperties = array;
      return this.pDrmFormatModifierProperties;
    } else {
      return this._pDrmFormatModifierProperties;
    }
    },
    },
  
});

VkDrmFormatModifierPropertiesListEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pDrmFormatModifierProperties = null;
  this._pDrmFormatModifierPropertiesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkDrmFormatModifierPropertiesListEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDrmFormatModifierPropertiesListEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDrmFormatModifierPropertiesListEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDrmFormatModifierPropertiesListEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.drmFormatModifierCount = original.drmFormatModifierCount;
  if (original.pDrmFormatModifierProperties !== null) {
        copy.pDrmFormatModifierProperties = [...Array(original.pDrmFormatModifierProperties.length)].map((v, i) => {
          return original.pDrmFormatModifierProperties[i].constructor.createCopyFrom(original.pDrmFormatModifierProperties[i]);
        });
      }
  
  return copy;
};

VkDrmFormatModifierPropertiesListEXT.byteLength = 0x0;

VkDrmFormatModifierPropertiesListEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  drmFormatModifierCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDrmFormatModifierProperties: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDrmFormatModifierPropertiesEXT **/
function VkDrmFormatModifierPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkDrmFormatModifierPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDrmFormatModifierPropertiesEXT, STRUCT_CACHE_VkDrmFormatModifierPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDrmFormatModifierPropertiesEXT, STRUCT_CACHE_VkDrmFormatModifierPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDrmFormatModifierPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkDrmFormatModifierPropertiesEXT.prototype, {
  "drmFormatModifier": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "drmFormatModifierPlaneCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "drmFormatModifierTilingFeatures": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkDrmFormatModifierPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkDrmFormatModifierPropertiesEXT.prototype.flush = function flush() {
  
  return true;
};

VkDrmFormatModifierPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkDrmFormatModifierPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDrmFormatModifierPropertiesEXT();
  copy.drmFormatModifier = original.drmFormatModifier;
  copy.drmFormatModifierPlaneCount = original.drmFormatModifierPlaneCount;
  copy.drmFormatModifierTilingFeatures = original.drmFormatModifierTilingFeatures;
  
  return copy;
};

VkDrmFormatModifierPropertiesEXT.byteLength = 0x0;

VkDrmFormatModifierPropertiesEXT.memoryLayout = {
  drmFormatModifier: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  drmFormatModifierPlaneCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  drmFormatModifierTilingFeatures: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceImageDrmFormatModifierInfoEXT **/
function VkPhysicalDeviceImageDrmFormatModifierInfoEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceImageDrmFormatModifierInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, STRUCT_CACHE_VkPhysicalDeviceImageDrmFormatModifierInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, STRUCT_CACHE_VkPhysicalDeviceImageDrmFormatModifierInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._pQueueFamilyIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.drmFormatModifier !== void 0) this.drmFormatModifier = opts.drmFormatModifier;
    if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImageDrmFormatModifierInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "drmFormatModifier": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.drmFormatModifier")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "sharingMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.sharingMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "queueFamilyIndexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.queueFamilyIndexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pQueueFamilyIndices": {
    get() {
    return this._pQueueFamilyIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this._pQueueFamilyIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.drmFormatModifier !== void 0) this.drmFormatModifier = opts.drmFormatModifier;
    if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
    if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
    if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
    
  }
};

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceImageDrmFormatModifierInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.drmFormatModifier = original.drmFormatModifier;
  copy.sharingMode = original.sharingMode;
  copy.queueFamilyIndexCount = original.queueFamilyIndexCount;
  if (original.pQueueFamilyIndices !== null) {
        copy.pQueueFamilyIndices = new Uint32Array(original.pQueueFamilyIndices);
      }
  
  return copy;
};

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.byteLength = 0x0;

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  drmFormatModifier: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sharingMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueFamilyIndexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pQueueFamilyIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageDrmFormatModifierListCreateInfoEXT **/
function VkImageDrmFormatModifierListCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkImageDrmFormatModifierListCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageDrmFormatModifierListCreateInfoEXT, STRUCT_CACHE_VkImageDrmFormatModifierListCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageDrmFormatModifierListCreateInfoEXT, STRUCT_CACHE_VkImageDrmFormatModifierListCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageDrmFormatModifierListCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pDrmFormatModifiers = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.drmFormatModifierCount !== void 0) this.drmFormatModifierCount = opts.drmFormatModifierCount;
    if (opts.pDrmFormatModifiers !== void 0) this.pDrmFormatModifiers = opts.pDrmFormatModifiers;
    
  }
};

Object.defineProperties(VkImageDrmFormatModifierListCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageDrmFormatModifierListCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageDrmFormatModifierListCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "drmFormatModifierCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageDrmFormatModifierListCreateInfoEXT.drmFormatModifierCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pDrmFormatModifiers": {
    get() {
    return this._pDrmFormatModifiers;
    },
    set(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pDrmFormatModifiers = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pDrmFormatModifiers = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierListCreateInfoEXT.pDrmFormatModifiers': Expected 'BigUint64Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageDrmFormatModifierListCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pDrmFormatModifiers = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.drmFormatModifierCount !== void 0) this.drmFormatModifierCount = opts.drmFormatModifierCount;
    if (opts.pDrmFormatModifiers !== void 0) this.pDrmFormatModifiers = opts.pDrmFormatModifiers;
    
  }
};

VkImageDrmFormatModifierListCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageDrmFormatModifierListCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageDrmFormatModifierListCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageDrmFormatModifierListCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.drmFormatModifierCount = original.drmFormatModifierCount;
  if (original.pDrmFormatModifiers !== null) {
        copy.pDrmFormatModifiers = new BigUint64Array(original.pDrmFormatModifiers);
      }
  
  return copy;
};

VkImageDrmFormatModifierListCreateInfoEXT.byteLength = 0x0;

VkImageDrmFormatModifierListCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  drmFormatModifierCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pDrmFormatModifiers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageDrmFormatModifierExplicitCreateInfoEXT **/
function VkImageDrmFormatModifierExplicitCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkImageDrmFormatModifierExplicitCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageDrmFormatModifierExplicitCreateInfoEXT, STRUCT_CACHE_VkImageDrmFormatModifierExplicitCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageDrmFormatModifierExplicitCreateInfoEXT, STRUCT_CACHE_VkImageDrmFormatModifierExplicitCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageDrmFormatModifierExplicitCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pPlaneLayouts = null;
  this._pPlaneLayoutsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.drmFormatModifier !== void 0) this.drmFormatModifier = opts.drmFormatModifier;
    if (opts.drmFormatModifierPlaneCount !== void 0) this.drmFormatModifierPlaneCount = opts.drmFormatModifierPlaneCount;
    if (opts.pPlaneLayouts !== void 0) this.pPlaneLayouts = opts.pPlaneLayouts;
    
  }
};

Object.defineProperties(VkImageDrmFormatModifierExplicitCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageDrmFormatModifierExplicitCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageDrmFormatModifierExplicitCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "drmFormatModifier": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkImageDrmFormatModifierExplicitCreateInfoEXT.drmFormatModifier")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "drmFormatModifierPlaneCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageDrmFormatModifierExplicitCreateInfoEXT.drmFormatModifierPlaneCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPlaneLayouts": {
    get() {
    if (this._pPlaneLayouts === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.drmFormatModifierPlaneCount, VkSubresourceLayout);
      this._pPlaneLayouts = array;
      return this.pPlaneLayouts;
    } else {
      return this._pPlaneLayouts;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPlaneLayouts = value;
    } else if (value === null) {
      this._pPlaneLayouts = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts': Expected 'Array VkSubresourceLayout' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkImageDrmFormatModifierExplicitCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pPlaneLayouts = null;
  this._pPlaneLayoutsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.drmFormatModifier !== void 0) this.drmFormatModifier = opts.drmFormatModifier;
    if (opts.drmFormatModifierPlaneCount !== void 0) this.drmFormatModifierPlaneCount = opts.drmFormatModifierPlaneCount;
    if (opts.pPlaneLayouts !== void 0) this.pPlaneLayouts = opts.pPlaneLayouts;
    
  }
};

VkImageDrmFormatModifierExplicitCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPlaneLayouts !== null) {
    let array = this._pPlaneLayouts;
    
    if (array.length !== this.drmFormatModifierPlaneCount) {
      throw new RangeError("Invalid array length, expected length of 'drmFormatModifierPlaneCount' for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkSubresourceLayout)) {
        throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts[" + ii + "]': Expected 'VkSubresourceLayout' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPlaneLayoutsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pPlaneLayoutsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkImageDrmFormatModifierExplicitCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageDrmFormatModifierExplicitCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageDrmFormatModifierExplicitCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.drmFormatModifier = original.drmFormatModifier;
  copy.drmFormatModifierPlaneCount = original.drmFormatModifierPlaneCount;
  if (original.pPlaneLayouts !== null) {
        copy.pPlaneLayouts = [...Array(original.pPlaneLayouts.length)].map((v, i) => {
          return original.pPlaneLayouts[i].constructor.createCopyFrom(original.pPlaneLayouts[i]);
        });
      }
  
  return copy;
};

VkImageDrmFormatModifierExplicitCreateInfoEXT.byteLength = 0x0;

VkImageDrmFormatModifierExplicitCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  drmFormatModifier: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  drmFormatModifierPlaneCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPlaneLayouts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageDrmFormatModifierPropertiesEXT **/
function VkImageDrmFormatModifierPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkImageDrmFormatModifierPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageDrmFormatModifierPropertiesEXT, STRUCT_CACHE_VkImageDrmFormatModifierPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageDrmFormatModifierPropertiesEXT, STRUCT_CACHE_VkImageDrmFormatModifierPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageDrmFormatModifierPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkImageDrmFormatModifierPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageDrmFormatModifierPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageDrmFormatModifierPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "drmFormatModifier": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkImageDrmFormatModifierPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkImageDrmFormatModifierPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageDrmFormatModifierPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkImageDrmFormatModifierPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageDrmFormatModifierPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.drmFormatModifier = original.drmFormatModifier;
  
  return copy;
};

VkImageDrmFormatModifierPropertiesEXT.byteLength = 0x0;

VkImageDrmFormatModifierPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  drmFormatModifier: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageStencilUsageCreateInfo **/
function VkImageStencilUsageCreateInfo(opts, byteOffset) {
  if (new.target !== VkImageStencilUsageCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageStencilUsageCreateInfo, STRUCT_CACHE_VkImageStencilUsageCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageStencilUsageCreateInfo, STRUCT_CACHE_VkImageStencilUsageCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageStencilUsageCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilUsage !== void 0) this.stencilUsage = opts.stencilUsage;
    
  }
};

Object.defineProperties(VkImageStencilUsageCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageStencilUsageCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageStencilUsageCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "stencilUsage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageStencilUsageCreateInfo.stencilUsage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImageStencilUsageCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilUsage !== void 0) this.stencilUsage = opts.stencilUsage;
    
  }
};

VkImageStencilUsageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageStencilUsageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageStencilUsageCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageStencilUsageCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.stencilUsage = original.stencilUsage;
  
  return copy;
};

VkImageStencilUsageCreateInfo.byteLength = 0x0;

VkImageStencilUsageCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilUsage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageStencilUsageCreateInfoEXT **/
function VkImageStencilUsageCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkImageStencilUsageCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageStencilUsageCreateInfoEXT, STRUCT_CACHE_VkImageStencilUsageCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageStencilUsageCreateInfoEXT, STRUCT_CACHE_VkImageStencilUsageCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageStencilUsageCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilUsage !== void 0) this.stencilUsage = opts.stencilUsage;
    
  }
};

Object.defineProperties(VkImageStencilUsageCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageStencilUsageCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageStencilUsageCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "stencilUsage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageStencilUsageCreateInfoEXT.stencilUsage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkImageStencilUsageCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilUsage !== void 0) this.stencilUsage = opts.stencilUsage;
    
  }
};

VkImageStencilUsageCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageStencilUsageCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageStencilUsageCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageStencilUsageCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.stencilUsage = original.stencilUsage;
  
  return copy;
};

VkImageStencilUsageCreateInfoEXT.byteLength = 0x0;

VkImageStencilUsageCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilUsage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceMemoryOverallocationCreateInfoAMD **/
function VkDeviceMemoryOverallocationCreateInfoAMD(opts, byteOffset) {
  if (new.target !== VkDeviceMemoryOverallocationCreateInfoAMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceMemoryOverallocationCreateInfoAMD, STRUCT_CACHE_VkDeviceMemoryOverallocationCreateInfoAMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceMemoryOverallocationCreateInfoAMD, STRUCT_CACHE_VkDeviceMemoryOverallocationCreateInfoAMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceMemoryOverallocationCreateInfoAMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.overallocationBehavior !== void 0) this.overallocationBehavior = opts.overallocationBehavior;
    
  }
};

Object.defineProperties(VkDeviceMemoryOverallocationCreateInfoAMD.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceMemoryOverallocationCreateInfoAMD.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceMemoryOverallocationCreateInfoAMD.pNext' isn't allowed to be filled");
    }
    },
  "overallocationBehavior": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceMemoryOverallocationCreateInfoAMD.overallocationBehavior");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkDeviceMemoryOverallocationCreateInfoAMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.overallocationBehavior !== void 0) this.overallocationBehavior = opts.overallocationBehavior;
    
  }
};

VkDeviceMemoryOverallocationCreateInfoAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceMemoryOverallocationCreateInfoAMD.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceMemoryOverallocationCreateInfoAMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceMemoryOverallocationCreateInfoAMD();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.overallocationBehavior = original.overallocationBehavior;
  
  return copy;
};

VkDeviceMemoryOverallocationCreateInfoAMD.byteLength = 0x0;

VkDeviceMemoryOverallocationCreateInfoAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  overallocationBehavior: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentDensityMapFeaturesEXT **/
function VkPhysicalDeviceFragmentDensityMapFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentDensityMapFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentDensityMapFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMapFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentDensityMapFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMapFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentDensityMapFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentDensityMap !== void 0) this.fragmentDensityMap = opts.fragmentDensityMap;
    if (opts.fragmentDensityMapDynamic !== void 0) this.fragmentDensityMapDynamic = opts.fragmentDensityMapDynamic;
    if (opts.fragmentDensityMapNonSubsampledImages !== void 0) this.fragmentDensityMapNonSubsampledImages = opts.fragmentDensityMapNonSubsampledImages;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentDensityMapFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentDensityMapFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentDensityMapFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "fragmentDensityMap": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "fragmentDensityMapDynamic": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "fragmentDensityMapNonSubsampledImages": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentDensityMap !== void 0) this.fragmentDensityMap = opts.fragmentDensityMap;
    if (opts.fragmentDensityMapDynamic !== void 0) this.fragmentDensityMapDynamic = opts.fragmentDensityMapDynamic;
    if (opts.fragmentDensityMapNonSubsampledImages !== void 0) this.fragmentDensityMapNonSubsampledImages = opts.fragmentDensityMapNonSubsampledImages;
    
  }
};

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentDensityMapFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.fragmentDensityMap = original.fragmentDensityMap;
  copy.fragmentDensityMapDynamic = original.fragmentDensityMapDynamic;
  copy.fragmentDensityMapNonSubsampledImages = original.fragmentDensityMapNonSubsampledImages;
  
  return copy;
};

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentDensityMap: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentDensityMapDynamic: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentDensityMapNonSubsampledImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentDensityMap2FeaturesEXT **/
function VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentDensityMap2FeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentDensityMap2FeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentDensityMapDeferred !== void 0) this.fragmentDensityMapDeferred = opts.fragmentDensityMapDeferred;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "fragmentDensityMapDeferred": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentDensityMapDeferred !== void 0) this.fragmentDensityMapDeferred = opts.fragmentDensityMapDeferred;
    
  }
};

VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentDensityMap2FeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.fragmentDensityMapDeferred = original.fragmentDensityMapDeferred;
  
  return copy;
};

VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentDensityMapDeferred: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentDensityMapPropertiesEXT **/
function VkPhysicalDeviceFragmentDensityMapPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentDensityMapPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMapPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMapPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentDensityMapPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._minFragmentDensityTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._maxFragmentDensityTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentDensityMapPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentDensityMapPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentDensityMapPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "minFragmentDensityTexelSize": {
    get() {
    return this._minFragmentDensityTexelSize;
    },
    },
  "maxFragmentDensityTexelSize": {
    get() {
    return this._maxFragmentDensityTexelSize;
    },
    },
  "fragmentDensityInvocations": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._minFragmentDensityTexelSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._minFragmentDensityTexelSize.memoryBuffer) this._minFragmentDensityTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._minFragmentDensityTexelSize.reset();
  }
  if (this._maxFragmentDensityTexelSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxFragmentDensityTexelSize.memoryBuffer) this._maxFragmentDensityTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxFragmentDensityTexelSize.reset();
  }
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentDensityMapPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.minFragmentDensityTexelSize !== null) {
        copy.minFragmentDensityTexelSize = original.minFragmentDensityTexelSize.constructor.createCopyFrom(original.minFragmentDensityTexelSize);
      }
  if (original.maxFragmentDensityTexelSize !== null) {
        copy.maxFragmentDensityTexelSize = original.maxFragmentDensityTexelSize.constructor.createCopyFrom(original.maxFragmentDensityTexelSize);
      }
  copy.fragmentDensityInvocations = original.fragmentDensityInvocations;
  
  return copy;
};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minFragmentDensityTexelSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentDensityTexelSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentDensityInvocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentDensityMap2PropertiesEXT **/
function VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentDensityMap2PropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentDensityMap2PropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "subsampledLoads": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "subsampledCoarseReconstructionEarlyAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "maxSubsampledArrayLayers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetSubsampledSamplers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentDensityMap2PropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.subsampledLoads = original.subsampledLoads;
  copy.subsampledCoarseReconstructionEarlyAccess = original.subsampledCoarseReconstructionEarlyAccess;
  copy.maxSubsampledArrayLayers = original.maxSubsampledArrayLayers;
  copy.maxDescriptorSetSubsampledSamplers = original.maxDescriptorSetSubsampledSamplers;
  
  return copy;
};

VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceFragmentDensityMap2PropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subsampledLoads: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subsampledCoarseReconstructionEarlyAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSubsampledArrayLayers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetSubsampledSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassFragmentDensityMapCreateInfoEXT **/
function VkRenderPassFragmentDensityMapCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkRenderPassFragmentDensityMapCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassFragmentDensityMapCreateInfoEXT, STRUCT_CACHE_VkRenderPassFragmentDensityMapCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassFragmentDensityMapCreateInfoEXT, STRUCT_CACHE_VkRenderPassFragmentDensityMapCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassFragmentDensityMapCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._fragmentDensityMapAttachment = new VkAttachmentReference({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentDensityMapAttachment !== void 0) this.fragmentDensityMapAttachment = opts.fragmentDensityMapAttachment;
    
  }
};

Object.defineProperties(VkRenderPassFragmentDensityMapCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassFragmentDensityMapCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassFragmentDensityMapCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "fragmentDensityMapAttachment": {
    get() {
    return this._fragmentDensityMapAttachment;
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference) {
      value.flush();
      this._fragmentDensityMapAttachment = value;
      
      
    } else if (value === null) {
      this._fragmentDensityMapAttachment = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassFragmentDensityMapCreateInfoEXT.fragmentDensityMapAttachment': Expected 'VkAttachmentReference' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkRenderPassFragmentDensityMapCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._fragmentDensityMapAttachment !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._fragmentDensityMapAttachment.memoryBuffer) this._fragmentDensityMapAttachment = new VkAttachmentReference({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._fragmentDensityMapAttachment.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentDensityMapAttachment !== void 0) this.fragmentDensityMapAttachment = opts.fragmentDensityMapAttachment;
    
  }
};

VkRenderPassFragmentDensityMapCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._fragmentDensityMapAttachment !== null) {
    let fragmentDensityMapAttachment = this._fragmentDensityMapAttachment;
    fragmentDensityMapAttachment.flush();
    if (this.memoryBuffer !== fragmentDensityMapAttachment.memoryBuffer) {
      let srcView = new Uint8Array(fragmentDensityMapAttachment.memoryBuffer, fragmentDensityMapAttachment.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkRenderPassFragmentDensityMapCreateInfoEXT.fragmentDensityMapAttachment' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkRenderPassFragmentDensityMapCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassFragmentDensityMapCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassFragmentDensityMapCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.fragmentDensityMapAttachment !== null) {
        copy.fragmentDensityMapAttachment = original.fragmentDensityMapAttachment.constructor.createCopyFrom(original.fragmentDensityMapAttachment);
      }
  
  return copy;
};

VkRenderPassFragmentDensityMapCreateInfoEXT.byteLength = 0x0;

VkRenderPassFragmentDensityMapCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentDensityMapAttachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceScalarBlockLayoutFeatures **/
function VkPhysicalDeviceScalarBlockLayoutFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceScalarBlockLayoutFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceScalarBlockLayoutFeatures, STRUCT_CACHE_VkPhysicalDeviceScalarBlockLayoutFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceScalarBlockLayoutFeatures, STRUCT_CACHE_VkPhysicalDeviceScalarBlockLayoutFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceScalarBlockLayoutFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.scalarBlockLayout !== void 0) this.scalarBlockLayout = opts.scalarBlockLayout;
    
  }
};

Object.defineProperties(VkPhysicalDeviceScalarBlockLayoutFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceScalarBlockLayoutFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceScalarBlockLayoutFeatures.pNext' isn't allowed to be filled");
    }
    },
  "scalarBlockLayout": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceScalarBlockLayoutFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.scalarBlockLayout !== void 0) this.scalarBlockLayout = opts.scalarBlockLayout;
    
  }
};

VkPhysicalDeviceScalarBlockLayoutFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceScalarBlockLayoutFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceScalarBlockLayoutFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceScalarBlockLayoutFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.scalarBlockLayout = original.scalarBlockLayout;
  
  return copy;
};

VkPhysicalDeviceScalarBlockLayoutFeatures.byteLength = 0x0;

VkPhysicalDeviceScalarBlockLayoutFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  scalarBlockLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceScalarBlockLayoutFeaturesEXT **/
function VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceScalarBlockLayoutFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceScalarBlockLayoutFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceScalarBlockLayoutFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceScalarBlockLayoutFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.scalarBlockLayout !== void 0) this.scalarBlockLayout = opts.scalarBlockLayout;
    
  }
};

Object.defineProperties(VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "scalarBlockLayout": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.scalarBlockLayout !== void 0) this.scalarBlockLayout = opts.scalarBlockLayout;
    
  }
};

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceScalarBlockLayoutFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.scalarBlockLayout = original.scalarBlockLayout;
  
  return copy;
};

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  scalarBlockLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSurfaceProtectedCapabilitiesKHR **/
function VkSurfaceProtectedCapabilitiesKHR(opts, byteOffset) {
  if (new.target !== VkSurfaceProtectedCapabilitiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSurfaceProtectedCapabilitiesKHR, STRUCT_CACHE_VkSurfaceProtectedCapabilitiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSurfaceProtectedCapabilitiesKHR, STRUCT_CACHE_VkSurfaceProtectedCapabilitiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSurfaceProtectedCapabilitiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.supportsProtected !== void 0) this.supportsProtected = opts.supportsProtected;
    
  }
};

Object.defineProperties(VkSurfaceProtectedCapabilitiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSurfaceProtectedCapabilitiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceProtectedCapabilitiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "supportsProtected": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkSurfaceProtectedCapabilitiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.supportsProtected !== void 0) this.supportsProtected = opts.supportsProtected;
    
  }
};

VkSurfaceProtectedCapabilitiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceProtectedCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkSurfaceProtectedCapabilitiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSurfaceProtectedCapabilitiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.supportsProtected = original.supportsProtected;
  
  return copy;
};

VkSurfaceProtectedCapabilitiesKHR.byteLength = 0x0;

VkSurfaceProtectedCapabilitiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportsProtected: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceUniformBufferStandardLayoutFeatures **/
function VkPhysicalDeviceUniformBufferStandardLayoutFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceUniformBufferStandardLayoutFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceUniformBufferStandardLayoutFeatures, STRUCT_CACHE_VkPhysicalDeviceUniformBufferStandardLayoutFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceUniformBufferStandardLayoutFeatures, STRUCT_CACHE_VkPhysicalDeviceUniformBufferStandardLayoutFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceUniformBufferStandardLayoutFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.uniformBufferStandardLayout !== void 0) this.uniformBufferStandardLayout = opts.uniformBufferStandardLayout;
    
  }
};

Object.defineProperties(VkPhysicalDeviceUniformBufferStandardLayoutFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceUniformBufferStandardLayoutFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceUniformBufferStandardLayoutFeatures.pNext' isn't allowed to be filled");
    }
    },
  "uniformBufferStandardLayout": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceUniformBufferStandardLayoutFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.uniformBufferStandardLayout !== void 0) this.uniformBufferStandardLayout = opts.uniformBufferStandardLayout;
    
  }
};

VkPhysicalDeviceUniformBufferStandardLayoutFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceUniformBufferStandardLayoutFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceUniformBufferStandardLayoutFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceUniformBufferStandardLayoutFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.uniformBufferStandardLayout = original.uniformBufferStandardLayout;
  
  return copy;
};

VkPhysicalDeviceUniformBufferStandardLayoutFeatures.byteLength = 0x0;

VkPhysicalDeviceUniformBufferStandardLayoutFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformBufferStandardLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR **/
function VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.uniformBufferStandardLayout !== void 0) this.uniformBufferStandardLayout = opts.uniformBufferStandardLayout;
    
  }
};

Object.defineProperties(VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "uniformBufferStandardLayout": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.uniformBufferStandardLayout !== void 0) this.uniformBufferStandardLayout = opts.uniformBufferStandardLayout;
    
  }
};

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.uniformBufferStandardLayout = original.uniformBufferStandardLayout;
  
  return copy;
};

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformBufferStandardLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDepthClipEnableFeaturesEXT **/
function VkPhysicalDeviceDepthClipEnableFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDepthClipEnableFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDepthClipEnableFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceDepthClipEnableFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDepthClipEnableFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceDepthClipEnableFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDepthClipEnableFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.depthClipEnable !== void 0) this.depthClipEnable = opts.depthClipEnable;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDepthClipEnableFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDepthClipEnableFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDepthClipEnableFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "depthClipEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceDepthClipEnableFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.depthClipEnable !== void 0) this.depthClipEnable = opts.depthClipEnable;
    
  }
};

VkPhysicalDeviceDepthClipEnableFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDepthClipEnableFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceDepthClipEnableFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDepthClipEnableFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.depthClipEnable = original.depthClipEnable;
  
  return copy;
};

VkPhysicalDeviceDepthClipEnableFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceDepthClipEnableFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthClipEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineRasterizationDepthClipStateCreateInfoEXT **/
function VkPipelineRasterizationDepthClipStateCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPipelineRasterizationDepthClipStateCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineRasterizationDepthClipStateCreateInfoEXT, STRUCT_CACHE_VkPipelineRasterizationDepthClipStateCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineRasterizationDepthClipStateCreateInfoEXT, STRUCT_CACHE_VkPipelineRasterizationDepthClipStateCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineRasterizationDepthClipStateCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.depthClipEnable !== void 0) this.depthClipEnable = opts.depthClipEnable;
    
  }
};

Object.defineProperties(VkPipelineRasterizationDepthClipStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationDepthClipStateCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRasterizationDepthClipStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationDepthClipStateCreateInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "depthClipEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPipelineRasterizationDepthClipStateCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.depthClipEnable !== void 0) this.depthClipEnable = opts.depthClipEnable;
    
  }
};

VkPipelineRasterizationDepthClipStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationDepthClipStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineRasterizationDepthClipStateCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineRasterizationDepthClipStateCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.depthClipEnable = original.depthClipEnable;
  
  return copy;
};

VkPipelineRasterizationDepthClipStateCreateInfoEXT.byteLength = 0x0;

VkPipelineRasterizationDepthClipStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthClipEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMemoryBudgetPropertiesEXT **/
function VkPhysicalDeviceMemoryBudgetPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMemoryBudgetPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMemoryBudgetPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceMemoryBudgetPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMemoryBudgetPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceMemoryBudgetPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMemoryBudgetPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._heapBudget = [...Array(16)].fill(0x0);
  this._heapUsage = [...Array(16)].fill(0x0);
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMemoryBudgetPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMemoryBudgetPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMemoryBudgetPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "heapBudget": {
    get() {
    return [
      this.memoryView.getBigUint64(0x0, true),
      this.memoryView.getBigUint64(0x8, true),
      this.memoryView.getBigUint64(0x10, true),
      this.memoryView.getBigUint64(0x18, true),
      this.memoryView.getBigUint64(0x20, true),
      this.memoryView.getBigUint64(0x28, true),
      this.memoryView.getBigUint64(0x30, true),
      this.memoryView.getBigUint64(0x38, true),
      this.memoryView.getBigUint64(0x40, true),
      this.memoryView.getBigUint64(0x48, true),
      this.memoryView.getBigUint64(0x50, true),
      this.memoryView.getBigUint64(0x58, true),
      this.memoryView.getBigUint64(0x60, true),
      this.memoryView.getBigUint64(0x68, true),
      this.memoryView.getBigUint64(0x70, true),
      this.memoryView.getBigUint64(0x78, true)
    ];
    },
    },
  "heapUsage": {
    get() {
    return [
      this.memoryView.getBigUint64(0x0, true),
      this.memoryView.getBigUint64(0x8, true),
      this.memoryView.getBigUint64(0x10, true),
      this.memoryView.getBigUint64(0x18, true),
      this.memoryView.getBigUint64(0x20, true),
      this.memoryView.getBigUint64(0x28, true),
      this.memoryView.getBigUint64(0x30, true),
      this.memoryView.getBigUint64(0x38, true),
      this.memoryView.getBigUint64(0x40, true),
      this.memoryView.getBigUint64(0x48, true),
      this.memoryView.getBigUint64(0x50, true),
      this.memoryView.getBigUint64(0x58, true),
      this.memoryView.getBigUint64(0x60, true),
      this.memoryView.getBigUint64(0x68, true),
      this.memoryView.getBigUint64(0x70, true),
      this.memoryView.getBigUint64(0x78, true)
    ];
    },
    },
  
});

VkPhysicalDeviceMemoryBudgetPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._heapBudget !== null) this._heapBudget.fill(0x0);
      else this._heapBudget = [...Array(16)].fill(0x0);
  if (this._heapUsage !== null) this._heapUsage.fill(0x0);
      else this._heapUsage = [...Array(16)].fill(0x0);
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceMemoryBudgetPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryBudgetPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceMemoryBudgetPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMemoryBudgetPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.heapBudget !== null) {
        copy.heapBudget = [...Array(original.heapBudget.length)].map((v, i) => {
          return original.heapBudget[i];
        });
      }
  if (original.heapUsage !== null) {
        copy.heapUsage = [...Array(original.heapUsage.length)].map((v, i) => {
          return original.heapUsage[i];
        });
      }
  
  return copy;
};

VkPhysicalDeviceMemoryBudgetPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceMemoryBudgetPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  heapBudget: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  heapUsage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceMemoryPriorityFeaturesEXT **/
function VkPhysicalDeviceMemoryPriorityFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceMemoryPriorityFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceMemoryPriorityFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceMemoryPriorityFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceMemoryPriorityFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceMemoryPriorityFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceMemoryPriorityFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memoryPriority !== void 0) this.memoryPriority = opts.memoryPriority;
    
  }
};

Object.defineProperties(VkPhysicalDeviceMemoryPriorityFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceMemoryPriorityFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceMemoryPriorityFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "memoryPriority": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceMemoryPriorityFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memoryPriority !== void 0) this.memoryPriority = opts.memoryPriority;
    
  }
};

VkPhysicalDeviceMemoryPriorityFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryPriorityFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceMemoryPriorityFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceMemoryPriorityFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.memoryPriority = original.memoryPriority;
  
  return copy;
};

VkPhysicalDeviceMemoryPriorityFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceMemoryPriorityFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memoryPriority: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryPriorityAllocateInfoEXT **/
function VkMemoryPriorityAllocateInfoEXT(opts, byteOffset) {
  if (new.target !== VkMemoryPriorityAllocateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryPriorityAllocateInfoEXT, STRUCT_CACHE_VkMemoryPriorityAllocateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryPriorityAllocateInfoEXT, STRUCT_CACHE_VkMemoryPriorityAllocateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryPriorityAllocateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.priority !== void 0) this.priority = opts.priority;
    
  }
};

Object.defineProperties(VkMemoryPriorityAllocateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryPriorityAllocateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryPriorityAllocateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "priority": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryPriorityAllocateInfoEXT.priority");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkMemoryPriorityAllocateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.priority !== void 0) this.priority = opts.priority;
    
  }
};

VkMemoryPriorityAllocateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryPriorityAllocateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryPriorityAllocateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryPriorityAllocateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.priority = original.priority;
  
  return copy;
};

VkMemoryPriorityAllocateInfoEXT.byteLength = 0x0;

VkMemoryPriorityAllocateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  priority: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceBufferDeviceAddressFeatures **/
function VkPhysicalDeviceBufferDeviceAddressFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceBufferDeviceAddressFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceBufferDeviceAddressFeatures, STRUCT_CACHE_VkPhysicalDeviceBufferDeviceAddressFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceBufferDeviceAddressFeatures, STRUCT_CACHE_VkPhysicalDeviceBufferDeviceAddressFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceBufferDeviceAddressFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    
  }
};

Object.defineProperties(VkPhysicalDeviceBufferDeviceAddressFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceBufferDeviceAddressFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceBufferDeviceAddressFeatures.pNext' isn't allowed to be filled");
    }
    },
  "bufferDeviceAddress": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddressCaptureReplay": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddressMultiDevice": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceBufferDeviceAddressFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    
  }
};

VkPhysicalDeviceBufferDeviceAddressFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBufferDeviceAddressFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceBufferDeviceAddressFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceBufferDeviceAddressFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.bufferDeviceAddress = original.bufferDeviceAddress;
  copy.bufferDeviceAddressCaptureReplay = original.bufferDeviceAddressCaptureReplay;
  copy.bufferDeviceAddressMultiDevice = original.bufferDeviceAddressMultiDevice;
  
  return copy;
};

VkPhysicalDeviceBufferDeviceAddressFeatures.byteLength = 0x0;

VkPhysicalDeviceBufferDeviceAddressFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddressCaptureReplay: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddressMultiDevice: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceBufferDeviceAddressFeaturesKHR **/
function VkPhysicalDeviceBufferDeviceAddressFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceBufferDeviceAddressFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceBufferDeviceAddressFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceBufferDeviceAddressFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceBufferDeviceAddressFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceBufferDeviceAddressFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceBufferDeviceAddressFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    
  }
};

Object.defineProperties(VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "bufferDeviceAddress": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddressCaptureReplay": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddressMultiDevice": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    
  }
};

VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceBufferDeviceAddressFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.bufferDeviceAddress = original.bufferDeviceAddress;
  copy.bufferDeviceAddressCaptureReplay = original.bufferDeviceAddressCaptureReplay;
  copy.bufferDeviceAddressMultiDevice = original.bufferDeviceAddressMultiDevice;
  
  return copy;
};

VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceBufferDeviceAddressFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddressCaptureReplay: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddressMultiDevice: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceBufferDeviceAddressFeaturesEXT **/
function VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceBufferDeviceAddressFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceBufferDeviceAddressFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    
  }
};

Object.defineProperties(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "bufferDeviceAddress": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddressCaptureReplay": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddressMultiDevice": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    
  }
};

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceBufferDeviceAddressFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.bufferDeviceAddress = original.bufferDeviceAddress;
  copy.bufferDeviceAddressCaptureReplay = original.bufferDeviceAddressCaptureReplay;
  copy.bufferDeviceAddressMultiDevice = original.bufferDeviceAddressMultiDevice;
  
  return copy;
};

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddressCaptureReplay: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddressMultiDevice: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceBufferAddressFeaturesEXT **/
function VkPhysicalDeviceBufferAddressFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceBufferAddressFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceBufferAddressFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceBufferAddressFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceBufferAddressFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceBufferAddressFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceBufferAddressFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    
  }
};

Object.defineProperties(VkPhysicalDeviceBufferAddressFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceBufferAddressFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceBufferAddressFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "bufferDeviceAddress": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddressCaptureReplay": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddressMultiDevice": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceBufferAddressFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    
  }
};

VkPhysicalDeviceBufferAddressFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBufferAddressFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceBufferAddressFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceBufferAddressFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.bufferDeviceAddress = original.bufferDeviceAddress;
  copy.bufferDeviceAddressCaptureReplay = original.bufferDeviceAddressCaptureReplay;
  copy.bufferDeviceAddressMultiDevice = original.bufferDeviceAddressMultiDevice;
  
  return copy;
};

VkPhysicalDeviceBufferAddressFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceBufferAddressFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddressCaptureReplay: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddressMultiDevice: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferDeviceAddressInfo **/
function VkBufferDeviceAddressInfo(opts, byteOffset) {
  if (new.target !== VkBufferDeviceAddressInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferDeviceAddressInfo, STRUCT_CACHE_VkBufferDeviceAddressInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferDeviceAddressInfo, STRUCT_CACHE_VkBufferDeviceAddressInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferDeviceAddressInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkBufferDeviceAddressInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferDeviceAddressInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferDeviceAddressInfo.pNext' isn't allowed to be filled");
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressInfo.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferDeviceAddressInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

VkBufferDeviceAddressInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferDeviceAddressInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferDeviceAddressInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferDeviceAddressInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  
  return copy;
};

VkBufferDeviceAddressInfo.byteLength = 0x0;

VkBufferDeviceAddressInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferDeviceAddressInfoKHR **/
function VkBufferDeviceAddressInfoKHR(opts, byteOffset) {
  if (new.target !== VkBufferDeviceAddressInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferDeviceAddressInfoKHR, STRUCT_CACHE_VkBufferDeviceAddressInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferDeviceAddressInfoKHR, STRUCT_CACHE_VkBufferDeviceAddressInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferDeviceAddressInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkBufferDeviceAddressInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferDeviceAddressInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferDeviceAddressInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressInfoKHR.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferDeviceAddressInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

VkBufferDeviceAddressInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferDeviceAddressInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferDeviceAddressInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferDeviceAddressInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  
  return copy;
};

VkBufferDeviceAddressInfoKHR.byteLength = 0x0;

VkBufferDeviceAddressInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferDeviceAddressInfoEXT **/
function VkBufferDeviceAddressInfoEXT(opts, byteOffset) {
  if (new.target !== VkBufferDeviceAddressInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferDeviceAddressInfoEXT, STRUCT_CACHE_VkBufferDeviceAddressInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferDeviceAddressInfoEXT, STRUCT_CACHE_VkBufferDeviceAddressInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferDeviceAddressInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

Object.defineProperties(VkBufferDeviceAddressInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferDeviceAddressInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferDeviceAddressInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressInfoEXT.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferDeviceAddressInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._buffer = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    
  }
};

VkBufferDeviceAddressInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferDeviceAddressInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferDeviceAddressInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferDeviceAddressInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  
  return copy;
};

VkBufferDeviceAddressInfoEXT.byteLength = 0x0;

VkBufferDeviceAddressInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferOpaqueCaptureAddressCreateInfo **/
function VkBufferOpaqueCaptureAddressCreateInfo(opts, byteOffset) {
  if (new.target !== VkBufferOpaqueCaptureAddressCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferOpaqueCaptureAddressCreateInfo, STRUCT_CACHE_VkBufferOpaqueCaptureAddressCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferOpaqueCaptureAddressCreateInfo, STRUCT_CACHE_VkBufferOpaqueCaptureAddressCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferOpaqueCaptureAddressCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.opaqueCaptureAddress !== void 0) this.opaqueCaptureAddress = opts.opaqueCaptureAddress;
    
  }
};

Object.defineProperties(VkBufferOpaqueCaptureAddressCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferOpaqueCaptureAddressCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferOpaqueCaptureAddressCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "opaqueCaptureAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferOpaqueCaptureAddressCreateInfo.opaqueCaptureAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBufferOpaqueCaptureAddressCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.opaqueCaptureAddress !== void 0) this.opaqueCaptureAddress = opts.opaqueCaptureAddress;
    
  }
};

VkBufferOpaqueCaptureAddressCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferOpaqueCaptureAddressCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferOpaqueCaptureAddressCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferOpaqueCaptureAddressCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.opaqueCaptureAddress = original.opaqueCaptureAddress;
  
  return copy;
};

VkBufferOpaqueCaptureAddressCreateInfo.byteLength = 0x0;

VkBufferOpaqueCaptureAddressCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  opaqueCaptureAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferOpaqueCaptureAddressCreateInfoKHR **/
function VkBufferOpaqueCaptureAddressCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkBufferOpaqueCaptureAddressCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferOpaqueCaptureAddressCreateInfoKHR, STRUCT_CACHE_VkBufferOpaqueCaptureAddressCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferOpaqueCaptureAddressCreateInfoKHR, STRUCT_CACHE_VkBufferOpaqueCaptureAddressCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferOpaqueCaptureAddressCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.opaqueCaptureAddress !== void 0) this.opaqueCaptureAddress = opts.opaqueCaptureAddress;
    
  }
};

Object.defineProperties(VkBufferOpaqueCaptureAddressCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferOpaqueCaptureAddressCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferOpaqueCaptureAddressCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "opaqueCaptureAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferOpaqueCaptureAddressCreateInfoKHR.opaqueCaptureAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBufferOpaqueCaptureAddressCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.opaqueCaptureAddress !== void 0) this.opaqueCaptureAddress = opts.opaqueCaptureAddress;
    
  }
};

VkBufferOpaqueCaptureAddressCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferOpaqueCaptureAddressCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferOpaqueCaptureAddressCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferOpaqueCaptureAddressCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.opaqueCaptureAddress = original.opaqueCaptureAddress;
  
  return copy;
};

VkBufferOpaqueCaptureAddressCreateInfoKHR.byteLength = 0x0;

VkBufferOpaqueCaptureAddressCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  opaqueCaptureAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferDeviceAddressCreateInfoEXT **/
function VkBufferDeviceAddressCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkBufferDeviceAddressCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferDeviceAddressCreateInfoEXT, STRUCT_CACHE_VkBufferDeviceAddressCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferDeviceAddressCreateInfoEXT, STRUCT_CACHE_VkBufferDeviceAddressCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferDeviceAddressCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    
  }
};

Object.defineProperties(VkBufferDeviceAddressCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferDeviceAddressCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferDeviceAddressCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "deviceAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferDeviceAddressCreateInfoEXT.deviceAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBufferDeviceAddressCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    
  }
};

VkBufferDeviceAddressCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferDeviceAddressCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferDeviceAddressCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferDeviceAddressCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceAddress = original.deviceAddress;
  
  return copy;
};

VkBufferDeviceAddressCreateInfoEXT.byteLength = 0x0;

VkBufferDeviceAddressCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceImageViewImageFormatInfoEXT **/
function VkPhysicalDeviceImageViewImageFormatInfoEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceImageViewImageFormatInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceImageViewImageFormatInfoEXT, STRUCT_CACHE_VkPhysicalDeviceImageViewImageFormatInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceImageViewImageFormatInfoEXT, STRUCT_CACHE_VkPhysicalDeviceImageViewImageFormatInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceImageViewImageFormatInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imageViewType !== void 0) this.imageViewType = opts.imageViewType;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImageViewImageFormatInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageViewImageFormatInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceImageViewImageFormatInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "imageViewType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageViewImageFormatInfoEXT.imageViewType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceImageViewImageFormatInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imageViewType !== void 0) this.imageViewType = opts.imageViewType;
    
  }
};

VkPhysicalDeviceImageViewImageFormatInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageViewImageFormatInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceImageViewImageFormatInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceImageViewImageFormatInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.imageViewType = original.imageViewType;
  
  return copy;
};

VkPhysicalDeviceImageViewImageFormatInfoEXT.byteLength = 0x0;

VkPhysicalDeviceImageViewImageFormatInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageViewType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFilterCubicImageViewImageFormatPropertiesEXT **/
function VkFilterCubicImageViewImageFormatPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkFilterCubicImageViewImageFormatPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFilterCubicImageViewImageFormatPropertiesEXT, STRUCT_CACHE_VkFilterCubicImageViewImageFormatPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFilterCubicImageViewImageFormatPropertiesEXT, STRUCT_CACHE_VkFilterCubicImageViewImageFormatPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFilterCubicImageViewImageFormatPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkFilterCubicImageViewImageFormatPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFilterCubicImageViewImageFormatPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFilterCubicImageViewImageFormatPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "filterCubic": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "filterCubicMinmax": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkFilterCubicImageViewImageFormatPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkFilterCubicImageViewImageFormatPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFilterCubicImageViewImageFormatPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkFilterCubicImageViewImageFormatPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFilterCubicImageViewImageFormatPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.filterCubic = original.filterCubic;
  copy.filterCubicMinmax = original.filterCubicMinmax;
  
  return copy;
};

VkFilterCubicImageViewImageFormatPropertiesEXT.byteLength = 0x0;

VkFilterCubicImageViewImageFormatPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  filterCubic: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  filterCubicMinmax: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceImagelessFramebufferFeatures **/
function VkPhysicalDeviceImagelessFramebufferFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceImagelessFramebufferFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceImagelessFramebufferFeatures, STRUCT_CACHE_VkPhysicalDeviceImagelessFramebufferFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceImagelessFramebufferFeatures, STRUCT_CACHE_VkPhysicalDeviceImagelessFramebufferFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceImagelessFramebufferFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imagelessFramebuffer !== void 0) this.imagelessFramebuffer = opts.imagelessFramebuffer;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImagelessFramebufferFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImagelessFramebufferFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceImagelessFramebufferFeatures.pNext' isn't allowed to be filled");
    }
    },
  "imagelessFramebuffer": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceImagelessFramebufferFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imagelessFramebuffer !== void 0) this.imagelessFramebuffer = opts.imagelessFramebuffer;
    
  }
};

VkPhysicalDeviceImagelessFramebufferFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImagelessFramebufferFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceImagelessFramebufferFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceImagelessFramebufferFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.imagelessFramebuffer = original.imagelessFramebuffer;
  
  return copy;
};

VkPhysicalDeviceImagelessFramebufferFeatures.byteLength = 0x0;

VkPhysicalDeviceImagelessFramebufferFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imagelessFramebuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceImagelessFramebufferFeaturesKHR **/
function VkPhysicalDeviceImagelessFramebufferFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceImagelessFramebufferFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceImagelessFramebufferFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceImagelessFramebufferFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceImagelessFramebufferFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceImagelessFramebufferFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceImagelessFramebufferFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imagelessFramebuffer !== void 0) this.imagelessFramebuffer = opts.imagelessFramebuffer;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImagelessFramebufferFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImagelessFramebufferFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceImagelessFramebufferFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "imagelessFramebuffer": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imagelessFramebuffer !== void 0) this.imagelessFramebuffer = opts.imagelessFramebuffer;
    
  }
};

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceImagelessFramebufferFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.imagelessFramebuffer = original.imagelessFramebuffer;
  
  return copy;
};

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceImagelessFramebufferFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imagelessFramebuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFramebufferAttachmentsCreateInfo **/
function VkFramebufferAttachmentsCreateInfo(opts, byteOffset) {
  if (new.target !== VkFramebufferAttachmentsCreateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFramebufferAttachmentsCreateInfo, STRUCT_CACHE_VkFramebufferAttachmentsCreateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFramebufferAttachmentsCreateInfo, STRUCT_CACHE_VkFramebufferAttachmentsCreateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFramebufferAttachmentsCreateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAttachmentImageInfos = null;
  this._pAttachmentImageInfosNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentImageInfoCount !== void 0) this.attachmentImageInfoCount = opts.attachmentImageInfoCount;
    if (opts.pAttachmentImageInfos !== void 0) this.pAttachmentImageInfos = opts.pAttachmentImageInfos;
    
  }
};

Object.defineProperties(VkFramebufferAttachmentsCreateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentsCreateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFramebufferAttachmentsCreateInfo.pNext' isn't allowed to be filled");
    }
    },
  "attachmentImageInfoCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentsCreateInfo.attachmentImageInfoCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAttachmentImageInfos": {
    get() {
    if (this._pAttachmentImageInfos === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.attachmentImageInfoCount, VkFramebufferAttachmentImageInfo);
      this._pAttachmentImageInfos = array;
      return this.pAttachmentImageInfos;
    } else {
      return this._pAttachmentImageInfos;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachmentImageInfos = value;
    } else if (value === null) {
      this._pAttachmentImageInfos = null;
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentsCreateInfo.pAttachmentImageInfos': Expected 'Array VkFramebufferAttachmentImageInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkFramebufferAttachmentsCreateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAttachmentImageInfos = null;
  this._pAttachmentImageInfosNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentImageInfoCount !== void 0) this.attachmentImageInfoCount = opts.attachmentImageInfoCount;
    if (opts.pAttachmentImageInfos !== void 0) this.pAttachmentImageInfos = opts.pAttachmentImageInfos;
    
  }
};

VkFramebufferAttachmentsCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachmentImageInfos !== null) {
    let array = this._pAttachmentImageInfos;
    
    if (array.length !== this.attachmentImageInfoCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentImageInfoCount' for 'VkFramebufferAttachmentsCreateInfo.pAttachmentImageInfos'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkFramebufferAttachmentImageInfo)) {
        throw new TypeError("Invalid type for 'VkFramebufferAttachmentsCreateInfo.pAttachmentImageInfos[" + ii + "]': Expected 'VkFramebufferAttachmentImageInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentImageInfosNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAttachmentImageInfosNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkFramebufferAttachmentsCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkFramebufferAttachmentsCreateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFramebufferAttachmentsCreateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.attachmentImageInfoCount = original.attachmentImageInfoCount;
  if (original.pAttachmentImageInfos !== null) {
        copy.pAttachmentImageInfos = [...Array(original.pAttachmentImageInfos.length)].map((v, i) => {
          return original.pAttachmentImageInfos[i].constructor.createCopyFrom(original.pAttachmentImageInfos[i]);
        });
      }
  
  return copy;
};

VkFramebufferAttachmentsCreateInfo.byteLength = 0x0;

VkFramebufferAttachmentsCreateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentImageInfoCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttachmentImageInfos: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFramebufferAttachmentsCreateInfoKHR **/
function VkFramebufferAttachmentsCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkFramebufferAttachmentsCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFramebufferAttachmentsCreateInfoKHR, STRUCT_CACHE_VkFramebufferAttachmentsCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFramebufferAttachmentsCreateInfoKHR, STRUCT_CACHE_VkFramebufferAttachmentsCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFramebufferAttachmentsCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAttachmentImageInfos = null;
  this._pAttachmentImageInfosNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentImageInfoCount !== void 0) this.attachmentImageInfoCount = opts.attachmentImageInfoCount;
    if (opts.pAttachmentImageInfos !== void 0) this.pAttachmentImageInfos = opts.pAttachmentImageInfos;
    
  }
};

Object.defineProperties(VkFramebufferAttachmentsCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentsCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFramebufferAttachmentsCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "attachmentImageInfoCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentsCreateInfoKHR.attachmentImageInfoCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAttachmentImageInfos": {
    get() {
    if (this._pAttachmentImageInfos === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.attachmentImageInfoCount, VkFramebufferAttachmentImageInfo);
      this._pAttachmentImageInfos = array;
      return this.pAttachmentImageInfos;
    } else {
      return this._pAttachmentImageInfos;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachmentImageInfos = value;
    } else if (value === null) {
      this._pAttachmentImageInfos = null;
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentsCreateInfoKHR.pAttachmentImageInfos': Expected 'Array VkFramebufferAttachmentImageInfo' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkFramebufferAttachmentsCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAttachmentImageInfos = null;
  this._pAttachmentImageInfosNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentImageInfoCount !== void 0) this.attachmentImageInfoCount = opts.attachmentImageInfoCount;
    if (opts.pAttachmentImageInfos !== void 0) this.pAttachmentImageInfos = opts.pAttachmentImageInfos;
    
  }
};

VkFramebufferAttachmentsCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachmentImageInfos !== null) {
    let array = this._pAttachmentImageInfos;
    
    if (array.length !== this.attachmentImageInfoCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentImageInfoCount' for 'VkFramebufferAttachmentsCreateInfoKHR.pAttachmentImageInfos'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkFramebufferAttachmentImageInfo)) {
        throw new TypeError("Invalid type for 'VkFramebufferAttachmentsCreateInfoKHR.pAttachmentImageInfos[" + ii + "]': Expected 'VkFramebufferAttachmentImageInfo' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentImageInfosNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAttachmentImageInfosNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkFramebufferAttachmentsCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkFramebufferAttachmentsCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFramebufferAttachmentsCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.attachmentImageInfoCount = original.attachmentImageInfoCount;
  if (original.pAttachmentImageInfos !== null) {
        copy.pAttachmentImageInfos = [...Array(original.pAttachmentImageInfos.length)].map((v, i) => {
          return original.pAttachmentImageInfos[i].constructor.createCopyFrom(original.pAttachmentImageInfos[i]);
        });
      }
  
  return copy;
};

VkFramebufferAttachmentsCreateInfoKHR.byteLength = 0x0;

VkFramebufferAttachmentsCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentImageInfoCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttachmentImageInfos: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFramebufferAttachmentImageInfo **/
function VkFramebufferAttachmentImageInfo(opts, byteOffset) {
  if (new.target !== VkFramebufferAttachmentImageInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFramebufferAttachmentImageInfo, STRUCT_CACHE_VkFramebufferAttachmentImageInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFramebufferAttachmentImageInfo, STRUCT_CACHE_VkFramebufferAttachmentImageInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFramebufferAttachmentImageInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  this._pViewFormats = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
    if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
    
  }
};

Object.defineProperties(VkFramebufferAttachmentImageInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFramebufferAttachmentImageInfo.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfo.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfo.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "width": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfo.width");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "height": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfo.height");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "layerCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfo.layerCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "viewFormatCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfo.viewFormatCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewFormats": {
    get() {
    return this._pViewFormats;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewFormats = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pViewFormats = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentImageInfo.pViewFormats': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkFramebufferAttachmentImageInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  this._pViewFormats = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
    if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
    
  }
};

VkFramebufferAttachmentImageInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFramebufferAttachmentImageInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkFramebufferAttachmentImageInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFramebufferAttachmentImageInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.usage = original.usage;
  copy.width = original.width;
  copy.height = original.height;
  copy.layerCount = original.layerCount;
  copy.viewFormatCount = original.viewFormatCount;
  if (original.pViewFormats !== null) {
        copy.pViewFormats = new Int32Array(original.pViewFormats);
      }
  
  return copy;
};

VkFramebufferAttachmentImageInfo.byteLength = 0x0;

VkFramebufferAttachmentImageInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  width: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  height: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layerCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewFormatCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewFormats: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFramebufferAttachmentImageInfoKHR **/
function VkFramebufferAttachmentImageInfoKHR(opts, byteOffset) {
  if (new.target !== VkFramebufferAttachmentImageInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFramebufferAttachmentImageInfoKHR, STRUCT_CACHE_VkFramebufferAttachmentImageInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFramebufferAttachmentImageInfoKHR, STRUCT_CACHE_VkFramebufferAttachmentImageInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFramebufferAttachmentImageInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  this._pViewFormats = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
    if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
    
  }
};

Object.defineProperties(VkFramebufferAttachmentImageInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFramebufferAttachmentImageInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "usage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfoKHR.usage");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "width": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfoKHR.width");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "height": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfoKHR.height");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "layerCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfoKHR.layerCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "viewFormatCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferAttachmentImageInfoKHR.viewFormatCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pViewFormats": {
    get() {
    return this._pViewFormats;
    },
    set(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewFormats = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pViewFormats = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferAttachmentImageInfoKHR.pViewFormats': Expected 'Int32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkFramebufferAttachmentImageInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  this._pViewFormats = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.usage !== void 0) this.usage = opts.usage;
    if (opts.width !== void 0) this.width = opts.width;
    if (opts.height !== void 0) this.height = opts.height;
    if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
    if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
    if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
    
  }
};

VkFramebufferAttachmentImageInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFramebufferAttachmentImageInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkFramebufferAttachmentImageInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFramebufferAttachmentImageInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.usage = original.usage;
  copy.width = original.width;
  copy.height = original.height;
  copy.layerCount = original.layerCount;
  copy.viewFormatCount = original.viewFormatCount;
  if (original.pViewFormats !== null) {
        copy.pViewFormats = new Int32Array(original.pViewFormats);
      }
  
  return copy;
};

VkFramebufferAttachmentImageInfoKHR.byteLength = 0x0;

VkFramebufferAttachmentImageInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  usage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  width: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  height: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layerCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  viewFormatCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pViewFormats: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassAttachmentBeginInfo **/
function VkRenderPassAttachmentBeginInfo(opts, byteOffset) {
  if (new.target !== VkRenderPassAttachmentBeginInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassAttachmentBeginInfo, STRUCT_CACHE_VkRenderPassAttachmentBeginInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassAttachmentBeginInfo, STRUCT_CACHE_VkRenderPassAttachmentBeginInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassAttachmentBeginInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    
  }
};

Object.defineProperties(VkRenderPassAttachmentBeginInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassAttachmentBeginInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassAttachmentBeginInfo.pNext' isn't allowed to be filled");
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassAttachmentBeginInfo.attachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAttachments": {
    get() {
    if (this._pAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.attachmentCount, VkImageView);
      this._pAttachments = array;
      return this.pAttachments;
    } else {
      return this._pAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassAttachmentBeginInfo.pAttachments': Expected 'Array VkImageView' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassAttachmentBeginInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    
  }
};

VkRenderPassAttachmentBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkRenderPassAttachmentBeginInfo.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkImageView)) {
        throw new TypeError("Invalid type for 'VkRenderPassAttachmentBeginInfo.pAttachments[" + ii + "]': Expected 'VkImageView' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRenderPassAttachmentBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassAttachmentBeginInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassAttachmentBeginInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.attachmentCount = original.attachmentCount;
  if (original.pAttachments !== null) {
        copy.pAttachments = [...Array(original.pAttachments.length)].map((v, i) => {
          return original.pAttachments[i].constructor.createCopyFrom(original.pAttachments[i]);
        });
      }
  
  return copy;
};

VkRenderPassAttachmentBeginInfo.byteLength = 0x0;

VkRenderPassAttachmentBeginInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassAttachmentBeginInfoKHR **/
function VkRenderPassAttachmentBeginInfoKHR(opts, byteOffset) {
  if (new.target !== VkRenderPassAttachmentBeginInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassAttachmentBeginInfoKHR, STRUCT_CACHE_VkRenderPassAttachmentBeginInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassAttachmentBeginInfoKHR, STRUCT_CACHE_VkRenderPassAttachmentBeginInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassAttachmentBeginInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    
  }
};

Object.defineProperties(VkRenderPassAttachmentBeginInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassAttachmentBeginInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassAttachmentBeginInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "attachmentCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassAttachmentBeginInfoKHR.attachmentCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pAttachments": {
    get() {
    if (this._pAttachments === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.attachmentCount, VkImageView);
      this._pAttachments = array;
      return this.pAttachments;
    } else {
      return this._pAttachments;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassAttachmentBeginInfoKHR.pAttachments': Expected 'Array VkImageView' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkRenderPassAttachmentBeginInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pAttachments = null;
  this._pAttachmentsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
    if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
    
  }
};

VkRenderPassAttachmentBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkRenderPassAttachmentBeginInfoKHR.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkImageView)) {
        throw new TypeError("Invalid type for 'VkRenderPassAttachmentBeginInfoKHR.pAttachments[" + ii + "]': Expected 'VkImageView' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pAttachmentsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pAttachmentsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkRenderPassAttachmentBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassAttachmentBeginInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassAttachmentBeginInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.attachmentCount = original.attachmentCount;
  if (original.pAttachments !== null) {
        copy.pAttachments = [...Array(original.pAttachments.length)].map((v, i) => {
          return original.pAttachments[i].constructor.createCopyFrom(original.pAttachments[i]);
        });
      }
  
  return copy;
};

VkRenderPassAttachmentBeginInfoKHR.byteLength = 0x0;

VkRenderPassAttachmentBeginInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT **/
function VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.textureCompressionASTC_HDR !== void 0) this.textureCompressionASTC_HDR = opts.textureCompressionASTC_HDR;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "textureCompressionASTC_HDR": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.textureCompressionASTC_HDR !== void 0) this.textureCompressionASTC_HDR = opts.textureCompressionASTC_HDR;
    
  }
};

VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.textureCompressionASTC_HDR = original.textureCompressionASTC_HDR;
  
  return copy;
};

VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  textureCompressionASTC_HDR: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceCooperativeMatrixFeaturesNV **/
function VkPhysicalDeviceCooperativeMatrixFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceCooperativeMatrixFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceCooperativeMatrixFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceCooperativeMatrixFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceCooperativeMatrixFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceCooperativeMatrixFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceCooperativeMatrixFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.cooperativeMatrix !== void 0) this.cooperativeMatrix = opts.cooperativeMatrix;
    if (opts.cooperativeMatrixRobustBufferAccess !== void 0) this.cooperativeMatrixRobustBufferAccess = opts.cooperativeMatrixRobustBufferAccess;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCooperativeMatrixFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceCooperativeMatrixFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCooperativeMatrixFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "cooperativeMatrix": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "cooperativeMatrixRobustBufferAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceCooperativeMatrixFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.cooperativeMatrix !== void 0) this.cooperativeMatrix = opts.cooperativeMatrix;
    if (opts.cooperativeMatrixRobustBufferAccess !== void 0) this.cooperativeMatrixRobustBufferAccess = opts.cooperativeMatrixRobustBufferAccess;
    
  }
};

VkPhysicalDeviceCooperativeMatrixFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCooperativeMatrixFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceCooperativeMatrixFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceCooperativeMatrixFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.cooperativeMatrix = original.cooperativeMatrix;
  copy.cooperativeMatrixRobustBufferAccess = original.cooperativeMatrixRobustBufferAccess;
  
  return copy;
};

VkPhysicalDeviceCooperativeMatrixFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceCooperativeMatrixFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  cooperativeMatrix: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  cooperativeMatrixRobustBufferAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceCooperativeMatrixPropertiesNV **/
function VkPhysicalDeviceCooperativeMatrixPropertiesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceCooperativeMatrixPropertiesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceCooperativeMatrixPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceCooperativeMatrixPropertiesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceCooperativeMatrixPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceCooperativeMatrixPropertiesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceCooperativeMatrixPropertiesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCooperativeMatrixPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceCooperativeMatrixPropertiesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCooperativeMatrixPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "cooperativeMatrixSupportedStages": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceCooperativeMatrixPropertiesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceCooperativeMatrixPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCooperativeMatrixPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceCooperativeMatrixPropertiesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceCooperativeMatrixPropertiesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.cooperativeMatrixSupportedStages = original.cooperativeMatrixSupportedStages;
  
  return copy;
};

VkPhysicalDeviceCooperativeMatrixPropertiesNV.byteLength = 0x0;

VkPhysicalDeviceCooperativeMatrixPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  cooperativeMatrixSupportedStages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCooperativeMatrixPropertiesNV **/
function VkCooperativeMatrixPropertiesNV(opts, byteOffset) {
  if (new.target !== VkCooperativeMatrixPropertiesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCooperativeMatrixPropertiesNV, STRUCT_CACHE_VkCooperativeMatrixPropertiesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCooperativeMatrixPropertiesNV, STRUCT_CACHE_VkCooperativeMatrixPropertiesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCooperativeMatrixPropertiesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.MSize !== void 0) this.MSize = opts.MSize;
    if (opts.NSize !== void 0) this.NSize = opts.NSize;
    if (opts.KSize !== void 0) this.KSize = opts.KSize;
    if (opts.AType !== void 0) this.AType = opts.AType;
    if (opts.BType !== void 0) this.BType = opts.BType;
    if (opts.CType !== void 0) this.CType = opts.CType;
    if (opts.DType !== void 0) this.DType = opts.DType;
    if (opts.scope !== void 0) this.scope = opts.scope;
    
  }
};

Object.defineProperties(VkCooperativeMatrixPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCooperativeMatrixPropertiesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCooperativeMatrixPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "MSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCooperativeMatrixPropertiesNV.MSize");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "NSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCooperativeMatrixPropertiesNV.NSize");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "KSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCooperativeMatrixPropertiesNV.KSize");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "AType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCooperativeMatrixPropertiesNV.AType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "BType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCooperativeMatrixPropertiesNV.BType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "CType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCooperativeMatrixPropertiesNV.CType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "DType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCooperativeMatrixPropertiesNV.DType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "scope": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCooperativeMatrixPropertiesNV.scope");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkCooperativeMatrixPropertiesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.MSize !== void 0) this.MSize = opts.MSize;
    if (opts.NSize !== void 0) this.NSize = opts.NSize;
    if (opts.KSize !== void 0) this.KSize = opts.KSize;
    if (opts.AType !== void 0) this.AType = opts.AType;
    if (opts.BType !== void 0) this.BType = opts.BType;
    if (opts.CType !== void 0) this.CType = opts.CType;
    if (opts.DType !== void 0) this.DType = opts.DType;
    if (opts.scope !== void 0) this.scope = opts.scope;
    
  }
};

VkCooperativeMatrixPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCooperativeMatrixPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkCooperativeMatrixPropertiesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCooperativeMatrixPropertiesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.MSize = original.MSize;
  copy.NSize = original.NSize;
  copy.KSize = original.KSize;
  copy.AType = original.AType;
  copy.BType = original.BType;
  copy.CType = original.CType;
  copy.DType = original.DType;
  copy.scope = original.scope;
  
  return copy;
};

VkCooperativeMatrixPropertiesNV.byteLength = 0x0;

VkCooperativeMatrixPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  MSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  NSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  KSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  AType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  BType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  CType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  DType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  scope: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceYcbcrImageArraysFeaturesEXT **/
function VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceYcbcrImageArraysFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceYcbcrImageArraysFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.ycbcrImageArrays !== void 0) this.ycbcrImageArrays = opts.ycbcrImageArrays;
    
  }
};

Object.defineProperties(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "ycbcrImageArrays": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.ycbcrImageArrays !== void 0) this.ycbcrImageArrays = opts.ycbcrImageArrays;
    
  }
};

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceYcbcrImageArraysFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.ycbcrImageArrays = original.ycbcrImageArrays;
  
  return copy;
};

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ycbcrImageArrays: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageViewHandleInfoNVX **/
function VkImageViewHandleInfoNVX(opts, byteOffset) {
  if (new.target !== VkImageViewHandleInfoNVX) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageViewHandleInfoNVX, STRUCT_CACHE_VkImageViewHandleInfoNVX);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageViewHandleInfoNVX, STRUCT_CACHE_VkImageViewHandleInfoNVX);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageViewHandleInfoNVX'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._imageView = null;
  
  this._sampler = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imageView !== void 0) this.imageView = opts.imageView;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.sampler !== void 0) this.sampler = opts.sampler;
    
  }
};

Object.defineProperties(VkImageViewHandleInfoNVX.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewHandleInfoNVX.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageViewHandleInfoNVX.pNext' isn't allowed to be filled");
    }
    },
  "imageView": {
    get() {
    return this._imageView;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageView) {
      
      this._imageView = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._imageView = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageViewHandleInfoNVX.imageView': Expected 'VkImageView' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "descriptorType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewHandleInfoNVX.descriptorType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "sampler": {
    get() {
    return this._sampler;
    },
    set(value) {
    if (value !== null && value.constructor === VkSampler) {
      
      this._sampler = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._sampler = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageViewHandleInfoNVX.sampler': Expected 'VkSampler' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageViewHandleInfoNVX.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._imageView = null;
  
  this._sampler = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.imageView !== void 0) this.imageView = opts.imageView;
    if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
    if (opts.sampler !== void 0) this.sampler = opts.sampler;
    
  }
};

VkImageViewHandleInfoNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewHandleInfoNVX.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageViewHandleInfoNVX.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageViewHandleInfoNVX();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.imageView !== null) {
        copy.imageView = original.imageView.constructor.createCopyFrom(original.imageView);
      }
  copy.descriptorType = original.descriptorType;
  if (original.sampler !== null) {
        copy.sampler = original.sampler.constructor.createCopyFrom(original.sampler);
      }
  
  return copy;
};

VkImageViewHandleInfoNVX.byteLength = 0x0;

VkImageViewHandleInfoNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageView: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampler: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageViewAddressPropertiesNVX **/
function VkImageViewAddressPropertiesNVX(opts, byteOffset) {
  if (new.target !== VkImageViewAddressPropertiesNVX) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageViewAddressPropertiesNVX, STRUCT_CACHE_VkImageViewAddressPropertiesNVX);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageViewAddressPropertiesNVX, STRUCT_CACHE_VkImageViewAddressPropertiesNVX);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageViewAddressPropertiesNVX'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkImageViewAddressPropertiesNVX.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageViewAddressPropertiesNVX.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageViewAddressPropertiesNVX.pNext' isn't allowed to be filled");
    }
    },
  "deviceAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkImageViewAddressPropertiesNVX.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkImageViewAddressPropertiesNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewAddressPropertiesNVX.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkImageViewAddressPropertiesNVX.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageViewAddressPropertiesNVX();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceAddress = original.deviceAddress;
  copy.size = original.size;
  
  return copy;
};

VkImageViewAddressPropertiesNVX.byteLength = 0x0;

VkImageViewAddressPropertiesNVX.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineCreationFeedbackEXT **/
function VkPipelineCreationFeedbackEXT(opts, byteOffset) {
  if (new.target !== VkPipelineCreationFeedbackEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineCreationFeedbackEXT, STRUCT_CACHE_VkPipelineCreationFeedbackEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineCreationFeedbackEXT, STRUCT_CACHE_VkPipelineCreationFeedbackEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineCreationFeedbackEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  if (typeof opts === "object") {
    
  }
};

Object.defineProperties(VkPipelineCreationFeedbackEXT.prototype, {
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "duration": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPipelineCreationFeedbackEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  if (typeof opts === "object") {
    
  }
};

VkPipelineCreationFeedbackEXT.prototype.flush = function flush() {
  
  return true;
};

VkPipelineCreationFeedbackEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPipelineCreationFeedbackEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineCreationFeedbackEXT();
  copy.flags = original.flags;
  copy.duration = original.duration;
  
  return copy;
};

VkPipelineCreationFeedbackEXT.byteLength = 0x0;

VkPipelineCreationFeedbackEXT.memoryLayout = {
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  duration: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineCreationFeedbackCreateInfoEXT **/
function VkPipelineCreationFeedbackCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPipelineCreationFeedbackCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineCreationFeedbackCreateInfoEXT, STRUCT_CACHE_VkPipelineCreationFeedbackCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineCreationFeedbackCreateInfoEXT, STRUCT_CACHE_VkPipelineCreationFeedbackCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineCreationFeedbackCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._pPipelineCreationFeedback = null;
  
  this._pPipelineStageCreationFeedbacks = null;
  this._pPipelineStageCreationFeedbacksNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pPipelineCreationFeedback !== void 0) this.pPipelineCreationFeedback = opts.pPipelineCreationFeedback;
    if (opts.pipelineStageCreationFeedbackCount !== void 0) this.pipelineStageCreationFeedbackCount = opts.pipelineStageCreationFeedbackCount;
    if (opts.pPipelineStageCreationFeedbacks !== void 0) this.pPipelineStageCreationFeedbacks = opts.pPipelineStageCreationFeedbacks;
    
  }
};

Object.defineProperties(VkPipelineCreationFeedbackCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCreationFeedbackCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCreationFeedbackCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "pPipelineCreationFeedback": {
    get() {
    if (this._pPipelineCreationFeedback === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkPipelineCreationFeedbackEXT.byteLength));
      this._pPipelineCreationFeedback = new VkPipelineCreationFeedbackEXT({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pPipelineCreationFeedback.memoryAddress, true);
      return this.pPipelineCreationFeedback;
    } else {
      return this._pPipelineCreationFeedback;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkPipelineCreationFeedbackEXT) {
      value.flush();
      this._pPipelineCreationFeedback = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pPipelineCreationFeedback = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineCreationFeedbackCreateInfoEXT.pPipelineCreationFeedback': Expected 'VkPipelineCreationFeedbackEXT' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "pipelineStageCreationFeedbackCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCreationFeedbackCreateInfoEXT.pipelineStageCreationFeedbackCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pPipelineStageCreationFeedbacks": {
    get() {
    if (this._pPipelineStageCreationFeedbacks === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.pipelineStageCreationFeedbackCount, VkPipelineCreationFeedbackEXT);
      this._pPipelineStageCreationFeedbacks = array;
      return this.pPipelineStageCreationFeedbacks;
    } else {
      return this._pPipelineStageCreationFeedbacks;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pPipelineStageCreationFeedbacks = value;
    } else if (value === null) {
      this._pPipelineStageCreationFeedbacks = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineCreationFeedbackCreateInfoEXT.pPipelineStageCreationFeedbacks': Expected 'Array VkPipelineCreationFeedbackEXT' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineCreationFeedbackCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._pPipelineCreationFeedback = null;
  
  this._pPipelineStageCreationFeedbacks = null;
  this._pPipelineStageCreationFeedbacksNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pPipelineCreationFeedback !== void 0) this.pPipelineCreationFeedback = opts.pPipelineCreationFeedback;
    if (opts.pipelineStageCreationFeedbackCount !== void 0) this.pipelineStageCreationFeedbackCount = opts.pipelineStageCreationFeedbackCount;
    if (opts.pPipelineStageCreationFeedbacks !== void 0) this.pPipelineStageCreationFeedbacks = opts.pPipelineStageCreationFeedbacks;
    
  }
};

VkPipelineCreationFeedbackCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPipelineStageCreationFeedbacks !== null) {
    let array = this._pPipelineStageCreationFeedbacks;
    
    if (array.length !== this.pipelineStageCreationFeedbackCount) {
      throw new RangeError("Invalid array length, expected length of 'pipelineStageCreationFeedbackCount' for 'VkPipelineCreationFeedbackCreateInfoEXT.pPipelineStageCreationFeedbacks'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipelineCreationFeedbackEXT)) {
        throw new TypeError("Invalid type for 'VkPipelineCreationFeedbackCreateInfoEXT.pPipelineStageCreationFeedbacks[" + ii + "]': Expected 'VkPipelineCreationFeedbackEXT' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pPipelineStageCreationFeedbacksNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pPipelineStageCreationFeedbacksNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineCreationFeedbackCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineCreationFeedbackCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineCreationFeedbackCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.pPipelineCreationFeedback !== null) {
        copy.pPipelineCreationFeedback = original.pPipelineCreationFeedback.constructor.createCopyFrom(original.pPipelineCreationFeedback);
      }
  copy.pipelineStageCreationFeedbackCount = original.pipelineStageCreationFeedbackCount;
  if (original.pPipelineStageCreationFeedbacks !== null) {
        copy.pPipelineStageCreationFeedbacks = [...Array(original.pPipelineStageCreationFeedbacks.length)].map((v, i) => {
          return original.pPipelineStageCreationFeedbacks[i].constructor.createCopyFrom(original.pPipelineStageCreationFeedbacks[i]);
        });
      }
  
  return copy;
};

VkPipelineCreationFeedbackCreateInfoEXT.byteLength = 0x0;

VkPipelineCreationFeedbackCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPipelineCreationFeedback: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineStageCreationFeedbackCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pPipelineStageCreationFeedbacks: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSurfaceFullScreenExclusiveInfoEXT **/
function VkSurfaceFullScreenExclusiveInfoEXT(opts, byteOffset) {
  if (new.target !== VkSurfaceFullScreenExclusiveInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSurfaceFullScreenExclusiveInfoEXT, STRUCT_CACHE_VkSurfaceFullScreenExclusiveInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSurfaceFullScreenExclusiveInfoEXT, STRUCT_CACHE_VkSurfaceFullScreenExclusiveInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSurfaceFullScreenExclusiveInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fullScreenExclusive !== void 0) this.fullScreenExclusive = opts.fullScreenExclusive;
    
  }
};

Object.defineProperties(VkSurfaceFullScreenExclusiveInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSurfaceFullScreenExclusiveInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceFullScreenExclusiveInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "fullScreenExclusive": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSurfaceFullScreenExclusiveInfoEXT.fullScreenExclusive");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSurfaceFullScreenExclusiveInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fullScreenExclusive !== void 0) this.fullScreenExclusive = opts.fullScreenExclusive;
    
  }
};

VkSurfaceFullScreenExclusiveInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceFullScreenExclusiveInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkSurfaceFullScreenExclusiveInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSurfaceFullScreenExclusiveInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.fullScreenExclusive = original.fullScreenExclusive;
  
  return copy;
};

VkSurfaceFullScreenExclusiveInfoEXT.byteLength = 0x0;

VkSurfaceFullScreenExclusiveInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fullScreenExclusive: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSurfaceFullScreenExclusiveWin32InfoEXT **/
function VkSurfaceFullScreenExclusiveWin32InfoEXT(opts, byteOffset) {
  if (new.target !== VkSurfaceFullScreenExclusiveWin32InfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSurfaceFullScreenExclusiveWin32InfoEXT, STRUCT_CACHE_VkSurfaceFullScreenExclusiveWin32InfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSurfaceFullScreenExclusiveWin32InfoEXT, STRUCT_CACHE_VkSurfaceFullScreenExclusiveWin32InfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSurfaceFullScreenExclusiveWin32InfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkSurfaceFullScreenExclusiveWin32InfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSurfaceFullScreenExclusiveWin32InfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceFullScreenExclusiveWin32InfoEXT.pNext' isn't allowed to be filled");
    }
    },
  
});

VkSurfaceFullScreenExclusiveWin32InfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkSurfaceFullScreenExclusiveWin32InfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceFullScreenExclusiveWin32InfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkSurfaceFullScreenExclusiveWin32InfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSurfaceFullScreenExclusiveWin32InfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  
  return copy;
};

VkSurfaceFullScreenExclusiveWin32InfoEXT.byteLength = 0x0;

VkSurfaceFullScreenExclusiveWin32InfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSurfaceCapabilitiesFullScreenExclusiveEXT **/
function VkSurfaceCapabilitiesFullScreenExclusiveEXT(opts, byteOffset) {
  if (new.target !== VkSurfaceCapabilitiesFullScreenExclusiveEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSurfaceCapabilitiesFullScreenExclusiveEXT, STRUCT_CACHE_VkSurfaceCapabilitiesFullScreenExclusiveEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSurfaceCapabilitiesFullScreenExclusiveEXT, STRUCT_CACHE_VkSurfaceCapabilitiesFullScreenExclusiveEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSurfaceCapabilitiesFullScreenExclusiveEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fullScreenExclusiveSupported !== void 0) this.fullScreenExclusiveSupported = opts.fullScreenExclusiveSupported;
    
  }
};

Object.defineProperties(VkSurfaceCapabilitiesFullScreenExclusiveEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSurfaceCapabilitiesFullScreenExclusiveEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSurfaceCapabilitiesFullScreenExclusiveEXT.pNext' isn't allowed to be filled");
    }
    },
  "fullScreenExclusiveSupported": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkSurfaceCapabilitiesFullScreenExclusiveEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fullScreenExclusiveSupported !== void 0) this.fullScreenExclusiveSupported = opts.fullScreenExclusiveSupported;
    
  }
};

VkSurfaceCapabilitiesFullScreenExclusiveEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceCapabilitiesFullScreenExclusiveEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkSurfaceCapabilitiesFullScreenExclusiveEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSurfaceCapabilitiesFullScreenExclusiveEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.fullScreenExclusiveSupported = original.fullScreenExclusiveSupported;
  
  return copy;
};

VkSurfaceCapabilitiesFullScreenExclusiveEXT.byteLength = 0x0;

VkSurfaceCapabilitiesFullScreenExclusiveEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fullScreenExclusiveSupported: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevicePerformanceQueryFeaturesKHR **/
function VkPhysicalDevicePerformanceQueryFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDevicePerformanceQueryFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevicePerformanceQueryFeaturesKHR, STRUCT_CACHE_VkPhysicalDevicePerformanceQueryFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevicePerformanceQueryFeaturesKHR, STRUCT_CACHE_VkPhysicalDevicePerformanceQueryFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevicePerformanceQueryFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.performanceCounterQueryPools !== void 0) this.performanceCounterQueryPools = opts.performanceCounterQueryPools;
    if (opts.performanceCounterMultipleQueryPools !== void 0) this.performanceCounterMultipleQueryPools = opts.performanceCounterMultipleQueryPools;
    
  }
};

Object.defineProperties(VkPhysicalDevicePerformanceQueryFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevicePerformanceQueryFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePerformanceQueryFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "performanceCounterQueryPools": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "performanceCounterMultipleQueryPools": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDevicePerformanceQueryFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.performanceCounterQueryPools !== void 0) this.performanceCounterQueryPools = opts.performanceCounterQueryPools;
    if (opts.performanceCounterMultipleQueryPools !== void 0) this.performanceCounterMultipleQueryPools = opts.performanceCounterMultipleQueryPools;
    
  }
};

VkPhysicalDevicePerformanceQueryFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePerformanceQueryFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDevicePerformanceQueryFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevicePerformanceQueryFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.performanceCounterQueryPools = original.performanceCounterQueryPools;
  copy.performanceCounterMultipleQueryPools = original.performanceCounterMultipleQueryPools;
  
  return copy;
};

VkPhysicalDevicePerformanceQueryFeaturesKHR.byteLength = 0x0;

VkPhysicalDevicePerformanceQueryFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  performanceCounterQueryPools: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  performanceCounterMultipleQueryPools: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevicePerformanceQueryPropertiesKHR **/
function VkPhysicalDevicePerformanceQueryPropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDevicePerformanceQueryPropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevicePerformanceQueryPropertiesKHR, STRUCT_CACHE_VkPhysicalDevicePerformanceQueryPropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevicePerformanceQueryPropertiesKHR, STRUCT_CACHE_VkPhysicalDevicePerformanceQueryPropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevicePerformanceQueryPropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDevicePerformanceQueryPropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevicePerformanceQueryPropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePerformanceQueryPropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "allowCommandBufferQueryCopies": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDevicePerformanceQueryPropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDevicePerformanceQueryPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePerformanceQueryPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDevicePerformanceQueryPropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevicePerformanceQueryPropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.allowCommandBufferQueryCopies = original.allowCommandBufferQueryCopies;
  
  return copy;
};

VkPhysicalDevicePerformanceQueryPropertiesKHR.byteLength = 0x0;

VkPhysicalDevicePerformanceQueryPropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  allowCommandBufferQueryCopies: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPerformanceCounterKHR **/
function VkPerformanceCounterKHR(opts, byteOffset) {
  if (new.target !== VkPerformanceCounterKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPerformanceCounterKHR, STRUCT_CACHE_VkPerformanceCounterKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPerformanceCounterKHR, STRUCT_CACHE_VkPerformanceCounterKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPerformanceCounterKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._uuid = [...Array(16)].fill(0x0);
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPerformanceCounterKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceCounterKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceCounterKHR.pNext' isn't allowed to be filled");
    }
    },
  "unit": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "scope": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "storage": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "uuid": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true),
      this.memoryView.getUint8(0x8, true),
      this.memoryView.getUint8(0x9, true),
      this.memoryView.getUint8(0xA, true),
      this.memoryView.getUint8(0xB, true),
      this.memoryView.getUint8(0xC, true),
      this.memoryView.getUint8(0xD, true),
      this.memoryView.getUint8(0xE, true),
      this.memoryView.getUint8(0xF, true)
    ];
    },
    },
  
});

VkPerformanceCounterKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  if (this._uuid !== null) this._uuid.fill(0x0);
      else this._uuid = [...Array(16)].fill(0x0);
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPerformanceCounterKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceCounterKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPerformanceCounterKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPerformanceCounterKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.unit = original.unit;
  copy.scope = original.scope;
  copy.storage = original.storage;
  if (original.uuid !== null) {
        copy.uuid = [...Array(original.uuid.length)].map((v, i) => {
          return original.uuid[i];
        });
      }
  
  return copy;
};

VkPerformanceCounterKHR.byteLength = 0x0;

VkPerformanceCounterKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  unit: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  scope: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uuid: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPerformanceCounterDescriptionKHR **/
function VkPerformanceCounterDescriptionKHR(opts, byteOffset) {
  if (new.target !== VkPerformanceCounterDescriptionKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPerformanceCounterDescriptionKHR, STRUCT_CACHE_VkPerformanceCounterDescriptionKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPerformanceCounterDescriptionKHR, STRUCT_CACHE_VkPerformanceCounterDescriptionKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPerformanceCounterDescriptionKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPerformanceCounterDescriptionKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceCounterDescriptionKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceCounterDescriptionKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "name": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "category": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "description": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  
});

VkPerformanceCounterDescriptionKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPerformanceCounterDescriptionKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceCounterDescriptionKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPerformanceCounterDescriptionKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPerformanceCounterDescriptionKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.name = original.name;
  copy.category = original.category;
  copy.description = original.description;
  
  return copy;
};

VkPerformanceCounterDescriptionKHR.byteLength = 0x0;

VkPerformanceCounterDescriptionKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  category: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  description: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkQueryPoolPerformanceCreateInfoKHR **/
function VkQueryPoolPerformanceCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkQueryPoolPerformanceCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkQueryPoolPerformanceCreateInfoKHR, STRUCT_CACHE_VkQueryPoolPerformanceCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkQueryPoolPerformanceCreateInfoKHR, STRUCT_CACHE_VkQueryPoolPerformanceCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkQueryPoolPerformanceCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this._pCounterIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    if (opts.counterIndexCount !== void 0) this.counterIndexCount = opts.counterIndexCount;
    if (opts.pCounterIndices !== void 0) this.pCounterIndices = opts.pCounterIndices;
    
  }
};

Object.defineProperties(VkQueryPoolPerformanceCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolPerformanceCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkQueryPoolPerformanceCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "queueFamilyIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolPerformanceCreateInfoKHR.queueFamilyIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "counterIndexCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolPerformanceCreateInfoKHR.counterIndexCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pCounterIndices": {
    get() {
    return this._pCounterIndices;
    },
    set(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCounterIndices = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pCounterIndices = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkQueryPoolPerformanceCreateInfoKHR.pCounterIndices': Expected 'Uint32Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkQueryPoolPerformanceCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this._pCounterIndices = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
    if (opts.counterIndexCount !== void 0) this.counterIndexCount = opts.counterIndexCount;
    if (opts.pCounterIndices !== void 0) this.pCounterIndices = opts.pCounterIndices;
    
  }
};

VkQueryPoolPerformanceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueryPoolPerformanceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkQueryPoolPerformanceCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkQueryPoolPerformanceCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.queueFamilyIndex = original.queueFamilyIndex;
  copy.counterIndexCount = original.counterIndexCount;
  if (original.pCounterIndices !== null) {
        copy.pCounterIndices = new Uint32Array(original.pCounterIndices);
      }
  
  return copy;
};

VkQueryPoolPerformanceCreateInfoKHR.byteLength = 0x0;

VkQueryPoolPerformanceCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  queueFamilyIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  counterIndexCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pCounterIndices: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAcquireProfilingLockInfoKHR **/
function VkAcquireProfilingLockInfoKHR(opts, byteOffset) {
  if (new.target !== VkAcquireProfilingLockInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAcquireProfilingLockInfoKHR, STRUCT_CACHE_VkAcquireProfilingLockInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAcquireProfilingLockInfoKHR, STRUCT_CACHE_VkAcquireProfilingLockInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAcquireProfilingLockInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.timeout !== void 0) this.timeout = opts.timeout;
    
  }
};

Object.defineProperties(VkAcquireProfilingLockInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAcquireProfilingLockInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAcquireProfilingLockInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAcquireProfilingLockInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "timeout": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAcquireProfilingLockInfoKHR.timeout")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkAcquireProfilingLockInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.timeout !== void 0) this.timeout = opts.timeout;
    
  }
};

VkAcquireProfilingLockInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAcquireProfilingLockInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAcquireProfilingLockInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAcquireProfilingLockInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.timeout = original.timeout;
  
  return copy;
};

VkAcquireProfilingLockInfoKHR.byteLength = 0x0;

VkAcquireProfilingLockInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  timeout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPerformanceQuerySubmitInfoKHR **/
function VkPerformanceQuerySubmitInfoKHR(opts, byteOffset) {
  if (new.target !== VkPerformanceQuerySubmitInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPerformanceQuerySubmitInfoKHR, STRUCT_CACHE_VkPerformanceQuerySubmitInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPerformanceQuerySubmitInfoKHR, STRUCT_CACHE_VkPerformanceQuerySubmitInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPerformanceQuerySubmitInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.counterPassIndex !== void 0) this.counterPassIndex = opts.counterPassIndex;
    
  }
};

Object.defineProperties(VkPerformanceQuerySubmitInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceQuerySubmitInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceQuerySubmitInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "counterPassIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceQuerySubmitInfoKHR.counterPassIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkPerformanceQuerySubmitInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.counterPassIndex !== void 0) this.counterPassIndex = opts.counterPassIndex;
    
  }
};

VkPerformanceQuerySubmitInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceQuerySubmitInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPerformanceQuerySubmitInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPerformanceQuerySubmitInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.counterPassIndex = original.counterPassIndex;
  
  return copy;
};

VkPerformanceQuerySubmitInfoKHR.byteLength = 0x0;

VkPerformanceQuerySubmitInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  counterPassIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkHeadlessSurfaceCreateInfoEXT **/
function VkHeadlessSurfaceCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkHeadlessSurfaceCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkHeadlessSurfaceCreateInfoEXT, STRUCT_CACHE_VkHeadlessSurfaceCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkHeadlessSurfaceCreateInfoEXT, STRUCT_CACHE_VkHeadlessSurfaceCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkHeadlessSurfaceCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkHeadlessSurfaceCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkHeadlessSurfaceCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkHeadlessSurfaceCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkHeadlessSurfaceCreateInfoEXT.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkHeadlessSurfaceCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkHeadlessSurfaceCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkHeadlessSurfaceCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkHeadlessSurfaceCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkHeadlessSurfaceCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  
  return copy;
};

VkHeadlessSurfaceCreateInfoEXT.byteLength = 0x0;

VkHeadlessSurfaceCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceCoverageReductionModeFeaturesNV **/
function VkPhysicalDeviceCoverageReductionModeFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceCoverageReductionModeFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceCoverageReductionModeFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceCoverageReductionModeFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceCoverageReductionModeFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceCoverageReductionModeFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceCoverageReductionModeFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.coverageReductionMode !== void 0) this.coverageReductionMode = opts.coverageReductionMode;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCoverageReductionModeFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceCoverageReductionModeFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCoverageReductionModeFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "coverageReductionMode": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceCoverageReductionModeFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.coverageReductionMode !== void 0) this.coverageReductionMode = opts.coverageReductionMode;
    
  }
};

VkPhysicalDeviceCoverageReductionModeFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCoverageReductionModeFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceCoverageReductionModeFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceCoverageReductionModeFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.coverageReductionMode = original.coverageReductionMode;
  
  return copy;
};

VkPhysicalDeviceCoverageReductionModeFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceCoverageReductionModeFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  coverageReductionMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineCoverageReductionStateCreateInfoNV **/
function VkPipelineCoverageReductionStateCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkPipelineCoverageReductionStateCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineCoverageReductionStateCreateInfoNV, STRUCT_CACHE_VkPipelineCoverageReductionStateCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineCoverageReductionStateCreateInfoNV, STRUCT_CACHE_VkPipelineCoverageReductionStateCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineCoverageReductionStateCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.coverageReductionMode !== void 0) this.coverageReductionMode = opts.coverageReductionMode;
    
  }
};

Object.defineProperties(VkPipelineCoverageReductionStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCoverageReductionStateCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCoverageReductionStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCoverageReductionStateCreateInfoNV.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "coverageReductionMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCoverageReductionStateCreateInfoNV.coverageReductionMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPipelineCoverageReductionStateCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.coverageReductionMode !== void 0) this.coverageReductionMode = opts.coverageReductionMode;
    
  }
};

VkPipelineCoverageReductionStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCoverageReductionStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineCoverageReductionStateCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineCoverageReductionStateCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  copy.coverageReductionMode = original.coverageReductionMode;
  
  return copy;
};

VkPipelineCoverageReductionStateCreateInfoNV.byteLength = 0x0;

VkPipelineCoverageReductionStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  coverageReductionMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFramebufferMixedSamplesCombinationNV **/
function VkFramebufferMixedSamplesCombinationNV(opts, byteOffset) {
  if (new.target !== VkFramebufferMixedSamplesCombinationNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFramebufferMixedSamplesCombinationNV, STRUCT_CACHE_VkFramebufferMixedSamplesCombinationNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFramebufferMixedSamplesCombinationNV, STRUCT_CACHE_VkFramebufferMixedSamplesCombinationNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFramebufferMixedSamplesCombinationNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkFramebufferMixedSamplesCombinationNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFramebufferMixedSamplesCombinationNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFramebufferMixedSamplesCombinationNV.pNext' isn't allowed to be filled");
    }
    },
  "coverageReductionMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "rasterizationSamples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "depthStencilSamples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "colorSamples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkFramebufferMixedSamplesCombinationNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkFramebufferMixedSamplesCombinationNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFramebufferMixedSamplesCombinationNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkFramebufferMixedSamplesCombinationNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFramebufferMixedSamplesCombinationNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.coverageReductionMode = original.coverageReductionMode;
  copy.rasterizationSamples = original.rasterizationSamples;
  copy.depthStencilSamples = original.depthStencilSamples;
  copy.colorSamples = original.colorSamples;
  
  return copy;
};

VkFramebufferMixedSamplesCombinationNV.byteLength = 0x0;

VkFramebufferMixedSamplesCombinationNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  coverageReductionMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rasterizationSamples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  depthStencilSamples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  colorSamples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL **/
function VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, STRUCT_CACHE_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, STRUCT_CACHE_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderIntegerFunctions2 !== void 0) this.shaderIntegerFunctions2 = opts.shaderIntegerFunctions2;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.pNext' isn't allowed to be filled");
    }
    },
  "shaderIntegerFunctions2": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderIntegerFunctions2 !== void 0) this.shaderIntegerFunctions2 = opts.shaderIntegerFunctions2;
    
  }
};

VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderIntegerFunctions2 = original.shaderIntegerFunctions2;
  
  return copy;
};

VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.byteLength = 0x0;

VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderIntegerFunctions2: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPerformanceValueINTEL **/
function VkPerformanceValueINTEL(opts, byteOffset) {
  if (new.target !== VkPerformanceValueINTEL) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPerformanceValueINTEL, STRUCT_CACHE_VkPerformanceValueINTEL);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPerformanceValueINTEL, STRUCT_CACHE_VkPerformanceValueINTEL);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPerformanceValueINTEL'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._data = new VkPerformanceValueDataINTEL({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.data !== void 0) this.data = opts.data;
    
  }
};

Object.defineProperties(VkPerformanceValueINTEL.prototype, {
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceValueINTEL.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "data": {
    get() {
    return this._data;
    },
    set(value) {
    if (value !== null && value.constructor === VkPerformanceValueDataINTEL) {
      value.flush();
      this._data = value;
      
      
    } else if (value === null) {
      this._data = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPerformanceValueINTEL.data': Expected 'VkPerformanceValueDataINTEL' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPerformanceValueINTEL.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  if (this._data !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._data.memoryBuffer) this._data = new VkPerformanceValueDataINTEL({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._data.reset();
  }
  
  if (typeof opts === "object") {
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.data !== void 0) this.data = opts.data;
    
  }
};

VkPerformanceValueINTEL.prototype.flush = function flush() {
  
  
  if (this._data !== null) {
    let data = this._data;
    data.flush();
    if (this.memoryBuffer !== data.memoryBuffer) {
      let srcView = new Uint8Array(data.memoryBuffer, data.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPerformanceValueINTEL.data' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkPerformanceValueINTEL.prototype.reflect = function reflect(memoryAddress) {
  };

VkPerformanceValueINTEL.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPerformanceValueINTEL();
  copy.type = original.type;
  if (original.data !== null) {
        copy.data = original.data.constructor.createCopyFrom(original.data);
      }
  
  return copy;
};

VkPerformanceValueINTEL.byteLength = 0x0;

VkPerformanceValueINTEL.memoryLayout = {
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  data: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkInitializePerformanceApiInfoINTEL **/
function VkInitializePerformanceApiInfoINTEL(opts, byteOffset) {
  if (new.target !== VkInitializePerformanceApiInfoINTEL) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkInitializePerformanceApiInfoINTEL, STRUCT_CACHE_VkInitializePerformanceApiInfoINTEL);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkInitializePerformanceApiInfoINTEL, STRUCT_CACHE_VkInitializePerformanceApiInfoINTEL);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkInitializePerformanceApiInfoINTEL'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._pUserData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

Object.defineProperties(VkInitializePerformanceApiInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkInitializePerformanceApiInfoINTEL.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkInitializePerformanceApiInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "pUserData": {
    get() {
    return this._pUserData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkInitializePerformanceApiInfoINTEL.pUserData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkInitializePerformanceApiInfoINTEL.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._pUserData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
    
  }
};

VkInitializePerformanceApiInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkInitializePerformanceApiInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  };

VkInitializePerformanceApiInfoINTEL.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkInitializePerformanceApiInfoINTEL();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.pUserData !== null) {
      let buf = new ArrayBuffer(original.pUserData.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pUserData), 0x0);
      copy.pUserData = buf;
    }
  
  return copy;
};

VkInitializePerformanceApiInfoINTEL.byteLength = 0x0;

VkInitializePerformanceApiInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pUserData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkQueryPoolPerformanceQueryCreateInfoINTEL **/
function VkQueryPoolPerformanceQueryCreateInfoINTEL(opts, byteOffset) {
  if (new.target !== VkQueryPoolPerformanceQueryCreateInfoINTEL) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkQueryPoolPerformanceQueryCreateInfoINTEL, STRUCT_CACHE_VkQueryPoolPerformanceQueryCreateInfoINTEL);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkQueryPoolPerformanceQueryCreateInfoINTEL, STRUCT_CACHE_VkQueryPoolPerformanceQueryCreateInfoINTEL);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkQueryPoolPerformanceQueryCreateInfoINTEL'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.performanceCountersSampling !== void 0) this.performanceCountersSampling = opts.performanceCountersSampling;
    
  }
};

Object.defineProperties(VkQueryPoolPerformanceQueryCreateInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolPerformanceQueryCreateInfoINTEL.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkQueryPoolPerformanceQueryCreateInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "performanceCountersSampling": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolPerformanceQueryCreateInfoINTEL.performanceCountersSampling");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkQueryPoolPerformanceQueryCreateInfoINTEL.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.performanceCountersSampling !== void 0) this.performanceCountersSampling = opts.performanceCountersSampling;
    
  }
};

VkQueryPoolPerformanceQueryCreateInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueryPoolPerformanceQueryCreateInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  };

VkQueryPoolPerformanceQueryCreateInfoINTEL.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkQueryPoolPerformanceQueryCreateInfoINTEL();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.performanceCountersSampling = original.performanceCountersSampling;
  
  return copy;
};

VkQueryPoolPerformanceQueryCreateInfoINTEL.byteLength = 0x0;

VkQueryPoolPerformanceQueryCreateInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  performanceCountersSampling: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkQueryPoolCreateInfoINTEL **/
function VkQueryPoolCreateInfoINTEL(opts, byteOffset) {
  if (new.target !== VkQueryPoolCreateInfoINTEL) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkQueryPoolCreateInfoINTEL, STRUCT_CACHE_VkQueryPoolCreateInfoINTEL);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkQueryPoolCreateInfoINTEL, STRUCT_CACHE_VkQueryPoolCreateInfoINTEL);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkQueryPoolCreateInfoINTEL'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.performanceCountersSampling !== void 0) this.performanceCountersSampling = opts.performanceCountersSampling;
    
  }
};

Object.defineProperties(VkQueryPoolCreateInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolCreateInfoINTEL.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkQueryPoolCreateInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "performanceCountersSampling": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkQueryPoolCreateInfoINTEL.performanceCountersSampling");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkQueryPoolCreateInfoINTEL.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.performanceCountersSampling !== void 0) this.performanceCountersSampling = opts.performanceCountersSampling;
    
  }
};

VkQueryPoolCreateInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueryPoolCreateInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  };

VkQueryPoolCreateInfoINTEL.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkQueryPoolCreateInfoINTEL();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.performanceCountersSampling = original.performanceCountersSampling;
  
  return copy;
};

VkQueryPoolCreateInfoINTEL.byteLength = 0x0;

VkQueryPoolCreateInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  performanceCountersSampling: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPerformanceMarkerInfoINTEL **/
function VkPerformanceMarkerInfoINTEL(opts, byteOffset) {
  if (new.target !== VkPerformanceMarkerInfoINTEL) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPerformanceMarkerInfoINTEL, STRUCT_CACHE_VkPerformanceMarkerInfoINTEL);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPerformanceMarkerInfoINTEL, STRUCT_CACHE_VkPerformanceMarkerInfoINTEL);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPerformanceMarkerInfoINTEL'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.marker !== void 0) this.marker = opts.marker;
    
  }
};

Object.defineProperties(VkPerformanceMarkerInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceMarkerInfoINTEL.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceMarkerInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "marker": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkPerformanceMarkerInfoINTEL.marker")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkPerformanceMarkerInfoINTEL.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.marker !== void 0) this.marker = opts.marker;
    
  }
};

VkPerformanceMarkerInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceMarkerInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  };

VkPerformanceMarkerInfoINTEL.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPerformanceMarkerInfoINTEL();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.marker = original.marker;
  
  return copy;
};

VkPerformanceMarkerInfoINTEL.byteLength = 0x0;

VkPerformanceMarkerInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  marker: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPerformanceStreamMarkerInfoINTEL **/
function VkPerformanceStreamMarkerInfoINTEL(opts, byteOffset) {
  if (new.target !== VkPerformanceStreamMarkerInfoINTEL) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPerformanceStreamMarkerInfoINTEL, STRUCT_CACHE_VkPerformanceStreamMarkerInfoINTEL);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPerformanceStreamMarkerInfoINTEL, STRUCT_CACHE_VkPerformanceStreamMarkerInfoINTEL);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPerformanceStreamMarkerInfoINTEL'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.marker !== void 0) this.marker = opts.marker;
    
  }
};

Object.defineProperties(VkPerformanceStreamMarkerInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceStreamMarkerInfoINTEL.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceStreamMarkerInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "marker": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceStreamMarkerInfoINTEL.marker");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkPerformanceStreamMarkerInfoINTEL.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.marker !== void 0) this.marker = opts.marker;
    
  }
};

VkPerformanceStreamMarkerInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceStreamMarkerInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  };

VkPerformanceStreamMarkerInfoINTEL.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPerformanceStreamMarkerInfoINTEL();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.marker = original.marker;
  
  return copy;
};

VkPerformanceStreamMarkerInfoINTEL.byteLength = 0x0;

VkPerformanceStreamMarkerInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  marker: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPerformanceOverrideInfoINTEL **/
function VkPerformanceOverrideInfoINTEL(opts, byteOffset) {
  if (new.target !== VkPerformanceOverrideInfoINTEL) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPerformanceOverrideInfoINTEL, STRUCT_CACHE_VkPerformanceOverrideInfoINTEL);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPerformanceOverrideInfoINTEL, STRUCT_CACHE_VkPerformanceOverrideInfoINTEL);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPerformanceOverrideInfoINTEL'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.enable !== void 0) this.enable = opts.enable;
    if (opts.parameter !== void 0) this.parameter = opts.parameter;
    
  }
};

Object.defineProperties(VkPerformanceOverrideInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceOverrideInfoINTEL.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceOverrideInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceOverrideInfoINTEL.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "enable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "parameter": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkPerformanceOverrideInfoINTEL.parameter")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkPerformanceOverrideInfoINTEL.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.enable !== void 0) this.enable = opts.enable;
    if (opts.parameter !== void 0) this.parameter = opts.parameter;
    
  }
};

VkPerformanceOverrideInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceOverrideInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  };

VkPerformanceOverrideInfoINTEL.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPerformanceOverrideInfoINTEL();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.type = original.type;
  copy.enable = original.enable;
  copy.parameter = original.parameter;
  
  return copy;
};

VkPerformanceOverrideInfoINTEL.byteLength = 0x0;

VkPerformanceOverrideInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  enable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  parameter: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPerformanceConfigurationAcquireInfoINTEL **/
function VkPerformanceConfigurationAcquireInfoINTEL(opts, byteOffset) {
  if (new.target !== VkPerformanceConfigurationAcquireInfoINTEL) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPerformanceConfigurationAcquireInfoINTEL, STRUCT_CACHE_VkPerformanceConfigurationAcquireInfoINTEL);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPerformanceConfigurationAcquireInfoINTEL, STRUCT_CACHE_VkPerformanceConfigurationAcquireInfoINTEL);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPerformanceConfigurationAcquireInfoINTEL'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    
  }
};

Object.defineProperties(VkPerformanceConfigurationAcquireInfoINTEL.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceConfigurationAcquireInfoINTEL.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPerformanceConfigurationAcquireInfoINTEL.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPerformanceConfigurationAcquireInfoINTEL.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPerformanceConfigurationAcquireInfoINTEL.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    
  }
};

VkPerformanceConfigurationAcquireInfoINTEL.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPerformanceConfigurationAcquireInfoINTEL.prototype.reflect = function reflect(memoryAddress) {
  };

VkPerformanceConfigurationAcquireInfoINTEL.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPerformanceConfigurationAcquireInfoINTEL();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.type = original.type;
  
  return copy;
};

VkPerformanceConfigurationAcquireInfoINTEL.byteLength = 0x0;

VkPerformanceConfigurationAcquireInfoINTEL.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderClockFeaturesKHR **/
function VkPhysicalDeviceShaderClockFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderClockFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderClockFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceShaderClockFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderClockFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceShaderClockFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderClockFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderSubgroupClock !== void 0) this.shaderSubgroupClock = opts.shaderSubgroupClock;
    if (opts.shaderDeviceClock !== void 0) this.shaderDeviceClock = opts.shaderDeviceClock;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderClockFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderClockFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderClockFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "shaderSubgroupClock": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderDeviceClock": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderClockFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderSubgroupClock !== void 0) this.shaderSubgroupClock = opts.shaderSubgroupClock;
    if (opts.shaderDeviceClock !== void 0) this.shaderDeviceClock = opts.shaderDeviceClock;
    
  }
};

VkPhysicalDeviceShaderClockFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderClockFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderClockFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderClockFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderSubgroupClock = original.shaderSubgroupClock;
  copy.shaderDeviceClock = original.shaderDeviceClock;
  
  return copy;
};

VkPhysicalDeviceShaderClockFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceShaderClockFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSubgroupClock: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDeviceClock: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceIndexTypeUint8FeaturesEXT **/
function VkPhysicalDeviceIndexTypeUint8FeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceIndexTypeUint8FeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceIndexTypeUint8FeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceIndexTypeUint8FeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceIndexTypeUint8FeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceIndexTypeUint8FeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceIndexTypeUint8FeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.indexTypeUint8 !== void 0) this.indexTypeUint8 = opts.indexTypeUint8;
    
  }
};

Object.defineProperties(VkPhysicalDeviceIndexTypeUint8FeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceIndexTypeUint8FeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceIndexTypeUint8FeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "indexTypeUint8": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceIndexTypeUint8FeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.indexTypeUint8 !== void 0) this.indexTypeUint8 = opts.indexTypeUint8;
    
  }
};

VkPhysicalDeviceIndexTypeUint8FeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceIndexTypeUint8FeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceIndexTypeUint8FeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceIndexTypeUint8FeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.indexTypeUint8 = original.indexTypeUint8;
  
  return copy;
};

VkPhysicalDeviceIndexTypeUint8FeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceIndexTypeUint8FeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indexTypeUint8: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderSMBuiltinsPropertiesNV **/
function VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderSMBuiltinsPropertiesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderSMBuiltinsPropertiesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "shaderSMCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "shaderWarpsPerSM": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderSMBuiltinsPropertiesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderSMCount = original.shaderSMCount;
  copy.shaderWarpsPerSM = original.shaderWarpsPerSM;
  
  return copy;
};

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.byteLength = 0x0;

VkPhysicalDeviceShaderSMBuiltinsPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSMCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderWarpsPerSM: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderSMBuiltinsFeaturesNV **/
function VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderSMBuiltinsFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderSMBuiltinsFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderSMBuiltins !== void 0) this.shaderSMBuiltins = opts.shaderSMBuiltins;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "shaderSMBuiltins": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderSMBuiltins !== void 0) this.shaderSMBuiltins = opts.shaderSMBuiltins;
    
  }
};

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderSMBuiltinsFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderSMBuiltins = original.shaderSMBuiltins;
  
  return copy;
};

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSMBuiltins: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT **/
function VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentShaderSampleInterlock !== void 0) this.fragmentShaderSampleInterlock = opts.fragmentShaderSampleInterlock;
    if (opts.fragmentShaderPixelInterlock !== void 0) this.fragmentShaderPixelInterlock = opts.fragmentShaderPixelInterlock;
    if (opts.fragmentShaderShadingRateInterlock !== void 0) this.fragmentShaderShadingRateInterlock = opts.fragmentShaderShadingRateInterlock;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "fragmentShaderSampleInterlock": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "fragmentShaderPixelInterlock": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "fragmentShaderShadingRateInterlock": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentShaderSampleInterlock !== void 0) this.fragmentShaderSampleInterlock = opts.fragmentShaderSampleInterlock;
    if (opts.fragmentShaderPixelInterlock !== void 0) this.fragmentShaderPixelInterlock = opts.fragmentShaderPixelInterlock;
    if (opts.fragmentShaderShadingRateInterlock !== void 0) this.fragmentShaderShadingRateInterlock = opts.fragmentShaderShadingRateInterlock;
    
  }
};

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.fragmentShaderSampleInterlock = original.fragmentShaderSampleInterlock;
  copy.fragmentShaderPixelInterlock = original.fragmentShaderPixelInterlock;
  copy.fragmentShaderShadingRateInterlock = original.fragmentShaderShadingRateInterlock;
  
  return copy;
};

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShaderSampleInterlock: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShaderPixelInterlock: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShaderShadingRateInterlock: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures **/
function VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, STRUCT_CACHE_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, STRUCT_CACHE_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.separateDepthStencilLayouts !== void 0) this.separateDepthStencilLayouts = opts.separateDepthStencilLayouts;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.pNext' isn't allowed to be filled");
    }
    },
  "separateDepthStencilLayouts": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.separateDepthStencilLayouts !== void 0) this.separateDepthStencilLayouts = opts.separateDepthStencilLayouts;
    
  }
};

VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.separateDepthStencilLayouts = original.separateDepthStencilLayouts;
  
  return copy;
};

VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.byteLength = 0x0;

VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  separateDepthStencilLayouts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR **/
function VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.separateDepthStencilLayouts !== void 0) this.separateDepthStencilLayouts = opts.separateDepthStencilLayouts;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "separateDepthStencilLayouts": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.separateDepthStencilLayouts !== void 0) this.separateDepthStencilLayouts = opts.separateDepthStencilLayouts;
    
  }
};

VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.separateDepthStencilLayouts = original.separateDepthStencilLayouts;
  
  return copy;
};

VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  separateDepthStencilLayouts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentReferenceStencilLayout **/
function VkAttachmentReferenceStencilLayout(opts, byteOffset) {
  if (new.target !== VkAttachmentReferenceStencilLayout) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentReferenceStencilLayout, STRUCT_CACHE_VkAttachmentReferenceStencilLayout);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentReferenceStencilLayout, STRUCT_CACHE_VkAttachmentReferenceStencilLayout);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentReferenceStencilLayout'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilLayout !== void 0) this.stencilLayout = opts.stencilLayout;
    
  }
};

Object.defineProperties(VkAttachmentReferenceStencilLayout.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReferenceStencilLayout.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAttachmentReferenceStencilLayout.pNext' isn't allowed to be filled");
    }
    },
  "stencilLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReferenceStencilLayout.stencilLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAttachmentReferenceStencilLayout.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilLayout !== void 0) this.stencilLayout = opts.stencilLayout;
    
  }
};

VkAttachmentReferenceStencilLayout.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentReferenceStencilLayout.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentReferenceStencilLayout.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentReferenceStencilLayout();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.stencilLayout = original.stencilLayout;
  
  return copy;
};

VkAttachmentReferenceStencilLayout.byteLength = 0x0;

VkAttachmentReferenceStencilLayout.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentReferenceStencilLayoutKHR **/
function VkAttachmentReferenceStencilLayoutKHR(opts, byteOffset) {
  if (new.target !== VkAttachmentReferenceStencilLayoutKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentReferenceStencilLayoutKHR, STRUCT_CACHE_VkAttachmentReferenceStencilLayoutKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentReferenceStencilLayoutKHR, STRUCT_CACHE_VkAttachmentReferenceStencilLayoutKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentReferenceStencilLayoutKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilLayout !== void 0) this.stencilLayout = opts.stencilLayout;
    
  }
};

Object.defineProperties(VkAttachmentReferenceStencilLayoutKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReferenceStencilLayoutKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAttachmentReferenceStencilLayoutKHR.pNext' isn't allowed to be filled");
    }
    },
  "stencilLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentReferenceStencilLayoutKHR.stencilLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAttachmentReferenceStencilLayoutKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilLayout !== void 0) this.stencilLayout = opts.stencilLayout;
    
  }
};

VkAttachmentReferenceStencilLayoutKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentReferenceStencilLayoutKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentReferenceStencilLayoutKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentReferenceStencilLayoutKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.stencilLayout = original.stencilLayout;
  
  return copy;
};

VkAttachmentReferenceStencilLayoutKHR.byteLength = 0x0;

VkAttachmentReferenceStencilLayoutKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentDescriptionStencilLayout **/
function VkAttachmentDescriptionStencilLayout(opts, byteOffset) {
  if (new.target !== VkAttachmentDescriptionStencilLayout) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentDescriptionStencilLayout, STRUCT_CACHE_VkAttachmentDescriptionStencilLayout);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentDescriptionStencilLayout, STRUCT_CACHE_VkAttachmentDescriptionStencilLayout);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentDescriptionStencilLayout'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilInitialLayout !== void 0) this.stencilInitialLayout = opts.stencilInitialLayout;
    if (opts.stencilFinalLayout !== void 0) this.stencilFinalLayout = opts.stencilFinalLayout;
    
  }
};

Object.defineProperties(VkAttachmentDescriptionStencilLayout.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescriptionStencilLayout.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAttachmentDescriptionStencilLayout.pNext' isn't allowed to be filled");
    }
    },
  "stencilInitialLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescriptionStencilLayout.stencilInitialLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stencilFinalLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescriptionStencilLayout.stencilFinalLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAttachmentDescriptionStencilLayout.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilInitialLayout !== void 0) this.stencilInitialLayout = opts.stencilInitialLayout;
    if (opts.stencilFinalLayout !== void 0) this.stencilFinalLayout = opts.stencilFinalLayout;
    
  }
};

VkAttachmentDescriptionStencilLayout.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentDescriptionStencilLayout.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentDescriptionStencilLayout.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentDescriptionStencilLayout();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.stencilInitialLayout = original.stencilInitialLayout;
  copy.stencilFinalLayout = original.stencilFinalLayout;
  
  return copy;
};

VkAttachmentDescriptionStencilLayout.byteLength = 0x0;

VkAttachmentDescriptionStencilLayout.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilInitialLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilFinalLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAttachmentDescriptionStencilLayoutKHR **/
function VkAttachmentDescriptionStencilLayoutKHR(opts, byteOffset) {
  if (new.target !== VkAttachmentDescriptionStencilLayoutKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAttachmentDescriptionStencilLayoutKHR, STRUCT_CACHE_VkAttachmentDescriptionStencilLayoutKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAttachmentDescriptionStencilLayoutKHR, STRUCT_CACHE_VkAttachmentDescriptionStencilLayoutKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAttachmentDescriptionStencilLayoutKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilInitialLayout !== void 0) this.stencilInitialLayout = opts.stencilInitialLayout;
    if (opts.stencilFinalLayout !== void 0) this.stencilFinalLayout = opts.stencilFinalLayout;
    
  }
};

Object.defineProperties(VkAttachmentDescriptionStencilLayoutKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescriptionStencilLayoutKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAttachmentDescriptionStencilLayoutKHR.pNext' isn't allowed to be filled");
    }
    },
  "stencilInitialLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescriptionStencilLayoutKHR.stencilInitialLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stencilFinalLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAttachmentDescriptionStencilLayoutKHR.stencilFinalLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAttachmentDescriptionStencilLayoutKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.stencilInitialLayout !== void 0) this.stencilInitialLayout = opts.stencilInitialLayout;
    if (opts.stencilFinalLayout !== void 0) this.stencilFinalLayout = opts.stencilFinalLayout;
    
  }
};

VkAttachmentDescriptionStencilLayoutKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentDescriptionStencilLayoutKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAttachmentDescriptionStencilLayoutKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAttachmentDescriptionStencilLayoutKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.stencilInitialLayout = original.stencilInitialLayout;
  copy.stencilFinalLayout = original.stencilFinalLayout;
  
  return copy;
};

VkAttachmentDescriptionStencilLayoutKHR.byteLength = 0x0;

VkAttachmentDescriptionStencilLayoutKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilInitialLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stencilFinalLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR **/
function VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, STRUCT_CACHE_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, STRUCT_CACHE_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineExecutableInfo !== void 0) this.pipelineExecutableInfo = opts.pipelineExecutableInfo;
    
  }
};

Object.defineProperties(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "pipelineExecutableInfo": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineExecutableInfo !== void 0) this.pipelineExecutableInfo = opts.pipelineExecutableInfo;
    
  }
};

VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pipelineExecutableInfo = original.pipelineExecutableInfo;
  
  return copy;
};

VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.byteLength = 0x0;

VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineExecutableInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineInfoKHR **/
function VkPipelineInfoKHR(opts, byteOffset) {
  if (new.target !== VkPipelineInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineInfoKHR, STRUCT_CACHE_VkPipelineInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineInfoKHR, STRUCT_CACHE_VkPipelineInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._pipeline = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipeline !== void 0) this.pipeline = opts.pipeline;
    
  }
};

Object.defineProperties(VkPipelineInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "pipeline": {
    get() {
    return this._pipeline;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._pipeline = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._pipeline = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineInfoKHR.pipeline': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._pipeline = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipeline !== void 0) this.pipeline = opts.pipeline;
    
  }
};

VkPipelineInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.pipeline !== null) {
        copy.pipeline = original.pipeline.constructor.createCopyFrom(original.pipeline);
      }
  
  return copy;
};

VkPipelineInfoKHR.byteLength = 0x0;

VkPipelineInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipeline: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineExecutablePropertiesKHR **/
function VkPipelineExecutablePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPipelineExecutablePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineExecutablePropertiesKHR, STRUCT_CACHE_VkPipelineExecutablePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineExecutablePropertiesKHR, STRUCT_CACHE_VkPipelineExecutablePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineExecutablePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPipelineExecutablePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineExecutablePropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineExecutablePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "stages": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "name": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "description": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "subgroupSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPipelineExecutablePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPipelineExecutablePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineExecutablePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPipelineExecutablePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineExecutablePropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.stages = original.stages;
  copy.name = original.name;
  copy.description = original.description;
  copy.subgroupSize = original.subgroupSize;
  
  return copy;
};

VkPipelineExecutablePropertiesKHR.byteLength = 0x0;

VkPipelineExecutablePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  description: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subgroupSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineExecutableInfoKHR **/
function VkPipelineExecutableInfoKHR(opts, byteOffset) {
  if (new.target !== VkPipelineExecutableInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineExecutableInfoKHR, STRUCT_CACHE_VkPipelineExecutableInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineExecutableInfoKHR, STRUCT_CACHE_VkPipelineExecutableInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineExecutableInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._pipeline = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipeline !== void 0) this.pipeline = opts.pipeline;
    if (opts.executableIndex !== void 0) this.executableIndex = opts.executableIndex;
    
  }
};

Object.defineProperties(VkPipelineExecutableInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineExecutableInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineExecutableInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "pipeline": {
    get() {
    return this._pipeline;
    },
    set(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._pipeline = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._pipeline = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineExecutableInfoKHR.pipeline': Expected 'VkPipeline' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "executableIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineExecutableInfoKHR.executableIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkPipelineExecutableInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._pipeline = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipeline !== void 0) this.pipeline = opts.pipeline;
    if (opts.executableIndex !== void 0) this.executableIndex = opts.executableIndex;
    
  }
};

VkPipelineExecutableInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineExecutableInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineExecutableInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineExecutableInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.pipeline !== null) {
        copy.pipeline = original.pipeline.constructor.createCopyFrom(original.pipeline);
      }
  copy.executableIndex = original.executableIndex;
  
  return copy;
};

VkPipelineExecutableInfoKHR.byteLength = 0x0;

VkPipelineExecutableInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipeline: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  executableIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineExecutableStatisticKHR **/
function VkPipelineExecutableStatisticKHR(opts, byteOffset) {
  if (new.target !== VkPipelineExecutableStatisticKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineExecutableStatisticKHR, STRUCT_CACHE_VkPipelineExecutableStatisticKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineExecutableStatisticKHR, STRUCT_CACHE_VkPipelineExecutableStatisticKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineExecutableStatisticKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._value = new VkPipelineExecutableStatisticValueKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPipelineExecutableStatisticKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineExecutableStatisticKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineExecutableStatisticKHR.pNext' isn't allowed to be filled");
    }
    },
  "name": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "description": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "value": {
    get() {
    return this._value;
    },
    },
  
});

VkPipelineExecutableStatisticKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  if (this._value !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._value.memoryBuffer) this._value = new VkPipelineExecutableStatisticValueKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._value.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPipelineExecutableStatisticKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineExecutableStatisticKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPipelineExecutableStatisticKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineExecutableStatisticKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.name = original.name;
  copy.description = original.description;
  copy.format = original.format;
  if (original.value !== null) {
        copy.value = original.value.constructor.createCopyFrom(original.value);
      }
  
  return copy;
};

VkPipelineExecutableStatisticKHR.byteLength = 0x0;

VkPipelineExecutableStatisticKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  description: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  value: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineExecutableInternalRepresentationKHR **/
function VkPipelineExecutableInternalRepresentationKHR(opts, byteOffset) {
  if (new.target !== VkPipelineExecutableInternalRepresentationKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineExecutableInternalRepresentationKHR, STRUCT_CACHE_VkPipelineExecutableInternalRepresentationKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineExecutableInternalRepresentationKHR, STRUCT_CACHE_VkPipelineExecutableInternalRepresentationKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineExecutableInternalRepresentationKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this._pData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pData !== void 0) this.pData = opts.pData;
    
  }
};

Object.defineProperties(VkPipelineExecutableInternalRepresentationKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineExecutableInternalRepresentationKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineExecutableInternalRepresentationKHR.pNext' isn't allowed to be filled");
    }
    },
  "name": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "description": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "isText": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "dataSize": {
    get() {
    return this.memoryView.getBigInt64(0x0, true);
    },
    },
  "pData": {
    get() {
    return this._pData;
    },
    set(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value), true);
    } else if (value === null) {
      this._pData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkPipelineExecutableInternalRepresentationKHR.pData': Expected 'ArrayBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkPipelineExecutableInternalRepresentationKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this._pData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pData !== void 0) this.pData = opts.pData;
    
  }
};

VkPipelineExecutableInternalRepresentationKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineExecutableInternalRepresentationKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPipelineExecutableInternalRepresentationKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineExecutableInternalRepresentationKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.name = original.name;
  copy.description = original.description;
  copy.isText = original.isText;
  copy.dataSize = original.dataSize;
  if (original.pData !== null) {
      let buf = new ArrayBuffer(original.pData.byteLength);
      new Uint8Array(buf).set(new Uint8Array(original.pData), 0x0);
      copy.pData = buf;
    }
  
  return copy;
};

VkPipelineExecutableInternalRepresentationKHR.byteLength = 0x0;

VkPipelineExecutableInternalRepresentationKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  description: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  isText: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dataSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT **/
function VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderDemoteToHelperInvocation !== void 0) this.shaderDemoteToHelperInvocation = opts.shaderDemoteToHelperInvocation;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "shaderDemoteToHelperInvocation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderDemoteToHelperInvocation !== void 0) this.shaderDemoteToHelperInvocation = opts.shaderDemoteToHelperInvocation;
    
  }
};

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderDemoteToHelperInvocation = original.shaderDemoteToHelperInvocation;
  
  return copy;
};

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDemoteToHelperInvocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT **/
function VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.texelBufferAlignment !== void 0) this.texelBufferAlignment = opts.texelBufferAlignment;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "texelBufferAlignment": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.texelBufferAlignment !== void 0) this.texelBufferAlignment = opts.texelBufferAlignment;
    
  }
};

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.texelBufferAlignment = original.texelBufferAlignment;
  
  return copy;
};

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  texelBufferAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT **/
function VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "storageTexelBufferOffsetAlignmentBytes": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "storageTexelBufferOffsetSingleTexelAlignment": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "uniformTexelBufferOffsetAlignmentBytes": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "uniformTexelBufferOffsetSingleTexelAlignment": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.storageTexelBufferOffsetAlignmentBytes = original.storageTexelBufferOffsetAlignmentBytes;
  copy.storageTexelBufferOffsetSingleTexelAlignment = original.storageTexelBufferOffsetSingleTexelAlignment;
  copy.uniformTexelBufferOffsetAlignmentBytes = original.uniformTexelBufferOffsetAlignmentBytes;
  copy.uniformTexelBufferOffsetSingleTexelAlignment = original.uniformTexelBufferOffsetSingleTexelAlignment;
  
  return copy;
};

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageTexelBufferOffsetAlignmentBytes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageTexelBufferOffsetSingleTexelAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformTexelBufferOffsetAlignmentBytes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformTexelBufferOffsetSingleTexelAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSubgroupSizeControlFeaturesEXT **/
function VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSubgroupSizeControlFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSubgroupSizeControlFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSubgroupSizeControlFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.subgroupSizeControl !== void 0) this.subgroupSizeControl = opts.subgroupSizeControl;
    if (opts.computeFullSubgroups !== void 0) this.computeFullSubgroups = opts.computeFullSubgroups;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "subgroupSizeControl": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "computeFullSubgroups": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.subgroupSizeControl !== void 0) this.subgroupSizeControl = opts.subgroupSizeControl;
    if (opts.computeFullSubgroups !== void 0) this.computeFullSubgroups = opts.computeFullSubgroups;
    
  }
};

VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSubgroupSizeControlFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.subgroupSizeControl = original.subgroupSizeControl;
  copy.computeFullSubgroups = original.computeFullSubgroups;
  
  return copy;
};

VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subgroupSizeControl: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  computeFullSubgroups: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceSubgroupSizeControlPropertiesEXT **/
function VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceSubgroupSizeControlPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceSubgroupSizeControlPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceSubgroupSizeControlPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "minSubgroupSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxSubgroupSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxComputeWorkgroupSubgroups": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "requiredSubgroupSizeStages": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceSubgroupSizeControlPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.minSubgroupSize = original.minSubgroupSize;
  copy.maxSubgroupSize = original.maxSubgroupSize;
  copy.maxComputeWorkgroupSubgroups = original.maxComputeWorkgroupSubgroups;
  copy.requiredSubgroupSizeStages = original.requiredSubgroupSizeStages;
  
  return copy;
};

VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceSubgroupSizeControlPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minSubgroupSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxSubgroupSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxComputeWorkgroupSubgroups: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  requiredSubgroupSizeStages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT **/
function VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, STRUCT_CACHE_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT, STRUCT_CACHE_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "requiredSubgroupSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.requiredSubgroupSize = original.requiredSubgroupSize;
  
  return copy;
};

VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.byteLength = 0x0;

VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  requiredSubgroupSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryOpaqueCaptureAddressAllocateInfo **/
function VkMemoryOpaqueCaptureAddressAllocateInfo(opts, byteOffset) {
  if (new.target !== VkMemoryOpaqueCaptureAddressAllocateInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryOpaqueCaptureAddressAllocateInfo, STRUCT_CACHE_VkMemoryOpaqueCaptureAddressAllocateInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryOpaqueCaptureAddressAllocateInfo, STRUCT_CACHE_VkMemoryOpaqueCaptureAddressAllocateInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryOpaqueCaptureAddressAllocateInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.opaqueCaptureAddress !== void 0) this.opaqueCaptureAddress = opts.opaqueCaptureAddress;
    
  }
};

Object.defineProperties(VkMemoryOpaqueCaptureAddressAllocateInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryOpaqueCaptureAddressAllocateInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryOpaqueCaptureAddressAllocateInfo.pNext' isn't allowed to be filled");
    }
    },
  "opaqueCaptureAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkMemoryOpaqueCaptureAddressAllocateInfo.opaqueCaptureAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkMemoryOpaqueCaptureAddressAllocateInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.opaqueCaptureAddress !== void 0) this.opaqueCaptureAddress = opts.opaqueCaptureAddress;
    
  }
};

VkMemoryOpaqueCaptureAddressAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryOpaqueCaptureAddressAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryOpaqueCaptureAddressAllocateInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryOpaqueCaptureAddressAllocateInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.opaqueCaptureAddress = original.opaqueCaptureAddress;
  
  return copy;
};

VkMemoryOpaqueCaptureAddressAllocateInfo.byteLength = 0x0;

VkMemoryOpaqueCaptureAddressAllocateInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  opaqueCaptureAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkMemoryOpaqueCaptureAddressAllocateInfoKHR **/
function VkMemoryOpaqueCaptureAddressAllocateInfoKHR(opts, byteOffset) {
  if (new.target !== VkMemoryOpaqueCaptureAddressAllocateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkMemoryOpaqueCaptureAddressAllocateInfoKHR, STRUCT_CACHE_VkMemoryOpaqueCaptureAddressAllocateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkMemoryOpaqueCaptureAddressAllocateInfoKHR, STRUCT_CACHE_VkMemoryOpaqueCaptureAddressAllocateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkMemoryOpaqueCaptureAddressAllocateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.opaqueCaptureAddress !== void 0) this.opaqueCaptureAddress = opts.opaqueCaptureAddress;
    
  }
};

Object.defineProperties(VkMemoryOpaqueCaptureAddressAllocateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkMemoryOpaqueCaptureAddressAllocateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkMemoryOpaqueCaptureAddressAllocateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "opaqueCaptureAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkMemoryOpaqueCaptureAddressAllocateInfoKHR.opaqueCaptureAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkMemoryOpaqueCaptureAddressAllocateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.opaqueCaptureAddress !== void 0) this.opaqueCaptureAddress = opts.opaqueCaptureAddress;
    
  }
};

VkMemoryOpaqueCaptureAddressAllocateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryOpaqueCaptureAddressAllocateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkMemoryOpaqueCaptureAddressAllocateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkMemoryOpaqueCaptureAddressAllocateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.opaqueCaptureAddress = original.opaqueCaptureAddress;
  
  return copy;
};

VkMemoryOpaqueCaptureAddressAllocateInfoKHR.byteLength = 0x0;

VkMemoryOpaqueCaptureAddressAllocateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  opaqueCaptureAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceMemoryOpaqueCaptureAddressInfo **/
function VkDeviceMemoryOpaqueCaptureAddressInfo(opts, byteOffset) {
  if (new.target !== VkDeviceMemoryOpaqueCaptureAddressInfo) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceMemoryOpaqueCaptureAddressInfo, STRUCT_CACHE_VkDeviceMemoryOpaqueCaptureAddressInfo);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceMemoryOpaqueCaptureAddressInfo, STRUCT_CACHE_VkDeviceMemoryOpaqueCaptureAddressInfo);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceMemoryOpaqueCaptureAddressInfo'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memory = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    
  }
};

Object.defineProperties(VkDeviceMemoryOpaqueCaptureAddressInfo.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceMemoryOpaqueCaptureAddressInfo.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceMemoryOpaqueCaptureAddressInfo.pNext' isn't allowed to be filled");
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceMemoryOpaqueCaptureAddressInfo.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceMemoryOpaqueCaptureAddressInfo.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._memory = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    
  }
};

VkDeviceMemoryOpaqueCaptureAddressInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceMemoryOpaqueCaptureAddressInfo.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceMemoryOpaqueCaptureAddressInfo.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceMemoryOpaqueCaptureAddressInfo();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  
  return copy;
};

VkDeviceMemoryOpaqueCaptureAddressInfo.byteLength = 0x0;

VkDeviceMemoryOpaqueCaptureAddressInfo.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceMemoryOpaqueCaptureAddressInfoKHR **/
function VkDeviceMemoryOpaqueCaptureAddressInfoKHR(opts, byteOffset) {
  if (new.target !== VkDeviceMemoryOpaqueCaptureAddressInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceMemoryOpaqueCaptureAddressInfoKHR, STRUCT_CACHE_VkDeviceMemoryOpaqueCaptureAddressInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceMemoryOpaqueCaptureAddressInfoKHR, STRUCT_CACHE_VkDeviceMemoryOpaqueCaptureAddressInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceMemoryOpaqueCaptureAddressInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._memory = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    
  }
};

Object.defineProperties(VkDeviceMemoryOpaqueCaptureAddressInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceMemoryOpaqueCaptureAddressInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceMemoryOpaqueCaptureAddressInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "memory": {
    get() {
    return this._memory;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._memory = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkDeviceMemoryOpaqueCaptureAddressInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkDeviceMemoryOpaqueCaptureAddressInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._memory = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.memory !== void 0) this.memory = opts.memory;
    
  }
};

VkDeviceMemoryOpaqueCaptureAddressInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceMemoryOpaqueCaptureAddressInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceMemoryOpaqueCaptureAddressInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceMemoryOpaqueCaptureAddressInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.memory !== null) {
        copy.memory = original.memory.constructor.createCopyFrom(original.memory);
      }
  
  return copy;
};

VkDeviceMemoryOpaqueCaptureAddressInfoKHR.byteLength = 0x0;

VkDeviceMemoryOpaqueCaptureAddressInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  memory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceLineRasterizationFeaturesEXT **/
function VkPhysicalDeviceLineRasterizationFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceLineRasterizationFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceLineRasterizationFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceLineRasterizationFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceLineRasterizationFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceLineRasterizationFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceLineRasterizationFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.rectangularLines !== void 0) this.rectangularLines = opts.rectangularLines;
    if (opts.bresenhamLines !== void 0) this.bresenhamLines = opts.bresenhamLines;
    if (opts.smoothLines !== void 0) this.smoothLines = opts.smoothLines;
    if (opts.stippledRectangularLines !== void 0) this.stippledRectangularLines = opts.stippledRectangularLines;
    if (opts.stippledBresenhamLines !== void 0) this.stippledBresenhamLines = opts.stippledBresenhamLines;
    if (opts.stippledSmoothLines !== void 0) this.stippledSmoothLines = opts.stippledSmoothLines;
    
  }
};

Object.defineProperties(VkPhysicalDeviceLineRasterizationFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceLineRasterizationFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceLineRasterizationFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "rectangularLines": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bresenhamLines": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "smoothLines": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "stippledRectangularLines": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "stippledBresenhamLines": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "stippledSmoothLines": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceLineRasterizationFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.rectangularLines !== void 0) this.rectangularLines = opts.rectangularLines;
    if (opts.bresenhamLines !== void 0) this.bresenhamLines = opts.bresenhamLines;
    if (opts.smoothLines !== void 0) this.smoothLines = opts.smoothLines;
    if (opts.stippledRectangularLines !== void 0) this.stippledRectangularLines = opts.stippledRectangularLines;
    if (opts.stippledBresenhamLines !== void 0) this.stippledBresenhamLines = opts.stippledBresenhamLines;
    if (opts.stippledSmoothLines !== void 0) this.stippledSmoothLines = opts.stippledSmoothLines;
    
  }
};

VkPhysicalDeviceLineRasterizationFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceLineRasterizationFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceLineRasterizationFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceLineRasterizationFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.rectangularLines = original.rectangularLines;
  copy.bresenhamLines = original.bresenhamLines;
  copy.smoothLines = original.smoothLines;
  copy.stippledRectangularLines = original.stippledRectangularLines;
  copy.stippledBresenhamLines = original.stippledBresenhamLines;
  copy.stippledSmoothLines = original.stippledSmoothLines;
  
  return copy;
};

VkPhysicalDeviceLineRasterizationFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceLineRasterizationFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  rectangularLines: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bresenhamLines: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  smoothLines: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stippledRectangularLines: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stippledBresenhamLines: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stippledSmoothLines: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceLineRasterizationPropertiesEXT **/
function VkPhysicalDeviceLineRasterizationPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceLineRasterizationPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceLineRasterizationPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceLineRasterizationPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceLineRasterizationPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceLineRasterizationPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceLineRasterizationPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceLineRasterizationPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceLineRasterizationPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceLineRasterizationPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "lineSubPixelPrecisionBits": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceLineRasterizationPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceLineRasterizationPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceLineRasterizationPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceLineRasterizationPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceLineRasterizationPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.lineSubPixelPrecisionBits = original.lineSubPixelPrecisionBits;
  
  return copy;
};

VkPhysicalDeviceLineRasterizationPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceLineRasterizationPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  lineSubPixelPrecisionBits: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineRasterizationLineStateCreateInfoEXT **/
function VkPipelineRasterizationLineStateCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkPipelineRasterizationLineStateCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineRasterizationLineStateCreateInfoEXT, STRUCT_CACHE_VkPipelineRasterizationLineStateCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineRasterizationLineStateCreateInfoEXT, STRUCT_CACHE_VkPipelineRasterizationLineStateCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineRasterizationLineStateCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.lineRasterizationMode !== void 0) this.lineRasterizationMode = opts.lineRasterizationMode;
    if (opts.stippledLineEnable !== void 0) this.stippledLineEnable = opts.stippledLineEnable;
    if (opts.lineStippleFactor !== void 0) this.lineStippleFactor = opts.lineStippleFactor;
    if (opts.lineStipplePattern !== void 0) this.lineStipplePattern = opts.lineStipplePattern;
    
  }
};

Object.defineProperties(VkPipelineRasterizationLineStateCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationLineStateCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineRasterizationLineStateCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "lineRasterizationMode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationLineStateCreateInfoEXT.lineRasterizationMode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "stippledLineEnable": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "lineStippleFactor": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationLineStateCreateInfoEXT.lineStippleFactor");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "lineStipplePattern": {
    get() {
    return this.memoryView.getUint16(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineRasterizationLineStateCreateInfoEXT.lineStipplePattern");
    this.memoryView.setUint16(0x0, value, true);
    }
    },
  
});

VkPipelineRasterizationLineStateCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.lineRasterizationMode !== void 0) this.lineRasterizationMode = opts.lineRasterizationMode;
    if (opts.stippledLineEnable !== void 0) this.stippledLineEnable = opts.stippledLineEnable;
    if (opts.lineStippleFactor !== void 0) this.lineStippleFactor = opts.lineStippleFactor;
    if (opts.lineStipplePattern !== void 0) this.lineStipplePattern = opts.lineStipplePattern;
    
  }
};

VkPipelineRasterizationLineStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationLineStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineRasterizationLineStateCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineRasterizationLineStateCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.lineRasterizationMode = original.lineRasterizationMode;
  copy.stippledLineEnable = original.stippledLineEnable;
  copy.lineStippleFactor = original.lineStippleFactor;
  copy.lineStipplePattern = original.lineStipplePattern;
  
  return copy;
};

VkPipelineRasterizationLineStateCreateInfoEXT.byteLength = 0x0;

VkPipelineRasterizationLineStateCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  lineRasterizationMode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stippledLineEnable: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  lineStippleFactor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  lineStipplePattern: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT **/
function VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT, STRUCT_CACHE_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT, STRUCT_CACHE_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineCreationCacheControl !== void 0) this.pipelineCreationCacheControl = opts.pipelineCreationCacheControl;
    
  }
};

Object.defineProperties(VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "pipelineCreationCacheControl": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineCreationCacheControl !== void 0) this.pipelineCreationCacheControl = opts.pipelineCreationCacheControl;
    
  }
};

VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pipelineCreationCacheControl = original.pipelineCreationCacheControl;
  
  return copy;
};

VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.byteLength = 0x0;

VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineCreationCacheControl: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVulkan11Features **/
function VkPhysicalDeviceVulkan11Features(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVulkan11Features) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVulkan11Features, STRUCT_CACHE_VkPhysicalDeviceVulkan11Features);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVulkan11Features, STRUCT_CACHE_VkPhysicalDeviceVulkan11Features);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVulkan11Features'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer16BitAccess !== void 0) this.storageBuffer16BitAccess = opts.storageBuffer16BitAccess;
    if (opts.uniformAndStorageBuffer16BitAccess !== void 0) this.uniformAndStorageBuffer16BitAccess = opts.uniformAndStorageBuffer16BitAccess;
    if (opts.storagePushConstant16 !== void 0) this.storagePushConstant16 = opts.storagePushConstant16;
    if (opts.storageInputOutput16 !== void 0) this.storageInputOutput16 = opts.storageInputOutput16;
    if (opts.multiview !== void 0) this.multiview = opts.multiview;
    if (opts.multiviewGeometryShader !== void 0) this.multiviewGeometryShader = opts.multiviewGeometryShader;
    if (opts.multiviewTessellationShader !== void 0) this.multiviewTessellationShader = opts.multiviewTessellationShader;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    if (opts.protectedMemory !== void 0) this.protectedMemory = opts.protectedMemory;
    if (opts.samplerYcbcrConversion !== void 0) this.samplerYcbcrConversion = opts.samplerYcbcrConversion;
    if (opts.shaderDrawParameters !== void 0) this.shaderDrawParameters = opts.shaderDrawParameters;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVulkan11Features.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVulkan11Features.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVulkan11Features.pNext' isn't allowed to be filled");
    }
    },
  "storageBuffer16BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "uniformAndStorageBuffer16BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "storagePushConstant16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "storageInputOutput16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "multiview": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "multiviewGeometryShader": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "multiviewTessellationShader": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "variablePointersStorageBuffer": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "variablePointers": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "protectedMemory": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "samplerYcbcrConversion": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderDrawParameters": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceVulkan11Features.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.storageBuffer16BitAccess !== void 0) this.storageBuffer16BitAccess = opts.storageBuffer16BitAccess;
    if (opts.uniformAndStorageBuffer16BitAccess !== void 0) this.uniformAndStorageBuffer16BitAccess = opts.uniformAndStorageBuffer16BitAccess;
    if (opts.storagePushConstant16 !== void 0) this.storagePushConstant16 = opts.storagePushConstant16;
    if (opts.storageInputOutput16 !== void 0) this.storageInputOutput16 = opts.storageInputOutput16;
    if (opts.multiview !== void 0) this.multiview = opts.multiview;
    if (opts.multiviewGeometryShader !== void 0) this.multiviewGeometryShader = opts.multiviewGeometryShader;
    if (opts.multiviewTessellationShader !== void 0) this.multiviewTessellationShader = opts.multiviewTessellationShader;
    if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
    if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
    if (opts.protectedMemory !== void 0) this.protectedMemory = opts.protectedMemory;
    if (opts.samplerYcbcrConversion !== void 0) this.samplerYcbcrConversion = opts.samplerYcbcrConversion;
    if (opts.shaderDrawParameters !== void 0) this.shaderDrawParameters = opts.shaderDrawParameters;
    
  }
};

VkPhysicalDeviceVulkan11Features.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVulkan11Features.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceVulkan11Features.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVulkan11Features();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.storageBuffer16BitAccess = original.storageBuffer16BitAccess;
  copy.uniformAndStorageBuffer16BitAccess = original.uniformAndStorageBuffer16BitAccess;
  copy.storagePushConstant16 = original.storagePushConstant16;
  copy.storageInputOutput16 = original.storageInputOutput16;
  copy.multiview = original.multiview;
  copy.multiviewGeometryShader = original.multiviewGeometryShader;
  copy.multiviewTessellationShader = original.multiviewTessellationShader;
  copy.variablePointersStorageBuffer = original.variablePointersStorageBuffer;
  copy.variablePointers = original.variablePointers;
  copy.protectedMemory = original.protectedMemory;
  copy.samplerYcbcrConversion = original.samplerYcbcrConversion;
  copy.shaderDrawParameters = original.shaderDrawParameters;
  
  return copy;
};

VkPhysicalDeviceVulkan11Features.byteLength = 0x0;

VkPhysicalDeviceVulkan11Features.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageBuffer16BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformAndStorageBuffer16BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storagePushConstant16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageInputOutput16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiview: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiviewGeometryShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  multiviewTessellationShader: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variablePointersStorageBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  variablePointers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  protectedMemory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samplerYcbcrConversion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDrawParameters: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVulkan11Properties **/
function VkPhysicalDeviceVulkan11Properties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVulkan11Properties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVulkan11Properties, STRUCT_CACHE_VkPhysicalDeviceVulkan11Properties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVulkan11Properties, STRUCT_CACHE_VkPhysicalDeviceVulkan11Properties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVulkan11Properties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._deviceUUID = [...Array(16)].fill(0x0);
  this._driverUUID = [...Array(16)].fill(0x0);
  this._deviceLUID = [...Array(8)].fill(0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVulkan11Properties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVulkan11Properties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVulkan11Properties.pNext' isn't allowed to be filled");
    }
    },
  "deviceUUID": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true),
      this.memoryView.getUint8(0x8, true),
      this.memoryView.getUint8(0x9, true),
      this.memoryView.getUint8(0xA, true),
      this.memoryView.getUint8(0xB, true),
      this.memoryView.getUint8(0xC, true),
      this.memoryView.getUint8(0xD, true),
      this.memoryView.getUint8(0xE, true),
      this.memoryView.getUint8(0xF, true)
    ];
    },
    },
  "driverUUID": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true),
      this.memoryView.getUint8(0x8, true),
      this.memoryView.getUint8(0x9, true),
      this.memoryView.getUint8(0xA, true),
      this.memoryView.getUint8(0xB, true),
      this.memoryView.getUint8(0xC, true),
      this.memoryView.getUint8(0xD, true),
      this.memoryView.getUint8(0xE, true),
      this.memoryView.getUint8(0xF, true)
    ];
    },
    },
  "deviceLUID": {
    get() {
    return [
      this.memoryView.getUint8(0x0, true),
      this.memoryView.getUint8(0x1, true),
      this.memoryView.getUint8(0x2, true),
      this.memoryView.getUint8(0x3, true),
      this.memoryView.getUint8(0x4, true),
      this.memoryView.getUint8(0x5, true),
      this.memoryView.getUint8(0x6, true),
      this.memoryView.getUint8(0x7, true)
    ];
    },
    },
  "deviceNodeMask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "deviceLUIDValid": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "subgroupSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "subgroupSupportedStages": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "subgroupSupportedOperations": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "subgroupQuadOperationsInAllStages": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "pointClippingBehavior": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "maxMultiviewViewCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMultiviewInstanceIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "protectedNoFault": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "maxPerSetDescriptors": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxMemoryAllocationSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPhysicalDeviceVulkan11Properties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._deviceUUID !== null) this._deviceUUID.fill(0x0);
      else this._deviceUUID = [...Array(16)].fill(0x0);
  if (this._driverUUID !== null) this._driverUUID.fill(0x0);
      else this._driverUUID = [...Array(16)].fill(0x0);
  if (this._deviceLUID !== null) this._deviceLUID.fill(0x0);
      else this._deviceLUID = [...Array(8)].fill(0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceVulkan11Properties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVulkan11Properties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceVulkan11Properties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVulkan11Properties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.deviceUUID !== null) {
        copy.deviceUUID = [...Array(original.deviceUUID.length)].map((v, i) => {
          return original.deviceUUID[i];
        });
      }
  if (original.driverUUID !== null) {
        copy.driverUUID = [...Array(original.driverUUID.length)].map((v, i) => {
          return original.driverUUID[i];
        });
      }
  if (original.deviceLUID !== null) {
        copy.deviceLUID = [...Array(original.deviceLUID.length)].map((v, i) => {
          return original.deviceLUID[i];
        });
      }
  copy.deviceNodeMask = original.deviceNodeMask;
  copy.deviceLUIDValid = original.deviceLUIDValid;
  copy.subgroupSize = original.subgroupSize;
  copy.subgroupSupportedStages = original.subgroupSupportedStages;
  copy.subgroupSupportedOperations = original.subgroupSupportedOperations;
  copy.subgroupQuadOperationsInAllStages = original.subgroupQuadOperationsInAllStages;
  copy.pointClippingBehavior = original.pointClippingBehavior;
  copy.maxMultiviewViewCount = original.maxMultiviewViewCount;
  copy.maxMultiviewInstanceIndex = original.maxMultiviewInstanceIndex;
  copy.protectedNoFault = original.protectedNoFault;
  copy.maxPerSetDescriptors = original.maxPerSetDescriptors;
  copy.maxMemoryAllocationSize = original.maxMemoryAllocationSize;
  
  return copy;
};

VkPhysicalDeviceVulkan11Properties.byteLength = 0x0;

VkPhysicalDeviceVulkan11Properties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceUUID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverUUID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceLUID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceNodeMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceLUIDValid: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subgroupSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subgroupSupportedStages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subgroupSupportedOperations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subgroupQuadOperationsInAllStages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pointClippingBehavior: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMultiviewViewCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMultiviewInstanceIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  protectedNoFault: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerSetDescriptors: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxMemoryAllocationSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVulkan12Features **/
function VkPhysicalDeviceVulkan12Features(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVulkan12Features) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVulkan12Features, STRUCT_CACHE_VkPhysicalDeviceVulkan12Features);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVulkan12Features, STRUCT_CACHE_VkPhysicalDeviceVulkan12Features);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVulkan12Features'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.samplerMirrorClampToEdge !== void 0) this.samplerMirrorClampToEdge = opts.samplerMirrorClampToEdge;
    if (opts.drawIndirectCount !== void 0) this.drawIndirectCount = opts.drawIndirectCount;
    if (opts.storageBuffer8BitAccess !== void 0) this.storageBuffer8BitAccess = opts.storageBuffer8BitAccess;
    if (opts.uniformAndStorageBuffer8BitAccess !== void 0) this.uniformAndStorageBuffer8BitAccess = opts.uniformAndStorageBuffer8BitAccess;
    if (opts.storagePushConstant8 !== void 0) this.storagePushConstant8 = opts.storagePushConstant8;
    if (opts.shaderBufferInt64Atomics !== void 0) this.shaderBufferInt64Atomics = opts.shaderBufferInt64Atomics;
    if (opts.shaderSharedInt64Atomics !== void 0) this.shaderSharedInt64Atomics = opts.shaderSharedInt64Atomics;
    if (opts.shaderFloat16 !== void 0) this.shaderFloat16 = opts.shaderFloat16;
    if (opts.shaderInt8 !== void 0) this.shaderInt8 = opts.shaderInt8;
    if (opts.descriptorIndexing !== void 0) this.descriptorIndexing = opts.descriptorIndexing;
    if (opts.shaderInputAttachmentArrayDynamicIndexing !== void 0) this.shaderInputAttachmentArrayDynamicIndexing = opts.shaderInputAttachmentArrayDynamicIndexing;
    if (opts.shaderUniformTexelBufferArrayDynamicIndexing !== void 0) this.shaderUniformTexelBufferArrayDynamicIndexing = opts.shaderUniformTexelBufferArrayDynamicIndexing;
    if (opts.shaderStorageTexelBufferArrayDynamicIndexing !== void 0) this.shaderStorageTexelBufferArrayDynamicIndexing = opts.shaderStorageTexelBufferArrayDynamicIndexing;
    if (opts.shaderUniformBufferArrayNonUniformIndexing !== void 0) this.shaderUniformBufferArrayNonUniformIndexing = opts.shaderUniformBufferArrayNonUniformIndexing;
    if (opts.shaderSampledImageArrayNonUniformIndexing !== void 0) this.shaderSampledImageArrayNonUniformIndexing = opts.shaderSampledImageArrayNonUniformIndexing;
    if (opts.shaderStorageBufferArrayNonUniformIndexing !== void 0) this.shaderStorageBufferArrayNonUniformIndexing = opts.shaderStorageBufferArrayNonUniformIndexing;
    if (opts.shaderStorageImageArrayNonUniformIndexing !== void 0) this.shaderStorageImageArrayNonUniformIndexing = opts.shaderStorageImageArrayNonUniformIndexing;
    if (opts.shaderInputAttachmentArrayNonUniformIndexing !== void 0) this.shaderInputAttachmentArrayNonUniformIndexing = opts.shaderInputAttachmentArrayNonUniformIndexing;
    if (opts.shaderUniformTexelBufferArrayNonUniformIndexing !== void 0) this.shaderUniformTexelBufferArrayNonUniformIndexing = opts.shaderUniformTexelBufferArrayNonUniformIndexing;
    if (opts.shaderStorageTexelBufferArrayNonUniformIndexing !== void 0) this.shaderStorageTexelBufferArrayNonUniformIndexing = opts.shaderStorageTexelBufferArrayNonUniformIndexing;
    if (opts.descriptorBindingUniformBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformBufferUpdateAfterBind = opts.descriptorBindingUniformBufferUpdateAfterBind;
    if (opts.descriptorBindingSampledImageUpdateAfterBind !== void 0) this.descriptorBindingSampledImageUpdateAfterBind = opts.descriptorBindingSampledImageUpdateAfterBind;
    if (opts.descriptorBindingStorageImageUpdateAfterBind !== void 0) this.descriptorBindingStorageImageUpdateAfterBind = opts.descriptorBindingStorageImageUpdateAfterBind;
    if (opts.descriptorBindingStorageBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageBufferUpdateAfterBind = opts.descriptorBindingStorageBufferUpdateAfterBind;
    if (opts.descriptorBindingUniformTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformTexelBufferUpdateAfterBind = opts.descriptorBindingUniformTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingStorageTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageTexelBufferUpdateAfterBind = opts.descriptorBindingStorageTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingUpdateUnusedWhilePending !== void 0) this.descriptorBindingUpdateUnusedWhilePending = opts.descriptorBindingUpdateUnusedWhilePending;
    if (opts.descriptorBindingPartiallyBound !== void 0) this.descriptorBindingPartiallyBound = opts.descriptorBindingPartiallyBound;
    if (opts.descriptorBindingVariableDescriptorCount !== void 0) this.descriptorBindingVariableDescriptorCount = opts.descriptorBindingVariableDescriptorCount;
    if (opts.runtimeDescriptorArray !== void 0) this.runtimeDescriptorArray = opts.runtimeDescriptorArray;
    if (opts.samplerFilterMinmax !== void 0) this.samplerFilterMinmax = opts.samplerFilterMinmax;
    if (opts.scalarBlockLayout !== void 0) this.scalarBlockLayout = opts.scalarBlockLayout;
    if (opts.imagelessFramebuffer !== void 0) this.imagelessFramebuffer = opts.imagelessFramebuffer;
    if (opts.uniformBufferStandardLayout !== void 0) this.uniformBufferStandardLayout = opts.uniformBufferStandardLayout;
    if (opts.shaderSubgroupExtendedTypes !== void 0) this.shaderSubgroupExtendedTypes = opts.shaderSubgroupExtendedTypes;
    if (opts.separateDepthStencilLayouts !== void 0) this.separateDepthStencilLayouts = opts.separateDepthStencilLayouts;
    if (opts.hostQueryReset !== void 0) this.hostQueryReset = opts.hostQueryReset;
    if (opts.timelineSemaphore !== void 0) this.timelineSemaphore = opts.timelineSemaphore;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    if (opts.vulkanMemoryModel !== void 0) this.vulkanMemoryModel = opts.vulkanMemoryModel;
    if (opts.vulkanMemoryModelDeviceScope !== void 0) this.vulkanMemoryModelDeviceScope = opts.vulkanMemoryModelDeviceScope;
    if (opts.vulkanMemoryModelAvailabilityVisibilityChains !== void 0) this.vulkanMemoryModelAvailabilityVisibilityChains = opts.vulkanMemoryModelAvailabilityVisibilityChains;
    if (opts.shaderOutputViewportIndex !== void 0) this.shaderOutputViewportIndex = opts.shaderOutputViewportIndex;
    if (opts.shaderOutputLayer !== void 0) this.shaderOutputLayer = opts.shaderOutputLayer;
    if (opts.subgroupBroadcastDynamicId !== void 0) this.subgroupBroadcastDynamicId = opts.subgroupBroadcastDynamicId;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVulkan12Features.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVulkan12Features.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVulkan12Features.pNext' isn't allowed to be filled");
    }
    },
  "samplerMirrorClampToEdge": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "drawIndirectCount": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "storageBuffer8BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "uniformAndStorageBuffer8BitAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "storagePushConstant8": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderBufferInt64Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSharedInt64Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderInt8": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderInputAttachmentArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderUniformTexelBufferArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageTexelBufferArrayDynamicIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderUniformBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSampledImageArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageImageArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderInputAttachmentArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderUniformTexelBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderStorageTexelBufferArrayNonUniformIndexing": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingUniformBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingSampledImageUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingStorageImageUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingStorageBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingUniformTexelBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingStorageTexelBufferUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingUpdateUnusedWhilePending": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingPartiallyBound": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "descriptorBindingVariableDescriptorCount": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "runtimeDescriptorArray": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "samplerFilterMinmax": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "scalarBlockLayout": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "imagelessFramebuffer": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "uniformBufferStandardLayout": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderSubgroupExtendedTypes": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "separateDepthStencilLayouts": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "hostQueryReset": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "timelineSemaphore": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddress": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddressCaptureReplay": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "bufferDeviceAddressMultiDevice": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "vulkanMemoryModel": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "vulkanMemoryModelDeviceScope": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "vulkanMemoryModelAvailabilityVisibilityChains": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderOutputViewportIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "shaderOutputLayer": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "subgroupBroadcastDynamicId": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceVulkan12Features.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.samplerMirrorClampToEdge !== void 0) this.samplerMirrorClampToEdge = opts.samplerMirrorClampToEdge;
    if (opts.drawIndirectCount !== void 0) this.drawIndirectCount = opts.drawIndirectCount;
    if (opts.storageBuffer8BitAccess !== void 0) this.storageBuffer8BitAccess = opts.storageBuffer8BitAccess;
    if (opts.uniformAndStorageBuffer8BitAccess !== void 0) this.uniformAndStorageBuffer8BitAccess = opts.uniformAndStorageBuffer8BitAccess;
    if (opts.storagePushConstant8 !== void 0) this.storagePushConstant8 = opts.storagePushConstant8;
    if (opts.shaderBufferInt64Atomics !== void 0) this.shaderBufferInt64Atomics = opts.shaderBufferInt64Atomics;
    if (opts.shaderSharedInt64Atomics !== void 0) this.shaderSharedInt64Atomics = opts.shaderSharedInt64Atomics;
    if (opts.shaderFloat16 !== void 0) this.shaderFloat16 = opts.shaderFloat16;
    if (opts.shaderInt8 !== void 0) this.shaderInt8 = opts.shaderInt8;
    if (opts.descriptorIndexing !== void 0) this.descriptorIndexing = opts.descriptorIndexing;
    if (opts.shaderInputAttachmentArrayDynamicIndexing !== void 0) this.shaderInputAttachmentArrayDynamicIndexing = opts.shaderInputAttachmentArrayDynamicIndexing;
    if (opts.shaderUniformTexelBufferArrayDynamicIndexing !== void 0) this.shaderUniformTexelBufferArrayDynamicIndexing = opts.shaderUniformTexelBufferArrayDynamicIndexing;
    if (opts.shaderStorageTexelBufferArrayDynamicIndexing !== void 0) this.shaderStorageTexelBufferArrayDynamicIndexing = opts.shaderStorageTexelBufferArrayDynamicIndexing;
    if (opts.shaderUniformBufferArrayNonUniformIndexing !== void 0) this.shaderUniformBufferArrayNonUniformIndexing = opts.shaderUniformBufferArrayNonUniformIndexing;
    if (opts.shaderSampledImageArrayNonUniformIndexing !== void 0) this.shaderSampledImageArrayNonUniformIndexing = opts.shaderSampledImageArrayNonUniformIndexing;
    if (opts.shaderStorageBufferArrayNonUniformIndexing !== void 0) this.shaderStorageBufferArrayNonUniformIndexing = opts.shaderStorageBufferArrayNonUniformIndexing;
    if (opts.shaderStorageImageArrayNonUniformIndexing !== void 0) this.shaderStorageImageArrayNonUniformIndexing = opts.shaderStorageImageArrayNonUniformIndexing;
    if (opts.shaderInputAttachmentArrayNonUniformIndexing !== void 0) this.shaderInputAttachmentArrayNonUniformIndexing = opts.shaderInputAttachmentArrayNonUniformIndexing;
    if (opts.shaderUniformTexelBufferArrayNonUniformIndexing !== void 0) this.shaderUniformTexelBufferArrayNonUniformIndexing = opts.shaderUniformTexelBufferArrayNonUniformIndexing;
    if (opts.shaderStorageTexelBufferArrayNonUniformIndexing !== void 0) this.shaderStorageTexelBufferArrayNonUniformIndexing = opts.shaderStorageTexelBufferArrayNonUniformIndexing;
    if (opts.descriptorBindingUniformBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformBufferUpdateAfterBind = opts.descriptorBindingUniformBufferUpdateAfterBind;
    if (opts.descriptorBindingSampledImageUpdateAfterBind !== void 0) this.descriptorBindingSampledImageUpdateAfterBind = opts.descriptorBindingSampledImageUpdateAfterBind;
    if (opts.descriptorBindingStorageImageUpdateAfterBind !== void 0) this.descriptorBindingStorageImageUpdateAfterBind = opts.descriptorBindingStorageImageUpdateAfterBind;
    if (opts.descriptorBindingStorageBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageBufferUpdateAfterBind = opts.descriptorBindingStorageBufferUpdateAfterBind;
    if (opts.descriptorBindingUniformTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformTexelBufferUpdateAfterBind = opts.descriptorBindingUniformTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingStorageTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageTexelBufferUpdateAfterBind = opts.descriptorBindingStorageTexelBufferUpdateAfterBind;
    if (opts.descriptorBindingUpdateUnusedWhilePending !== void 0) this.descriptorBindingUpdateUnusedWhilePending = opts.descriptorBindingUpdateUnusedWhilePending;
    if (opts.descriptorBindingPartiallyBound !== void 0) this.descriptorBindingPartiallyBound = opts.descriptorBindingPartiallyBound;
    if (opts.descriptorBindingVariableDescriptorCount !== void 0) this.descriptorBindingVariableDescriptorCount = opts.descriptorBindingVariableDescriptorCount;
    if (opts.runtimeDescriptorArray !== void 0) this.runtimeDescriptorArray = opts.runtimeDescriptorArray;
    if (opts.samplerFilterMinmax !== void 0) this.samplerFilterMinmax = opts.samplerFilterMinmax;
    if (opts.scalarBlockLayout !== void 0) this.scalarBlockLayout = opts.scalarBlockLayout;
    if (opts.imagelessFramebuffer !== void 0) this.imagelessFramebuffer = opts.imagelessFramebuffer;
    if (opts.uniformBufferStandardLayout !== void 0) this.uniformBufferStandardLayout = opts.uniformBufferStandardLayout;
    if (opts.shaderSubgroupExtendedTypes !== void 0) this.shaderSubgroupExtendedTypes = opts.shaderSubgroupExtendedTypes;
    if (opts.separateDepthStencilLayouts !== void 0) this.separateDepthStencilLayouts = opts.separateDepthStencilLayouts;
    if (opts.hostQueryReset !== void 0) this.hostQueryReset = opts.hostQueryReset;
    if (opts.timelineSemaphore !== void 0) this.timelineSemaphore = opts.timelineSemaphore;
    if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
    if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
    if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
    if (opts.vulkanMemoryModel !== void 0) this.vulkanMemoryModel = opts.vulkanMemoryModel;
    if (opts.vulkanMemoryModelDeviceScope !== void 0) this.vulkanMemoryModelDeviceScope = opts.vulkanMemoryModelDeviceScope;
    if (opts.vulkanMemoryModelAvailabilityVisibilityChains !== void 0) this.vulkanMemoryModelAvailabilityVisibilityChains = opts.vulkanMemoryModelAvailabilityVisibilityChains;
    if (opts.shaderOutputViewportIndex !== void 0) this.shaderOutputViewportIndex = opts.shaderOutputViewportIndex;
    if (opts.shaderOutputLayer !== void 0) this.shaderOutputLayer = opts.shaderOutputLayer;
    if (opts.subgroupBroadcastDynamicId !== void 0) this.subgroupBroadcastDynamicId = opts.subgroupBroadcastDynamicId;
    
  }
};

VkPhysicalDeviceVulkan12Features.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVulkan12Features.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceVulkan12Features.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVulkan12Features();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.samplerMirrorClampToEdge = original.samplerMirrorClampToEdge;
  copy.drawIndirectCount = original.drawIndirectCount;
  copy.storageBuffer8BitAccess = original.storageBuffer8BitAccess;
  copy.uniformAndStorageBuffer8BitAccess = original.uniformAndStorageBuffer8BitAccess;
  copy.storagePushConstant8 = original.storagePushConstant8;
  copy.shaderBufferInt64Atomics = original.shaderBufferInt64Atomics;
  copy.shaderSharedInt64Atomics = original.shaderSharedInt64Atomics;
  copy.shaderFloat16 = original.shaderFloat16;
  copy.shaderInt8 = original.shaderInt8;
  copy.descriptorIndexing = original.descriptorIndexing;
  copy.shaderInputAttachmentArrayDynamicIndexing = original.shaderInputAttachmentArrayDynamicIndexing;
  copy.shaderUniformTexelBufferArrayDynamicIndexing = original.shaderUniformTexelBufferArrayDynamicIndexing;
  copy.shaderStorageTexelBufferArrayDynamicIndexing = original.shaderStorageTexelBufferArrayDynamicIndexing;
  copy.shaderUniformBufferArrayNonUniformIndexing = original.shaderUniformBufferArrayNonUniformIndexing;
  copy.shaderSampledImageArrayNonUniformIndexing = original.shaderSampledImageArrayNonUniformIndexing;
  copy.shaderStorageBufferArrayNonUniformIndexing = original.shaderStorageBufferArrayNonUniformIndexing;
  copy.shaderStorageImageArrayNonUniformIndexing = original.shaderStorageImageArrayNonUniformIndexing;
  copy.shaderInputAttachmentArrayNonUniformIndexing = original.shaderInputAttachmentArrayNonUniformIndexing;
  copy.shaderUniformTexelBufferArrayNonUniformIndexing = original.shaderUniformTexelBufferArrayNonUniformIndexing;
  copy.shaderStorageTexelBufferArrayNonUniformIndexing = original.shaderStorageTexelBufferArrayNonUniformIndexing;
  copy.descriptorBindingUniformBufferUpdateAfterBind = original.descriptorBindingUniformBufferUpdateAfterBind;
  copy.descriptorBindingSampledImageUpdateAfterBind = original.descriptorBindingSampledImageUpdateAfterBind;
  copy.descriptorBindingStorageImageUpdateAfterBind = original.descriptorBindingStorageImageUpdateAfterBind;
  copy.descriptorBindingStorageBufferUpdateAfterBind = original.descriptorBindingStorageBufferUpdateAfterBind;
  copy.descriptorBindingUniformTexelBufferUpdateAfterBind = original.descriptorBindingUniformTexelBufferUpdateAfterBind;
  copy.descriptorBindingStorageTexelBufferUpdateAfterBind = original.descriptorBindingStorageTexelBufferUpdateAfterBind;
  copy.descriptorBindingUpdateUnusedWhilePending = original.descriptorBindingUpdateUnusedWhilePending;
  copy.descriptorBindingPartiallyBound = original.descriptorBindingPartiallyBound;
  copy.descriptorBindingVariableDescriptorCount = original.descriptorBindingVariableDescriptorCount;
  copy.runtimeDescriptorArray = original.runtimeDescriptorArray;
  copy.samplerFilterMinmax = original.samplerFilterMinmax;
  copy.scalarBlockLayout = original.scalarBlockLayout;
  copy.imagelessFramebuffer = original.imagelessFramebuffer;
  copy.uniformBufferStandardLayout = original.uniformBufferStandardLayout;
  copy.shaderSubgroupExtendedTypes = original.shaderSubgroupExtendedTypes;
  copy.separateDepthStencilLayouts = original.separateDepthStencilLayouts;
  copy.hostQueryReset = original.hostQueryReset;
  copy.timelineSemaphore = original.timelineSemaphore;
  copy.bufferDeviceAddress = original.bufferDeviceAddress;
  copy.bufferDeviceAddressCaptureReplay = original.bufferDeviceAddressCaptureReplay;
  copy.bufferDeviceAddressMultiDevice = original.bufferDeviceAddressMultiDevice;
  copy.vulkanMemoryModel = original.vulkanMemoryModel;
  copy.vulkanMemoryModelDeviceScope = original.vulkanMemoryModelDeviceScope;
  copy.vulkanMemoryModelAvailabilityVisibilityChains = original.vulkanMemoryModelAvailabilityVisibilityChains;
  copy.shaderOutputViewportIndex = original.shaderOutputViewportIndex;
  copy.shaderOutputLayer = original.shaderOutputLayer;
  copy.subgroupBroadcastDynamicId = original.subgroupBroadcastDynamicId;
  
  return copy;
};

VkPhysicalDeviceVulkan12Features.byteLength = 0x0;

VkPhysicalDeviceVulkan12Features.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samplerMirrorClampToEdge: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  drawIndirectCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storageBuffer8BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformAndStorageBuffer8BitAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  storagePushConstant8: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderBufferInt64Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSharedInt64Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInt8: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInputAttachmentArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformTexelBufferArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageTexelBufferArrayDynamicIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSampledImageArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInputAttachmentArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformTexelBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageTexelBufferArrayNonUniformIndexing: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingUniformBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingSampledImageUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingStorageImageUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingStorageBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingUniformTexelBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingStorageTexelBufferUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingUpdateUnusedWhilePending: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingPartiallyBound: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  descriptorBindingVariableDescriptorCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  runtimeDescriptorArray: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  samplerFilterMinmax: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  scalarBlockLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imagelessFramebuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  uniformBufferStandardLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSubgroupExtendedTypes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  separateDepthStencilLayouts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  hostQueryReset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  timelineSemaphore: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddressCaptureReplay: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferDeviceAddressMultiDevice: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vulkanMemoryModel: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vulkanMemoryModelDeviceScope: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vulkanMemoryModelAvailabilityVisibilityChains: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderOutputViewportIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderOutputLayer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  subgroupBroadcastDynamicId: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceVulkan12Properties **/
function VkPhysicalDeviceVulkan12Properties(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceVulkan12Properties) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceVulkan12Properties, STRUCT_CACHE_VkPhysicalDeviceVulkan12Properties);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceVulkan12Properties, STRUCT_CACHE_VkPhysicalDeviceVulkan12Properties);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceVulkan12Properties'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._conformanceVersion = new VkConformanceVersion({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceVulkan12Properties.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceVulkan12Properties.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceVulkan12Properties.pNext' isn't allowed to be filled");
    }
    },
  "driverID": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "driverName": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "driverInfo": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "conformanceVersion": {
    get() {
    return this._conformanceVersion;
    },
    },
  "denormBehaviorIndependence": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "roundingModeIndependence": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "shaderSignedZeroInfNanPreserveFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderSignedZeroInfNanPreserveFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderSignedZeroInfNanPreserveFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormPreserveFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormPreserveFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormPreserveFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderDenormFlushToZeroFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTEFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTEFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTEFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTZFloat16": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTZFloat32": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderRoundingModeRTZFloat64": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "maxUpdateAfterBindDescriptorsInAllPools": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "shaderUniformBufferArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderSampledImageArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderStorageBufferArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderStorageImageArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "shaderInputAttachmentArrayNonUniformIndexingNative": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "robustBufferAccessUpdateAfterBind": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "quadDivergentImplicitLod": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "maxPerStageDescriptorUpdateAfterBindSamplers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindUniformBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindStorageBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindSampledImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindStorageImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageDescriptorUpdateAfterBindInputAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxPerStageUpdateAfterBindResources": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindSamplers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindUniformBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageBuffers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindSampledImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindStorageImages": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxDescriptorSetUpdateAfterBindInputAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "supportedDepthResolveModes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "supportedStencilResolveModes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "independentResolveNone": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "independentResolve": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "filterMinmaxSingleComponentFormats": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "filterMinmaxImageComponentMapping": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "maxTimelineSemaphoreValueDifference": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "framebufferIntegerColorSampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceVulkan12Properties.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  if (this._conformanceVersion !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._conformanceVersion.memoryBuffer) this._conformanceVersion = new VkConformanceVersion({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._conformanceVersion.reset();
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceVulkan12Properties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVulkan12Properties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceVulkan12Properties.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceVulkan12Properties();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.driverID = original.driverID;
  copy.driverName = original.driverName;
  copy.driverInfo = original.driverInfo;
  if (original.conformanceVersion !== null) {
        copy.conformanceVersion = original.conformanceVersion.constructor.createCopyFrom(original.conformanceVersion);
      }
  copy.denormBehaviorIndependence = original.denormBehaviorIndependence;
  copy.roundingModeIndependence = original.roundingModeIndependence;
  copy.shaderSignedZeroInfNanPreserveFloat16 = original.shaderSignedZeroInfNanPreserveFloat16;
  copy.shaderSignedZeroInfNanPreserveFloat32 = original.shaderSignedZeroInfNanPreserveFloat32;
  copy.shaderSignedZeroInfNanPreserveFloat64 = original.shaderSignedZeroInfNanPreserveFloat64;
  copy.shaderDenormPreserveFloat16 = original.shaderDenormPreserveFloat16;
  copy.shaderDenormPreserveFloat32 = original.shaderDenormPreserveFloat32;
  copy.shaderDenormPreserveFloat64 = original.shaderDenormPreserveFloat64;
  copy.shaderDenormFlushToZeroFloat16 = original.shaderDenormFlushToZeroFloat16;
  copy.shaderDenormFlushToZeroFloat32 = original.shaderDenormFlushToZeroFloat32;
  copy.shaderDenormFlushToZeroFloat64 = original.shaderDenormFlushToZeroFloat64;
  copy.shaderRoundingModeRTEFloat16 = original.shaderRoundingModeRTEFloat16;
  copy.shaderRoundingModeRTEFloat32 = original.shaderRoundingModeRTEFloat32;
  copy.shaderRoundingModeRTEFloat64 = original.shaderRoundingModeRTEFloat64;
  copy.shaderRoundingModeRTZFloat16 = original.shaderRoundingModeRTZFloat16;
  copy.shaderRoundingModeRTZFloat32 = original.shaderRoundingModeRTZFloat32;
  copy.shaderRoundingModeRTZFloat64 = original.shaderRoundingModeRTZFloat64;
  copy.maxUpdateAfterBindDescriptorsInAllPools = original.maxUpdateAfterBindDescriptorsInAllPools;
  copy.shaderUniformBufferArrayNonUniformIndexingNative = original.shaderUniformBufferArrayNonUniformIndexingNative;
  copy.shaderSampledImageArrayNonUniformIndexingNative = original.shaderSampledImageArrayNonUniformIndexingNative;
  copy.shaderStorageBufferArrayNonUniformIndexingNative = original.shaderStorageBufferArrayNonUniformIndexingNative;
  copy.shaderStorageImageArrayNonUniformIndexingNative = original.shaderStorageImageArrayNonUniformIndexingNative;
  copy.shaderInputAttachmentArrayNonUniformIndexingNative = original.shaderInputAttachmentArrayNonUniformIndexingNative;
  copy.robustBufferAccessUpdateAfterBind = original.robustBufferAccessUpdateAfterBind;
  copy.quadDivergentImplicitLod = original.quadDivergentImplicitLod;
  copy.maxPerStageDescriptorUpdateAfterBindSamplers = original.maxPerStageDescriptorUpdateAfterBindSamplers;
  copy.maxPerStageDescriptorUpdateAfterBindUniformBuffers = original.maxPerStageDescriptorUpdateAfterBindUniformBuffers;
  copy.maxPerStageDescriptorUpdateAfterBindStorageBuffers = original.maxPerStageDescriptorUpdateAfterBindStorageBuffers;
  copy.maxPerStageDescriptorUpdateAfterBindSampledImages = original.maxPerStageDescriptorUpdateAfterBindSampledImages;
  copy.maxPerStageDescriptorUpdateAfterBindStorageImages = original.maxPerStageDescriptorUpdateAfterBindStorageImages;
  copy.maxPerStageDescriptorUpdateAfterBindInputAttachments = original.maxPerStageDescriptorUpdateAfterBindInputAttachments;
  copy.maxPerStageUpdateAfterBindResources = original.maxPerStageUpdateAfterBindResources;
  copy.maxDescriptorSetUpdateAfterBindSamplers = original.maxDescriptorSetUpdateAfterBindSamplers;
  copy.maxDescriptorSetUpdateAfterBindUniformBuffers = original.maxDescriptorSetUpdateAfterBindUniformBuffers;
  copy.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = original.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
  copy.maxDescriptorSetUpdateAfterBindStorageBuffers = original.maxDescriptorSetUpdateAfterBindStorageBuffers;
  copy.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = original.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
  copy.maxDescriptorSetUpdateAfterBindSampledImages = original.maxDescriptorSetUpdateAfterBindSampledImages;
  copy.maxDescriptorSetUpdateAfterBindStorageImages = original.maxDescriptorSetUpdateAfterBindStorageImages;
  copy.maxDescriptorSetUpdateAfterBindInputAttachments = original.maxDescriptorSetUpdateAfterBindInputAttachments;
  copy.supportedDepthResolveModes = original.supportedDepthResolveModes;
  copy.supportedStencilResolveModes = original.supportedStencilResolveModes;
  copy.independentResolveNone = original.independentResolveNone;
  copy.independentResolve = original.independentResolve;
  copy.filterMinmaxSingleComponentFormats = original.filterMinmaxSingleComponentFormats;
  copy.filterMinmaxImageComponentMapping = original.filterMinmaxImageComponentMapping;
  copy.maxTimelineSemaphoreValueDifference = original.maxTimelineSemaphoreValueDifference;
  copy.framebufferIntegerColorSampleCounts = original.framebufferIntegerColorSampleCounts;
  
  return copy;
};

VkPhysicalDeviceVulkan12Properties.byteLength = 0x0;

VkPhysicalDeviceVulkan12Properties.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverID: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverName: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  driverInfo: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  conformanceVersion: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  denormBehaviorIndependence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  roundingModeIndependence: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSignedZeroInfNanPreserveFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSignedZeroInfNanPreserveFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSignedZeroInfNanPreserveFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormPreserveFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormPreserveFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormPreserveFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormFlushToZeroFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormFlushToZeroFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderDenormFlushToZeroFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTEFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTEFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTEFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTZFloat16: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTZFloat32: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderRoundingModeRTZFloat64: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxUpdateAfterBindDescriptorsInAllPools: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderUniformBufferArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderSampledImageArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageBufferArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderStorageImageArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderInputAttachmentArrayNonUniformIndexingNative: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  robustBufferAccessUpdateAfterBind: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  quadDivergentImplicitLod: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindUniformBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindStorageBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindSampledImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindStorageImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageDescriptorUpdateAfterBindInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPerStageUpdateAfterBindResources: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindUniformBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindStorageBuffers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindSampledImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindStorageImages: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxDescriptorSetUpdateAfterBindInputAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedDepthResolveModes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supportedStencilResolveModes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  independentResolveNone: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  independentResolve: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  filterMinmaxSingleComponentFormats: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  filterMinmaxImageComponentMapping: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxTimelineSemaphoreValueDifference: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  framebufferIntegerColorSampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineCompilerControlCreateInfoAMD **/
function VkPipelineCompilerControlCreateInfoAMD(opts, byteOffset) {
  if (new.target !== VkPipelineCompilerControlCreateInfoAMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineCompilerControlCreateInfoAMD, STRUCT_CACHE_VkPipelineCompilerControlCreateInfoAMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineCompilerControlCreateInfoAMD, STRUCT_CACHE_VkPipelineCompilerControlCreateInfoAMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineCompilerControlCreateInfoAMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.compilerControlFlags !== void 0) this.compilerControlFlags = opts.compilerControlFlags;
    
  }
};

Object.defineProperties(VkPipelineCompilerControlCreateInfoAMD.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCompilerControlCreateInfoAMD.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineCompilerControlCreateInfoAMD.pNext' isn't allowed to be filled");
    }
    },
  "compilerControlFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineCompilerControlCreateInfoAMD.compilerControlFlags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPipelineCompilerControlCreateInfoAMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.compilerControlFlags !== void 0) this.compilerControlFlags = opts.compilerControlFlags;
    
  }
};

VkPipelineCompilerControlCreateInfoAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCompilerControlCreateInfoAMD.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineCompilerControlCreateInfoAMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineCompilerControlCreateInfoAMD();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.compilerControlFlags = original.compilerControlFlags;
  
  return copy;
};

VkPipelineCompilerControlCreateInfoAMD.byteLength = 0x0;

VkPipelineCompilerControlCreateInfoAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  compilerControlFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceCoherentMemoryFeaturesAMD **/
function VkPhysicalDeviceCoherentMemoryFeaturesAMD(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceCoherentMemoryFeaturesAMD) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceCoherentMemoryFeaturesAMD, STRUCT_CACHE_VkPhysicalDeviceCoherentMemoryFeaturesAMD);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceCoherentMemoryFeaturesAMD, STRUCT_CACHE_VkPhysicalDeviceCoherentMemoryFeaturesAMD);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceCoherentMemoryFeaturesAMD'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceCoherentMemory !== void 0) this.deviceCoherentMemory = opts.deviceCoherentMemory;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCoherentMemoryFeaturesAMD.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceCoherentMemoryFeaturesAMD.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCoherentMemoryFeaturesAMD.pNext' isn't allowed to be filled");
    }
    },
  "deviceCoherentMemory": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceCoherentMemoryFeaturesAMD.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.deviceCoherentMemory !== void 0) this.deviceCoherentMemory = opts.deviceCoherentMemory;
    
  }
};

VkPhysicalDeviceCoherentMemoryFeaturesAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCoherentMemoryFeaturesAMD.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceCoherentMemoryFeaturesAMD.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceCoherentMemoryFeaturesAMD();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.deviceCoherentMemory = original.deviceCoherentMemory;
  
  return copy;
};

VkPhysicalDeviceCoherentMemoryFeaturesAMD.byteLength = 0x0;

VkPhysicalDeviceCoherentMemoryFeaturesAMD.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceCoherentMemory: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceToolPropertiesEXT **/
function VkPhysicalDeviceToolPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceToolPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceToolPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceToolPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceToolPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceToolPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceToolPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceToolPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceToolPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceToolPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "name": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "version": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "purposes": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "description": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  "layer": {
    get() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(this.$memoryOffset + 0x0, 0x0)
    ) || null;
    },
    },
  
});

VkPhysicalDeviceToolPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceToolPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceToolPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceToolPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceToolPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.name = original.name;
  copy.version = original.version;
  copy.purposes = original.purposes;
  copy.description = original.description;
  copy.layer = original.layer;
  
  return copy;
};

VkPhysicalDeviceToolPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceToolPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  name: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  version: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  purposes: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  description: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkSamplerCustomBorderColorCreateInfoEXT **/
function VkSamplerCustomBorderColorCreateInfoEXT(opts, byteOffset) {
  if (new.target !== VkSamplerCustomBorderColorCreateInfoEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkSamplerCustomBorderColorCreateInfoEXT, STRUCT_CACHE_VkSamplerCustomBorderColorCreateInfoEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkSamplerCustomBorderColorCreateInfoEXT, STRUCT_CACHE_VkSamplerCustomBorderColorCreateInfoEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkSamplerCustomBorderColorCreateInfoEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._customBorderColor = new VkClearColorValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.customBorderColor !== void 0) this.customBorderColor = opts.customBorderColor;
    if (opts.format !== void 0) this.format = opts.format;
    
  }
};

Object.defineProperties(VkSamplerCustomBorderColorCreateInfoEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCustomBorderColorCreateInfoEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkSamplerCustomBorderColorCreateInfoEXT.pNext' isn't allowed to be filled");
    }
    },
  "customBorderColor": {
    get() {
    return this._customBorderColor;
    },
    set(value) {
    if (value !== null && value.constructor === VkClearColorValue) {
      value.flush();
      this._customBorderColor = value;
      
      
    } else if (value === null) {
      this._customBorderColor = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSamplerCustomBorderColorCreateInfoEXT.customBorderColor': Expected 'VkClearColorValue' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "format": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkSamplerCustomBorderColorCreateInfoEXT.format");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkSamplerCustomBorderColorCreateInfoEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._customBorderColor !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._customBorderColor.memoryBuffer) this._customBorderColor = new VkClearColorValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._customBorderColor.reset();
  }
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.customBorderColor !== void 0) this.customBorderColor = opts.customBorderColor;
    if (opts.format !== void 0) this.format = opts.format;
    
  }
};

VkSamplerCustomBorderColorCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._customBorderColor !== null) {
    let customBorderColor = this._customBorderColor;
    customBorderColor.flush();
    if (this.memoryBuffer !== customBorderColor.memoryBuffer) {
      let srcView = new Uint8Array(customBorderColor.memoryBuffer, customBorderColor.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkSamplerCustomBorderColorCreateInfoEXT.customBorderColor' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkSamplerCustomBorderColorCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkSamplerCustomBorderColorCreateInfoEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkSamplerCustomBorderColorCreateInfoEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.customBorderColor !== null) {
        copy.customBorderColor = original.customBorderColor.constructor.createCopyFrom(original.customBorderColor);
      }
  copy.format = original.format;
  
  return copy;
};

VkSamplerCustomBorderColorCreateInfoEXT.byteLength = 0x0;

VkSamplerCustomBorderColorCreateInfoEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  customBorderColor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  format: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceCustomBorderColorPropertiesEXT **/
function VkPhysicalDeviceCustomBorderColorPropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceCustomBorderColorPropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceCustomBorderColorPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceCustomBorderColorPropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceCustomBorderColorPropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceCustomBorderColorPropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceCustomBorderColorPropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCustomBorderColorPropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceCustomBorderColorPropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCustomBorderColorPropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "maxCustomBorderColorSamplers": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  
});

VkPhysicalDeviceCustomBorderColorPropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceCustomBorderColorPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCustomBorderColorPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceCustomBorderColorPropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceCustomBorderColorPropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxCustomBorderColorSamplers = original.maxCustomBorderColorSamplers;
  
  return copy;
};

VkPhysicalDeviceCustomBorderColorPropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceCustomBorderColorPropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxCustomBorderColorSamplers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceCustomBorderColorFeaturesEXT **/
function VkPhysicalDeviceCustomBorderColorFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceCustomBorderColorFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceCustomBorderColorFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceCustomBorderColorFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceCustomBorderColorFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceCustomBorderColorFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceCustomBorderColorFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.customBorderColors !== void 0) this.customBorderColors = opts.customBorderColors;
    if (opts.customBorderColorWithoutFormat !== void 0) this.customBorderColorWithoutFormat = opts.customBorderColorWithoutFormat;
    
  }
};

Object.defineProperties(VkPhysicalDeviceCustomBorderColorFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceCustomBorderColorFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceCustomBorderColorFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "customBorderColors": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "customBorderColorWithoutFormat": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceCustomBorderColorFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.customBorderColors !== void 0) this.customBorderColors = opts.customBorderColors;
    if (opts.customBorderColorWithoutFormat !== void 0) this.customBorderColorWithoutFormat = opts.customBorderColorWithoutFormat;
    
  }
};

VkPhysicalDeviceCustomBorderColorFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCustomBorderColorFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceCustomBorderColorFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceCustomBorderColorFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.customBorderColors = original.customBorderColors;
  copy.customBorderColorWithoutFormat = original.customBorderColorWithoutFormat;
  
  return copy;
};

VkPhysicalDeviceCustomBorderColorFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceCustomBorderColorFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  customBorderColors: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  customBorderColorWithoutFormat: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureGeometryTrianglesDataKHR **/
function VkAccelerationStructureGeometryTrianglesDataKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureGeometryTrianglesDataKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureGeometryTrianglesDataKHR, STRUCT_CACHE_VkAccelerationStructureGeometryTrianglesDataKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureGeometryTrianglesDataKHR, STRUCT_CACHE_VkAccelerationStructureGeometryTrianglesDataKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureGeometryTrianglesDataKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._vertexData = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  this._indexData = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._transformData = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexFormat !== void 0) this.vertexFormat = opts.vertexFormat;
    if (opts.vertexData !== void 0) this.vertexData = opts.vertexData;
    if (opts.vertexStride !== void 0) this.vertexStride = opts.vertexStride;
    if (opts.maxVertex !== void 0) this.maxVertex = opts.maxVertex;
    if (opts.indexType !== void 0) this.indexType = opts.indexType;
    if (opts.indexData !== void 0) this.indexData = opts.indexData;
    if (opts.transformData !== void 0) this.transformData = opts.transformData;
    
  }
};

Object.defineProperties(VkAccelerationStructureGeometryTrianglesDataKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureGeometryTrianglesDataKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureGeometryTrianglesDataKHR.pNext' isn't allowed to be filled");
    }
    },
  "vertexFormat": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureGeometryTrianglesDataKHR.vertexFormat");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "vertexData": {
    get() {
    return this._vertexData;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceOrHostAddressConstKHR) {
      value.flush();
      this._vertexData = value;
      
      
    } else if (value === null) {
      this._vertexData = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureGeometryTrianglesDataKHR.vertexData': Expected 'VkDeviceOrHostAddressConstKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "vertexStride": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureGeometryTrianglesDataKHR.vertexStride")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "maxVertex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureGeometryTrianglesDataKHR.maxVertex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "indexType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureGeometryTrianglesDataKHR.indexType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "indexData": {
    get() {
    return this._indexData;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceOrHostAddressConstKHR) {
      value.flush();
      this._indexData = value;
      
      
    } else if (value === null) {
      this._indexData = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureGeometryTrianglesDataKHR.indexData': Expected 'VkDeviceOrHostAddressConstKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "transformData": {
    get() {
    return this._transformData;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceOrHostAddressConstKHR) {
      value.flush();
      this._transformData = value;
      
      
    } else if (value === null) {
      this._transformData = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureGeometryTrianglesDataKHR.transformData': Expected 'VkDeviceOrHostAddressConstKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAccelerationStructureGeometryTrianglesDataKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._vertexData !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._vertexData.memoryBuffer) this._vertexData = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._vertexData.reset();
  }
  
  
  
  if (this._indexData !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._indexData.memoryBuffer) this._indexData = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._indexData.reset();
  }
  if (this._transformData !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._transformData.memoryBuffer) this._transformData = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._transformData.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.vertexFormat !== void 0) this.vertexFormat = opts.vertexFormat;
    if (opts.vertexData !== void 0) this.vertexData = opts.vertexData;
    if (opts.vertexStride !== void 0) this.vertexStride = opts.vertexStride;
    if (opts.maxVertex !== void 0) this.maxVertex = opts.maxVertex;
    if (opts.indexType !== void 0) this.indexType = opts.indexType;
    if (opts.indexData !== void 0) this.indexData = opts.indexData;
    if (opts.transformData !== void 0) this.transformData = opts.transformData;
    
  }
};

VkAccelerationStructureGeometryTrianglesDataKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._vertexData !== null) {
    let vertexData = this._vertexData;
    vertexData.flush();
    if (this.memoryBuffer !== vertexData.memoryBuffer) {
      let srcView = new Uint8Array(vertexData.memoryBuffer, vertexData.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureGeometryTrianglesDataKHR.vertexData' isn't used as shared-memory");
    }
  }
  
  
  if (this._indexData !== null) {
    let indexData = this._indexData;
    indexData.flush();
    if (this.memoryBuffer !== indexData.memoryBuffer) {
      let srcView = new Uint8Array(indexData.memoryBuffer, indexData.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureGeometryTrianglesDataKHR.indexData' isn't used as shared-memory");
    }
  }
  
  
  if (this._transformData !== null) {
    let transformData = this._transformData;
    transformData.flush();
    if (this.memoryBuffer !== transformData.memoryBuffer) {
      let srcView = new Uint8Array(transformData.memoryBuffer, transformData.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureGeometryTrianglesDataKHR.transformData' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAccelerationStructureGeometryTrianglesDataKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureGeometryTrianglesDataKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureGeometryTrianglesDataKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.vertexFormat = original.vertexFormat;
  if (original.vertexData !== null) {
        copy.vertexData = original.vertexData.constructor.createCopyFrom(original.vertexData);
      }
  copy.vertexStride = original.vertexStride;
  copy.maxVertex = original.maxVertex;
  copy.indexType = original.indexType;
  if (original.indexData !== null) {
        copy.indexData = original.indexData.constructor.createCopyFrom(original.indexData);
      }
  if (original.transformData !== null) {
        copy.transformData = original.transformData.constructor.createCopyFrom(original.transformData);
      }
  
  return copy;
};

VkAccelerationStructureGeometryTrianglesDataKHR.byteLength = 0x0;

VkAccelerationStructureGeometryTrianglesDataKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexFormat: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  vertexStride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxVertex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indexType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  indexData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transformData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureGeometryAabbsDataKHR **/
function VkAccelerationStructureGeometryAabbsDataKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureGeometryAabbsDataKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureGeometryAabbsDataKHR, STRUCT_CACHE_VkAccelerationStructureGeometryAabbsDataKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureGeometryAabbsDataKHR, STRUCT_CACHE_VkAccelerationStructureGeometryAabbsDataKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureGeometryAabbsDataKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._data = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.data !== void 0) this.data = opts.data;
    if (opts.stride !== void 0) this.stride = opts.stride;
    
  }
};

Object.defineProperties(VkAccelerationStructureGeometryAabbsDataKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureGeometryAabbsDataKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureGeometryAabbsDataKHR.pNext' isn't allowed to be filled");
    }
    },
  "data": {
    get() {
    return this._data;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceOrHostAddressConstKHR) {
      value.flush();
      this._data = value;
      
      
    } else if (value === null) {
      this._data = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureGeometryAabbsDataKHR.data': Expected 'VkDeviceOrHostAddressConstKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "stride": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureGeometryAabbsDataKHR.stride")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkAccelerationStructureGeometryAabbsDataKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._data !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._data.memoryBuffer) this._data = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._data.reset();
  }
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.data !== void 0) this.data = opts.data;
    if (opts.stride !== void 0) this.stride = opts.stride;
    
  }
};

VkAccelerationStructureGeometryAabbsDataKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._data !== null) {
    let data = this._data;
    data.flush();
    if (this.memoryBuffer !== data.memoryBuffer) {
      let srcView = new Uint8Array(data.memoryBuffer, data.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureGeometryAabbsDataKHR.data' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAccelerationStructureGeometryAabbsDataKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureGeometryAabbsDataKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureGeometryAabbsDataKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.data !== null) {
        copy.data = original.data.constructor.createCopyFrom(original.data);
      }
  copy.stride = original.stride;
  
  return copy;
};

VkAccelerationStructureGeometryAabbsDataKHR.byteLength = 0x0;

VkAccelerationStructureGeometryAabbsDataKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  data: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  stride: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureGeometryInstancesDataKHR **/
function VkAccelerationStructureGeometryInstancesDataKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureGeometryInstancesDataKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureGeometryInstancesDataKHR, STRUCT_CACHE_VkAccelerationStructureGeometryInstancesDataKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureGeometryInstancesDataKHR, STRUCT_CACHE_VkAccelerationStructureGeometryInstancesDataKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureGeometryInstancesDataKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._data = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.arrayOfPointers !== void 0) this.arrayOfPointers = opts.arrayOfPointers;
    if (opts.data !== void 0) this.data = opts.data;
    
  }
};

Object.defineProperties(VkAccelerationStructureGeometryInstancesDataKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureGeometryInstancesDataKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureGeometryInstancesDataKHR.pNext' isn't allowed to be filled");
    }
    },
  "arrayOfPointers": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "data": {
    get() {
    return this._data;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceOrHostAddressConstKHR) {
      value.flush();
      this._data = value;
      
      
    } else if (value === null) {
      this._data = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureGeometryInstancesDataKHR.data': Expected 'VkDeviceOrHostAddressConstKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAccelerationStructureGeometryInstancesDataKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._data !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._data.memoryBuffer) this._data = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._data.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.arrayOfPointers !== void 0) this.arrayOfPointers = opts.arrayOfPointers;
    if (opts.data !== void 0) this.data = opts.data;
    
  }
};

VkAccelerationStructureGeometryInstancesDataKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._data !== null) {
    let data = this._data;
    data.flush();
    if (this.memoryBuffer !== data.memoryBuffer) {
      let srcView = new Uint8Array(data.memoryBuffer, data.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureGeometryInstancesDataKHR.data' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAccelerationStructureGeometryInstancesDataKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureGeometryInstancesDataKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureGeometryInstancesDataKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.arrayOfPointers = original.arrayOfPointers;
  if (original.data !== null) {
        copy.data = original.data.constructor.createCopyFrom(original.data);
      }
  
  return copy;
};

VkAccelerationStructureGeometryInstancesDataKHR.byteLength = 0x0;

VkAccelerationStructureGeometryInstancesDataKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  arrayOfPointers: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  data: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureGeometryKHR **/
function VkAccelerationStructureGeometryKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureGeometryKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureGeometryKHR, STRUCT_CACHE_VkAccelerationStructureGeometryKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureGeometryKHR, STRUCT_CACHE_VkAccelerationStructureGeometryKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureGeometryKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._geometry = new VkAccelerationStructureGeometryDataKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.geometryType !== void 0) this.geometryType = opts.geometryType;
    if (opts.geometry !== void 0) this.geometry = opts.geometry;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkAccelerationStructureGeometryKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureGeometryKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureGeometryKHR.pNext' isn't allowed to be filled");
    }
    },
  "geometryType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureGeometryKHR.geometryType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "geometry": {
    get() {
    return this._geometry;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureGeometryDataKHR) {
      value.flush();
      this._geometry = value;
      
      
    } else if (value === null) {
      this._geometry = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureGeometryKHR.geometry': Expected 'VkAccelerationStructureGeometryDataKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureGeometryKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkAccelerationStructureGeometryKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._geometry !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._geometry.memoryBuffer) this._geometry = new VkAccelerationStructureGeometryDataKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._geometry.reset();
  }
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.geometryType !== void 0) this.geometryType = opts.geometryType;
    if (opts.geometry !== void 0) this.geometry = opts.geometry;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkAccelerationStructureGeometryKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._geometry !== null) {
    let geometry = this._geometry;
    geometry.flush();
    if (this.memoryBuffer !== geometry.memoryBuffer) {
      let srcView = new Uint8Array(geometry.memoryBuffer, geometry.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureGeometryKHR.geometry' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAccelerationStructureGeometryKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureGeometryKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureGeometryKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.geometryType = original.geometryType;
  if (original.geometry !== null) {
        copy.geometry = original.geometry.constructor.createCopyFrom(original.geometry);
      }
  copy.flags = original.flags;
  
  return copy;
};

VkAccelerationStructureGeometryKHR.byteLength = 0x0;

VkAccelerationStructureGeometryKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  geometryType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  geometry: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureBuildGeometryInfoKHR **/
function VkAccelerationStructureBuildGeometryInfoKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureBuildGeometryInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureBuildGeometryInfoKHR, STRUCT_CACHE_VkAccelerationStructureBuildGeometryInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureBuildGeometryInfoKHR, STRUCT_CACHE_VkAccelerationStructureBuildGeometryInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureBuildGeometryInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._srcAccelerationStructure = null;
  this._dstAccelerationStructure = null;
  
  this._pGeometries = null;
  this._pGeometriesNative = null;
  this._ppGeometries = null;
  this._ppGeometriesNative = null;
  this._scratchData = new VkDeviceOrHostAddressKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.mode !== void 0) this.mode = opts.mode;
    if (opts.srcAccelerationStructure !== void 0) this.srcAccelerationStructure = opts.srcAccelerationStructure;
    if (opts.dstAccelerationStructure !== void 0) this.dstAccelerationStructure = opts.dstAccelerationStructure;
    if (opts.geometryCount !== void 0) this.geometryCount = opts.geometryCount;
    if (opts.pGeometries !== void 0) this.pGeometries = opts.pGeometries;
    if (opts.ppGeometries !== void 0) this.ppGeometries = opts.ppGeometries;
    if (opts.scratchData !== void 0) this.scratchData = opts.scratchData;
    
  }
};

Object.defineProperties(VkAccelerationStructureBuildGeometryInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureBuildGeometryInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureBuildGeometryInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureBuildGeometryInfoKHR.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureBuildGeometryInfoKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "mode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureBuildGeometryInfoKHR.mode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "srcAccelerationStructure": {
    get() {
    return this._srcAccelerationStructure;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureKHR) {
      
      this._srcAccelerationStructure = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._srcAccelerationStructure = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureBuildGeometryInfoKHR.srcAccelerationStructure': Expected 'VkAccelerationStructureKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstAccelerationStructure": {
    get() {
    return this._dstAccelerationStructure;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureKHR) {
      
      this._dstAccelerationStructure = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dstAccelerationStructure = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureBuildGeometryInfoKHR.dstAccelerationStructure': Expected 'VkAccelerationStructureKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "geometryCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureBuildGeometryInfoKHR.geometryCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pGeometries": {
    get() {
    if (this._pGeometries === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.geometryCount, VkAccelerationStructureGeometryKHR);
      this._pGeometries = array;
      return this.pGeometries;
    } else {
      return this._pGeometries;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pGeometries = value;
    } else if (value === null) {
      this._pGeometries = null;
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureBuildGeometryInfoKHR.pGeometries': Expected 'Array VkAccelerationStructureGeometryKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "ppGeometries": {
    get() {
    if (this._ppGeometries === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.geometryCount,1, VkAccelerationStructureGeometryKHR);
      this._ppGeometries = array;
      return this.ppGeometries;
    } else {
      return this._ppGeometries;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._ppGeometries = value;
    } else if (value === null) {
      this._ppGeometries = null;
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureBuildGeometryInfoKHR.ppGeometries': Expected 'Array VkAccelerationStructureGeometryKHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "scratchData": {
    get() {
    return this._scratchData;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceOrHostAddressKHR) {
      value.flush();
      this._scratchData = value;
      
      
    } else if (value === null) {
      this._scratchData = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureBuildGeometryInfoKHR.scratchData': Expected 'VkDeviceOrHostAddressKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAccelerationStructureBuildGeometryInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this._srcAccelerationStructure = null;
  this._dstAccelerationStructure = null;
  
  this._pGeometries = null;
  this._pGeometriesNative = null;
  this._ppGeometries = null;
  this._ppGeometriesNative = null;
  if (this._scratchData !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._scratchData.memoryBuffer) this._scratchData = new VkDeviceOrHostAddressKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._scratchData.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.mode !== void 0) this.mode = opts.mode;
    if (opts.srcAccelerationStructure !== void 0) this.srcAccelerationStructure = opts.srcAccelerationStructure;
    if (opts.dstAccelerationStructure !== void 0) this.dstAccelerationStructure = opts.dstAccelerationStructure;
    if (opts.geometryCount !== void 0) this.geometryCount = opts.geometryCount;
    if (opts.pGeometries !== void 0) this.pGeometries = opts.pGeometries;
    if (opts.ppGeometries !== void 0) this.ppGeometries = opts.ppGeometries;
    if (opts.scratchData !== void 0) this.scratchData = opts.scratchData;
    
  }
};

VkAccelerationStructureBuildGeometryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pGeometries !== null) {
    let array = this._pGeometries;
    
    if (array.length !== this.geometryCount) {
      throw new RangeError("Invalid array length, expected length of 'geometryCount' for 'VkAccelerationStructureBuildGeometryInfoKHR.pGeometries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAccelerationStructureGeometryKHR)) {
        throw new TypeError("Invalid type for 'VkAccelerationStructureBuildGeometryInfoKHR.pGeometries[" + ii + "]': Expected 'VkAccelerationStructureGeometryKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pGeometriesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pGeometriesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._ppGeometries !== null) {
    let array = this._ppGeometries;
    
    if (array.length !== this.geometryCount,1) {
      throw new RangeError("Invalid array length, expected length of 'geometryCount,1' for 'VkAccelerationStructureBuildGeometryInfoKHR.ppGeometries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkAccelerationStructureGeometryKHR)) {
        throw new TypeError("Invalid type for 'VkAccelerationStructureBuildGeometryInfoKHR.ppGeometries[" + ii + "]': Expected 'VkAccelerationStructureGeometryKHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._ppGeometriesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._ppGeometriesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  
  if (this._scratchData !== null) {
    let scratchData = this._scratchData;
    scratchData.flush();
    if (this.memoryBuffer !== scratchData.memoryBuffer) {
      let srcView = new Uint8Array(scratchData.memoryBuffer, scratchData.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureBuildGeometryInfoKHR.scratchData' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAccelerationStructureBuildGeometryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureBuildGeometryInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureBuildGeometryInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.type = original.type;
  copy.flags = original.flags;
  copy.mode = original.mode;
  if (original.srcAccelerationStructure !== null) {
        copy.srcAccelerationStructure = original.srcAccelerationStructure.constructor.createCopyFrom(original.srcAccelerationStructure);
      }
  if (original.dstAccelerationStructure !== null) {
        copy.dstAccelerationStructure = original.dstAccelerationStructure.constructor.createCopyFrom(original.dstAccelerationStructure);
      }
  copy.geometryCount = original.geometryCount;
  if (original.pGeometries !== null) {
        copy.pGeometries = [...Array(original.pGeometries.length)].map((v, i) => {
          return original.pGeometries[i].constructor.createCopyFrom(original.pGeometries[i]);
        });
      }
  if (original.ppGeometries !== null) {
        copy.ppGeometries = [...Array(original.ppGeometries.length)].map((v, i) => {
          return original.ppGeometries[i].constructor.createCopyFrom(original.ppGeometries[i]);
        });
      }
  if (original.scratchData !== null) {
        copy.scratchData = original.scratchData.constructor.createCopyFrom(original.scratchData);
      }
  
  return copy;
};

VkAccelerationStructureBuildGeometryInfoKHR.byteLength = 0x0;

VkAccelerationStructureBuildGeometryInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcAccelerationStructure: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstAccelerationStructure: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  geometryCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pGeometries: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  ppGeometries: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  scratchData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureBuildRangeInfoKHR **/
function VkAccelerationStructureBuildRangeInfoKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureBuildRangeInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureBuildRangeInfoKHR, STRUCT_CACHE_VkAccelerationStructureBuildRangeInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureBuildRangeInfoKHR, STRUCT_CACHE_VkAccelerationStructureBuildRangeInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureBuildRangeInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.primitiveCount !== void 0) this.primitiveCount = opts.primitiveCount;
    if (opts.primitiveOffset !== void 0) this.primitiveOffset = opts.primitiveOffset;
    if (opts.firstVertex !== void 0) this.firstVertex = opts.firstVertex;
    if (opts.transformOffset !== void 0) this.transformOffset = opts.transformOffset;
    
  }
};

Object.defineProperties(VkAccelerationStructureBuildRangeInfoKHR.prototype, {
  "primitiveCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureBuildRangeInfoKHR.primitiveCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "primitiveOffset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureBuildRangeInfoKHR.primitiveOffset");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "firstVertex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureBuildRangeInfoKHR.firstVertex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "transformOffset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureBuildRangeInfoKHR.transformOffset");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkAccelerationStructureBuildRangeInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.primitiveCount !== void 0) this.primitiveCount = opts.primitiveCount;
    if (opts.primitiveOffset !== void 0) this.primitiveOffset = opts.primitiveOffset;
    if (opts.firstVertex !== void 0) this.firstVertex = opts.firstVertex;
    if (opts.transformOffset !== void 0) this.transformOffset = opts.transformOffset;
    
  }
};

VkAccelerationStructureBuildRangeInfoKHR.prototype.flush = function flush() {
  
  return true;
};

VkAccelerationStructureBuildRangeInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureBuildRangeInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureBuildRangeInfoKHR();
  copy.primitiveCount = original.primitiveCount;
  copy.primitiveOffset = original.primitiveOffset;
  copy.firstVertex = original.firstVertex;
  copy.transformOffset = original.transformOffset;
  
  return copy;
};

VkAccelerationStructureBuildRangeInfoKHR.byteLength = 0x0;

VkAccelerationStructureBuildRangeInfoKHR.memoryLayout = {
  primitiveCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  primitiveOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  firstVertex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transformOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureCreateInfoKHR **/
function VkAccelerationStructureCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureCreateInfoKHR, STRUCT_CACHE_VkAccelerationStructureCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureCreateInfoKHR, STRUCT_CACHE_VkAccelerationStructureCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._buffer = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.createFlags !== void 0) this.createFlags = opts.createFlags;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    
  }
};

Object.defineProperties(VkAccelerationStructureCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "createFlags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureCreateInfoKHR.createFlags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "buffer": {
    get() {
    return this._buffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._buffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureCreateInfoKHR.buffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "offset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureCreateInfoKHR.offset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureCreateInfoKHR.size")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "type": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureCreateInfoKHR.type");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "deviceAddress": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureCreateInfoKHR.deviceAddress")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkAccelerationStructureCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._buffer = null;
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.createFlags !== void 0) this.createFlags = opts.createFlags;
    if (opts.buffer !== void 0) this.buffer = opts.buffer;
    if (opts.offset !== void 0) this.offset = opts.offset;
    if (opts.size !== void 0) this.size = opts.size;
    if (opts.type !== void 0) this.type = opts.type;
    if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
    
  }
};

VkAccelerationStructureCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAccelerationStructureCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.createFlags = original.createFlags;
  if (original.buffer !== null) {
        copy.buffer = original.buffer.constructor.createCopyFrom(original.buffer);
      }
  copy.offset = original.offset;
  copy.size = original.size;
  copy.type = original.type;
  copy.deviceAddress = original.deviceAddress;
  
  return copy;
};

VkAccelerationStructureCreateInfoKHR.byteLength = 0x0;

VkAccelerationStructureCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  createFlags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  offset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  type: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  deviceAddress: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAabbPositionsKHR **/
function VkAabbPositionsKHR(opts, byteOffset) {
  if (new.target !== VkAabbPositionsKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAabbPositionsKHR, STRUCT_CACHE_VkAabbPositionsKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAabbPositionsKHR, STRUCT_CACHE_VkAabbPositionsKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAabbPositionsKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.minX !== void 0) this.minX = opts.minX;
    if (opts.minY !== void 0) this.minY = opts.minY;
    if (opts.minZ !== void 0) this.minZ = opts.minZ;
    if (opts.maxX !== void 0) this.maxX = opts.maxX;
    if (opts.maxY !== void 0) this.maxY = opts.maxY;
    if (opts.maxZ !== void 0) this.maxZ = opts.maxZ;
    
  }
};

Object.defineProperties(VkAabbPositionsKHR.prototype, {
  "minX": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsKHR.minX");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "minY": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsKHR.minY");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "minZ": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsKHR.minZ");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxX": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsKHR.maxX");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxY": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsKHR.maxY");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxZ": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsKHR.maxZ");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkAabbPositionsKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.minX !== void 0) this.minX = opts.minX;
    if (opts.minY !== void 0) this.minY = opts.minY;
    if (opts.minZ !== void 0) this.minZ = opts.minZ;
    if (opts.maxX !== void 0) this.maxX = opts.maxX;
    if (opts.maxY !== void 0) this.maxY = opts.maxY;
    if (opts.maxZ !== void 0) this.maxZ = opts.maxZ;
    
  }
};

VkAabbPositionsKHR.prototype.flush = function flush() {
  
  return true;
};

VkAabbPositionsKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAabbPositionsKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAabbPositionsKHR();
  copy.minX = original.minX;
  copy.minY = original.minY;
  copy.minZ = original.minZ;
  copy.maxX = original.maxX;
  copy.maxY = original.maxY;
  copy.maxZ = original.maxZ;
  
  return copy;
};

VkAabbPositionsKHR.byteLength = 0x0;

VkAabbPositionsKHR.memoryLayout = {
  minX: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minY: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minZ: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxX: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxY: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxZ: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAabbPositionsNV **/
function VkAabbPositionsNV(opts, byteOffset) {
  if (new.target !== VkAabbPositionsNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAabbPositionsNV, STRUCT_CACHE_VkAabbPositionsNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAabbPositionsNV, STRUCT_CACHE_VkAabbPositionsNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAabbPositionsNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.minX !== void 0) this.minX = opts.minX;
    if (opts.minY !== void 0) this.minY = opts.minY;
    if (opts.minZ !== void 0) this.minZ = opts.minZ;
    if (opts.maxX !== void 0) this.maxX = opts.maxX;
    if (opts.maxY !== void 0) this.maxY = opts.maxY;
    if (opts.maxZ !== void 0) this.maxZ = opts.maxZ;
    
  }
};

Object.defineProperties(VkAabbPositionsNV.prototype, {
  "minX": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsNV.minX");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "minY": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsNV.minY");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "minZ": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsNV.minZ");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxX": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsNV.maxX");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxY": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsNV.maxY");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  "maxZ": {
    get() {
    return this.memoryView.getFloat32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAabbPositionsNV.maxZ");
    this.memoryView.setFloat32(0x0, value, true);
    }
    },
  
});

VkAabbPositionsNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.minX !== void 0) this.minX = opts.minX;
    if (opts.minY !== void 0) this.minY = opts.minY;
    if (opts.minZ !== void 0) this.minZ = opts.minZ;
    if (opts.maxX !== void 0) this.maxX = opts.maxX;
    if (opts.maxY !== void 0) this.maxY = opts.maxY;
    if (opts.maxZ !== void 0) this.maxZ = opts.maxZ;
    
  }
};

VkAabbPositionsNV.prototype.flush = function flush() {
  
  return true;
};

VkAabbPositionsNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkAabbPositionsNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAabbPositionsNV();
  copy.minX = original.minX;
  copy.minY = original.minY;
  copy.minZ = original.minZ;
  copy.maxX = original.maxX;
  copy.maxY = original.maxY;
  copy.maxZ = original.maxZ;
  
  return copy;
};

VkAabbPositionsNV.byteLength = 0x0;

VkAabbPositionsNV.memoryLayout = {
  minX: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minY: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minZ: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxX: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxY: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxZ: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkTransformMatrixKHR **/
function VkTransformMatrixKHR(opts, byteOffset) {
  if (new.target !== VkTransformMatrixKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkTransformMatrixKHR, STRUCT_CACHE_VkTransformMatrixKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkTransformMatrixKHR, STRUCT_CACHE_VkTransformMatrixKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkTransformMatrixKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._matrix = [...Array(3)].fill(0x0);
  
  if (typeof opts === "object") {
    if (opts.matrix !== void 0) this.matrix = opts.matrix;
    
  }
};

Object.defineProperties(VkTransformMatrixKHR.prototype, {
  "matrix": {
    get() {
    return this._matrix;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._matrix = value;
    } else if (value === null) {
      this._matrix = null;
    } else {
      throw new TypeError("Invalid type for 'VkTransformMatrixKHR.matrix': Expected 'Array float' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkTransformMatrixKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._matrix !== null) this._matrix.fill(0x0);
      else this._matrix = [...Array(3)].fill(0x0);
  
  if (typeof opts === "object") {
    if (opts.matrix !== void 0) this.matrix = opts.matrix;
    
  }
};

VkTransformMatrixKHR.prototype.flush = function flush() {
  
  
  if (this._matrix !== null) {
    let array = this._matrix;
    
    // validate length
    if (array.length !== 3][4) {
      throw new RangeError("Invalid array length, expected length of '3][4' for 'VkTransformMatrixKHR.matrix'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkTransformMatrixKHR.matrix[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryView.setFloat32(0x0 + (ii * 4), array[ii], true);
    };
  } else {
    this.memoryView.setFloat32(0x0, 0x0, true);
  }
  
  return true;
};

VkTransformMatrixKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkTransformMatrixKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkTransformMatrixKHR();
  if (original.matrix !== null) {
        copy.matrix = [...Array(original.matrix.length)].map((v, i) => {
          return original.matrix[i];
        });
      }
  
  return copy;
};

VkTransformMatrixKHR.byteLength = 0x0;

VkTransformMatrixKHR.memoryLayout = {
  matrix: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkTransformMatrixNV **/
function VkTransformMatrixNV(opts, byteOffset) {
  if (new.target !== VkTransformMatrixNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkTransformMatrixNV, STRUCT_CACHE_VkTransformMatrixNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkTransformMatrixNV, STRUCT_CACHE_VkTransformMatrixNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkTransformMatrixNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._matrix = [...Array(3)].fill(0x0);
  
  if (typeof opts === "object") {
    if (opts.matrix !== void 0) this.matrix = opts.matrix;
    
  }
};

Object.defineProperties(VkTransformMatrixNV.prototype, {
  "matrix": {
    get() {
    return this._matrix;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._matrix = value;
    } else if (value === null) {
      this._matrix = null;
    } else {
      throw new TypeError("Invalid type for 'VkTransformMatrixNV.matrix': Expected 'Array float' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkTransformMatrixNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._matrix !== null) this._matrix.fill(0x0);
      else this._matrix = [...Array(3)].fill(0x0);
  
  if (typeof opts === "object") {
    if (opts.matrix !== void 0) this.matrix = opts.matrix;
    
  }
};

VkTransformMatrixNV.prototype.flush = function flush() {
  
  
  if (this._matrix !== null) {
    let array = this._matrix;
    
    // validate length
    if (array.length !== 3][4) {
      throw new RangeError("Invalid array length, expected length of '3][4' for 'VkTransformMatrixNV.matrix'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (typeof (array[ii]) !== "number") {
        throw new TypeError("Invalid type for 'VkTransformMatrixNV.matrix[" + ii + "]': Expected 'Number' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryView.setFloat32(0x0 + (ii * 4), array[ii], true);
    };
  } else {
    this.memoryView.setFloat32(0x0, 0x0, true);
  }
  
  return true;
};

VkTransformMatrixNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkTransformMatrixNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkTransformMatrixNV();
  if (original.matrix !== null) {
        copy.matrix = [...Array(original.matrix.length)].map((v, i) => {
          return original.matrix[i];
        });
      }
  
  return copy;
};

VkTransformMatrixNV.byteLength = 0x0;

VkTransformMatrixNV.memoryLayout = {
  matrix: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureInstanceKHR **/
function VkAccelerationStructureInstanceKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureInstanceKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureInstanceKHR, STRUCT_CACHE_VkAccelerationStructureInstanceKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureInstanceKHR, STRUCT_CACHE_VkAccelerationStructureInstanceKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureInstanceKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._transform = new VkTransformMatrixKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.transform !== void 0) this.transform = opts.transform;
    if (opts.instanceCustomIndex !== void 0) this.instanceCustomIndex = opts.instanceCustomIndex;
    if (opts.mask !== void 0) this.mask = opts.mask;
    if (opts.instanceShaderBindingTableRecordOffset !== void 0) this.instanceShaderBindingTableRecordOffset = opts.instanceShaderBindingTableRecordOffset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.accelerationStructureReference !== void 0) this.accelerationStructureReference = opts.accelerationStructureReference;
    
  }
};

Object.defineProperties(VkAccelerationStructureInstanceKHR.prototype, {
  "transform": {
    get() {
    return this._transform;
    },
    set(value) {
    if (value !== null && value.constructor === VkTransformMatrixKHR) {
      value.flush();
      this._transform = value;
      
      
    } else if (value === null) {
      this._transform = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInstanceKHR.transform': Expected 'VkTransformMatrixKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "instanceCustomIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInstanceKHR.instanceCustomIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "mask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInstanceKHR.mask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "instanceShaderBindingTableRecordOffset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInstanceKHR.instanceShaderBindingTableRecordOffset");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInstanceKHR.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "accelerationStructureReference": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureInstanceKHR.accelerationStructureReference")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkAccelerationStructureInstanceKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._transform !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._transform.memoryBuffer) this._transform = new VkTransformMatrixKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._transform.reset();
  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.transform !== void 0) this.transform = opts.transform;
    if (opts.instanceCustomIndex !== void 0) this.instanceCustomIndex = opts.instanceCustomIndex;
    if (opts.mask !== void 0) this.mask = opts.mask;
    if (opts.instanceShaderBindingTableRecordOffset !== void 0) this.instanceShaderBindingTableRecordOffset = opts.instanceShaderBindingTableRecordOffset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.accelerationStructureReference !== void 0) this.accelerationStructureReference = opts.accelerationStructureReference;
    
  }
};

VkAccelerationStructureInstanceKHR.prototype.flush = function flush() {
  
  
  if (this._transform !== null) {
    let transform = this._transform;
    transform.flush();
    if (this.memoryBuffer !== transform.memoryBuffer) {
      let srcView = new Uint8Array(transform.memoryBuffer, transform.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureInstanceKHR.transform' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAccelerationStructureInstanceKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureInstanceKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureInstanceKHR();
  if (original.transform !== null) {
        copy.transform = original.transform.constructor.createCopyFrom(original.transform);
      }
  copy.instanceCustomIndex = original.instanceCustomIndex;
  copy.mask = original.mask;
  copy.instanceShaderBindingTableRecordOffset = original.instanceShaderBindingTableRecordOffset;
  copy.flags = original.flags;
  copy.accelerationStructureReference = original.accelerationStructureReference;
  
  return copy;
};

VkAccelerationStructureInstanceKHR.byteLength = 0x0;

VkAccelerationStructureInstanceKHR.memoryLayout = {
  transform: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  instanceCustomIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  instanceShaderBindingTableRecordOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructureReference: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureInstanceNV **/
function VkAccelerationStructureInstanceNV(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureInstanceNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureInstanceNV, STRUCT_CACHE_VkAccelerationStructureInstanceNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureInstanceNV, STRUCT_CACHE_VkAccelerationStructureInstanceNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureInstanceNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  this._transform = new VkTransformMatrixKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.transform !== void 0) this.transform = opts.transform;
    if (opts.instanceCustomIndex !== void 0) this.instanceCustomIndex = opts.instanceCustomIndex;
    if (opts.mask !== void 0) this.mask = opts.mask;
    if (opts.instanceShaderBindingTableRecordOffset !== void 0) this.instanceShaderBindingTableRecordOffset = opts.instanceShaderBindingTableRecordOffset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.accelerationStructureReference !== void 0) this.accelerationStructureReference = opts.accelerationStructureReference;
    
  }
};

Object.defineProperties(VkAccelerationStructureInstanceNV.prototype, {
  "transform": {
    get() {
    return this._transform;
    },
    set(value) {
    if (value !== null && value.constructor === VkTransformMatrixKHR) {
      value.flush();
      this._transform = value;
      
      
    } else if (value === null) {
      this._transform = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInstanceNV.transform': Expected 'VkTransformMatrixKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "instanceCustomIndex": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInstanceNV.instanceCustomIndex");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "mask": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInstanceNV.mask");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "instanceShaderBindingTableRecordOffset": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInstanceNV.instanceShaderBindingTableRecordOffset");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureInstanceNV.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "accelerationStructureReference": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureInstanceNV.accelerationStructureReference")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkAccelerationStructureInstanceNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  if (this._transform !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._transform.memoryBuffer) this._transform = new VkTransformMatrixKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._transform.reset();
  }
  
  
  
  
  
  
  if (typeof opts === "object") {
    if (opts.transform !== void 0) this.transform = opts.transform;
    if (opts.instanceCustomIndex !== void 0) this.instanceCustomIndex = opts.instanceCustomIndex;
    if (opts.mask !== void 0) this.mask = opts.mask;
    if (opts.instanceShaderBindingTableRecordOffset !== void 0) this.instanceShaderBindingTableRecordOffset = opts.instanceShaderBindingTableRecordOffset;
    if (opts.flags !== void 0) this.flags = opts.flags;
    if (opts.accelerationStructureReference !== void 0) this.accelerationStructureReference = opts.accelerationStructureReference;
    
  }
};

VkAccelerationStructureInstanceNV.prototype.flush = function flush() {
  
  
  if (this._transform !== null) {
    let transform = this._transform;
    transform.flush();
    if (this.memoryBuffer !== transform.memoryBuffer) {
      let srcView = new Uint8Array(transform.memoryBuffer, transform.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkAccelerationStructureInstanceNV.transform' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkAccelerationStructureInstanceNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureInstanceNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureInstanceNV();
  if (original.transform !== null) {
        copy.transform = original.transform.constructor.createCopyFrom(original.transform);
      }
  copy.instanceCustomIndex = original.instanceCustomIndex;
  copy.mask = original.mask;
  copy.instanceShaderBindingTableRecordOffset = original.instanceShaderBindingTableRecordOffset;
  copy.flags = original.flags;
  copy.accelerationStructureReference = original.accelerationStructureReference;
  
  return copy;
};

VkAccelerationStructureInstanceNV.byteLength = 0x0;

VkAccelerationStructureInstanceNV.memoryLayout = {
  transform: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  instanceCustomIndex: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  instanceShaderBindingTableRecordOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructureReference: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureDeviceAddressInfoKHR **/
function VkAccelerationStructureDeviceAddressInfoKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureDeviceAddressInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureDeviceAddressInfoKHR, STRUCT_CACHE_VkAccelerationStructureDeviceAddressInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureDeviceAddressInfoKHR, STRUCT_CACHE_VkAccelerationStructureDeviceAddressInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureDeviceAddressInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._accelerationStructure = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
    
  }
};

Object.defineProperties(VkAccelerationStructureDeviceAddressInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureDeviceAddressInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureDeviceAddressInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "accelerationStructure": {
    get() {
    return this._accelerationStructure;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureKHR) {
      
      this._accelerationStructure = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._accelerationStructure = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureDeviceAddressInfoKHR.accelerationStructure': Expected 'VkAccelerationStructureKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAccelerationStructureDeviceAddressInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._accelerationStructure = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
    
  }
};

VkAccelerationStructureDeviceAddressInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAccelerationStructureDeviceAddressInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureDeviceAddressInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureDeviceAddressInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.accelerationStructure !== null) {
        copy.accelerationStructure = original.accelerationStructure.constructor.createCopyFrom(original.accelerationStructure);
      }
  
  return copy;
};

VkAccelerationStructureDeviceAddressInfoKHR.byteLength = 0x0;

VkAccelerationStructureDeviceAddressInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructure: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureVersionInfoKHR **/
function VkAccelerationStructureVersionInfoKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureVersionInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureVersionInfoKHR, STRUCT_CACHE_VkAccelerationStructureVersionInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureVersionInfoKHR, STRUCT_CACHE_VkAccelerationStructureVersionInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureVersionInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._pVersionData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pVersionData !== void 0) this.pVersionData = opts.pVersionData;
    
  }
};

Object.defineProperties(VkAccelerationStructureVersionInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureVersionInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureVersionInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "pVersionData": {
    get() {
    return this._pVersionData;
    },
    set(value) {
    if (value !== null && value.constructor === Uint8Array) {
      this._pVersionData = value;
      this.memoryView.setBigInt64(0x0, getAddressFromArrayBuffer(value.buffer), true);
    } else if (value === null) {
      this._pVersionData = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureVersionInfoKHR.pVersionData': Expected 'Uint8Array' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkAccelerationStructureVersionInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._pVersionData = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pVersionData !== void 0) this.pVersionData = opts.pVersionData;
    
  }
};

VkAccelerationStructureVersionInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAccelerationStructureVersionInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureVersionInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureVersionInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.pVersionData !== null) {
        copy.pVersionData = new Uint8Array(original.pVersionData);
      }
  
  return copy;
};

VkAccelerationStructureVersionInfoKHR.byteLength = 0x0;

VkAccelerationStructureVersionInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pVersionData: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCopyAccelerationStructureInfoKHR **/
function VkCopyAccelerationStructureInfoKHR(opts, byteOffset) {
  if (new.target !== VkCopyAccelerationStructureInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCopyAccelerationStructureInfoKHR, STRUCT_CACHE_VkCopyAccelerationStructureInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCopyAccelerationStructureInfoKHR, STRUCT_CACHE_VkCopyAccelerationStructureInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCopyAccelerationStructureInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._src = null;
  this._dst = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.src !== void 0) this.src = opts.src;
    if (opts.dst !== void 0) this.dst = opts.dst;
    if (opts.mode !== void 0) this.mode = opts.mode;
    
  }
};

Object.defineProperties(VkCopyAccelerationStructureInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyAccelerationStructureInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCopyAccelerationStructureInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "src": {
    get() {
    return this._src;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureKHR) {
      
      this._src = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._src = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyAccelerationStructureInfoKHR.src': Expected 'VkAccelerationStructureKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dst": {
    get() {
    return this._dst;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureKHR) {
      
      this._dst = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dst = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyAccelerationStructureInfoKHR.dst': Expected 'VkAccelerationStructureKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "mode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyAccelerationStructureInfoKHR.mode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkCopyAccelerationStructureInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._src = null;
  this._dst = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.src !== void 0) this.src = opts.src;
    if (opts.dst !== void 0) this.dst = opts.dst;
    if (opts.mode !== void 0) this.mode = opts.mode;
    
  }
};

VkCopyAccelerationStructureInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCopyAccelerationStructureInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkCopyAccelerationStructureInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCopyAccelerationStructureInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.src !== null) {
        copy.src = original.src.constructor.createCopyFrom(original.src);
      }
  if (original.dst !== null) {
        copy.dst = original.dst.constructor.createCopyFrom(original.dst);
      }
  copy.mode = original.mode;
  
  return copy;
};

VkCopyAccelerationStructureInfoKHR.byteLength = 0x0;

VkCopyAccelerationStructureInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  src: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dst: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCopyAccelerationStructureToMemoryInfoKHR **/
function VkCopyAccelerationStructureToMemoryInfoKHR(opts, byteOffset) {
  if (new.target !== VkCopyAccelerationStructureToMemoryInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCopyAccelerationStructureToMemoryInfoKHR, STRUCT_CACHE_VkCopyAccelerationStructureToMemoryInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCopyAccelerationStructureToMemoryInfoKHR, STRUCT_CACHE_VkCopyAccelerationStructureToMemoryInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCopyAccelerationStructureToMemoryInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._src = null;
  this._dst = new VkDeviceOrHostAddressKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.src !== void 0) this.src = opts.src;
    if (opts.dst !== void 0) this.dst = opts.dst;
    if (opts.mode !== void 0) this.mode = opts.mode;
    
  }
};

Object.defineProperties(VkCopyAccelerationStructureToMemoryInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyAccelerationStructureToMemoryInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCopyAccelerationStructureToMemoryInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "src": {
    get() {
    return this._src;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureKHR) {
      
      this._src = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._src = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyAccelerationStructureToMemoryInfoKHR.src': Expected 'VkAccelerationStructureKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dst": {
    get() {
    return this._dst;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceOrHostAddressKHR) {
      value.flush();
      this._dst = value;
      
      
    } else if (value === null) {
      this._dst = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkCopyAccelerationStructureToMemoryInfoKHR.dst': Expected 'VkDeviceOrHostAddressKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "mode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyAccelerationStructureToMemoryInfoKHR.mode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkCopyAccelerationStructureToMemoryInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._src = null;
  if (this._dst !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dst.memoryBuffer) this._dst = new VkDeviceOrHostAddressKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dst.reset();
  }
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.src !== void 0) this.src = opts.src;
    if (opts.dst !== void 0) this.dst = opts.dst;
    if (opts.mode !== void 0) this.mode = opts.mode;
    
  }
};

VkCopyAccelerationStructureToMemoryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._dst !== null) {
    let dst = this._dst;
    dst.flush();
    if (this.memoryBuffer !== dst.memoryBuffer) {
      let srcView = new Uint8Array(dst.memoryBuffer, dst.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkCopyAccelerationStructureToMemoryInfoKHR.dst' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkCopyAccelerationStructureToMemoryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkCopyAccelerationStructureToMemoryInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCopyAccelerationStructureToMemoryInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.src !== null) {
        copy.src = original.src.constructor.createCopyFrom(original.src);
      }
  if (original.dst !== null) {
        copy.dst = original.dst.constructor.createCopyFrom(original.dst);
      }
  copy.mode = original.mode;
  
  return copy;
};

VkCopyAccelerationStructureToMemoryInfoKHR.byteLength = 0x0;

VkCopyAccelerationStructureToMemoryInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  src: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dst: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCopyMemoryToAccelerationStructureInfoKHR **/
function VkCopyMemoryToAccelerationStructureInfoKHR(opts, byteOffset) {
  if (new.target !== VkCopyMemoryToAccelerationStructureInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCopyMemoryToAccelerationStructureInfoKHR, STRUCT_CACHE_VkCopyMemoryToAccelerationStructureInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCopyMemoryToAccelerationStructureInfoKHR, STRUCT_CACHE_VkCopyMemoryToAccelerationStructureInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCopyMemoryToAccelerationStructureInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._src = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dst = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.src !== void 0) this.src = opts.src;
    if (opts.dst !== void 0) this.dst = opts.dst;
    if (opts.mode !== void 0) this.mode = opts.mode;
    
  }
};

Object.defineProperties(VkCopyMemoryToAccelerationStructureInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyMemoryToAccelerationStructureInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCopyMemoryToAccelerationStructureInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "src": {
    get() {
    return this._src;
    },
    set(value) {
    if (value !== null && value.constructor === VkDeviceOrHostAddressConstKHR) {
      value.flush();
      this._src = value;
      
      
    } else if (value === null) {
      this._src = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkCopyMemoryToAccelerationStructureInfoKHR.src': Expected 'VkDeviceOrHostAddressConstKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dst": {
    get() {
    return this._dst;
    },
    set(value) {
    if (value !== null && value.constructor === VkAccelerationStructureKHR) {
      
      this._dst = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dst = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyMemoryToAccelerationStructureInfoKHR.dst': Expected 'VkAccelerationStructureKHR' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "mode": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyMemoryToAccelerationStructureInfoKHR.mode");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkCopyMemoryToAccelerationStructureInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._src !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._src.memoryBuffer) this._src = new VkDeviceOrHostAddressConstKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._src.reset();
  }
  this._dst = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.src !== void 0) this.src = opts.src;
    if (opts.dst !== void 0) this.dst = opts.dst;
    if (opts.mode !== void 0) this.mode = opts.mode;
    
  }
};

VkCopyMemoryToAccelerationStructureInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._src !== null) {
    let src = this._src;
    src.flush();
    if (this.memoryBuffer !== src.memoryBuffer) {
      let srcView = new Uint8Array(src.memoryBuffer, src.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkCopyMemoryToAccelerationStructureInfoKHR.src' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkCopyMemoryToAccelerationStructureInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkCopyMemoryToAccelerationStructureInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCopyMemoryToAccelerationStructureInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.src !== null) {
        copy.src = original.src.constructor.createCopyFrom(original.src);
      }
  if (original.dst !== null) {
        copy.dst = original.dst.constructor.createCopyFrom(original.dst);
      }
  copy.mode = original.mode;
  
  return copy;
};

VkCopyMemoryToAccelerationStructureInfoKHR.byteLength = 0x0;

VkCopyMemoryToAccelerationStructureInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  src: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dst: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  mode: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRayTracingPipelineInterfaceCreateInfoKHR **/
function VkRayTracingPipelineInterfaceCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkRayTracingPipelineInterfaceCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRayTracingPipelineInterfaceCreateInfoKHR, STRUCT_CACHE_VkRayTracingPipelineInterfaceCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRayTracingPipelineInterfaceCreateInfoKHR, STRUCT_CACHE_VkRayTracingPipelineInterfaceCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRayTracingPipelineInterfaceCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.maxPipelineRayPayloadSize !== void 0) this.maxPipelineRayPayloadSize = opts.maxPipelineRayPayloadSize;
    if (opts.maxPipelineRayHitAttributeSize !== void 0) this.maxPipelineRayHitAttributeSize = opts.maxPipelineRayHitAttributeSize;
    
  }
};

Object.defineProperties(VkRayTracingPipelineInterfaceCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineInterfaceCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRayTracingPipelineInterfaceCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "maxPipelineRayPayloadSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineInterfaceCreateInfoKHR.maxPipelineRayPayloadSize");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "maxPipelineRayHitAttributeSize": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRayTracingPipelineInterfaceCreateInfoKHR.maxPipelineRayHitAttributeSize");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  
});

VkRayTracingPipelineInterfaceCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.maxPipelineRayPayloadSize !== void 0) this.maxPipelineRayPayloadSize = opts.maxPipelineRayPayloadSize;
    if (opts.maxPipelineRayHitAttributeSize !== void 0) this.maxPipelineRayHitAttributeSize = opts.maxPipelineRayHitAttributeSize;
    
  }
};

VkRayTracingPipelineInterfaceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRayTracingPipelineInterfaceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkRayTracingPipelineInterfaceCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRayTracingPipelineInterfaceCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxPipelineRayPayloadSize = original.maxPipelineRayPayloadSize;
  copy.maxPipelineRayHitAttributeSize = original.maxPipelineRayHitAttributeSize;
  
  return copy;
};

VkRayTracingPipelineInterfaceCreateInfoKHR.byteLength = 0x0;

VkRayTracingPipelineInterfaceCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPipelineRayPayloadSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxPipelineRayHitAttributeSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineLibraryCreateInfoKHR **/
function VkPipelineLibraryCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkPipelineLibraryCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineLibraryCreateInfoKHR, STRUCT_CACHE_VkPipelineLibraryCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineLibraryCreateInfoKHR, STRUCT_CACHE_VkPipelineLibraryCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineLibraryCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._pLibraries = null;
  this._pLibrariesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.libraryCount !== void 0) this.libraryCount = opts.libraryCount;
    if (opts.pLibraries !== void 0) this.pLibraries = opts.pLibraries;
    
  }
};

Object.defineProperties(VkPipelineLibraryCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineLibraryCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineLibraryCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "libraryCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineLibraryCreateInfoKHR.libraryCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pLibraries": {
    get() {
    if (this._pLibraries === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.libraryCount, VkPipeline);
      this._pLibraries = array;
      return this.pLibraries;
    } else {
      return this._pLibraries;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pLibraries = value;
    } else if (value === null) {
      this._pLibraries = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineLibraryCreateInfoKHR.pLibraries': Expected 'Array VkPipeline' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkPipelineLibraryCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this._pLibraries = null;
  this._pLibrariesNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.libraryCount !== void 0) this.libraryCount = opts.libraryCount;
    if (opts.pLibraries !== void 0) this.pLibraries = opts.pLibraries;
    
  }
};

VkPipelineLibraryCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pLibraries !== null) {
    let array = this._pLibraries;
    
    if (array.length !== this.libraryCount) {
      throw new RangeError("Invalid array length, expected length of 'libraryCount' for 'VkPipelineLibraryCreateInfoKHR.pLibraries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkPipeline)) {
        throw new TypeError("Invalid type for 'VkPipelineLibraryCreateInfoKHR.pLibraries[" + ii + "]': Expected 'VkPipeline' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pLibrariesNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pLibrariesNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkPipelineLibraryCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineLibraryCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineLibraryCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.libraryCount = original.libraryCount;
  if (original.pLibraries !== null) {
        copy.pLibraries = [...Array(original.pLibraries.length)].map((v, i) => {
          return original.pLibraries[i].constructor.createCopyFrom(original.pLibraries[i]);
        });
      }
  
  return copy;
};

VkPipelineLibraryCreateInfoKHR.byteLength = 0x0;

VkPipelineLibraryCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  libraryCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pLibraries: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceExtendedDynamicStateFeaturesEXT **/
function VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceExtendedDynamicStateFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceExtendedDynamicStateFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.extendedDynamicState !== void 0) this.extendedDynamicState = opts.extendedDynamicState;
    
  }
};

Object.defineProperties(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "extendedDynamicState": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.extendedDynamicState !== void 0) this.extendedDynamicState = opts.extendedDynamicState;
    
  }
};

VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceExtendedDynamicStateFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.extendedDynamicState = original.extendedDynamicState;
  
  return copy;
};

VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extendedDynamicState: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkRenderPassTransformBeginInfoQCOM **/
function VkRenderPassTransformBeginInfoQCOM(opts, byteOffset) {
  if (new.target !== VkRenderPassTransformBeginInfoQCOM) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkRenderPassTransformBeginInfoQCOM, STRUCT_CACHE_VkRenderPassTransformBeginInfoQCOM);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkRenderPassTransformBeginInfoQCOM, STRUCT_CACHE_VkRenderPassTransformBeginInfoQCOM);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkRenderPassTransformBeginInfoQCOM'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.transform !== void 0) this.transform = opts.transform;
    
  }
};

Object.defineProperties(VkRenderPassTransformBeginInfoQCOM.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassTransformBeginInfoQCOM.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkRenderPassTransformBeginInfoQCOM.pNext' isn't allowed to be filled");
    }
    },
  "transform": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkRenderPassTransformBeginInfoQCOM.transform");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkRenderPassTransformBeginInfoQCOM.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.transform !== void 0) this.transform = opts.transform;
    
  }
};

VkRenderPassTransformBeginInfoQCOM.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRenderPassTransformBeginInfoQCOM.prototype.reflect = function reflect(memoryAddress) {
  };

VkRenderPassTransformBeginInfoQCOM.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkRenderPassTransformBeginInfoQCOM();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.transform = original.transform;
  
  return copy;
};

VkRenderPassTransformBeginInfoQCOM.byteLength = 0x0;

VkRenderPassTransformBeginInfoQCOM.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transform: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCopyCommandTransformInfoQCOM **/
function VkCopyCommandTransformInfoQCOM(opts, byteOffset) {
  if (new.target !== VkCopyCommandTransformInfoQCOM) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCopyCommandTransformInfoQCOM, STRUCT_CACHE_VkCopyCommandTransformInfoQCOM);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCopyCommandTransformInfoQCOM, STRUCT_CACHE_VkCopyCommandTransformInfoQCOM);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCopyCommandTransformInfoQCOM'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.transform !== void 0) this.transform = opts.transform;
    
  }
};

Object.defineProperties(VkCopyCommandTransformInfoQCOM.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyCommandTransformInfoQCOM.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCopyCommandTransformInfoQCOM.pNext' isn't allowed to be filled");
    }
    },
  "transform": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyCommandTransformInfoQCOM.transform");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkCopyCommandTransformInfoQCOM.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.transform !== void 0) this.transform = opts.transform;
    
  }
};

VkCopyCommandTransformInfoQCOM.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCopyCommandTransformInfoQCOM.prototype.reflect = function reflect(memoryAddress) {
  };

VkCopyCommandTransformInfoQCOM.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCopyCommandTransformInfoQCOM();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.transform = original.transform;
  
  return copy;
};

VkCopyCommandTransformInfoQCOM.byteLength = 0x0;

VkCopyCommandTransformInfoQCOM.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transform: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCommandBufferInheritanceRenderPassTransformInfoQCOM **/
function VkCommandBufferInheritanceRenderPassTransformInfoQCOM(opts, byteOffset) {
  if (new.target !== VkCommandBufferInheritanceRenderPassTransformInfoQCOM) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCommandBufferInheritanceRenderPassTransformInfoQCOM, STRUCT_CACHE_VkCommandBufferInheritanceRenderPassTransformInfoQCOM);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCommandBufferInheritanceRenderPassTransformInfoQCOM, STRUCT_CACHE_VkCommandBufferInheritanceRenderPassTransformInfoQCOM);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCommandBufferInheritanceRenderPassTransformInfoQCOM'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._renderArea = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.transform !== void 0) this.transform = opts.transform;
    if (opts.renderArea !== void 0) this.renderArea = opts.renderArea;
    
  }
};

Object.defineProperties(VkCommandBufferInheritanceRenderPassTransformInfoQCOM.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferInheritanceRenderPassTransformInfoQCOM.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCommandBufferInheritanceRenderPassTransformInfoQCOM.pNext' isn't allowed to be filled");
    }
    },
  "transform": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCommandBufferInheritanceRenderPassTransformInfoQCOM.transform");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "renderArea": {
    get() {
    return this._renderArea;
    },
    set(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._renderArea = value;
      
      
    } else if (value === null) {
      this._renderArea = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceRenderPassTransformInfoQCOM.renderArea': Expected 'VkRect2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkCommandBufferInheritanceRenderPassTransformInfoQCOM.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._renderArea !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._renderArea.memoryBuffer) this._renderArea = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._renderArea.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.transform !== void 0) this.transform = opts.transform;
    if (opts.renderArea !== void 0) this.renderArea = opts.renderArea;
    
  }
};

VkCommandBufferInheritanceRenderPassTransformInfoQCOM.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._renderArea !== null) {
    let renderArea = this._renderArea;
    renderArea.flush();
    if (this.memoryBuffer !== renderArea.memoryBuffer) {
      let srcView = new Uint8Array(renderArea.memoryBuffer, renderArea.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkCommandBufferInheritanceRenderPassTransformInfoQCOM.renderArea' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkCommandBufferInheritanceRenderPassTransformInfoQCOM.prototype.reflect = function reflect(memoryAddress) {
  };

VkCommandBufferInheritanceRenderPassTransformInfoQCOM.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCommandBufferInheritanceRenderPassTransformInfoQCOM();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.transform = original.transform;
  if (original.renderArea !== null) {
        copy.renderArea = original.renderArea.constructor.createCopyFrom(original.renderArea);
      }
  
  return copy;
};

VkCommandBufferInheritanceRenderPassTransformInfoQCOM.byteLength = 0x0;

VkCommandBufferInheritanceRenderPassTransformInfoQCOM.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  transform: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  renderArea: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceDiagnosticsConfigFeaturesNV **/
function VkPhysicalDeviceDiagnosticsConfigFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceDiagnosticsConfigFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceDiagnosticsConfigFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceDiagnosticsConfigFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceDiagnosticsConfigFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceDiagnosticsConfigFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceDiagnosticsConfigFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.diagnosticsConfig !== void 0) this.diagnosticsConfig = opts.diagnosticsConfig;
    
  }
};

Object.defineProperties(VkPhysicalDeviceDiagnosticsConfigFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceDiagnosticsConfigFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceDiagnosticsConfigFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "diagnosticsConfig": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceDiagnosticsConfigFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.diagnosticsConfig !== void 0) this.diagnosticsConfig = opts.diagnosticsConfig;
    
  }
};

VkPhysicalDeviceDiagnosticsConfigFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDiagnosticsConfigFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceDiagnosticsConfigFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceDiagnosticsConfigFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.diagnosticsConfig = original.diagnosticsConfig;
  
  return copy;
};

VkPhysicalDeviceDiagnosticsConfigFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceDiagnosticsConfigFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  diagnosticsConfig: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkDeviceDiagnosticsConfigCreateInfoNV **/
function VkDeviceDiagnosticsConfigCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkDeviceDiagnosticsConfigCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkDeviceDiagnosticsConfigCreateInfoNV, STRUCT_CACHE_VkDeviceDiagnosticsConfigCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkDeviceDiagnosticsConfigCreateInfoNV, STRUCT_CACHE_VkDeviceDiagnosticsConfigCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkDeviceDiagnosticsConfigCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

Object.defineProperties(VkDeviceDiagnosticsConfigCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceDiagnosticsConfigCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkDeviceDiagnosticsConfigCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "flags": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkDeviceDiagnosticsConfigCreateInfoNV.flags");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkDeviceDiagnosticsConfigCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.flags !== void 0) this.flags = opts.flags;
    
  }
};

VkDeviceDiagnosticsConfigCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceDiagnosticsConfigCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkDeviceDiagnosticsConfigCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkDeviceDiagnosticsConfigCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.flags = original.flags;
  
  return copy;
};

VkDeviceDiagnosticsConfigCreateInfoNV.byteLength = 0x0;

VkDeviceDiagnosticsConfigCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  flags: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceRobustness2FeaturesEXT **/
function VkPhysicalDeviceRobustness2FeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceRobustness2FeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceRobustness2FeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceRobustness2FeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceRobustness2FeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceRobustness2FeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceRobustness2FeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.robustBufferAccess2 !== void 0) this.robustBufferAccess2 = opts.robustBufferAccess2;
    if (opts.robustImageAccess2 !== void 0) this.robustImageAccess2 = opts.robustImageAccess2;
    if (opts.nullDescriptor !== void 0) this.nullDescriptor = opts.nullDescriptor;
    
  }
};

Object.defineProperties(VkPhysicalDeviceRobustness2FeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceRobustness2FeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceRobustness2FeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "robustBufferAccess2": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "robustImageAccess2": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "nullDescriptor": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceRobustness2FeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.robustBufferAccess2 !== void 0) this.robustBufferAccess2 = opts.robustBufferAccess2;
    if (opts.robustImageAccess2 !== void 0) this.robustImageAccess2 = opts.robustImageAccess2;
    if (opts.nullDescriptor !== void 0) this.nullDescriptor = opts.nullDescriptor;
    
  }
};

VkPhysicalDeviceRobustness2FeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRobustness2FeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceRobustness2FeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceRobustness2FeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.robustBufferAccess2 = original.robustBufferAccess2;
  copy.robustImageAccess2 = original.robustImageAccess2;
  copy.nullDescriptor = original.nullDescriptor;
  
  return copy;
};

VkPhysicalDeviceRobustness2FeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceRobustness2FeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  robustBufferAccess2: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  robustImageAccess2: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  nullDescriptor: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceRobustness2PropertiesEXT **/
function VkPhysicalDeviceRobustness2PropertiesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceRobustness2PropertiesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceRobustness2PropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceRobustness2PropertiesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceRobustness2PropertiesEXT, STRUCT_CACHE_VkPhysicalDeviceRobustness2PropertiesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceRobustness2PropertiesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceRobustness2PropertiesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceRobustness2PropertiesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceRobustness2PropertiesEXT.pNext' isn't allowed to be filled");
    }
    },
  "robustStorageBufferAccessSizeAlignment": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  "robustUniformBufferAccessSizeAlignment": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    },
  
});

VkPhysicalDeviceRobustness2PropertiesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceRobustness2PropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRobustness2PropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceRobustness2PropertiesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceRobustness2PropertiesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.robustStorageBufferAccessSizeAlignment = original.robustStorageBufferAccessSizeAlignment;
  copy.robustUniformBufferAccessSizeAlignment = original.robustUniformBufferAccessSizeAlignment;
  
  return copy;
};

VkPhysicalDeviceRobustness2PropertiesEXT.byteLength = 0x0;

VkPhysicalDeviceRobustness2PropertiesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  robustStorageBufferAccessSizeAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  robustUniformBufferAccessSizeAlignment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceImageRobustnessFeaturesEXT **/
function VkPhysicalDeviceImageRobustnessFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceImageRobustnessFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceImageRobustnessFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceImageRobustnessFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceImageRobustnessFeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceImageRobustnessFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceImageRobustnessFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.robustImageAccess !== void 0) this.robustImageAccess = opts.robustImageAccess;
    
  }
};

Object.defineProperties(VkPhysicalDeviceImageRobustnessFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceImageRobustnessFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceImageRobustnessFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "robustImageAccess": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceImageRobustnessFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.robustImageAccess !== void 0) this.robustImageAccess = opts.robustImageAccess;
    
  }
};

VkPhysicalDeviceImageRobustnessFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageRobustnessFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceImageRobustnessFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceImageRobustnessFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.robustImageAccess = original.robustImageAccess;
  
  return copy;
};

VkPhysicalDeviceImageRobustnessFeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceImageRobustnessFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  robustImageAccess: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDevice4444FormatsFeaturesEXT **/
function VkPhysicalDevice4444FormatsFeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDevice4444FormatsFeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDevice4444FormatsFeaturesEXT, STRUCT_CACHE_VkPhysicalDevice4444FormatsFeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDevice4444FormatsFeaturesEXT, STRUCT_CACHE_VkPhysicalDevice4444FormatsFeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDevice4444FormatsFeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.formatA4R4G4B4 !== void 0) this.formatA4R4G4B4 = opts.formatA4R4G4B4;
    if (opts.formatA4B4G4R4 !== void 0) this.formatA4B4G4R4 = opts.formatA4B4G4R4;
    
  }
};

Object.defineProperties(VkPhysicalDevice4444FormatsFeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDevice4444FormatsFeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDevice4444FormatsFeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "formatA4R4G4B4": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "formatA4B4G4R4": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDevice4444FormatsFeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.formatA4R4G4B4 !== void 0) this.formatA4R4G4B4 = opts.formatA4R4G4B4;
    if (opts.formatA4B4G4R4 !== void 0) this.formatA4B4G4R4 = opts.formatA4B4G4R4;
    
  }
};

VkPhysicalDevice4444FormatsFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice4444FormatsFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDevice4444FormatsFeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDevice4444FormatsFeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.formatA4R4G4B4 = original.formatA4R4G4B4;
  copy.formatA4B4G4R4 = original.formatA4B4G4R4;
  
  return copy;
};

VkPhysicalDevice4444FormatsFeaturesEXT.byteLength = 0x0;

VkPhysicalDevice4444FormatsFeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  formatA4R4G4B4: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  formatA4B4G4R4: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferCopy2KHR **/
function VkBufferCopy2KHR(opts, byteOffset) {
  if (new.target !== VkBufferCopy2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferCopy2KHR, STRUCT_CACHE_VkBufferCopy2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferCopy2KHR, STRUCT_CACHE_VkBufferCopy2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferCopy2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

Object.defineProperties(VkBufferCopy2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferCopy2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBufferCopy2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferCopy2KHR.srcOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "dstOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferCopy2KHR.dstOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "size": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferCopy2KHR.size")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkBufferCopy2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.size !== void 0) this.size = opts.size;
    
  }
};

VkBufferCopy2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferCopy2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferCopy2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferCopy2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.srcOffset = original.srcOffset;
  copy.dstOffset = original.dstOffset;
  copy.size = original.size;
  
  return copy;
};

VkBufferCopy2KHR.byteLength = 0x0;

VkBufferCopy2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  size: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageCopy2KHR **/
function VkImageCopy2KHR(opts, byteOffset) {
  if (new.target !== VkImageCopy2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageCopy2KHR, STRUCT_CACHE_VkImageCopy2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageCopy2KHR, STRUCT_CACHE_VkImageCopy2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageCopy2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

Object.defineProperties(VkImageCopy2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageCopy2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageCopy2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcSubresource": {
    get() {
    return this._srcSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy2KHR.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcOffset": {
    get() {
    return this._srcOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._srcOffset = value;
      
      
    } else if (value === null) {
      this._srcOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy2KHR.srcOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstSubresource": {
    get() {
    return this._dstSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy2KHR.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstOffset": {
    get() {
    return this._dstOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._dstOffset = value;
      
      
    } else if (value === null) {
      this._dstOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy2KHR.dstOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy2KHR.extent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageCopy2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._srcSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcSubresource.memoryBuffer) this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcSubresource.reset();
  }
  if (this._srcOffset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcOffset.memoryBuffer) this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcOffset.reset();
  }
  if (this._dstSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstSubresource.memoryBuffer) this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstSubresource.reset();
  }
  if (this._dstOffset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstOffset.memoryBuffer) this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstOffset.reset();
  }
  if (this._extent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._extent.memoryBuffer) this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._extent.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

VkImageCopy2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._srcSubresource !== null) {
    let srcSubresource = this._srcSubresource;
    srcSubresource.flush();
    if (this.memoryBuffer !== srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(srcSubresource.memoryBuffer, srcSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy2KHR.srcSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._srcOffset !== null) {
    let srcOffset = this._srcOffset;
    srcOffset.flush();
    if (this.memoryBuffer !== srcOffset.memoryBuffer) {
      let srcView = new Uint8Array(srcOffset.memoryBuffer, srcOffset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy2KHR.srcOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstSubresource !== null) {
    let dstSubresource = this._dstSubresource;
    dstSubresource.flush();
    if (this.memoryBuffer !== dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(dstSubresource.memoryBuffer, dstSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy2KHR.dstSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstOffset !== null) {
    let dstOffset = this._dstOffset;
    dstOffset.flush();
    if (this.memoryBuffer !== dstOffset.memoryBuffer) {
      let srcView = new Uint8Array(dstOffset.memoryBuffer, dstOffset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy2KHR.dstOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer, extent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageCopy2KHR.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageCopy2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageCopy2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageCopy2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcSubresource !== null) {
        copy.srcSubresource = original.srcSubresource.constructor.createCopyFrom(original.srcSubresource);
      }
  if (original.srcOffset !== null) {
        copy.srcOffset = original.srcOffset.constructor.createCopyFrom(original.srcOffset);
      }
  if (original.dstSubresource !== null) {
        copy.dstSubresource = original.dstSubresource.constructor.createCopyFrom(original.dstSubresource);
      }
  if (original.dstOffset !== null) {
        copy.dstOffset = original.dstOffset.constructor.createCopyFrom(original.dstOffset);
      }
  if (original.extent !== null) {
        copy.extent = original.extent.constructor.createCopyFrom(original.extent);
      }
  
  return copy;
};

VkImageCopy2KHR.byteLength = 0x0;

VkImageCopy2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageBlit2KHR **/
function VkImageBlit2KHR(opts, byteOffset) {
  if (new.target !== VkImageBlit2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageBlit2KHR, STRUCT_CACHE_VkImageBlit2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageBlit2KHR, STRUCT_CACHE_VkImageBlit2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageBlit2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._srcOffsets = [...Array(2)].map((v, i) => new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 + (i * 0x0) }));
  this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstOffsets = [...Array(2)].map((v, i) => new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 + (i * 0x0) }));
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffsets !== void 0) this.srcOffsets = opts.srcOffsets;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffsets !== void 0) this.dstOffsets = opts.dstOffsets;
    
  }
};

Object.defineProperties(VkImageBlit2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageBlit2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageBlit2KHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageBlit2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit2KHR.pNext'");
    }
    
    }
    },
  "srcSubresource": {
    get() {
    return this._srcSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit2KHR.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcOffsets": {
    get() {
    return this._srcOffsets;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._srcOffsets = value;
    } else if (value === null) {
      this._srcOffsets = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit2KHR.srcOffsets': Expected 'Array VkOffset3D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "dstSubresource": {
    get() {
    return this._dstSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit2KHR.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstOffsets": {
    get() {
    return this._dstOffsets;
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._dstOffsets = value;
    } else if (value === null) {
      this._dstOffsets = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit2KHR.dstOffsets': Expected 'Array VkOffset3D' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkImageBlit2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._srcSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcSubresource.memoryBuffer) this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcSubresource.reset();
  }
  if (this._srcOffsets !== null) {
    let array = this._srcOffsets;
    for (let ii = 0; ii < array.length; ++ii) {
      array[ii].reset();
    };
  }
  if (this._dstSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstSubresource.memoryBuffer) this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstSubresource.reset();
  }
  if (this._dstOffsets !== null) {
    let array = this._dstOffsets;
    for (let ii = 0; ii < array.length; ++ii) {
      array[ii].reset();
    };
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffsets !== void 0) this.srcOffsets = opts.srcOffsets;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffsets !== void 0) this.dstOffsets = opts.dstOffsets;
    
  }
};

VkImageBlit2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._srcSubresource !== null) {
    let srcSubresource = this._srcSubresource;
    srcSubresource.flush();
    if (this.memoryBuffer !== srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(srcSubresource.memoryBuffer, srcSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageBlit2KHR.srcSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._srcOffsets !== null) {
    let array = this._srcOffsets;
    
    if (array.length !== 2) {
      throw new RangeError("Invalid array length, expected length of '2' for 'VkImageBlit2KHR.srcOffsets'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkOffset3D)) {
        throw new TypeError("Invalid type for 'VkImageBlit2KHR.srcOffsets[" + ii + "]': Expected 'VkOffset3D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let dstView = new Uint8Array(this.memoryBuffer);
    let byteOffset = 0x0;
    for (let ii = 0; ii < array.length; ++ii) {
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      dstView.set(srcView, byteOffset);
      byteOffset += VkOffset3D.byteLength;
    };
  }
  
  
  if (this._dstSubresource !== null) {
    let dstSubresource = this._dstSubresource;
    dstSubresource.flush();
    if (this.memoryBuffer !== dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(dstSubresource.memoryBuffer, dstSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageBlit2KHR.dstSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstOffsets !== null) {
    let array = this._dstOffsets;
    
    if (array.length !== 2) {
      throw new RangeError("Invalid array length, expected length of '2' for 'VkImageBlit2KHR.dstOffsets'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkOffset3D)) {
        throw new TypeError("Invalid type for 'VkImageBlit2KHR.dstOffsets[" + ii + "]': Expected 'VkOffset3D' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let dstView = new Uint8Array(this.memoryBuffer);
    let byteOffset = 0x0;
    for (let ii = 0; ii < array.length; ++ii) {
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      dstView.set(srcView, byteOffset);
      byteOffset += VkOffset3D.byteLength;
    };
  }
  
  return true;
};

VkImageBlit2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageBlit2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageBlit2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcSubresource !== null) {
        copy.srcSubresource = original.srcSubresource.constructor.createCopyFrom(original.srcSubresource);
      }
  if (original.srcOffsets !== null) {
        copy.srcOffsets = [...Array(original.srcOffsets.length)].map((v, i) => {
          return original.srcOffsets[i].constructor.createCopyFrom(original.srcOffsets[i]);
        });
      }
  if (original.dstSubresource !== null) {
        copy.dstSubresource = original.dstSubresource.constructor.createCopyFrom(original.dstSubresource);
      }
  if (original.dstOffsets !== null) {
        copy.dstOffsets = [...Array(original.dstOffsets.length)].map((v, i) => {
          return original.dstOffsets[i].constructor.createCopyFrom(original.dstOffsets[i]);
        });
      }
  
  return copy;
};

VkImageBlit2KHR.byteLength = 0x0;

VkImageBlit2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcOffsets: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstOffsets: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBufferImageCopy2KHR **/
function VkBufferImageCopy2KHR(opts, byteOffset) {
  if (new.target !== VkBufferImageCopy2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBufferImageCopy2KHR, STRUCT_CACHE_VkBufferImageCopy2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBufferImageCopy2KHR, STRUCT_CACHE_VkBufferImageCopy2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBufferImageCopy2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this._imageSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._imageOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._imageExtent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferOffset !== void 0) this.bufferOffset = opts.bufferOffset;
    if (opts.bufferRowLength !== void 0) this.bufferRowLength = opts.bufferRowLength;
    if (opts.bufferImageHeight !== void 0) this.bufferImageHeight = opts.bufferImageHeight;
    if (opts.imageSubresource !== void 0) this.imageSubresource = opts.imageSubresource;
    if (opts.imageOffset !== void 0) this.imageOffset = opts.imageOffset;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    
  }
};

Object.defineProperties(VkBufferImageCopy2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferImageCopy2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBufferImageCopy2KHR.pNext'");
      switch (sType) {
          
        case :
          break;
        default:
          throw new TypeError("Invalid type for 'VkBufferImageCopy2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
    } else if (value === null) {
      this._pNext = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy2KHR.pNext'");
    }
    
    }
    },
  "bufferOffset": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkBufferImageCopy2KHR.bufferOffset")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "bufferRowLength": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferImageCopy2KHR.bufferRowLength");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "bufferImageHeight": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBufferImageCopy2KHR.bufferImageHeight");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "imageSubresource": {
    get() {
    return this._imageSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._imageSubresource = value;
      
      
    } else if (value === null) {
      this._imageSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy2KHR.imageSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageOffset": {
    get() {
    return this._imageOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._imageOffset = value;
      
      
    } else if (value === null) {
      this._imageOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy2KHR.imageOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "imageExtent": {
    get() {
    return this._imageExtent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._imageExtent = value;
      
      
    } else if (value === null) {
      this._imageExtent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy2KHR.imageExtent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkBufferImageCopy2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  if (this._imageSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageSubresource.memoryBuffer) this._imageSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageSubresource.reset();
  }
  if (this._imageOffset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageOffset.memoryBuffer) this._imageOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageOffset.reset();
  }
  if (this._imageExtent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._imageExtent.memoryBuffer) this._imageExtent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._imageExtent.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.bufferOffset !== void 0) this.bufferOffset = opts.bufferOffset;
    if (opts.bufferRowLength !== void 0) this.bufferRowLength = opts.bufferRowLength;
    if (opts.bufferImageHeight !== void 0) this.bufferImageHeight = opts.bufferImageHeight;
    if (opts.imageSubresource !== void 0) this.imageSubresource = opts.imageSubresource;
    if (opts.imageOffset !== void 0) this.imageOffset = opts.imageOffset;
    if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
    
  }
};

VkBufferImageCopy2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._imageSubresource !== null) {
    let imageSubresource = this._imageSubresource;
    imageSubresource.flush();
    if (this.memoryBuffer !== imageSubresource.memoryBuffer) {
      let srcView = new Uint8Array(imageSubresource.memoryBuffer, imageSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkBufferImageCopy2KHR.imageSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._imageOffset !== null) {
    let imageOffset = this._imageOffset;
    imageOffset.flush();
    if (this.memoryBuffer !== imageOffset.memoryBuffer) {
      let srcView = new Uint8Array(imageOffset.memoryBuffer, imageOffset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkBufferImageCopy2KHR.imageOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._imageExtent !== null) {
    let imageExtent = this._imageExtent;
    imageExtent.flush();
    if (this.memoryBuffer !== imageExtent.memoryBuffer) {
      let srcView = new Uint8Array(imageExtent.memoryBuffer, imageExtent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkBufferImageCopy2KHR.imageExtent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkBufferImageCopy2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBufferImageCopy2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBufferImageCopy2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.bufferOffset = original.bufferOffset;
  copy.bufferRowLength = original.bufferRowLength;
  copy.bufferImageHeight = original.bufferImageHeight;
  if (original.imageSubresource !== null) {
        copy.imageSubresource = original.imageSubresource.constructor.createCopyFrom(original.imageSubresource);
      }
  if (original.imageOffset !== null) {
        copy.imageOffset = original.imageOffset.constructor.createCopyFrom(original.imageOffset);
      }
  if (original.imageExtent !== null) {
        copy.imageExtent = original.imageExtent.constructor.createCopyFrom(original.imageExtent);
      }
  
  return copy;
};

VkBufferImageCopy2KHR.byteLength = 0x0;

VkBufferImageCopy2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferRowLength: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  bufferImageHeight: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  imageExtent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkImageResolve2KHR **/
function VkImageResolve2KHR(opts, byteOffset) {
  if (new.target !== VkImageResolve2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkImageResolve2KHR, STRUCT_CACHE_VkImageResolve2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkImageResolve2KHR, STRUCT_CACHE_VkImageResolve2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkImageResolve2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

Object.defineProperties(VkImageResolve2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkImageResolve2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkImageResolve2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcSubresource": {
    get() {
    return this._srcSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve2KHR.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcOffset": {
    get() {
    return this._srcOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._srcOffset = value;
      
      
    } else if (value === null) {
      this._srcOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve2KHR.srcOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstSubresource": {
    get() {
    return this._dstSubresource;
    },
    set(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve2KHR.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstOffset": {
    get() {
    return this._dstOffset;
    },
    set(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._dstOffset = value;
      
      
    } else if (value === null) {
      this._dstOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve2KHR.dstOffset': Expected 'VkOffset3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "extent": {
    get() {
    return this._extent;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve2KHR.extent': Expected 'VkExtent3D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkImageResolve2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._srcSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcSubresource.memoryBuffer) this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcSubresource.reset();
  }
  if (this._srcOffset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._srcOffset.memoryBuffer) this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._srcOffset.reset();
  }
  if (this._dstSubresource !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstSubresource.memoryBuffer) this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstSubresource.reset();
  }
  if (this._dstOffset !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._dstOffset.memoryBuffer) this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._dstOffset.reset();
  }
  if (this._extent !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._extent.memoryBuffer) this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._extent.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
    if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
    if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
    if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
    if (opts.extent !== void 0) this.extent = opts.extent;
    
  }
};

VkImageResolve2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._srcSubresource !== null) {
    let srcSubresource = this._srcSubresource;
    srcSubresource.flush();
    if (this.memoryBuffer !== srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(srcSubresource.memoryBuffer, srcSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve2KHR.srcSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._srcOffset !== null) {
    let srcOffset = this._srcOffset;
    srcOffset.flush();
    if (this.memoryBuffer !== srcOffset.memoryBuffer) {
      let srcView = new Uint8Array(srcOffset.memoryBuffer, srcOffset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve2KHR.srcOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstSubresource !== null) {
    let dstSubresource = this._dstSubresource;
    dstSubresource.flush();
    if (this.memoryBuffer !== dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(dstSubresource.memoryBuffer, dstSubresource.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve2KHR.dstSubresource' isn't used as shared-memory");
    }
  }
  
  
  if (this._dstOffset !== null) {
    let dstOffset = this._dstOffset;
    dstOffset.flush();
    if (this.memoryBuffer !== dstOffset.memoryBuffer) {
      let srcView = new Uint8Array(dstOffset.memoryBuffer, dstOffset.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve2KHR.dstOffset' isn't used as shared-memory");
    }
  }
  
  
  if (this._extent !== null) {
    let extent = this._extent;
    extent.flush();
    if (this.memoryBuffer !== extent.memoryBuffer) {
      let srcView = new Uint8Array(extent.memoryBuffer, extent.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkImageResolve2KHR.extent' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkImageResolve2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkImageResolve2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkImageResolve2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcSubresource !== null) {
        copy.srcSubresource = original.srcSubresource.constructor.createCopyFrom(original.srcSubresource);
      }
  if (original.srcOffset !== null) {
        copy.srcOffset = original.srcOffset.constructor.createCopyFrom(original.srcOffset);
      }
  if (original.dstSubresource !== null) {
        copy.dstSubresource = original.dstSubresource.constructor.createCopyFrom(original.dstSubresource);
      }
  if (original.dstOffset !== null) {
        copy.dstOffset = original.dstOffset.constructor.createCopyFrom(original.dstOffset);
      }
  if (original.extent !== null) {
        copy.extent = original.extent.constructor.createCopyFrom(original.extent);
      }
  
  return copy;
};

VkImageResolve2KHR.byteLength = 0x0;

VkImageResolve2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstSubresource: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstOffset: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  extent: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCopyBufferInfo2KHR **/
function VkCopyBufferInfo2KHR(opts, byteOffset) {
  if (new.target !== VkCopyBufferInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCopyBufferInfo2KHR, STRUCT_CACHE_VkCopyBufferInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCopyBufferInfo2KHR, STRUCT_CACHE_VkCopyBufferInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCopyBufferInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcBuffer = null;
  this._dstBuffer = null;
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcBuffer !== void 0) this.srcBuffer = opts.srcBuffer;
    if (opts.dstBuffer !== void 0) this.dstBuffer = opts.dstBuffer;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

Object.defineProperties(VkCopyBufferInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyBufferInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCopyBufferInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcBuffer": {
    get() {
    return this._srcBuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._srcBuffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._srcBuffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyBufferInfo2KHR.srcBuffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstBuffer": {
    get() {
    return this._dstBuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._dstBuffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dstBuffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyBufferInfo2KHR.dstBuffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "regionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyBufferInfo2KHR.regionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pRegions": {
    get() {
    if (this._pRegions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.regionCount, VkBufferCopy2KHR);
      this._pRegions = array;
      return this.pRegions;
    } else {
      return this._pRegions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pRegions = value;
    } else if (value === null) {
      this._pRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkCopyBufferInfo2KHR.pRegions': Expected 'Array VkBufferCopy2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkCopyBufferInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._srcBuffer = null;
  this._dstBuffer = null;
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcBuffer !== void 0) this.srcBuffer = opts.srcBuffer;
    if (opts.dstBuffer !== void 0) this.dstBuffer = opts.dstBuffer;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

VkCopyBufferInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pRegions !== null) {
    let array = this._pRegions;
    
    if (array.length !== this.regionCount) {
      throw new RangeError("Invalid array length, expected length of 'regionCount' for 'VkCopyBufferInfo2KHR.pRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkBufferCopy2KHR)) {
        throw new TypeError("Invalid type for 'VkCopyBufferInfo2KHR.pRegions[" + ii + "]': Expected 'VkBufferCopy2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pRegionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pRegionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkCopyBufferInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkCopyBufferInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCopyBufferInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcBuffer !== null) {
        copy.srcBuffer = original.srcBuffer.constructor.createCopyFrom(original.srcBuffer);
      }
  if (original.dstBuffer !== null) {
        copy.dstBuffer = original.dstBuffer.constructor.createCopyFrom(original.dstBuffer);
      }
  copy.regionCount = original.regionCount;
  if (original.pRegions !== null) {
        copy.pRegions = [...Array(original.pRegions.length)].map((v, i) => {
          return original.pRegions[i].constructor.createCopyFrom(original.pRegions[i]);
        });
      }
  
  return copy;
};

VkCopyBufferInfo2KHR.byteLength = 0x0;

VkCopyBufferInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  regionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pRegions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCopyImageInfo2KHR **/
function VkCopyImageInfo2KHR(opts, byteOffset) {
  if (new.target !== VkCopyImageInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCopyImageInfo2KHR, STRUCT_CACHE_VkCopyImageInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCopyImageInfo2KHR, STRUCT_CACHE_VkCopyImageInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCopyImageInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcImage = null;
  
  this._dstImage = null;
  
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcImage !== void 0) this.srcImage = opts.srcImage;
    if (opts.srcImageLayout !== void 0) this.srcImageLayout = opts.srcImageLayout;
    if (opts.dstImage !== void 0) this.dstImage = opts.dstImage;
    if (opts.dstImageLayout !== void 0) this.dstImageLayout = opts.dstImageLayout;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

Object.defineProperties(VkCopyImageInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyImageInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCopyImageInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcImage": {
    get() {
    return this._srcImage;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._srcImage = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._srcImage = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyImageInfo2KHR.srcImage': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcImageLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyImageInfo2KHR.srcImageLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstImage": {
    get() {
    return this._dstImage;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._dstImage = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dstImage = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyImageInfo2KHR.dstImage': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstImageLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyImageInfo2KHR.dstImageLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "regionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyImageInfo2KHR.regionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pRegions": {
    get() {
    if (this._pRegions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.regionCount, VkImageCopy2KHR);
      this._pRegions = array;
      return this.pRegions;
    } else {
      return this._pRegions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pRegions = value;
    } else if (value === null) {
      this._pRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkCopyImageInfo2KHR.pRegions': Expected 'Array VkImageCopy2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkCopyImageInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._srcImage = null;
  
  this._dstImage = null;
  
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcImage !== void 0) this.srcImage = opts.srcImage;
    if (opts.srcImageLayout !== void 0) this.srcImageLayout = opts.srcImageLayout;
    if (opts.dstImage !== void 0) this.dstImage = opts.dstImage;
    if (opts.dstImageLayout !== void 0) this.dstImageLayout = opts.dstImageLayout;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

VkCopyImageInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pRegions !== null) {
    let array = this._pRegions;
    
    if (array.length !== this.regionCount) {
      throw new RangeError("Invalid array length, expected length of 'regionCount' for 'VkCopyImageInfo2KHR.pRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkImageCopy2KHR)) {
        throw new TypeError("Invalid type for 'VkCopyImageInfo2KHR.pRegions[" + ii + "]': Expected 'VkImageCopy2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pRegionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pRegionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkCopyImageInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkCopyImageInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCopyImageInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcImage !== null) {
        copy.srcImage = original.srcImage.constructor.createCopyFrom(original.srcImage);
      }
  copy.srcImageLayout = original.srcImageLayout;
  if (original.dstImage !== null) {
        copy.dstImage = original.dstImage.constructor.createCopyFrom(original.dstImage);
      }
  copy.dstImageLayout = original.dstImageLayout;
  copy.regionCount = original.regionCount;
  if (original.pRegions !== null) {
        copy.pRegions = [...Array(original.pRegions.length)].map((v, i) => {
          return original.pRegions[i].constructor.createCopyFrom(original.pRegions[i]);
        });
      }
  
  return copy;
};

VkCopyImageInfo2KHR.byteLength = 0x0;

VkCopyImageInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcImage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcImageLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstImage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstImageLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  regionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pRegions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkBlitImageInfo2KHR **/
function VkBlitImageInfo2KHR(opts, byteOffset) {
  if (new.target !== VkBlitImageInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkBlitImageInfo2KHR, STRUCT_CACHE_VkBlitImageInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkBlitImageInfo2KHR, STRUCT_CACHE_VkBlitImageInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkBlitImageInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcImage = null;
  
  this._dstImage = null;
  
  
  this._pRegions = null;
  this._pRegionsNative = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcImage !== void 0) this.srcImage = opts.srcImage;
    if (opts.srcImageLayout !== void 0) this.srcImageLayout = opts.srcImageLayout;
    if (opts.dstImage !== void 0) this.dstImage = opts.dstImage;
    if (opts.dstImageLayout !== void 0) this.dstImageLayout = opts.dstImageLayout;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    if (opts.filter !== void 0) this.filter = opts.filter;
    
  }
};

Object.defineProperties(VkBlitImageInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBlitImageInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkBlitImageInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcImage": {
    get() {
    return this._srcImage;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._srcImage = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._srcImage = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBlitImageInfo2KHR.srcImage': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcImageLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBlitImageInfo2KHR.srcImageLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstImage": {
    get() {
    return this._dstImage;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._dstImage = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dstImage = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkBlitImageInfo2KHR.dstImage': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstImageLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBlitImageInfo2KHR.dstImageLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "regionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBlitImageInfo2KHR.regionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pRegions": {
    get() {
    if (this._pRegions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.regionCount, VkImageBlit2KHR);
      this._pRegions = array;
      return this.pRegions;
    } else {
      return this._pRegions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pRegions = value;
    } else if (value === null) {
      this._pRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkBlitImageInfo2KHR.pRegions': Expected 'Array VkImageBlit2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  "filter": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkBlitImageInfo2KHR.filter");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkBlitImageInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._srcImage = null;
  
  this._dstImage = null;
  
  
  this._pRegions = null;
  this._pRegionsNative = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcImage !== void 0) this.srcImage = opts.srcImage;
    if (opts.srcImageLayout !== void 0) this.srcImageLayout = opts.srcImageLayout;
    if (opts.dstImage !== void 0) this.dstImage = opts.dstImage;
    if (opts.dstImageLayout !== void 0) this.dstImageLayout = opts.dstImageLayout;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    if (opts.filter !== void 0) this.filter = opts.filter;
    
  }
};

VkBlitImageInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pRegions !== null) {
    let array = this._pRegions;
    
    if (array.length !== this.regionCount) {
      throw new RangeError("Invalid array length, expected length of 'regionCount' for 'VkBlitImageInfo2KHR.pRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkImageBlit2KHR)) {
        throw new TypeError("Invalid type for 'VkBlitImageInfo2KHR.pRegions[" + ii + "]': Expected 'VkImageBlit2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pRegionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pRegionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkBlitImageInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkBlitImageInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkBlitImageInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcImage !== null) {
        copy.srcImage = original.srcImage.constructor.createCopyFrom(original.srcImage);
      }
  copy.srcImageLayout = original.srcImageLayout;
  if (original.dstImage !== null) {
        copy.dstImage = original.dstImage.constructor.createCopyFrom(original.dstImage);
      }
  copy.dstImageLayout = original.dstImageLayout;
  copy.regionCount = original.regionCount;
  if (original.pRegions !== null) {
        copy.pRegions = [...Array(original.pRegions.length)].map((v, i) => {
          return original.pRegions[i].constructor.createCopyFrom(original.pRegions[i]);
        });
      }
  copy.filter = original.filter;
  
  return copy;
};

VkBlitImageInfo2KHR.byteLength = 0x0;

VkBlitImageInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcImage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcImageLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstImage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstImageLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  regionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pRegions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  filter: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCopyBufferToImageInfo2KHR **/
function VkCopyBufferToImageInfo2KHR(opts, byteOffset) {
  if (new.target !== VkCopyBufferToImageInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCopyBufferToImageInfo2KHR, STRUCT_CACHE_VkCopyBufferToImageInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCopyBufferToImageInfo2KHR, STRUCT_CACHE_VkCopyBufferToImageInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCopyBufferToImageInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcBuffer = null;
  this._dstImage = null;
  
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcBuffer !== void 0) this.srcBuffer = opts.srcBuffer;
    if (opts.dstImage !== void 0) this.dstImage = opts.dstImage;
    if (opts.dstImageLayout !== void 0) this.dstImageLayout = opts.dstImageLayout;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

Object.defineProperties(VkCopyBufferToImageInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyBufferToImageInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCopyBufferToImageInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcBuffer": {
    get() {
    return this._srcBuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._srcBuffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._srcBuffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyBufferToImageInfo2KHR.srcBuffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstImage": {
    get() {
    return this._dstImage;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._dstImage = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dstImage = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyBufferToImageInfo2KHR.dstImage': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstImageLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyBufferToImageInfo2KHR.dstImageLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "regionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyBufferToImageInfo2KHR.regionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pRegions": {
    get() {
    if (this._pRegions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.regionCount, VkBufferImageCopy2KHR);
      this._pRegions = array;
      return this.pRegions;
    } else {
      return this._pRegions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pRegions = value;
    } else if (value === null) {
      this._pRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkCopyBufferToImageInfo2KHR.pRegions': Expected 'Array VkBufferImageCopy2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkCopyBufferToImageInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._srcBuffer = null;
  this._dstImage = null;
  
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcBuffer !== void 0) this.srcBuffer = opts.srcBuffer;
    if (opts.dstImage !== void 0) this.dstImage = opts.dstImage;
    if (opts.dstImageLayout !== void 0) this.dstImageLayout = opts.dstImageLayout;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

VkCopyBufferToImageInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pRegions !== null) {
    let array = this._pRegions;
    
    if (array.length !== this.regionCount) {
      throw new RangeError("Invalid array length, expected length of 'regionCount' for 'VkCopyBufferToImageInfo2KHR.pRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkBufferImageCopy2KHR)) {
        throw new TypeError("Invalid type for 'VkCopyBufferToImageInfo2KHR.pRegions[" + ii + "]': Expected 'VkBufferImageCopy2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pRegionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pRegionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkCopyBufferToImageInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkCopyBufferToImageInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCopyBufferToImageInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcBuffer !== null) {
        copy.srcBuffer = original.srcBuffer.constructor.createCopyFrom(original.srcBuffer);
      }
  if (original.dstImage !== null) {
        copy.dstImage = original.dstImage.constructor.createCopyFrom(original.dstImage);
      }
  copy.dstImageLayout = original.dstImageLayout;
  copy.regionCount = original.regionCount;
  if (original.pRegions !== null) {
        copy.pRegions = [...Array(original.pRegions.length)].map((v, i) => {
          return original.pRegions[i].constructor.createCopyFrom(original.pRegions[i]);
        });
      }
  
  return copy;
};

VkCopyBufferToImageInfo2KHR.byteLength = 0x0;

VkCopyBufferToImageInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstImage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstImageLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  regionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pRegions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkCopyImageToBufferInfo2KHR **/
function VkCopyImageToBufferInfo2KHR(opts, byteOffset) {
  if (new.target !== VkCopyImageToBufferInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkCopyImageToBufferInfo2KHR, STRUCT_CACHE_VkCopyImageToBufferInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkCopyImageToBufferInfo2KHR, STRUCT_CACHE_VkCopyImageToBufferInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkCopyImageToBufferInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcImage = null;
  
  this._dstBuffer = null;
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcImage !== void 0) this.srcImage = opts.srcImage;
    if (opts.srcImageLayout !== void 0) this.srcImageLayout = opts.srcImageLayout;
    if (opts.dstBuffer !== void 0) this.dstBuffer = opts.dstBuffer;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

Object.defineProperties(VkCopyImageToBufferInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyImageToBufferInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkCopyImageToBufferInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcImage": {
    get() {
    return this._srcImage;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._srcImage = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._srcImage = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyImageToBufferInfo2KHR.srcImage': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcImageLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyImageToBufferInfo2KHR.srcImageLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstBuffer": {
    get() {
    return this._dstBuffer;
    },
    set(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._dstBuffer = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dstBuffer = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkCopyImageToBufferInfo2KHR.dstBuffer': Expected 'VkBuffer' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "regionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkCopyImageToBufferInfo2KHR.regionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pRegions": {
    get() {
    if (this._pRegions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.regionCount, VkBufferImageCopy2KHR);
      this._pRegions = array;
      return this.pRegions;
    } else {
      return this._pRegions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pRegions = value;
    } else if (value === null) {
      this._pRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkCopyImageToBufferInfo2KHR.pRegions': Expected 'Array VkBufferImageCopy2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkCopyImageToBufferInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._srcImage = null;
  
  this._dstBuffer = null;
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcImage !== void 0) this.srcImage = opts.srcImage;
    if (opts.srcImageLayout !== void 0) this.srcImageLayout = opts.srcImageLayout;
    if (opts.dstBuffer !== void 0) this.dstBuffer = opts.dstBuffer;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

VkCopyImageToBufferInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pRegions !== null) {
    let array = this._pRegions;
    
    if (array.length !== this.regionCount) {
      throw new RangeError("Invalid array length, expected length of 'regionCount' for 'VkCopyImageToBufferInfo2KHR.pRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkBufferImageCopy2KHR)) {
        throw new TypeError("Invalid type for 'VkCopyImageToBufferInfo2KHR.pRegions[" + ii + "]': Expected 'VkBufferImageCopy2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pRegionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pRegionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkCopyImageToBufferInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkCopyImageToBufferInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkCopyImageToBufferInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcImage !== null) {
        copy.srcImage = original.srcImage.constructor.createCopyFrom(original.srcImage);
      }
  copy.srcImageLayout = original.srcImageLayout;
  if (original.dstBuffer !== null) {
        copy.dstBuffer = original.dstBuffer.constructor.createCopyFrom(original.dstBuffer);
      }
  copy.regionCount = original.regionCount;
  if (original.pRegions !== null) {
        copy.pRegions = [...Array(original.pRegions.length)].map((v, i) => {
          return original.pRegions[i].constructor.createCopyFrom(original.pRegions[i]);
        });
      }
  
  return copy;
};

VkCopyImageToBufferInfo2KHR.byteLength = 0x0;

VkCopyImageToBufferInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcImage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcImageLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstBuffer: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  regionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pRegions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkResolveImageInfo2KHR **/
function VkResolveImageInfo2KHR(opts, byteOffset) {
  if (new.target !== VkResolveImageInfo2KHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkResolveImageInfo2KHR, STRUCT_CACHE_VkResolveImageInfo2KHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkResolveImageInfo2KHR, STRUCT_CACHE_VkResolveImageInfo2KHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkResolveImageInfo2KHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._srcImage = null;
  
  this._dstImage = null;
  
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcImage !== void 0) this.srcImage = opts.srcImage;
    if (opts.srcImageLayout !== void 0) this.srcImageLayout = opts.srcImageLayout;
    if (opts.dstImage !== void 0) this.dstImage = opts.dstImage;
    if (opts.dstImageLayout !== void 0) this.dstImageLayout = opts.dstImageLayout;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

Object.defineProperties(VkResolveImageInfo2KHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkResolveImageInfo2KHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkResolveImageInfo2KHR.pNext' isn't allowed to be filled");
    }
    },
  "srcImage": {
    get() {
    return this._srcImage;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._srcImage = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._srcImage = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkResolveImageInfo2KHR.srcImage': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "srcImageLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkResolveImageInfo2KHR.srcImageLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "dstImage": {
    get() {
    return this._dstImage;
    },
    set(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._dstImage = value;
      
      this.memoryView.setBigInt64(0x0, value.memoryView.getBigInt64(0x0, true), true);
    } else if (value === null) {
      this._dstImage = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkResolveImageInfo2KHR.dstImage': Expected 'VkImage' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "dstImageLayout": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkResolveImageInfo2KHR.dstImageLayout");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "regionCount": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkResolveImageInfo2KHR.regionCount");
    this.memoryView.setUint32(0x0, value, true);
    }
    },
  "pRegions": {
    get() {
    if (this._pRegions === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let array = decodeNativeArrayOfObjects(addr, this.regionCount, VkImageResolve2KHR);
      this._pRegions = array;
      return this.pRegions;
    } else {
      return this._pRegions;
    }
    },
    set(value) {
    if (value !== null && value.constructor === Array) {
      this._pRegions = value;
    } else if (value === null) {
      this._pRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkResolveImageInfo2KHR.pRegions': Expected 'Array VkImageResolve2KHR' but got '" + typeToString(value) + "'");
    } 
    
    }
    },
  
});

VkResolveImageInfo2KHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._srcImage = null;
  
  this._dstImage = null;
  
  
  this._pRegions = null;
  this._pRegionsNative = null;
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.srcImage !== void 0) this.srcImage = opts.srcImage;
    if (opts.srcImageLayout !== void 0) this.srcImageLayout = opts.srcImageLayout;
    if (opts.dstImage !== void 0) this.dstImage = opts.dstImage;
    if (opts.dstImageLayout !== void 0) this.dstImageLayout = opts.dstImageLayout;
    if (opts.regionCount !== void 0) this.regionCount = opts.regionCount;
    if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
    
  }
};

VkResolveImageInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pRegions !== null) {
    let array = this._pRegions;
    
    if (array.length !== this.regionCount) {
      throw new RangeError("Invalid array length, expected length of 'regionCount' for 'VkResolveImageInfo2KHR.pRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      
      if (!array[ii] || (array[ii].constructor !== VkImageResolve2KHR)) {
        throw new TypeError("Invalid type for 'VkResolveImageInfo2KHR.pRegions[" + ii + "]': Expected 'VkImageResolve2KHR' but got '" + typeToString(array[ii]) + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    if (array.length > 0) {
      let nativeArray = new NativeObjectArray(array);
      this._pRegionsNative = nativeArray;
      this.memoryView.setBigInt64(0x0, nativeArray.address, true);
    } else {
      this._pRegionsNative = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    }
  }
  
  return true;
};

VkResolveImageInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkResolveImageInfo2KHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkResolveImageInfo2KHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.srcImage !== null) {
        copy.srcImage = original.srcImage.constructor.createCopyFrom(original.srcImage);
      }
  copy.srcImageLayout = original.srcImageLayout;
  if (original.dstImage !== null) {
        copy.dstImage = original.dstImage.constructor.createCopyFrom(original.dstImage);
      }
  copy.dstImageLayout = original.dstImageLayout;
  copy.regionCount = original.regionCount;
  if (original.pRegions !== null) {
        copy.pRegions = [...Array(original.pRegions.length)].map((v, i) => {
          return original.pRegions[i].constructor.createCopyFrom(original.pRegions[i]);
        });
      }
  
  return copy;
};

VkResolveImageInfo2KHR.byteLength = 0x0;

VkResolveImageInfo2KHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcImage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  srcImageLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstImage: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  dstImageLayout: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  regionCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pRegions: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT **/
function VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, STRUCT_CACHE_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderImageInt64Atomics !== void 0) this.shaderImageInt64Atomics = opts.shaderImageInt64Atomics;
    if (opts.sparseImageInt64Atomics !== void 0) this.sparseImageInt64Atomics = opts.sparseImageInt64Atomics;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.pNext' isn't allowed to be filled");
    }
    },
  "shaderImageInt64Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "sparseImageInt64Atomics": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderImageInt64Atomics !== void 0) this.shaderImageInt64Atomics = opts.shaderImageInt64Atomics;
    if (opts.sparseImageInt64Atomics !== void 0) this.sparseImageInt64Atomics = opts.sparseImageInt64Atomics;
    
  }
};

VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderImageInt64Atomics = original.shaderImageInt64Atomics;
  copy.sparseImageInt64Atomics = original.sparseImageInt64Atomics;
  
  return copy;
};

VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.byteLength = 0x0;

VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderImageInt64Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sparseImageInt64Atomics: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkFragmentShadingRateAttachmentInfoKHR **/
function VkFragmentShadingRateAttachmentInfoKHR(opts, byteOffset) {
  if (new.target !== VkFragmentShadingRateAttachmentInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkFragmentShadingRateAttachmentInfoKHR, STRUCT_CACHE_VkFragmentShadingRateAttachmentInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkFragmentShadingRateAttachmentInfoKHR, STRUCT_CACHE_VkFragmentShadingRateAttachmentInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkFragmentShadingRateAttachmentInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._pFragmentShadingRateAttachment = null;
  this._shadingRateAttachmentTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pFragmentShadingRateAttachment !== void 0) this.pFragmentShadingRateAttachment = opts.pFragmentShadingRateAttachment;
    if (opts.shadingRateAttachmentTexelSize !== void 0) this.shadingRateAttachmentTexelSize = opts.shadingRateAttachmentTexelSize;
    
  }
};

Object.defineProperties(VkFragmentShadingRateAttachmentInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkFragmentShadingRateAttachmentInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkFragmentShadingRateAttachmentInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "pFragmentShadingRateAttachment": {
    get() {
    if (this._pFragmentShadingRateAttachment === null && this.memoryView.getBigInt64(0x0, true) !== BI0) {
      let addr = this.memoryView.getBigInt64(0x0, true);
      let buffer = getArrayBufferFromAddress(addr, BigInt(VkAttachmentReference2.byteLength));
      this._pFragmentShadingRateAttachment = new VkAttachmentReference2({ $memoryBuffer: buffer, $memoryOffset: 0x0 });
      this.memoryView.setBigInt64(0x0, this._pFragmentShadingRateAttachment.memoryAddress, true);
      return this.pFragmentShadingRateAttachment;
    } else {
      return this._pFragmentShadingRateAttachment;
    }
    },
    set(value) {
    if (value !== null && value.constructor === VkAttachmentReference2) {
      value.flush();
      this._pFragmentShadingRateAttachment = value;
      this.memoryView.setBigInt64(0x0, value.memoryAddress, true);
      
    } else if (value === null) {
      this._pFragmentShadingRateAttachment = null;
      this.memoryView.setBigInt64(0x0, BI0, true);
    } else {
      throw new TypeError("Invalid type for 'VkFragmentShadingRateAttachmentInfoKHR.pFragmentShadingRateAttachment': Expected 'VkAttachmentReference2' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "shadingRateAttachmentTexelSize": {
    get() {
    return this._shadingRateAttachmentTexelSize;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._shadingRateAttachmentTexelSize = value;
      
      
    } else if (value === null) {
      this._shadingRateAttachmentTexelSize = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkFragmentShadingRateAttachmentInfoKHR.shadingRateAttachmentTexelSize': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  
});

VkFragmentShadingRateAttachmentInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  this._pFragmentShadingRateAttachment = null;
  if (this._shadingRateAttachmentTexelSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._shadingRateAttachmentTexelSize.memoryBuffer) this._shadingRateAttachmentTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._shadingRateAttachmentTexelSize.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pFragmentShadingRateAttachment !== void 0) this.pFragmentShadingRateAttachment = opts.pFragmentShadingRateAttachment;
    if (opts.shadingRateAttachmentTexelSize !== void 0) this.shadingRateAttachmentTexelSize = opts.shadingRateAttachmentTexelSize;
    
  }
};

VkFragmentShadingRateAttachmentInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._shadingRateAttachmentTexelSize !== null) {
    let shadingRateAttachmentTexelSize = this._shadingRateAttachmentTexelSize;
    shadingRateAttachmentTexelSize.flush();
    if (this.memoryBuffer !== shadingRateAttachmentTexelSize.memoryBuffer) {
      let srcView = new Uint8Array(shadingRateAttachmentTexelSize.memoryBuffer, shadingRateAttachmentTexelSize.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkFragmentShadingRateAttachmentInfoKHR.shadingRateAttachmentTexelSize' isn't used as shared-memory");
    }
  }
  
  return true;
};

VkFragmentShadingRateAttachmentInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkFragmentShadingRateAttachmentInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkFragmentShadingRateAttachmentInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.pFragmentShadingRateAttachment !== null) {
        copy.pFragmentShadingRateAttachment = original.pFragmentShadingRateAttachment.constructor.createCopyFrom(original.pFragmentShadingRateAttachment);
      }
  if (original.shadingRateAttachmentTexelSize !== null) {
        copy.shadingRateAttachmentTexelSize = original.shadingRateAttachmentTexelSize.constructor.createCopyFrom(original.shadingRateAttachmentTexelSize);
      }
  
  return copy;
};

VkFragmentShadingRateAttachmentInfoKHR.byteLength = 0x0;

VkFragmentShadingRateAttachmentInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pFragmentShadingRateAttachment: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shadingRateAttachmentTexelSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineFragmentShadingRateStateCreateInfoKHR **/
function VkPipelineFragmentShadingRateStateCreateInfoKHR(opts, byteOffset) {
  if (new.target !== VkPipelineFragmentShadingRateStateCreateInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineFragmentShadingRateStateCreateInfoKHR, STRUCT_CACHE_VkPipelineFragmentShadingRateStateCreateInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineFragmentShadingRateStateCreateInfoKHR, STRUCT_CACHE_VkPipelineFragmentShadingRateStateCreateInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineFragmentShadingRateStateCreateInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._fragmentSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentSize !== void 0) this.fragmentSize = opts.fragmentSize;
    if (opts.combinerOps !== void 0) this.combinerOps = opts.combinerOps;
    
  }
};

Object.defineProperties(VkPipelineFragmentShadingRateStateCreateInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineFragmentShadingRateStateCreateInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineFragmentShadingRateStateCreateInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "fragmentSize": {
    get() {
    return this._fragmentSize;
    },
    set(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._fragmentSize = value;
      
      
    } else if (value === null) {
      this._fragmentSize = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPipelineFragmentShadingRateStateCreateInfoKHR.fragmentSize': Expected 'VkExtent2D' but got '" + typeToString(value) + "'");
    }
    
    }
    },
  "combinerOps": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineFragmentShadingRateStateCreateInfoKHR.combinerOps");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPipelineFragmentShadingRateStateCreateInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._fragmentSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._fragmentSize.memoryBuffer) this._fragmentSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._fragmentSize.reset();
  }
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentSize !== void 0) this.fragmentSize = opts.fragmentSize;
    if (opts.combinerOps !== void 0) this.combinerOps = opts.combinerOps;
    
  }
};

VkPipelineFragmentShadingRateStateCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._fragmentSize !== null) {
    let fragmentSize = this._fragmentSize;
    fragmentSize.flush();
    if (this.memoryBuffer !== fragmentSize.memoryBuffer) {
      let srcView = new Uint8Array(fragmentSize.memoryBuffer, fragmentSize.$memoryOffset, 0x0);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
      if (ENABLE_SHARED_MEMORY_HINTS) console.warn("'VkPipelineFragmentShadingRateStateCreateInfoKHR.fragmentSize' isn't used as shared-memory");
    }
  }
  
  
  
  return true;
};

VkPipelineFragmentShadingRateStateCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineFragmentShadingRateStateCreateInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineFragmentShadingRateStateCreateInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.fragmentSize !== null) {
        copy.fragmentSize = original.fragmentSize.constructor.createCopyFrom(original.fragmentSize);
      }
  copy.combinerOps = original.combinerOps;
  
  return copy;
};

VkPipelineFragmentShadingRateStateCreateInfoKHR.byteLength = 0x0;

VkPipelineFragmentShadingRateStateCreateInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  combinerOps: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentShadingRateFeaturesKHR **/
function VkPhysicalDeviceFragmentShadingRateFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentShadingRateFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentShadingRateFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentShadingRateFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentShadingRateFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineFragmentShadingRate !== void 0) this.pipelineFragmentShadingRate = opts.pipelineFragmentShadingRate;
    if (opts.primitiveFragmentShadingRate !== void 0) this.primitiveFragmentShadingRate = opts.primitiveFragmentShadingRate;
    if (opts.attachmentFragmentShadingRate !== void 0) this.attachmentFragmentShadingRate = opts.attachmentFragmentShadingRate;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentShadingRateFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentShadingRateFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentShadingRateFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "pipelineFragmentShadingRate": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "primitiveFragmentShadingRate": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "attachmentFragmentShadingRate": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceFragmentShadingRateFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.pipelineFragmentShadingRate !== void 0) this.pipelineFragmentShadingRate = opts.pipelineFragmentShadingRate;
    if (opts.primitiveFragmentShadingRate !== void 0) this.primitiveFragmentShadingRate = opts.primitiveFragmentShadingRate;
    if (opts.attachmentFragmentShadingRate !== void 0) this.attachmentFragmentShadingRate = opts.attachmentFragmentShadingRate;
    
  }
};

VkPhysicalDeviceFragmentShadingRateFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentShadingRateFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFragmentShadingRateFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentShadingRateFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.pipelineFragmentShadingRate = original.pipelineFragmentShadingRate;
  copy.primitiveFragmentShadingRate = original.primitiveFragmentShadingRate;
  copy.attachmentFragmentShadingRate = original.attachmentFragmentShadingRate;
  
  return copy;
};

VkPhysicalDeviceFragmentShadingRateFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceFragmentShadingRateFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pipelineFragmentShadingRate: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  primitiveFragmentShadingRate: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  attachmentFragmentShadingRate: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentShadingRatePropertiesKHR **/
function VkPhysicalDeviceFragmentShadingRatePropertiesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentShadingRatePropertiesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentShadingRatePropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRatePropertiesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentShadingRatePropertiesKHR, STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRatePropertiesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentShadingRatePropertiesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  this._minFragmentShadingRateAttachmentTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this._maxFragmentShadingRateAttachmentTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  this._maxFragmentSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentShadingRatePropertiesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentShadingRatePropertiesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentShadingRatePropertiesKHR.pNext' isn't allowed to be filled");
    }
    },
  "minFragmentShadingRateAttachmentTexelSize": {
    get() {
    return this._minFragmentShadingRateAttachmentTexelSize;
    },
    },
  "maxFragmentShadingRateAttachmentTexelSize": {
    get() {
    return this._maxFragmentShadingRateAttachmentTexelSize;
    },
    },
  "maxFragmentShadingRateAttachmentTexelSizeAspectRatio": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "primitiveFragmentShadingRateWithMultipleViewports": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "layeredShadingRateAttachments": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "fragmentShadingRateNonTrivialCombinerOps": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "maxFragmentSize": {
    get() {
    return this._maxFragmentSize;
    },
    },
  "maxFragmentSizeAspectRatio": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxFragmentShadingRateCoverageSamples": {
    get() {
    return this.memoryView.getUint32(0x0, true);
    },
    },
  "maxFragmentShadingRateRasterizationSamples": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "fragmentShadingRateWithShaderDepthStencilWrites": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "fragmentShadingRateWithSampleMask": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "fragmentShadingRateWithShaderSampleMask": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "fragmentShadingRateWithConservativeRasterization": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "fragmentShadingRateWithFragmentShaderInterlock": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "fragmentShadingRateWithCustomSampleLocations": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  "fragmentShadingRateStrictMultiplyCombiner": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    },
  
});

VkPhysicalDeviceFragmentShadingRatePropertiesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  if (this._minFragmentShadingRateAttachmentTexelSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._minFragmentShadingRateAttachmentTexelSize.memoryBuffer) this._minFragmentShadingRateAttachmentTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._minFragmentShadingRateAttachmentTexelSize.reset();
  }
  if (this._maxFragmentShadingRateAttachmentTexelSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxFragmentShadingRateAttachmentTexelSize.memoryBuffer) this._maxFragmentShadingRateAttachmentTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxFragmentShadingRateAttachmentTexelSize.reset();
  }
  
  
  
  
  if (this._maxFragmentSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._maxFragmentSize.memoryBuffer) this._maxFragmentSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._maxFragmentSize.reset();
  }
  
  
  
  
  
  
  
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceFragmentShadingRatePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentShadingRatePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceFragmentShadingRatePropertiesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentShadingRatePropertiesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  if (original.minFragmentShadingRateAttachmentTexelSize !== null) {
        copy.minFragmentShadingRateAttachmentTexelSize = original.minFragmentShadingRateAttachmentTexelSize.constructor.createCopyFrom(original.minFragmentShadingRateAttachmentTexelSize);
      }
  if (original.maxFragmentShadingRateAttachmentTexelSize !== null) {
        copy.maxFragmentShadingRateAttachmentTexelSize = original.maxFragmentShadingRateAttachmentTexelSize.constructor.createCopyFrom(original.maxFragmentShadingRateAttachmentTexelSize);
      }
  copy.maxFragmentShadingRateAttachmentTexelSizeAspectRatio = original.maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
  copy.primitiveFragmentShadingRateWithMultipleViewports = original.primitiveFragmentShadingRateWithMultipleViewports;
  copy.layeredShadingRateAttachments = original.layeredShadingRateAttachments;
  copy.fragmentShadingRateNonTrivialCombinerOps = original.fragmentShadingRateNonTrivialCombinerOps;
  if (original.maxFragmentSize !== null) {
        copy.maxFragmentSize = original.maxFragmentSize.constructor.createCopyFrom(original.maxFragmentSize);
      }
  copy.maxFragmentSizeAspectRatio = original.maxFragmentSizeAspectRatio;
  copy.maxFragmentShadingRateCoverageSamples = original.maxFragmentShadingRateCoverageSamples;
  copy.maxFragmentShadingRateRasterizationSamples = original.maxFragmentShadingRateRasterizationSamples;
  copy.fragmentShadingRateWithShaderDepthStencilWrites = original.fragmentShadingRateWithShaderDepthStencilWrites;
  copy.fragmentShadingRateWithSampleMask = original.fragmentShadingRateWithSampleMask;
  copy.fragmentShadingRateWithShaderSampleMask = original.fragmentShadingRateWithShaderSampleMask;
  copy.fragmentShadingRateWithConservativeRasterization = original.fragmentShadingRateWithConservativeRasterization;
  copy.fragmentShadingRateWithFragmentShaderInterlock = original.fragmentShadingRateWithFragmentShaderInterlock;
  copy.fragmentShadingRateWithCustomSampleLocations = original.fragmentShadingRateWithCustomSampleLocations;
  copy.fragmentShadingRateStrictMultiplyCombiner = original.fragmentShadingRateStrictMultiplyCombiner;
  
  return copy;
};

VkPhysicalDeviceFragmentShadingRatePropertiesKHR.byteLength = 0x0;

VkPhysicalDeviceFragmentShadingRatePropertiesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  minFragmentShadingRateAttachmentTexelSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentShadingRateAttachmentTexelSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentShadingRateAttachmentTexelSizeAspectRatio: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  primitiveFragmentShadingRateWithMultipleViewports: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  layeredShadingRateAttachments: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShadingRateNonTrivialCombinerOps: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentSizeAspectRatio: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentShadingRateCoverageSamples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentShadingRateRasterizationSamples: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShadingRateWithShaderDepthStencilWrites: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShadingRateWithSampleMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShadingRateWithShaderSampleMask: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShadingRateWithConservativeRasterization: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShadingRateWithFragmentShaderInterlock: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShadingRateWithCustomSampleLocations: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShadingRateStrictMultiplyCombiner: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentShadingRateKHR **/
function VkPhysicalDeviceFragmentShadingRateKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentShadingRateKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentShadingRateKHR, STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentShadingRateKHR, STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentShadingRateKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this._fragmentSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentShadingRateKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentShadingRateKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentShadingRateKHR.pNext' isn't allowed to be filled");
    }
    },
  "sampleCounts": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    },
  "fragmentSize": {
    get() {
    return this._fragmentSize;
    },
    },
  
});

VkPhysicalDeviceFragmentShadingRateKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  if (this._fragmentSize !== null) {
    // TODO: optimize this
    if (this.memoryBuffer !== this._fragmentSize.memoryBuffer) this._fragmentSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: this.$memoryOffset + 0x0 });
    else this._fragmentSize.reset();
  }
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    
  }
};

VkPhysicalDeviceFragmentShadingRateKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentShadingRateKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x0));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x0), 0x0);};

VkPhysicalDeviceFragmentShadingRateKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentShadingRateKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.sampleCounts = original.sampleCounts;
  if (original.fragmentSize !== null) {
        copy.fragmentSize = original.fragmentSize.constructor.createCopyFrom(original.fragmentSize);
      }
  
  return copy;
};

VkPhysicalDeviceFragmentShadingRateKHR.byteLength = 0x0;

VkPhysicalDeviceFragmentShadingRateKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  sampleCounts: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR **/
function VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR, STRUCT_CACHE_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderTerminateInvocation !== void 0) this.shaderTerminateInvocation = opts.shaderTerminateInvocation;
    
  }
};

Object.defineProperties(VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.pNext' isn't allowed to be filled");
    }
    },
  "shaderTerminateInvocation": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shaderTerminateInvocation !== void 0) this.shaderTerminateInvocation = opts.shaderTerminateInvocation;
    
  }
};

VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shaderTerminateInvocation = original.shaderTerminateInvocation;
  
  return copy;
};

VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.byteLength = 0x0;

VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shaderTerminateInvocation: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV **/
function VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentShadingRateEnums !== void 0) this.fragmentShadingRateEnums = opts.fragmentShadingRateEnums;
    if (opts.supersampleFragmentShadingRates !== void 0) this.supersampleFragmentShadingRates = opts.supersampleFragmentShadingRates;
    if (opts.noInvocationFragmentShadingRates !== void 0) this.noInvocationFragmentShadingRates = opts.noInvocationFragmentShadingRates;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.pNext' isn't allowed to be filled");
    }
    },
  "fragmentShadingRateEnums": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "supersampleFragmentShadingRates": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  "noInvocationFragmentShadingRates": {
    get() {
    return this.memoryView.getUint32(0x0, true) !== 0;
    },
    set(value) {
    this.memoryView.setUint32(0x0, value | 0, true);
    }
    },
  
});

VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.fragmentShadingRateEnums !== void 0) this.fragmentShadingRateEnums = opts.fragmentShadingRateEnums;
    if (opts.supersampleFragmentShadingRates !== void 0) this.supersampleFragmentShadingRates = opts.supersampleFragmentShadingRates;
    if (opts.noInvocationFragmentShadingRates !== void 0) this.noInvocationFragmentShadingRates = opts.noInvocationFragmentShadingRates;
    
  }
};

VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.fragmentShadingRateEnums = original.fragmentShadingRateEnums;
  copy.supersampleFragmentShadingRates = original.supersampleFragmentShadingRates;
  copy.noInvocationFragmentShadingRates = original.noInvocationFragmentShadingRates;
  
  return copy;
};

VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.byteLength = 0x0;

VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  fragmentShadingRateEnums: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  supersampleFragmentShadingRates: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  noInvocationFragmentShadingRates: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV **/
function VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(opts, byteOffset) {
  if (new.target !== VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.maxFragmentShadingRateInvocationCount !== void 0) this.maxFragmentShadingRateInvocationCount = opts.maxFragmentShadingRateInvocationCount;
    
  }
};

Object.defineProperties(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.pNext' isn't allowed to be filled");
    }
    },
  "maxFragmentShadingRateInvocationCount": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.maxFragmentShadingRateInvocationCount");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.maxFragmentShadingRateInvocationCount !== void 0) this.maxFragmentShadingRateInvocationCount = opts.maxFragmentShadingRateInvocationCount;
    
  }
};

VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.maxFragmentShadingRateInvocationCount = original.maxFragmentShadingRateInvocationCount;
  
  return copy;
};

VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.byteLength = 0x0;

VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  maxFragmentShadingRateInvocationCount: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkPipelineFragmentShadingRateEnumStateCreateInfoNV **/
function VkPipelineFragmentShadingRateEnumStateCreateInfoNV(opts, byteOffset) {
  if (new.target !== VkPipelineFragmentShadingRateEnumStateCreateInfoNV) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkPipelineFragmentShadingRateEnumStateCreateInfoNV, STRUCT_CACHE_VkPipelineFragmentShadingRateEnumStateCreateInfoNV);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkPipelineFragmentShadingRateEnumStateCreateInfoNV, STRUCT_CACHE_VkPipelineFragmentShadingRateEnumStateCreateInfoNV);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkPipelineFragmentShadingRateEnumStateCreateInfoNV'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shadingRateType !== void 0) this.shadingRateType = opts.shadingRateType;
    if (opts.shadingRate !== void 0) this.shadingRate = opts.shadingRate;
    if (opts.combinerOps !== void 0) this.combinerOps = opts.combinerOps;
    
  }
};

Object.defineProperties(VkPipelineFragmentShadingRateEnumStateCreateInfoNV.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineFragmentShadingRateEnumStateCreateInfoNV.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkPipelineFragmentShadingRateEnumStateCreateInfoNV.pNext' isn't allowed to be filled");
    }
    },
  "shadingRateType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineFragmentShadingRateEnumStateCreateInfoNV.shadingRateType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "shadingRate": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineFragmentShadingRateEnumStateCreateInfoNV.shadingRate");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "combinerOps": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkPipelineFragmentShadingRateEnumStateCreateInfoNV.combinerOps");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  
});

VkPipelineFragmentShadingRateEnumStateCreateInfoNV.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.shadingRateType !== void 0) this.shadingRateType = opts.shadingRateType;
    if (opts.shadingRate !== void 0) this.shadingRate = opts.shadingRate;
    if (opts.combinerOps !== void 0) this.combinerOps = opts.combinerOps;
    
  }
};

VkPipelineFragmentShadingRateEnumStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  
  return true;
};

VkPipelineFragmentShadingRateEnumStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  };

VkPipelineFragmentShadingRateEnumStateCreateInfoNV.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkPipelineFragmentShadingRateEnumStateCreateInfoNV();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.shadingRateType = original.shadingRateType;
  copy.shadingRate = original.shadingRate;
  copy.combinerOps = original.combinerOps;
  
  return copy;
};

VkPipelineFragmentShadingRateEnumStateCreateInfoNV.byteLength = 0x0;

VkPipelineFragmentShadingRateEnumStateCreateInfoNV.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shadingRateType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  shadingRate: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  combinerOps: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};
/** VkAccelerationStructureBuildSizesInfoKHR **/
function VkAccelerationStructureBuildSizesInfoKHR(opts, byteOffset) {
  if (new.target !== VkAccelerationStructureBuildSizesInfoKHR) {
    if (typeof opts === "string") {
      // opts contains our stack byteOffset
      // byteOffset is unused
      let out = getStructFromStack(opts, VkAccelerationStructureBuildSizesInfoKHR, STRUCT_CACHE_VkAccelerationStructureBuildSizesInfoKHR);
      out.reset();
      return out;
    } else if (typeof opts === "object" && byteOffset !== void 0) {
      // opts contains our initialization data
      // byteOffset contains the stack byteOffset
      let out = getStructFromStack(byteOffset, VkAccelerationStructureBuildSizesInfoKHR, STRUCT_CACHE_VkAccelerationStructureBuildSizesInfoKHR);
      out.reset(opts);
      return out;
    } else {
      throw new Error(`Invalid Signature for 'VkAccelerationStructureBuildSizesInfoKHR'`);
    }
  }
  this.memoryBuffer = null;
  this.memoryAddress = BI0;
  this.$memoryOffset = 0x0;
  this.resetMemoryView = null;
  if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
    this.memoryBuffer = opts.$memoryBuffer;
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
    this.$memoryOffset = opts.$memoryOffset | 0;
    this.memoryView = new DataView(this.memoryBuffer, opts.$memoryOffset, 0x0);

  } else {
    this.memoryBuffer = new ArrayBuffer(0x0);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    this.memoryView = new DataView(this.memoryBuffer, 0x0, 0x0);

  }
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructureSize !== void 0) this.accelerationStructureSize = opts.accelerationStructureSize;
    if (opts.updateScratchSize !== void 0) this.updateScratchSize = opts.updateScratchSize;
    if (opts.buildScratchSize !== void 0) this.buildScratchSize = opts.buildScratchSize;
    
  }
};

Object.defineProperties(VkAccelerationStructureBuildSizesInfoKHR.prototype, {
  "sType": {
    get() {
    return this.memoryView.getInt32(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER(value, "VkAccelerationStructureBuildSizesInfoKHR.sType");
    this.memoryView.setInt32(0x0, value, true);
    }
    },
  "pNext": {
    get() {
    return this._pNext;
    },
    set(value) {
    if (value !== null) throw new TypeError("'VkAccelerationStructureBuildSizesInfoKHR.pNext' isn't allowed to be filled");
    }
    },
  "accelerationStructureSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureBuildSizesInfoKHR.accelerationStructureSize")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "updateScratchSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureBuildSizesInfoKHR.updateScratchSize")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  "buildScratchSize": {
    get() {
    return this.memoryView.getBigUint64(0x0, true);
    },
    set(value) {
    ASSERT_IS_NUMBER_OR_BIGINT(value, "VkAccelerationStructureBuildSizesInfoKHR.buildScratchSize")
    this.memoryView.setBigUint64(0x0, BigInt(value), true);
    }
    },
  
});

VkAccelerationStructureBuildSizesInfoKHR.prototype.reset = function reset(opts) {
  if (this.resetMemoryView === null) {
    this.resetMemoryView = new Uint8Array(this.memoryBuffer, this.$memoryOffset, 0x0);
  }
  this.resetMemoryView.set(STRUCT_RESET_CACHE["0x0"], 0x0);
  
  this._pNext = null;
  
  
  
  this.sType = ;
  if (typeof opts === "object") {
    if (opts.sType !== void 0) this.sType = opts.sType;
    if (opts.pNext !== void 0) this.pNext = opts.pNext;
    if (opts.accelerationStructureSize !== void 0) this.accelerationStructureSize = opts.accelerationStructureSize;
    if (opts.updateScratchSize !== void 0) this.updateScratchSize = opts.updateScratchSize;
    if (opts.buildScratchSize !== void 0) this.buildScratchSize = opts.buildScratchSize;
    
  }
};

VkAccelerationStructureBuildSizesInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAccelerationStructureBuildSizesInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  };

VkAccelerationStructureBuildSizesInfoKHR.createCopyFrom = function createCopyFrom(original) {
  let copy = new VkAccelerationStructureBuildSizesInfoKHR();
  copy.sType = original.sType;
  if (original.pNext !== null) {
      copy.pNext = original.pNext.constructor.createCopyFrom(original.pNext);
    }
  copy.accelerationStructureSize = original.accelerationStructureSize;
  copy.updateScratchSize = original.updateScratchSize;
  copy.buildScratchSize = original.buildScratchSize;
  
  return copy;
};

VkAccelerationStructureBuildSizesInfoKHR.byteLength = 0x0;

VkAccelerationStructureBuildSizesInfoKHR.memoryLayout = {
  sType: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  pNext: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  accelerationStructureSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  updateScratchSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
  buildScratchSize: {
    byteOffset: 0x0,
    byteLength: 0x0
  },
};

let STRUCT_CACHE_VkClearColorValue = {};
let STRUCT_CACHE_VkClearValue = {};
let STRUCT_CACHE_VkPerformanceCounterResultKHR = {};
let STRUCT_CACHE_VkPerformanceValueDataINTEL = {};
let STRUCT_CACHE_VkPipelineExecutableStatisticValueKHR = {};
let STRUCT_CACHE_VkDeviceOrHostAddressKHR = {};
let STRUCT_CACHE_VkDeviceOrHostAddressConstKHR = {};
let STRUCT_CACHE_VkAccelerationStructureGeometryDataKHR = {};
let STRUCT_CACHE_VkBaseOutStructure = {};
let STRUCT_CACHE_VkBaseInStructure = {};
let STRUCT_CACHE_VkOffset2D = {};
let STRUCT_CACHE_VkOffset3D = {};
let STRUCT_CACHE_VkExtent2D = {};
let STRUCT_CACHE_VkExtent3D = {};
let STRUCT_CACHE_VkViewport = {};
let STRUCT_CACHE_VkRect2D = {};
let STRUCT_CACHE_VkClearRect = {};
let STRUCT_CACHE_VkComponentMapping = {};
let STRUCT_CACHE_VkPhysicalDeviceProperties = {};
let STRUCT_CACHE_VkExtensionProperties = {};
let STRUCT_CACHE_VkLayerProperties = {};
let STRUCT_CACHE_VkApplicationInfo = {};
let STRUCT_CACHE_VkAllocationCallbacks = {};
let STRUCT_CACHE_VkDeviceQueueCreateInfo = {};
let STRUCT_CACHE_VkDeviceCreateInfo = {};
let STRUCT_CACHE_VkInstanceCreateInfo = {};
let STRUCT_CACHE_VkQueueFamilyProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceMemoryProperties = {};
let STRUCT_CACHE_VkMemoryAllocateInfo = {};
let STRUCT_CACHE_VkMemoryRequirements = {};
let STRUCT_CACHE_VkSparseImageFormatProperties = {};
let STRUCT_CACHE_VkSparseImageMemoryRequirements = {};
let STRUCT_CACHE_VkMemoryType = {};
let STRUCT_CACHE_VkMemoryHeap = {};
let STRUCT_CACHE_VkMappedMemoryRange = {};
let STRUCT_CACHE_VkFormatProperties = {};
let STRUCT_CACHE_VkImageFormatProperties = {};
let STRUCT_CACHE_VkDescriptorBufferInfo = {};
let STRUCT_CACHE_VkDescriptorImageInfo = {};
let STRUCT_CACHE_VkWriteDescriptorSet = {};
let STRUCT_CACHE_VkCopyDescriptorSet = {};
let STRUCT_CACHE_VkBufferCreateInfo = {};
let STRUCT_CACHE_VkBufferViewCreateInfo = {};
let STRUCT_CACHE_VkImageSubresource = {};
let STRUCT_CACHE_VkImageSubresourceLayers = {};
let STRUCT_CACHE_VkImageSubresourceRange = {};
let STRUCT_CACHE_VkMemoryBarrier = {};
let STRUCT_CACHE_VkBufferMemoryBarrier = {};
let STRUCT_CACHE_VkImageMemoryBarrier = {};
let STRUCT_CACHE_VkImageCreateInfo = {};
let STRUCT_CACHE_VkSubresourceLayout = {};
let STRUCT_CACHE_VkImageViewCreateInfo = {};
let STRUCT_CACHE_VkBufferCopy = {};
let STRUCT_CACHE_VkSparseMemoryBind = {};
let STRUCT_CACHE_VkSparseImageMemoryBind = {};
let STRUCT_CACHE_VkSparseBufferMemoryBindInfo = {};
let STRUCT_CACHE_VkSparseImageOpaqueMemoryBindInfo = {};
let STRUCT_CACHE_VkSparseImageMemoryBindInfo = {};
let STRUCT_CACHE_VkBindSparseInfo = {};
let STRUCT_CACHE_VkImageCopy = {};
let STRUCT_CACHE_VkImageBlit = {};
let STRUCT_CACHE_VkBufferImageCopy = {};
let STRUCT_CACHE_VkImageResolve = {};
let STRUCT_CACHE_VkShaderModuleCreateInfo = {};
let STRUCT_CACHE_VkDescriptorSetLayoutBinding = {};
let STRUCT_CACHE_VkDescriptorSetLayoutCreateInfo = {};
let STRUCT_CACHE_VkDescriptorPoolSize = {};
let STRUCT_CACHE_VkDescriptorPoolCreateInfo = {};
let STRUCT_CACHE_VkDescriptorSetAllocateInfo = {};
let STRUCT_CACHE_VkSpecializationMapEntry = {};
let STRUCT_CACHE_VkSpecializationInfo = {};
let STRUCT_CACHE_VkPipelineShaderStageCreateInfo = {};
let STRUCT_CACHE_VkComputePipelineCreateInfo = {};
let STRUCT_CACHE_VkVertexInputBindingDescription = {};
let STRUCT_CACHE_VkVertexInputAttributeDescription = {};
let STRUCT_CACHE_VkPipelineVertexInputStateCreateInfo = {};
let STRUCT_CACHE_VkPipelineInputAssemblyStateCreateInfo = {};
let STRUCT_CACHE_VkPipelineTessellationStateCreateInfo = {};
let STRUCT_CACHE_VkPipelineViewportStateCreateInfo = {};
let STRUCT_CACHE_VkPipelineRasterizationStateCreateInfo = {};
let STRUCT_CACHE_VkPipelineMultisampleStateCreateInfo = {};
let STRUCT_CACHE_VkPipelineColorBlendAttachmentState = {};
let STRUCT_CACHE_VkPipelineColorBlendStateCreateInfo = {};
let STRUCT_CACHE_VkPipelineDynamicStateCreateInfo = {};
let STRUCT_CACHE_VkStencilOpState = {};
let STRUCT_CACHE_VkPipelineDepthStencilStateCreateInfo = {};
let STRUCT_CACHE_VkGraphicsPipelineCreateInfo = {};
let STRUCT_CACHE_VkPipelineCacheCreateInfo = {};
let STRUCT_CACHE_VkPushConstantRange = {};
let STRUCT_CACHE_VkPipelineLayoutCreateInfo = {};
let STRUCT_CACHE_VkSamplerCreateInfo = {};
let STRUCT_CACHE_VkCommandPoolCreateInfo = {};
let STRUCT_CACHE_VkCommandBufferAllocateInfo = {};
let STRUCT_CACHE_VkCommandBufferInheritanceInfo = {};
let STRUCT_CACHE_VkCommandBufferBeginInfo = {};
let STRUCT_CACHE_VkRenderPassBeginInfo = {};
let STRUCT_CACHE_VkClearDepthStencilValue = {};
let STRUCT_CACHE_VkClearAttachment = {};
let STRUCT_CACHE_VkAttachmentDescription = {};
let STRUCT_CACHE_VkAttachmentReference = {};
let STRUCT_CACHE_VkSubpassDescription = {};
let STRUCT_CACHE_VkSubpassDependency = {};
let STRUCT_CACHE_VkRenderPassCreateInfo = {};
let STRUCT_CACHE_VkEventCreateInfo = {};
let STRUCT_CACHE_VkFenceCreateInfo = {};
let STRUCT_CACHE_VkPhysicalDeviceFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceSparseProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceLimits = {};
let STRUCT_CACHE_VkSemaphoreCreateInfo = {};
let STRUCT_CACHE_VkQueryPoolCreateInfo = {};
let STRUCT_CACHE_VkFramebufferCreateInfo = {};
let STRUCT_CACHE_VkDrawIndirectCommand = {};
let STRUCT_CACHE_VkDrawIndexedIndirectCommand = {};
let STRUCT_CACHE_VkDispatchIndirectCommand = {};
let STRUCT_CACHE_VkSubmitInfo = {};
let STRUCT_CACHE_VkDisplayPropertiesKHR = {};
let STRUCT_CACHE_VkDisplayPlanePropertiesKHR = {};
let STRUCT_CACHE_VkDisplayModeParametersKHR = {};
let STRUCT_CACHE_VkDisplayModePropertiesKHR = {};
let STRUCT_CACHE_VkDisplayModeCreateInfoKHR = {};
let STRUCT_CACHE_VkDisplayPlaneCapabilitiesKHR = {};
let STRUCT_CACHE_VkDisplaySurfaceCreateInfoKHR = {};
let STRUCT_CACHE_VkDisplayPresentInfoKHR = {};
let STRUCT_CACHE_VkSurfaceCapabilitiesKHR = {};
let STRUCT_CACHE_VkWin32SurfaceCreateInfoKHR = {};
let STRUCT_CACHE_VkSurfaceFormatKHR = {};
let STRUCT_CACHE_VkSwapchainCreateInfoKHR = {};
let STRUCT_CACHE_VkPresentInfoKHR = {};
let STRUCT_CACHE_VkDebugReportCallbackCreateInfoEXT = {};
let STRUCT_CACHE_VkValidationFlagsEXT = {};
let STRUCT_CACHE_VkValidationFeaturesEXT = {};
let STRUCT_CACHE_VkPipelineRasterizationStateRasterizationOrderAMD = {};
let STRUCT_CACHE_VkDebugMarkerObjectNameInfoEXT = {};
let STRUCT_CACHE_VkDebugMarkerObjectTagInfoEXT = {};
let STRUCT_CACHE_VkDebugMarkerMarkerInfoEXT = {};
let STRUCT_CACHE_VkDedicatedAllocationImageCreateInfoNV = {};
let STRUCT_CACHE_VkDedicatedAllocationBufferCreateInfoNV = {};
let STRUCT_CACHE_VkDedicatedAllocationMemoryAllocateInfoNV = {};
let STRUCT_CACHE_VkExternalImageFormatPropertiesNV = {};
let STRUCT_CACHE_VkExternalMemoryImageCreateInfoNV = {};
let STRUCT_CACHE_VkExportMemoryAllocateInfoNV = {};
let STRUCT_CACHE_VkImportMemoryWin32HandleInfoNV = {};
let STRUCT_CACHE_VkExportMemoryWin32HandleInfoNV = {};
let STRUCT_CACHE_VkWin32KeyedMutexAcquireReleaseInfoNV = {};
let STRUCT_CACHE_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = {};
let STRUCT_CACHE_VkDevicePrivateDataCreateInfoEXT = {};
let STRUCT_CACHE_VkPrivateDataSlotCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDevicePrivateDataFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = {};
let STRUCT_CACHE_VkGraphicsShaderGroupCreateInfoNV = {};
let STRUCT_CACHE_VkGraphicsPipelineShaderGroupsCreateInfoNV = {};
let STRUCT_CACHE_VkBindShaderGroupIndirectCommandNV = {};
let STRUCT_CACHE_VkBindIndexBufferIndirectCommandNV = {};
let STRUCT_CACHE_VkBindVertexBufferIndirectCommandNV = {};
let STRUCT_CACHE_VkSetStateFlagsIndirectCommandNV = {};
let STRUCT_CACHE_VkIndirectCommandsStreamNV = {};
let STRUCT_CACHE_VkIndirectCommandsLayoutTokenNV = {};
let STRUCT_CACHE_VkIndirectCommandsLayoutCreateInfoNV = {};
let STRUCT_CACHE_VkGeneratedCommandsInfoNV = {};
let STRUCT_CACHE_VkGeneratedCommandsMemoryRequirementsInfoNV = {};
let STRUCT_CACHE_VkPhysicalDeviceFeatures2 = {};
let STRUCT_CACHE_VkPhysicalDeviceFeatures2KHR = {};
let STRUCT_CACHE_VkPhysicalDeviceProperties2 = {};
let STRUCT_CACHE_VkPhysicalDeviceProperties2KHR = {};
let STRUCT_CACHE_VkFormatProperties2 = {};
let STRUCT_CACHE_VkFormatProperties2KHR = {};
let STRUCT_CACHE_VkImageFormatProperties2 = {};
let STRUCT_CACHE_VkImageFormatProperties2KHR = {};
let STRUCT_CACHE_VkPhysicalDeviceImageFormatInfo2 = {};
let STRUCT_CACHE_VkPhysicalDeviceImageFormatInfo2KHR = {};
let STRUCT_CACHE_VkQueueFamilyProperties2 = {};
let STRUCT_CACHE_VkQueueFamilyProperties2KHR = {};
let STRUCT_CACHE_VkPhysicalDeviceMemoryProperties2 = {};
let STRUCT_CACHE_VkPhysicalDeviceMemoryProperties2KHR = {};
let STRUCT_CACHE_VkSparseImageFormatProperties2 = {};
let STRUCT_CACHE_VkSparseImageFormatProperties2KHR = {};
let STRUCT_CACHE_VkPhysicalDeviceSparseImageFormatInfo2 = {};
let STRUCT_CACHE_VkPhysicalDeviceSparseImageFormatInfo2KHR = {};
let STRUCT_CACHE_VkPhysicalDevicePushDescriptorPropertiesKHR = {};
let STRUCT_CACHE_VkConformanceVersion = {};
let STRUCT_CACHE_VkConformanceVersionKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceDriverProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceDriverPropertiesKHR = {};
let STRUCT_CACHE_VkPresentRegionsKHR = {};
let STRUCT_CACHE_VkPresentRegionKHR = {};
let STRUCT_CACHE_VkRectLayerKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceVariablePointersFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceVariablePointersFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceVariablePointerFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceVariablePointerFeatures = {};
let STRUCT_CACHE_VkExternalMemoryProperties = {};
let STRUCT_CACHE_VkExternalMemoryPropertiesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceExternalImageFormatInfo = {};
let STRUCT_CACHE_VkPhysicalDeviceExternalImageFormatInfoKHR = {};
let STRUCT_CACHE_VkExternalImageFormatProperties = {};
let STRUCT_CACHE_VkExternalImageFormatPropertiesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceExternalBufferInfo = {};
let STRUCT_CACHE_VkPhysicalDeviceExternalBufferInfoKHR = {};
let STRUCT_CACHE_VkExternalBufferProperties = {};
let STRUCT_CACHE_VkExternalBufferPropertiesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceIDProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceIDPropertiesKHR = {};
let STRUCT_CACHE_VkExternalMemoryImageCreateInfo = {};
let STRUCT_CACHE_VkExternalMemoryImageCreateInfoKHR = {};
let STRUCT_CACHE_VkExternalMemoryBufferCreateInfo = {};
let STRUCT_CACHE_VkExternalMemoryBufferCreateInfoKHR = {};
let STRUCT_CACHE_VkExportMemoryAllocateInfo = {};
let STRUCT_CACHE_VkExportMemoryAllocateInfoKHR = {};
let STRUCT_CACHE_VkImportMemoryWin32HandleInfoKHR = {};
let STRUCT_CACHE_VkExportMemoryWin32HandleInfoKHR = {};
let STRUCT_CACHE_VkMemoryWin32HandlePropertiesKHR = {};
let STRUCT_CACHE_VkMemoryGetWin32HandleInfoKHR = {};
let STRUCT_CACHE_VkImportMemoryFdInfoKHR = {};
let STRUCT_CACHE_VkMemoryFdPropertiesKHR = {};
let STRUCT_CACHE_VkMemoryGetFdInfoKHR = {};
let STRUCT_CACHE_VkWin32KeyedMutexAcquireReleaseInfoKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceExternalSemaphoreInfo = {};
let STRUCT_CACHE_VkPhysicalDeviceExternalSemaphoreInfoKHR = {};
let STRUCT_CACHE_VkExternalSemaphoreProperties = {};
let STRUCT_CACHE_VkExternalSemaphorePropertiesKHR = {};
let STRUCT_CACHE_VkExportSemaphoreCreateInfo = {};
let STRUCT_CACHE_VkExportSemaphoreCreateInfoKHR = {};
let STRUCT_CACHE_VkImportSemaphoreWin32HandleInfoKHR = {};
let STRUCT_CACHE_VkExportSemaphoreWin32HandleInfoKHR = {};
let STRUCT_CACHE_VkD3D12FenceSubmitInfoKHR = {};
let STRUCT_CACHE_VkSemaphoreGetWin32HandleInfoKHR = {};
let STRUCT_CACHE_VkImportSemaphoreFdInfoKHR = {};
let STRUCT_CACHE_VkSemaphoreGetFdInfoKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceExternalFenceInfo = {};
let STRUCT_CACHE_VkPhysicalDeviceExternalFenceInfoKHR = {};
let STRUCT_CACHE_VkExternalFenceProperties = {};
let STRUCT_CACHE_VkExternalFencePropertiesKHR = {};
let STRUCT_CACHE_VkExportFenceCreateInfo = {};
let STRUCT_CACHE_VkExportFenceCreateInfoKHR = {};
let STRUCT_CACHE_VkImportFenceWin32HandleInfoKHR = {};
let STRUCT_CACHE_VkExportFenceWin32HandleInfoKHR = {};
let STRUCT_CACHE_VkFenceGetWin32HandleInfoKHR = {};
let STRUCT_CACHE_VkImportFenceFdInfoKHR = {};
let STRUCT_CACHE_VkFenceGetFdInfoKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceMultiviewFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceMultiviewFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceMultiviewProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceMultiviewPropertiesKHR = {};
let STRUCT_CACHE_VkRenderPassMultiviewCreateInfo = {};
let STRUCT_CACHE_VkRenderPassMultiviewCreateInfoKHR = {};
let STRUCT_CACHE_VkSurfaceCapabilities2EXT = {};
let STRUCT_CACHE_VkDisplayPowerInfoEXT = {};
let STRUCT_CACHE_VkDeviceEventInfoEXT = {};
let STRUCT_CACHE_VkDisplayEventInfoEXT = {};
let STRUCT_CACHE_VkSwapchainCounterCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceGroupProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceGroupPropertiesKHR = {};
let STRUCT_CACHE_VkMemoryAllocateFlagsInfo = {};
let STRUCT_CACHE_VkMemoryAllocateFlagsInfoKHR = {};
let STRUCT_CACHE_VkBindBufferMemoryInfo = {};
let STRUCT_CACHE_VkBindBufferMemoryInfoKHR = {};
let STRUCT_CACHE_VkBindBufferMemoryDeviceGroupInfo = {};
let STRUCT_CACHE_VkBindBufferMemoryDeviceGroupInfoKHR = {};
let STRUCT_CACHE_VkBindImageMemoryInfo = {};
let STRUCT_CACHE_VkBindImageMemoryInfoKHR = {};
let STRUCT_CACHE_VkBindImageMemoryDeviceGroupInfo = {};
let STRUCT_CACHE_VkBindImageMemoryDeviceGroupInfoKHR = {};
let STRUCT_CACHE_VkDeviceGroupRenderPassBeginInfo = {};
let STRUCT_CACHE_VkDeviceGroupRenderPassBeginInfoKHR = {};
let STRUCT_CACHE_VkDeviceGroupCommandBufferBeginInfo = {};
let STRUCT_CACHE_VkDeviceGroupCommandBufferBeginInfoKHR = {};
let STRUCT_CACHE_VkDeviceGroupSubmitInfo = {};
let STRUCT_CACHE_VkDeviceGroupSubmitInfoKHR = {};
let STRUCT_CACHE_VkDeviceGroupBindSparseInfo = {};
let STRUCT_CACHE_VkDeviceGroupBindSparseInfoKHR = {};
let STRUCT_CACHE_VkDeviceGroupPresentCapabilitiesKHR = {};
let STRUCT_CACHE_VkImageSwapchainCreateInfoKHR = {};
let STRUCT_CACHE_VkBindImageMemorySwapchainInfoKHR = {};
let STRUCT_CACHE_VkAcquireNextImageInfoKHR = {};
let STRUCT_CACHE_VkDeviceGroupPresentInfoKHR = {};
let STRUCT_CACHE_VkDeviceGroupDeviceCreateInfo = {};
let STRUCT_CACHE_VkDeviceGroupDeviceCreateInfoKHR = {};
let STRUCT_CACHE_VkDeviceGroupSwapchainCreateInfoKHR = {};
let STRUCT_CACHE_VkDescriptorUpdateTemplateEntry = {};
let STRUCT_CACHE_VkDescriptorUpdateTemplateEntryKHR = {};
let STRUCT_CACHE_VkDescriptorUpdateTemplateCreateInfo = {};
let STRUCT_CACHE_VkDescriptorUpdateTemplateCreateInfoKHR = {};
let STRUCT_CACHE_VkXYColorEXT = {};
let STRUCT_CACHE_VkHdrMetadataEXT = {};
let STRUCT_CACHE_VkDisplayNativeHdrSurfaceCapabilitiesAMD = {};
let STRUCT_CACHE_VkSwapchainDisplayNativeHdrCreateInfoAMD = {};
let STRUCT_CACHE_VkRefreshCycleDurationGOOGLE = {};
let STRUCT_CACHE_VkPastPresentationTimingGOOGLE = {};
let STRUCT_CACHE_VkPresentTimesInfoGOOGLE = {};
let STRUCT_CACHE_VkPresentTimeGOOGLE = {};
let STRUCT_CACHE_VkViewportWScalingNV = {};
let STRUCT_CACHE_VkPipelineViewportWScalingStateCreateInfoNV = {};
let STRUCT_CACHE_VkViewportSwizzleNV = {};
let STRUCT_CACHE_VkPipelineViewportSwizzleStateCreateInfoNV = {};
let STRUCT_CACHE_VkPhysicalDeviceDiscardRectanglePropertiesEXT = {};
let STRUCT_CACHE_VkPipelineDiscardRectangleStateCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = {};
let STRUCT_CACHE_VkInputAttachmentAspectReference = {};
let STRUCT_CACHE_VkInputAttachmentAspectReferenceKHR = {};
let STRUCT_CACHE_VkRenderPassInputAttachmentAspectCreateInfo = {};
let STRUCT_CACHE_VkRenderPassInputAttachmentAspectCreateInfoKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceSurfaceInfo2KHR = {};
let STRUCT_CACHE_VkSurfaceCapabilities2KHR = {};
let STRUCT_CACHE_VkSurfaceFormat2KHR = {};
let STRUCT_CACHE_VkDisplayProperties2KHR = {};
let STRUCT_CACHE_VkDisplayPlaneProperties2KHR = {};
let STRUCT_CACHE_VkDisplayModeProperties2KHR = {};
let STRUCT_CACHE_VkDisplayPlaneInfo2KHR = {};
let STRUCT_CACHE_VkDisplayPlaneCapabilities2KHR = {};
let STRUCT_CACHE_VkSharedPresentSurfaceCapabilitiesKHR = {};
let STRUCT_CACHE_VkPhysicalDevice16BitStorageFeatures = {};
let STRUCT_CACHE_VkPhysicalDevice16BitStorageFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceSubgroupProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = {};
let STRUCT_CACHE_VkBufferMemoryRequirementsInfo2 = {};
let STRUCT_CACHE_VkBufferMemoryRequirementsInfo2KHR = {};
let STRUCT_CACHE_VkImageMemoryRequirementsInfo2 = {};
let STRUCT_CACHE_VkImageMemoryRequirementsInfo2KHR = {};
let STRUCT_CACHE_VkImageSparseMemoryRequirementsInfo2 = {};
let STRUCT_CACHE_VkImageSparseMemoryRequirementsInfo2KHR = {};
let STRUCT_CACHE_VkMemoryRequirements2 = {};
let STRUCT_CACHE_VkMemoryRequirements2KHR = {};
let STRUCT_CACHE_VkSparseImageMemoryRequirements2 = {};
let STRUCT_CACHE_VkSparseImageMemoryRequirements2KHR = {};
let STRUCT_CACHE_VkPhysicalDevicePointClippingProperties = {};
let STRUCT_CACHE_VkPhysicalDevicePointClippingPropertiesKHR = {};
let STRUCT_CACHE_VkMemoryDedicatedRequirements = {};
let STRUCT_CACHE_VkMemoryDedicatedRequirementsKHR = {};
let STRUCT_CACHE_VkMemoryDedicatedAllocateInfo = {};
let STRUCT_CACHE_VkMemoryDedicatedAllocateInfoKHR = {};
let STRUCT_CACHE_VkImageViewUsageCreateInfo = {};
let STRUCT_CACHE_VkImageViewUsageCreateInfoKHR = {};
let STRUCT_CACHE_VkPipelineTessellationDomainOriginStateCreateInfo = {};
let STRUCT_CACHE_VkPipelineTessellationDomainOriginStateCreateInfoKHR = {};
let STRUCT_CACHE_VkSamplerYcbcrConversionInfo = {};
let STRUCT_CACHE_VkSamplerYcbcrConversionInfoKHR = {};
let STRUCT_CACHE_VkSamplerYcbcrConversionCreateInfo = {};
let STRUCT_CACHE_VkSamplerYcbcrConversionCreateInfoKHR = {};
let STRUCT_CACHE_VkBindImagePlaneMemoryInfo = {};
let STRUCT_CACHE_VkBindImagePlaneMemoryInfoKHR = {};
let STRUCT_CACHE_VkImagePlaneMemoryRequirementsInfo = {};
let STRUCT_CACHE_VkImagePlaneMemoryRequirementsInfoKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceSamplerYcbcrConversionFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = {};
let STRUCT_CACHE_VkSamplerYcbcrConversionImageFormatProperties = {};
let STRUCT_CACHE_VkSamplerYcbcrConversionImageFormatPropertiesKHR = {};
let STRUCT_CACHE_VkTextureLODGatherFormatPropertiesAMD = {};
let STRUCT_CACHE_VkConditionalRenderingBeginInfoEXT = {};
let STRUCT_CACHE_VkProtectedSubmitInfo = {};
let STRUCT_CACHE_VkPhysicalDeviceProtectedMemoryFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceProtectedMemoryProperties = {};
let STRUCT_CACHE_VkDeviceQueueInfo2 = {};
let STRUCT_CACHE_VkPipelineCoverageToColorStateCreateInfoNV = {};
let STRUCT_CACHE_VkPhysicalDeviceSamplerFilterMinmaxProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = {};
let STRUCT_CACHE_VkSampleLocationEXT = {};
let STRUCT_CACHE_VkSampleLocationsInfoEXT = {};
let STRUCT_CACHE_VkAttachmentSampleLocationsEXT = {};
let STRUCT_CACHE_VkSubpassSampleLocationsEXT = {};
let STRUCT_CACHE_VkRenderPassSampleLocationsBeginInfoEXT = {};
let STRUCT_CACHE_VkPipelineSampleLocationsStateCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceSampleLocationsPropertiesEXT = {};
let STRUCT_CACHE_VkMultisamplePropertiesEXT = {};
let STRUCT_CACHE_VkSamplerReductionModeCreateInfo = {};
let STRUCT_CACHE_VkSamplerReductionModeCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = {};
let STRUCT_CACHE_VkPipelineColorBlendAdvancedStateCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceInlineUniformBlockFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceInlineUniformBlockPropertiesEXT = {};
let STRUCT_CACHE_VkWriteDescriptorSetInlineUniformBlockEXT = {};
let STRUCT_CACHE_VkDescriptorPoolInlineUniformBlockCreateInfoEXT = {};
let STRUCT_CACHE_VkPipelineCoverageModulationStateCreateInfoNV = {};
let STRUCT_CACHE_VkImageFormatListCreateInfo = {};
let STRUCT_CACHE_VkImageFormatListCreateInfoKHR = {};
let STRUCT_CACHE_VkValidationCacheCreateInfoEXT = {};
let STRUCT_CACHE_VkShaderModuleValidationCacheCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceMaintenance3Properties = {};
let STRUCT_CACHE_VkPhysicalDeviceMaintenance3PropertiesKHR = {};
let STRUCT_CACHE_VkDescriptorSetLayoutSupport = {};
let STRUCT_CACHE_VkDescriptorSetLayoutSupportKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderDrawParametersFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderDrawParameterFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderFloat16Int8Features = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceFloat16Int8FeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceFloatControlsProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceFloatControlsPropertiesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceHostQueryResetFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceHostQueryResetFeaturesEXT = {};
let STRUCT_CACHE_VkShaderResourceUsageAMD = {};
let STRUCT_CACHE_VkShaderStatisticsInfoAMD = {};
let STRUCT_CACHE_VkDeviceQueueGlobalPriorityCreateInfoEXT = {};
let STRUCT_CACHE_VkDebugUtilsObjectNameInfoEXT = {};
let STRUCT_CACHE_VkDebugUtilsObjectTagInfoEXT = {};
let STRUCT_CACHE_VkDebugUtilsLabelEXT = {};
let STRUCT_CACHE_VkDebugUtilsMessengerCreateInfoEXT = {};
let STRUCT_CACHE_VkDebugUtilsMessengerCallbackDataEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = {};
let STRUCT_CACHE_VkDeviceDeviceMemoryReportCreateInfoEXT = {};
let STRUCT_CACHE_VkDeviceMemoryReportCallbackDataEXT = {};
let STRUCT_CACHE_VkImportMemoryHostPointerInfoEXT = {};
let STRUCT_CACHE_VkMemoryHostPointerPropertiesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceExternalMemoryHostPropertiesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceConservativeRasterizationPropertiesEXT = {};
let STRUCT_CACHE_VkCalibratedTimestampInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderCorePropertiesAMD = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderCoreProperties2AMD = {};
let STRUCT_CACHE_VkPipelineRasterizationConservativeStateCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceDescriptorIndexingPropertiesEXT = {};
let STRUCT_CACHE_VkDescriptorSetLayoutBindingFlagsCreateInfo = {};
let STRUCT_CACHE_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = {};
let STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountAllocateInfo = {};
let STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = {};
let STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountLayoutSupport = {};
let STRUCT_CACHE_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = {};
let STRUCT_CACHE_VkAttachmentDescription2 = {};
let STRUCT_CACHE_VkAttachmentDescription2KHR = {};
let STRUCT_CACHE_VkAttachmentReference2 = {};
let STRUCT_CACHE_VkAttachmentReference2KHR = {};
let STRUCT_CACHE_VkSubpassDescription2 = {};
let STRUCT_CACHE_VkSubpassDescription2KHR = {};
let STRUCT_CACHE_VkSubpassDependency2 = {};
let STRUCT_CACHE_VkSubpassDependency2KHR = {};
let STRUCT_CACHE_VkRenderPassCreateInfo2 = {};
let STRUCT_CACHE_VkRenderPassCreateInfo2KHR = {};
let STRUCT_CACHE_VkSubpassBeginInfo = {};
let STRUCT_CACHE_VkSubpassBeginInfoKHR = {};
let STRUCT_CACHE_VkSubpassEndInfo = {};
let STRUCT_CACHE_VkSubpassEndInfoKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphoreFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphoreProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceTimelineSemaphorePropertiesKHR = {};
let STRUCT_CACHE_VkSemaphoreTypeCreateInfo = {};
let STRUCT_CACHE_VkSemaphoreTypeCreateInfoKHR = {};
let STRUCT_CACHE_VkTimelineSemaphoreSubmitInfo = {};
let STRUCT_CACHE_VkTimelineSemaphoreSubmitInfoKHR = {};
let STRUCT_CACHE_VkSemaphoreWaitInfo = {};
let STRUCT_CACHE_VkSemaphoreWaitInfoKHR = {};
let STRUCT_CACHE_VkSemaphoreSignalInfo = {};
let STRUCT_CACHE_VkSemaphoreSignalInfoKHR = {};
let STRUCT_CACHE_VkVertexInputBindingDivisorDescriptionEXT = {};
let STRUCT_CACHE_VkPipelineVertexInputDivisorStateCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = {};
let STRUCT_CACHE_VkPhysicalDevicePCIBusInfoPropertiesEXT = {};
let STRUCT_CACHE_VkCommandBufferInheritanceConditionalRenderingInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDevice8BitStorageFeatures = {};
let STRUCT_CACHE_VkPhysicalDevice8BitStorageFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceConditionalRenderingFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceVulkanMemoryModelFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderAtomicInt64Features = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = {};
let STRUCT_CACHE_VkQueueFamilyCheckpointPropertiesNV = {};
let STRUCT_CACHE_VkCheckpointDataNV = {};
let STRUCT_CACHE_VkPhysicalDeviceDepthStencilResolveProperties = {};
let STRUCT_CACHE_VkPhysicalDeviceDepthStencilResolvePropertiesKHR = {};
let STRUCT_CACHE_VkSubpassDescriptionDepthStencilResolve = {};
let STRUCT_CACHE_VkSubpassDescriptionDepthStencilResolveKHR = {};
let STRUCT_CACHE_VkImageViewASTCDecodeModeEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceASTCDecodeFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceTransformFeedbackFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceTransformFeedbackPropertiesEXT = {};
let STRUCT_CACHE_VkPipelineRasterizationStateStreamCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = {};
let STRUCT_CACHE_VkPipelineRepresentativeFragmentTestStateCreateInfoNV = {};
let STRUCT_CACHE_VkPhysicalDeviceExclusiveScissorFeaturesNV = {};
let STRUCT_CACHE_VkPipelineViewportExclusiveScissorStateCreateInfoNV = {};
let STRUCT_CACHE_VkPhysicalDeviceCornerSampledImageFeaturesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderImageFootprintFeaturesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = {};
let STRUCT_CACHE_VkShadingRatePaletteNV = {};
let STRUCT_CACHE_VkPipelineViewportShadingRateImageStateCreateInfoNV = {};
let STRUCT_CACHE_VkPhysicalDeviceShadingRateImageFeaturesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceShadingRateImagePropertiesNV = {};
let STRUCT_CACHE_VkCoarseSampleLocationNV = {};
let STRUCT_CACHE_VkCoarseSampleOrderCustomNV = {};
let STRUCT_CACHE_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = {};
let STRUCT_CACHE_VkPhysicalDeviceMeshShaderFeaturesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceMeshShaderPropertiesNV = {};
let STRUCT_CACHE_VkDrawMeshTasksIndirectCommandNV = {};
let STRUCT_CACHE_VkRayTracingShaderGroupCreateInfoNV = {};
let STRUCT_CACHE_VkRayTracingShaderGroupCreateInfoKHR = {};
let STRUCT_CACHE_VkRayTracingPipelineCreateInfoNV = {};
let STRUCT_CACHE_VkRayTracingPipelineCreateInfoKHR = {};
let STRUCT_CACHE_VkGeometryTrianglesNV = {};
let STRUCT_CACHE_VkGeometryAABBNV = {};
let STRUCT_CACHE_VkGeometryDataNV = {};
let STRUCT_CACHE_VkGeometryNV = {};
let STRUCT_CACHE_VkAccelerationStructureInfoNV = {};
let STRUCT_CACHE_VkAccelerationStructureCreateInfoNV = {};
let STRUCT_CACHE_VkBindAccelerationStructureMemoryInfoNV = {};
let STRUCT_CACHE_VkWriteDescriptorSetAccelerationStructureKHR = {};
let STRUCT_CACHE_VkWriteDescriptorSetAccelerationStructureNV = {};
let STRUCT_CACHE_VkAccelerationStructureMemoryRequirementsInfoNV = {};
let STRUCT_CACHE_VkPhysicalDeviceAccelerationStructureFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceRayTracingPipelineFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceRayQueryFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceAccelerationStructurePropertiesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceRayTracingPipelinePropertiesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceRayTracingPropertiesNV = {};
let STRUCT_CACHE_VkStridedDeviceAddressRegionKHR = {};
let STRUCT_CACHE_VkTraceRaysIndirectCommandKHR = {};
let STRUCT_CACHE_VkDrmFormatModifierPropertiesListEXT = {};
let STRUCT_CACHE_VkDrmFormatModifierPropertiesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceImageDrmFormatModifierInfoEXT = {};
let STRUCT_CACHE_VkImageDrmFormatModifierListCreateInfoEXT = {};
let STRUCT_CACHE_VkImageDrmFormatModifierExplicitCreateInfoEXT = {};
let STRUCT_CACHE_VkImageDrmFormatModifierPropertiesEXT = {};
let STRUCT_CACHE_VkImageStencilUsageCreateInfo = {};
let STRUCT_CACHE_VkImageStencilUsageCreateInfoEXT = {};
let STRUCT_CACHE_VkDeviceMemoryOverallocationCreateInfoAMD = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMapFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMapPropertiesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = {};
let STRUCT_CACHE_VkRenderPassFragmentDensityMapCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceScalarBlockLayoutFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = {};
let STRUCT_CACHE_VkSurfaceProtectedCapabilitiesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceUniformBufferStandardLayoutFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceDepthClipEnableFeaturesEXT = {};
let STRUCT_CACHE_VkPipelineRasterizationDepthClipStateCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceMemoryBudgetPropertiesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceMemoryPriorityFeaturesEXT = {};
let STRUCT_CACHE_VkMemoryPriorityAllocateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceBufferDeviceAddressFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceBufferAddressFeaturesEXT = {};
let STRUCT_CACHE_VkBufferDeviceAddressInfo = {};
let STRUCT_CACHE_VkBufferDeviceAddressInfoKHR = {};
let STRUCT_CACHE_VkBufferDeviceAddressInfoEXT = {};
let STRUCT_CACHE_VkBufferOpaqueCaptureAddressCreateInfo = {};
let STRUCT_CACHE_VkBufferOpaqueCaptureAddressCreateInfoKHR = {};
let STRUCT_CACHE_VkBufferDeviceAddressCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceImageViewImageFormatInfoEXT = {};
let STRUCT_CACHE_VkFilterCubicImageViewImageFormatPropertiesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceImagelessFramebufferFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceImagelessFramebufferFeaturesKHR = {};
let STRUCT_CACHE_VkFramebufferAttachmentsCreateInfo = {};
let STRUCT_CACHE_VkFramebufferAttachmentsCreateInfoKHR = {};
let STRUCT_CACHE_VkFramebufferAttachmentImageInfo = {};
let STRUCT_CACHE_VkFramebufferAttachmentImageInfoKHR = {};
let STRUCT_CACHE_VkRenderPassAttachmentBeginInfo = {};
let STRUCT_CACHE_VkRenderPassAttachmentBeginInfoKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceCooperativeMatrixFeaturesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceCooperativeMatrixPropertiesNV = {};
let STRUCT_CACHE_VkCooperativeMatrixPropertiesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = {};
let STRUCT_CACHE_VkImageViewHandleInfoNVX = {};
let STRUCT_CACHE_VkImageViewAddressPropertiesNVX = {};
let STRUCT_CACHE_VkPipelineCreationFeedbackEXT = {};
let STRUCT_CACHE_VkPipelineCreationFeedbackCreateInfoEXT = {};
let STRUCT_CACHE_VkSurfaceFullScreenExclusiveInfoEXT = {};
let STRUCT_CACHE_VkSurfaceFullScreenExclusiveWin32InfoEXT = {};
let STRUCT_CACHE_VkSurfaceCapabilitiesFullScreenExclusiveEXT = {};
let STRUCT_CACHE_VkPhysicalDevicePerformanceQueryFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDevicePerformanceQueryPropertiesKHR = {};
let STRUCT_CACHE_VkPerformanceCounterKHR = {};
let STRUCT_CACHE_VkPerformanceCounterDescriptionKHR = {};
let STRUCT_CACHE_VkQueryPoolPerformanceCreateInfoKHR = {};
let STRUCT_CACHE_VkAcquireProfilingLockInfoKHR = {};
let STRUCT_CACHE_VkPerformanceQuerySubmitInfoKHR = {};
let STRUCT_CACHE_VkHeadlessSurfaceCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceCoverageReductionModeFeaturesNV = {};
let STRUCT_CACHE_VkPipelineCoverageReductionStateCreateInfoNV = {};
let STRUCT_CACHE_VkFramebufferMixedSamplesCombinationNV = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = {};
let STRUCT_CACHE_VkPerformanceValueINTEL = {};
let STRUCT_CACHE_VkInitializePerformanceApiInfoINTEL = {};
let STRUCT_CACHE_VkQueryPoolPerformanceQueryCreateInfoINTEL = {};
let STRUCT_CACHE_VkQueryPoolCreateInfoINTEL = {};
let STRUCT_CACHE_VkPerformanceMarkerInfoINTEL = {};
let STRUCT_CACHE_VkPerformanceStreamMarkerInfoINTEL = {};
let STRUCT_CACHE_VkPerformanceOverrideInfoINTEL = {};
let STRUCT_CACHE_VkPerformanceConfigurationAcquireInfoINTEL = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderClockFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceIndexTypeUint8FeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = {};
let STRUCT_CACHE_VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = {};
let STRUCT_CACHE_VkAttachmentReferenceStencilLayout = {};
let STRUCT_CACHE_VkAttachmentReferenceStencilLayoutKHR = {};
let STRUCT_CACHE_VkAttachmentDescriptionStencilLayout = {};
let STRUCT_CACHE_VkAttachmentDescriptionStencilLayoutKHR = {};
let STRUCT_CACHE_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = {};
let STRUCT_CACHE_VkPipelineInfoKHR = {};
let STRUCT_CACHE_VkPipelineExecutablePropertiesKHR = {};
let STRUCT_CACHE_VkPipelineExecutableInfoKHR = {};
let STRUCT_CACHE_VkPipelineExecutableStatisticKHR = {};
let STRUCT_CACHE_VkPipelineExecutableInternalRepresentationKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = {};
let STRUCT_CACHE_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = {};
let STRUCT_CACHE_VkMemoryOpaqueCaptureAddressAllocateInfo = {};
let STRUCT_CACHE_VkMemoryOpaqueCaptureAddressAllocateInfoKHR = {};
let STRUCT_CACHE_VkDeviceMemoryOpaqueCaptureAddressInfo = {};
let STRUCT_CACHE_VkDeviceMemoryOpaqueCaptureAddressInfoKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceLineRasterizationFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceLineRasterizationPropertiesEXT = {};
let STRUCT_CACHE_VkPipelineRasterizationLineStateCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceVulkan11Features = {};
let STRUCT_CACHE_VkPhysicalDeviceVulkan11Properties = {};
let STRUCT_CACHE_VkPhysicalDeviceVulkan12Features = {};
let STRUCT_CACHE_VkPhysicalDeviceVulkan12Properties = {};
let STRUCT_CACHE_VkPipelineCompilerControlCreateInfoAMD = {};
let STRUCT_CACHE_VkPhysicalDeviceCoherentMemoryFeaturesAMD = {};
let STRUCT_CACHE_VkPhysicalDeviceToolPropertiesEXT = {};
let STRUCT_CACHE_VkSamplerCustomBorderColorCreateInfoEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceCustomBorderColorPropertiesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceCustomBorderColorFeaturesEXT = {};
let STRUCT_CACHE_VkAccelerationStructureGeometryTrianglesDataKHR = {};
let STRUCT_CACHE_VkAccelerationStructureGeometryAabbsDataKHR = {};
let STRUCT_CACHE_VkAccelerationStructureGeometryInstancesDataKHR = {};
let STRUCT_CACHE_VkAccelerationStructureGeometryKHR = {};
let STRUCT_CACHE_VkAccelerationStructureBuildGeometryInfoKHR = {};
let STRUCT_CACHE_VkAccelerationStructureBuildRangeInfoKHR = {};
let STRUCT_CACHE_VkAccelerationStructureCreateInfoKHR = {};
let STRUCT_CACHE_VkAabbPositionsKHR = {};
let STRUCT_CACHE_VkAabbPositionsNV = {};
let STRUCT_CACHE_VkTransformMatrixKHR = {};
let STRUCT_CACHE_VkTransformMatrixNV = {};
let STRUCT_CACHE_VkAccelerationStructureInstanceKHR = {};
let STRUCT_CACHE_VkAccelerationStructureInstanceNV = {};
let STRUCT_CACHE_VkAccelerationStructureDeviceAddressInfoKHR = {};
let STRUCT_CACHE_VkAccelerationStructureVersionInfoKHR = {};
let STRUCT_CACHE_VkCopyAccelerationStructureInfoKHR = {};
let STRUCT_CACHE_VkCopyAccelerationStructureToMemoryInfoKHR = {};
let STRUCT_CACHE_VkCopyMemoryToAccelerationStructureInfoKHR = {};
let STRUCT_CACHE_VkRayTracingPipelineInterfaceCreateInfoKHR = {};
let STRUCT_CACHE_VkPipelineLibraryCreateInfoKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = {};
let STRUCT_CACHE_VkRenderPassTransformBeginInfoQCOM = {};
let STRUCT_CACHE_VkCopyCommandTransformInfoQCOM = {};
let STRUCT_CACHE_VkCommandBufferInheritanceRenderPassTransformInfoQCOM = {};
let STRUCT_CACHE_VkPhysicalDeviceDiagnosticsConfigFeaturesNV = {};
let STRUCT_CACHE_VkDeviceDiagnosticsConfigCreateInfoNV = {};
let STRUCT_CACHE_VkPhysicalDeviceRobustness2FeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceRobustness2PropertiesEXT = {};
let STRUCT_CACHE_VkPhysicalDeviceImageRobustnessFeaturesEXT = {};
let STRUCT_CACHE_VkPhysicalDevice4444FormatsFeaturesEXT = {};
let STRUCT_CACHE_VkBufferCopy2KHR = {};
let STRUCT_CACHE_VkImageCopy2KHR = {};
let STRUCT_CACHE_VkImageBlit2KHR = {};
let STRUCT_CACHE_VkBufferImageCopy2KHR = {};
let STRUCT_CACHE_VkImageResolve2KHR = {};
let STRUCT_CACHE_VkCopyBufferInfo2KHR = {};
let STRUCT_CACHE_VkCopyImageInfo2KHR = {};
let STRUCT_CACHE_VkBlitImageInfo2KHR = {};
let STRUCT_CACHE_VkCopyBufferToImageInfo2KHR = {};
let STRUCT_CACHE_VkCopyImageToBufferInfo2KHR = {};
let STRUCT_CACHE_VkResolveImageInfo2KHR = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = {};
let STRUCT_CACHE_VkFragmentShadingRateAttachmentInfoKHR = {};
let STRUCT_CACHE_VkPipelineFragmentShadingRateStateCreateInfoKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRatePropertiesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = {};
let STRUCT_CACHE_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = {};
let STRUCT_CACHE_VkPipelineFragmentShadingRateEnumStateCreateInfoNV = {};
let STRUCT_CACHE_VkAccelerationStructureBuildSizesInfoKHR = {};


module.exports = {
  ...VK_ENUMERATIONS,
  VK_MAKE_VERSION: nvk.VK_MAKE_VERSION,
  VK_VERSION_MAJOR: nvk.VK_VERSION_MAJOR,
  VK_VERSION_MINOR: nvk.VK_VERSION_MINOR,
  VK_VERSION_PATCH: nvk.VK_VERSION_PATCH,
  VK_API_VERSION_1_0: nvk.VK_API_VERSION_1_0,
  VK_API_VERSION_1_1: nvk.VK_API_VERSION_1_1,
  vkUseDevice: nvk.vkUseDevice,
  vkUseInstance: nvk.vkUseInstance,
  VulkanWindow: nvk.VulkanWindow,
  vkCreateInstance: nvk.vkCreateInstance,
  vkDestroyInstance: nvk.vkDestroyInstance,
  vkEnumeratePhysicalDevices: nvk.vkEnumeratePhysicalDevices,
  vkGetDeviceProcAddr: nvk.vkGetDeviceProcAddr,
  vkGetInstanceProcAddr: nvk.vkGetInstanceProcAddr,
  vkGetPhysicalDeviceProperties: nvk.vkGetPhysicalDeviceProperties,
  vkGetPhysicalDeviceQueueFamilyProperties: nvk.vkGetPhysicalDeviceQueueFamilyProperties,
  vkGetPhysicalDeviceMemoryProperties: nvk.vkGetPhysicalDeviceMemoryProperties,
  vkGetPhysicalDeviceFeatures: nvk.vkGetPhysicalDeviceFeatures,
  vkGetPhysicalDeviceFormatProperties: nvk.vkGetPhysicalDeviceFormatProperties,
  vkGetPhysicalDeviceImageFormatProperties: nvk.vkGetPhysicalDeviceImageFormatProperties,
  vkCreateDevice: nvk.vkCreateDevice,
  vkDestroyDevice: nvk.vkDestroyDevice,
  vkEnumerateInstanceVersion: nvk.vkEnumerateInstanceVersion,
  vkEnumerateInstanceLayerProperties: nvk.vkEnumerateInstanceLayerProperties,
  vkEnumerateInstanceExtensionProperties: nvk.vkEnumerateInstanceExtensionProperties,
  vkEnumerateDeviceLayerProperties: nvk.vkEnumerateDeviceLayerProperties,
  vkEnumerateDeviceExtensionProperties: nvk.vkEnumerateDeviceExtensionProperties,
  vkGetDeviceQueue: nvk.vkGetDeviceQueue,
  vkQueueSubmit: nvk.vkQueueSubmit,
  vkQueueWaitIdle: nvk.vkQueueWaitIdle,
  vkDeviceWaitIdle: nvk.vkDeviceWaitIdle,
  vkAllocateMemory: nvk.vkAllocateMemory,
  vkFreeMemory: nvk.vkFreeMemory,
  vkMapMemory: nvk.vkMapMemory,
  vkUnmapMemory: nvk.vkUnmapMemory,
  vkFlushMappedMemoryRanges: nvk.vkFlushMappedMemoryRanges,
  vkInvalidateMappedMemoryRanges: nvk.vkInvalidateMappedMemoryRanges,
  vkGetDeviceMemoryCommitment: nvk.vkGetDeviceMemoryCommitment,
  vkGetBufferMemoryRequirements: nvk.vkGetBufferMemoryRequirements,
  vkBindBufferMemory: nvk.vkBindBufferMemory,
  vkGetImageMemoryRequirements: nvk.vkGetImageMemoryRequirements,
  vkBindImageMemory: nvk.vkBindImageMemory,
  vkGetImageSparseMemoryRequirements: nvk.vkGetImageSparseMemoryRequirements,
  vkGetPhysicalDeviceSparseImageFormatProperties: nvk.vkGetPhysicalDeviceSparseImageFormatProperties,
  vkQueueBindSparse: nvk.vkQueueBindSparse,
  vkCreateFence: nvk.vkCreateFence,
  vkDestroyFence: nvk.vkDestroyFence,
  vkResetFences: nvk.vkResetFences,
  vkGetFenceStatus: nvk.vkGetFenceStatus,
  vkWaitForFences: nvk.vkWaitForFences,
  vkCreateSemaphore: nvk.vkCreateSemaphore,
  vkDestroySemaphore: nvk.vkDestroySemaphore,
  vkCreateEvent: nvk.vkCreateEvent,
  vkDestroyEvent: nvk.vkDestroyEvent,
  vkGetEventStatus: nvk.vkGetEventStatus,
  vkSetEvent: nvk.vkSetEvent,
  vkResetEvent: nvk.vkResetEvent,
  vkCreateQueryPool: nvk.vkCreateQueryPool,
  vkDestroyQueryPool: nvk.vkDestroyQueryPool,
  vkGetQueryPoolResults: nvk.vkGetQueryPoolResults,
  vkResetQueryPool: nvk.vkResetQueryPool,
  vkCreateBuffer: nvk.vkCreateBuffer,
  vkDestroyBuffer: nvk.vkDestroyBuffer,
  vkCreateBufferView: nvk.vkCreateBufferView,
  vkDestroyBufferView: nvk.vkDestroyBufferView,
  vkCreateImage: nvk.vkCreateImage,
  vkDestroyImage: nvk.vkDestroyImage,
  vkGetImageSubresourceLayout: nvk.vkGetImageSubresourceLayout,
  vkCreateImageView: nvk.vkCreateImageView,
  vkDestroyImageView: nvk.vkDestroyImageView,
  vkCreateShaderModule: nvk.vkCreateShaderModule,
  vkDestroyShaderModule: nvk.vkDestroyShaderModule,
  vkCreatePipelineCache: nvk.vkCreatePipelineCache,
  vkDestroyPipelineCache: nvk.vkDestroyPipelineCache,
  vkGetPipelineCacheData: nvk.vkGetPipelineCacheData,
  vkMergePipelineCaches: nvk.vkMergePipelineCaches,
  vkCreateGraphicsPipelines: nvk.vkCreateGraphicsPipelines,
  vkCreateComputePipelines: nvk.vkCreateComputePipelines,
  vkDestroyPipeline: nvk.vkDestroyPipeline,
  vkCreatePipelineLayout: nvk.vkCreatePipelineLayout,
  vkDestroyPipelineLayout: nvk.vkDestroyPipelineLayout,
  vkCreateSampler: nvk.vkCreateSampler,
  vkDestroySampler: nvk.vkDestroySampler,
  vkCreateDescriptorSetLayout: nvk.vkCreateDescriptorSetLayout,
  vkDestroyDescriptorSetLayout: nvk.vkDestroyDescriptorSetLayout,
  vkCreateDescriptorPool: nvk.vkCreateDescriptorPool,
  vkDestroyDescriptorPool: nvk.vkDestroyDescriptorPool,
  vkResetDescriptorPool: nvk.vkResetDescriptorPool,
  vkAllocateDescriptorSets: nvk.vkAllocateDescriptorSets,
  vkFreeDescriptorSets: nvk.vkFreeDescriptorSets,
  vkUpdateDescriptorSets: nvk.vkUpdateDescriptorSets,
  vkCreateFramebuffer: nvk.vkCreateFramebuffer,
  vkDestroyFramebuffer: nvk.vkDestroyFramebuffer,
  vkCreateRenderPass: nvk.vkCreateRenderPass,
  vkDestroyRenderPass: nvk.vkDestroyRenderPass,
  vkGetRenderAreaGranularity: nvk.vkGetRenderAreaGranularity,
  vkCreateCommandPool: nvk.vkCreateCommandPool,
  vkDestroyCommandPool: nvk.vkDestroyCommandPool,
  vkResetCommandPool: nvk.vkResetCommandPool,
  vkAllocateCommandBuffers: nvk.vkAllocateCommandBuffers,
  vkFreeCommandBuffers: nvk.vkFreeCommandBuffers,
  vkBeginCommandBuffer: nvk.vkBeginCommandBuffer,
  vkEndCommandBuffer: nvk.vkEndCommandBuffer,
  vkResetCommandBuffer: nvk.vkResetCommandBuffer,
  vkCmdBindPipeline: nvk.vkCmdBindPipeline,
  vkCmdSetViewport: nvk.vkCmdSetViewport,
  vkCmdSetScissor: nvk.vkCmdSetScissor,
  vkCmdSetLineWidth: nvk.vkCmdSetLineWidth,
  vkCmdSetDepthBias: nvk.vkCmdSetDepthBias,
  vkCmdSetBlendConstants: nvk.vkCmdSetBlendConstants,
  vkCmdSetDepthBounds: nvk.vkCmdSetDepthBounds,
  vkCmdSetStencilCompareMask: nvk.vkCmdSetStencilCompareMask,
  vkCmdSetStencilWriteMask: nvk.vkCmdSetStencilWriteMask,
  vkCmdSetStencilReference: nvk.vkCmdSetStencilReference,
  vkCmdBindDescriptorSets: nvk.vkCmdBindDescriptorSets,
  vkCmdBindIndexBuffer: nvk.vkCmdBindIndexBuffer,
  vkCmdBindVertexBuffers: nvk.vkCmdBindVertexBuffers,
  vkCmdDraw: nvk.vkCmdDraw,
  vkCmdDrawIndexed: nvk.vkCmdDrawIndexed,
  vkCmdDrawIndirect: nvk.vkCmdDrawIndirect,
  vkCmdDrawIndexedIndirect: nvk.vkCmdDrawIndexedIndirect,
  vkCmdDispatch: nvk.vkCmdDispatch,
  vkCmdDispatchIndirect: nvk.vkCmdDispatchIndirect,
  vkCmdCopyBuffer: nvk.vkCmdCopyBuffer,
  vkCmdCopyImage: nvk.vkCmdCopyImage,
  vkCmdBlitImage: nvk.vkCmdBlitImage,
  vkCmdCopyBufferToImage: nvk.vkCmdCopyBufferToImage,
  vkCmdCopyImageToBuffer: nvk.vkCmdCopyImageToBuffer,
  vkCmdUpdateBuffer: nvk.vkCmdUpdateBuffer,
  vkCmdFillBuffer: nvk.vkCmdFillBuffer,
  vkCmdClearColorImage: nvk.vkCmdClearColorImage,
  vkCmdClearDepthStencilImage: nvk.vkCmdClearDepthStencilImage,
  vkCmdClearAttachments: nvk.vkCmdClearAttachments,
  vkCmdResolveImage: nvk.vkCmdResolveImage,
  vkCmdSetEvent: nvk.vkCmdSetEvent,
  vkCmdResetEvent: nvk.vkCmdResetEvent,
  vkCmdWaitEvents: nvk.vkCmdWaitEvents,
  vkCmdPipelineBarrier: nvk.vkCmdPipelineBarrier,
  vkCmdBeginQuery: nvk.vkCmdBeginQuery,
  vkCmdEndQuery: nvk.vkCmdEndQuery,
  vkCmdBeginConditionalRenderingEXT: nvk.vkCmdBeginConditionalRenderingEXT,
  vkCmdEndConditionalRenderingEXT: nvk.vkCmdEndConditionalRenderingEXT,
  vkCmdResetQueryPool: nvk.vkCmdResetQueryPool,
  vkCmdWriteTimestamp: nvk.vkCmdWriteTimestamp,
  vkCmdCopyQueryPoolResults: nvk.vkCmdCopyQueryPoolResults,
  vkCmdPushConstants: nvk.vkCmdPushConstants,
  vkCmdBeginRenderPass: nvk.vkCmdBeginRenderPass,
  vkCmdNextSubpass: nvk.vkCmdNextSubpass,
  vkCmdEndRenderPass: nvk.vkCmdEndRenderPass,
  vkCmdExecuteCommands: nvk.vkCmdExecuteCommands,
  vkGetPhysicalDeviceDisplayPropertiesKHR: nvk.vkGetPhysicalDeviceDisplayPropertiesKHR,
  vkGetPhysicalDeviceDisplayPlanePropertiesKHR: nvk.vkGetPhysicalDeviceDisplayPlanePropertiesKHR,
  vkGetDisplayPlaneSupportedDisplaysKHR: nvk.vkGetDisplayPlaneSupportedDisplaysKHR,
  vkGetDisplayModePropertiesKHR: nvk.vkGetDisplayModePropertiesKHR,
  vkCreateDisplayModeKHR: nvk.vkCreateDisplayModeKHR,
  vkGetDisplayPlaneCapabilitiesKHR: nvk.vkGetDisplayPlaneCapabilitiesKHR,
  vkCreateDisplayPlaneSurfaceKHR: nvk.vkCreateDisplayPlaneSurfaceKHR,
  vkCreateSharedSwapchainsKHR: nvk.vkCreateSharedSwapchainsKHR,
  vkDestroySurfaceKHR: nvk.vkDestroySurfaceKHR,
  vkGetPhysicalDeviceSurfaceSupportKHR: nvk.vkGetPhysicalDeviceSurfaceSupportKHR,
  vkGetPhysicalDeviceSurfaceCapabilitiesKHR: nvk.vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
  vkGetPhysicalDeviceSurfaceFormatsKHR: nvk.vkGetPhysicalDeviceSurfaceFormatsKHR,
  vkGetPhysicalDeviceSurfacePresentModesKHR: nvk.vkGetPhysicalDeviceSurfacePresentModesKHR,
  vkCreateSwapchainKHR: nvk.vkCreateSwapchainKHR,
  vkDestroySwapchainKHR: nvk.vkDestroySwapchainKHR,
  vkGetSwapchainImagesKHR: nvk.vkGetSwapchainImagesKHR,
  vkAcquireNextImageKHR: nvk.vkAcquireNextImageKHR,
  vkQueuePresentKHR: nvk.vkQueuePresentKHR,
  vkCreateWin32SurfaceKHR: nvk.vkCreateWin32SurfaceKHR,
  vkGetPhysicalDeviceWin32PresentationSupportKHR: nvk.vkGetPhysicalDeviceWin32PresentationSupportKHR,
  vkCreateDebugReportCallbackEXT: nvk.vkCreateDebugReportCallbackEXT,
  vkDestroyDebugReportCallbackEXT: nvk.vkDestroyDebugReportCallbackEXT,
  vkDebugReportMessageEXT: nvk.vkDebugReportMessageEXT,
  vkDebugMarkerSetObjectNameEXT: nvk.vkDebugMarkerSetObjectNameEXT,
  vkDebugMarkerSetObjectTagEXT: nvk.vkDebugMarkerSetObjectTagEXT,
  vkCmdDebugMarkerBeginEXT: nvk.vkCmdDebugMarkerBeginEXT,
  vkCmdDebugMarkerEndEXT: nvk.vkCmdDebugMarkerEndEXT,
  vkCmdDebugMarkerInsertEXT: nvk.vkCmdDebugMarkerInsertEXT,
  vkGetPhysicalDeviceExternalImageFormatPropertiesNV: nvk.vkGetPhysicalDeviceExternalImageFormatPropertiesNV,
  vkGetMemoryWin32HandleNV: nvk.vkGetMemoryWin32HandleNV,
  vkCmdExecuteGeneratedCommandsNV: nvk.vkCmdExecuteGeneratedCommandsNV,
  vkCmdPreprocessGeneratedCommandsNV: nvk.vkCmdPreprocessGeneratedCommandsNV,
  vkCmdBindPipelineShaderGroupNV: nvk.vkCmdBindPipelineShaderGroupNV,
  vkGetGeneratedCommandsMemoryRequirementsNV: nvk.vkGetGeneratedCommandsMemoryRequirementsNV,
  vkCreateIndirectCommandsLayoutNV: nvk.vkCreateIndirectCommandsLayoutNV,
  vkDestroyIndirectCommandsLayoutNV: nvk.vkDestroyIndirectCommandsLayoutNV,
  vkGetPhysicalDeviceFeatures2: nvk.vkGetPhysicalDeviceFeatures2,
  vkGetPhysicalDeviceProperties2: nvk.vkGetPhysicalDeviceProperties2,
  vkGetPhysicalDeviceFormatProperties2: nvk.vkGetPhysicalDeviceFormatProperties2,
  vkGetPhysicalDeviceImageFormatProperties2: nvk.vkGetPhysicalDeviceImageFormatProperties2,
  vkGetPhysicalDeviceQueueFamilyProperties2: nvk.vkGetPhysicalDeviceQueueFamilyProperties2,
  vkGetPhysicalDeviceMemoryProperties2: nvk.vkGetPhysicalDeviceMemoryProperties2,
  vkGetPhysicalDeviceSparseImageFormatProperties2: nvk.vkGetPhysicalDeviceSparseImageFormatProperties2,
  vkCmdPushDescriptorSetKHR: nvk.vkCmdPushDescriptorSetKHR,
  vkTrimCommandPool: nvk.vkTrimCommandPool,
  vkGetPhysicalDeviceExternalBufferProperties: nvk.vkGetPhysicalDeviceExternalBufferProperties,
  vkGetMemoryWin32HandleKHR: nvk.vkGetMemoryWin32HandleKHR,
  vkGetMemoryWin32HandlePropertiesKHR: nvk.vkGetMemoryWin32HandlePropertiesKHR,
  vkGetMemoryFdKHR: nvk.vkGetMemoryFdKHR,
  vkGetMemoryFdPropertiesKHR: nvk.vkGetMemoryFdPropertiesKHR,
  vkGetPhysicalDeviceExternalSemaphoreProperties: nvk.vkGetPhysicalDeviceExternalSemaphoreProperties,
  vkGetSemaphoreWin32HandleKHR: nvk.vkGetSemaphoreWin32HandleKHR,
  vkImportSemaphoreWin32HandleKHR: nvk.vkImportSemaphoreWin32HandleKHR,
  vkGetSemaphoreFdKHR: nvk.vkGetSemaphoreFdKHR,
  vkImportSemaphoreFdKHR: nvk.vkImportSemaphoreFdKHR,
  vkGetPhysicalDeviceExternalFenceProperties: nvk.vkGetPhysicalDeviceExternalFenceProperties,
  vkGetFenceWin32HandleKHR: nvk.vkGetFenceWin32HandleKHR,
  vkImportFenceWin32HandleKHR: nvk.vkImportFenceWin32HandleKHR,
  vkGetFenceFdKHR: nvk.vkGetFenceFdKHR,
  vkImportFenceFdKHR: nvk.vkImportFenceFdKHR,
  vkReleaseDisplayEXT: nvk.vkReleaseDisplayEXT,
  vkDisplayPowerControlEXT: nvk.vkDisplayPowerControlEXT,
  vkRegisterDeviceEventEXT: nvk.vkRegisterDeviceEventEXT,
  vkRegisterDisplayEventEXT: nvk.vkRegisterDisplayEventEXT,
  vkGetSwapchainCounterEXT: nvk.vkGetSwapchainCounterEXT,
  vkGetPhysicalDeviceSurfaceCapabilities2EXT: nvk.vkGetPhysicalDeviceSurfaceCapabilities2EXT,
  vkEnumeratePhysicalDeviceGroups: nvk.vkEnumeratePhysicalDeviceGroups,
  vkGetDeviceGroupPeerMemoryFeatures: nvk.vkGetDeviceGroupPeerMemoryFeatures,
  vkBindBufferMemory2: nvk.vkBindBufferMemory2,
  vkBindImageMemory2: nvk.vkBindImageMemory2,
  vkCmdSetDeviceMask: nvk.vkCmdSetDeviceMask,
  vkGetDeviceGroupPresentCapabilitiesKHR: nvk.vkGetDeviceGroupPresentCapabilitiesKHR,
  vkGetDeviceGroupSurfacePresentModesKHR: nvk.vkGetDeviceGroupSurfacePresentModesKHR,
  vkAcquireNextImage2KHR: nvk.vkAcquireNextImage2KHR,
  vkCmdDispatchBase: nvk.vkCmdDispatchBase,
  vkGetPhysicalDevicePresentRectanglesKHR: nvk.vkGetPhysicalDevicePresentRectanglesKHR,
  vkCreateDescriptorUpdateTemplate: nvk.vkCreateDescriptorUpdateTemplate,
  vkDestroyDescriptorUpdateTemplate: nvk.vkDestroyDescriptorUpdateTemplate,
  vkUpdateDescriptorSetWithTemplate: nvk.vkUpdateDescriptorSetWithTemplate,
  vkCmdPushDescriptorSetWithTemplateKHR: nvk.vkCmdPushDescriptorSetWithTemplateKHR,
  vkSetHdrMetadataEXT: nvk.vkSetHdrMetadataEXT,
  vkGetSwapchainStatusKHR: nvk.vkGetSwapchainStatusKHR,
  vkGetRefreshCycleDurationGOOGLE: nvk.vkGetRefreshCycleDurationGOOGLE,
  vkGetPastPresentationTimingGOOGLE: nvk.vkGetPastPresentationTimingGOOGLE,
  vkCmdSetViewportWScalingNV: nvk.vkCmdSetViewportWScalingNV,
  vkCmdSetDiscardRectangleEXT: nvk.vkCmdSetDiscardRectangleEXT,
  vkCmdSetSampleLocationsEXT: nvk.vkCmdSetSampleLocationsEXT,
  vkGetPhysicalDeviceMultisamplePropertiesEXT: nvk.vkGetPhysicalDeviceMultisamplePropertiesEXT,
  vkGetPhysicalDeviceSurfaceCapabilities2KHR: nvk.vkGetPhysicalDeviceSurfaceCapabilities2KHR,
  vkGetPhysicalDeviceSurfaceFormats2KHR: nvk.vkGetPhysicalDeviceSurfaceFormats2KHR,
  vkGetPhysicalDeviceDisplayProperties2KHR: nvk.vkGetPhysicalDeviceDisplayProperties2KHR,
  vkGetPhysicalDeviceDisplayPlaneProperties2KHR: nvk.vkGetPhysicalDeviceDisplayPlaneProperties2KHR,
  vkGetDisplayModeProperties2KHR: nvk.vkGetDisplayModeProperties2KHR,
  vkGetDisplayPlaneCapabilities2KHR: nvk.vkGetDisplayPlaneCapabilities2KHR,
  vkGetBufferMemoryRequirements2: nvk.vkGetBufferMemoryRequirements2,
  vkGetImageMemoryRequirements2: nvk.vkGetImageMemoryRequirements2,
  vkGetImageSparseMemoryRequirements2: nvk.vkGetImageSparseMemoryRequirements2,
  vkCreateSamplerYcbcrConversion: nvk.vkCreateSamplerYcbcrConversion,
  vkDestroySamplerYcbcrConversion: nvk.vkDestroySamplerYcbcrConversion,
  vkGetDeviceQueue2: nvk.vkGetDeviceQueue2,
  vkCreateValidationCacheEXT: nvk.vkCreateValidationCacheEXT,
  vkDestroyValidationCacheEXT: nvk.vkDestroyValidationCacheEXT,
  vkGetValidationCacheDataEXT: nvk.vkGetValidationCacheDataEXT,
  vkMergeValidationCachesEXT: nvk.vkMergeValidationCachesEXT,
  vkGetDescriptorSetLayoutSupport: nvk.vkGetDescriptorSetLayoutSupport,
  vkGetShaderInfoAMD: nvk.vkGetShaderInfoAMD,
  vkSetLocalDimmingAMD: nvk.vkSetLocalDimmingAMD,
  vkGetPhysicalDeviceCalibrateableTimeDomainsEXT: nvk.vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
  vkGetCalibratedTimestampsEXT: nvk.vkGetCalibratedTimestampsEXT,
  vkSetDebugUtilsObjectNameEXT: nvk.vkSetDebugUtilsObjectNameEXT,
  vkSetDebugUtilsObjectTagEXT: nvk.vkSetDebugUtilsObjectTagEXT,
  vkQueueBeginDebugUtilsLabelEXT: nvk.vkQueueBeginDebugUtilsLabelEXT,
  vkQueueEndDebugUtilsLabelEXT: nvk.vkQueueEndDebugUtilsLabelEXT,
  vkQueueInsertDebugUtilsLabelEXT: nvk.vkQueueInsertDebugUtilsLabelEXT,
  vkCmdBeginDebugUtilsLabelEXT: nvk.vkCmdBeginDebugUtilsLabelEXT,
  vkCmdEndDebugUtilsLabelEXT: nvk.vkCmdEndDebugUtilsLabelEXT,
  vkCmdInsertDebugUtilsLabelEXT: nvk.vkCmdInsertDebugUtilsLabelEXT,
  vkCreateDebugUtilsMessengerEXT: nvk.vkCreateDebugUtilsMessengerEXT,
  vkDestroyDebugUtilsMessengerEXT: nvk.vkDestroyDebugUtilsMessengerEXT,
  vkSubmitDebugUtilsMessageEXT: nvk.vkSubmitDebugUtilsMessageEXT,
  vkGetMemoryHostPointerPropertiesEXT: nvk.vkGetMemoryHostPointerPropertiesEXT,
  vkCmdWriteBufferMarkerAMD: nvk.vkCmdWriteBufferMarkerAMD,
  vkCreateRenderPass2: nvk.vkCreateRenderPass2,
  vkCmdBeginRenderPass2: nvk.vkCmdBeginRenderPass2,
  vkCmdNextSubpass2: nvk.vkCmdNextSubpass2,
  vkCmdEndRenderPass2: nvk.vkCmdEndRenderPass2,
  vkGetSemaphoreCounterValue: nvk.vkGetSemaphoreCounterValue,
  vkWaitSemaphores: nvk.vkWaitSemaphores,
  vkSignalSemaphore: nvk.vkSignalSemaphore,
  vkCmdDrawIndirectCount: nvk.vkCmdDrawIndirectCount,
  vkCmdDrawIndexedIndirectCount: nvk.vkCmdDrawIndexedIndirectCount,
  vkCmdSetCheckpointNV: nvk.vkCmdSetCheckpointNV,
  vkGetQueueCheckpointDataNV: nvk.vkGetQueueCheckpointDataNV,
  vkCmdBindTransformFeedbackBuffersEXT: nvk.vkCmdBindTransformFeedbackBuffersEXT,
  vkCmdBeginTransformFeedbackEXT: nvk.vkCmdBeginTransformFeedbackEXT,
  vkCmdEndTransformFeedbackEXT: nvk.vkCmdEndTransformFeedbackEXT,
  vkCmdBeginQueryIndexedEXT: nvk.vkCmdBeginQueryIndexedEXT,
  vkCmdEndQueryIndexedEXT: nvk.vkCmdEndQueryIndexedEXT,
  vkCmdDrawIndirectByteCountEXT: nvk.vkCmdDrawIndirectByteCountEXT,
  vkCmdSetExclusiveScissorNV: nvk.vkCmdSetExclusiveScissorNV,
  vkCmdBindShadingRateImageNV: nvk.vkCmdBindShadingRateImageNV,
  vkCmdSetViewportShadingRatePaletteNV: nvk.vkCmdSetViewportShadingRatePaletteNV,
  vkCmdSetCoarseSampleOrderNV: nvk.vkCmdSetCoarseSampleOrderNV,
  vkCmdDrawMeshTasksNV: nvk.vkCmdDrawMeshTasksNV,
  vkCmdDrawMeshTasksIndirectNV: nvk.vkCmdDrawMeshTasksIndirectNV,
  vkCmdDrawMeshTasksIndirectCountNV: nvk.vkCmdDrawMeshTasksIndirectCountNV,
  vkCompileDeferredNV: nvk.vkCompileDeferredNV,
  vkCreateAccelerationStructureNV: nvk.vkCreateAccelerationStructureNV,
  vkDestroyAccelerationStructureKHR: nvk.vkDestroyAccelerationStructureKHR,
  vkDestroyAccelerationStructureNV: nvk.vkDestroyAccelerationStructureNV,
  vkGetAccelerationStructureMemoryRequirementsNV: nvk.vkGetAccelerationStructureMemoryRequirementsNV,
  vkBindAccelerationStructureMemoryNV: nvk.vkBindAccelerationStructureMemoryNV,
  vkCmdCopyAccelerationStructureNV: nvk.vkCmdCopyAccelerationStructureNV,
  vkCmdCopyAccelerationStructureKHR: nvk.vkCmdCopyAccelerationStructureKHR,
  vkCopyAccelerationStructureKHR: nvk.vkCopyAccelerationStructureKHR,
  vkCmdCopyAccelerationStructureToMemoryKHR: nvk.vkCmdCopyAccelerationStructureToMemoryKHR,
  vkCopyAccelerationStructureToMemoryKHR: nvk.vkCopyAccelerationStructureToMemoryKHR,
  vkCmdCopyMemoryToAccelerationStructureKHR: nvk.vkCmdCopyMemoryToAccelerationStructureKHR,
  vkCopyMemoryToAccelerationStructureKHR: nvk.vkCopyMemoryToAccelerationStructureKHR,
  vkCmdWriteAccelerationStructuresPropertiesKHR: nvk.vkCmdWriteAccelerationStructuresPropertiesKHR,
  vkCmdWriteAccelerationStructuresPropertiesNV: nvk.vkCmdWriteAccelerationStructuresPropertiesNV,
  vkCmdBuildAccelerationStructureNV: nvk.vkCmdBuildAccelerationStructureNV,
  vkWriteAccelerationStructuresPropertiesKHR: nvk.vkWriteAccelerationStructuresPropertiesKHR,
  vkCmdTraceRaysKHR: nvk.vkCmdTraceRaysKHR,
  vkCmdTraceRaysNV: nvk.vkCmdTraceRaysNV,
  vkGetRayTracingShaderGroupHandlesKHR: nvk.vkGetRayTracingShaderGroupHandlesKHR,
  vkGetRayTracingCaptureReplayShaderGroupHandlesKHR: nvk.vkGetRayTracingCaptureReplayShaderGroupHandlesKHR,
  vkGetAccelerationStructureHandleNV: nvk.vkGetAccelerationStructureHandleNV,
  vkCreateRayTracingPipelinesNV: nvk.vkCreateRayTracingPipelinesNV,
  vkCreateRayTracingPipelinesKHR: nvk.vkCreateRayTracingPipelinesKHR,
  vkGetPhysicalDeviceCooperativeMatrixPropertiesNV: nvk.vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
  vkCmdTraceRaysIndirectKHR: nvk.vkCmdTraceRaysIndirectKHR,
  vkGetDeviceAccelerationStructureCompatibilityKHR: nvk.vkGetDeviceAccelerationStructureCompatibilityKHR,
  vkGetRayTracingShaderGroupStackSizeKHR: nvk.vkGetRayTracingShaderGroupStackSizeKHR,
  vkCmdSetRayTracingPipelineStackSizeKHR: nvk.vkCmdSetRayTracingPipelineStackSizeKHR,
  vkGetImageViewHandleNVX: nvk.vkGetImageViewHandleNVX,
  vkGetImageViewAddressNVX: nvk.vkGetImageViewAddressNVX,
  vkGetPhysicalDeviceSurfacePresentModes2EXT: nvk.vkGetPhysicalDeviceSurfacePresentModes2EXT,
  vkGetDeviceGroupSurfacePresentModes2EXT: nvk.vkGetDeviceGroupSurfacePresentModes2EXT,
  vkAcquireFullScreenExclusiveModeEXT: nvk.vkAcquireFullScreenExclusiveModeEXT,
  vkReleaseFullScreenExclusiveModeEXT: nvk.vkReleaseFullScreenExclusiveModeEXT,
  vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR: nvk.vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
  vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR: nvk.vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR,
  vkAcquireProfilingLockKHR: nvk.vkAcquireProfilingLockKHR,
  vkReleaseProfilingLockKHR: nvk.vkReleaseProfilingLockKHR,
  vkGetImageDrmFormatModifierPropertiesEXT: nvk.vkGetImageDrmFormatModifierPropertiesEXT,
  vkGetBufferOpaqueCaptureAddress: nvk.vkGetBufferOpaqueCaptureAddress,
  vkGetBufferDeviceAddress: nvk.vkGetBufferDeviceAddress,
  vkCreateHeadlessSurfaceEXT: nvk.vkCreateHeadlessSurfaceEXT,
  vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV: nvk.vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
  vkInitializePerformanceApiINTEL: nvk.vkInitializePerformanceApiINTEL,
  vkUninitializePerformanceApiINTEL: nvk.vkUninitializePerformanceApiINTEL,
  vkCmdSetPerformanceMarkerINTEL: nvk.vkCmdSetPerformanceMarkerINTEL,
  vkCmdSetPerformanceStreamMarkerINTEL: nvk.vkCmdSetPerformanceStreamMarkerINTEL,
  vkCmdSetPerformanceOverrideINTEL: nvk.vkCmdSetPerformanceOverrideINTEL,
  vkAcquirePerformanceConfigurationINTEL: nvk.vkAcquirePerformanceConfigurationINTEL,
  vkReleasePerformanceConfigurationINTEL: nvk.vkReleasePerformanceConfigurationINTEL,
  vkQueueSetPerformanceConfigurationINTEL: nvk.vkQueueSetPerformanceConfigurationINTEL,
  vkGetPerformanceParameterINTEL: nvk.vkGetPerformanceParameterINTEL,
  vkGetDeviceMemoryOpaqueCaptureAddress: nvk.vkGetDeviceMemoryOpaqueCaptureAddress,
  vkGetPipelineExecutablePropertiesKHR: nvk.vkGetPipelineExecutablePropertiesKHR,
  vkGetPipelineExecutableStatisticsKHR: nvk.vkGetPipelineExecutableStatisticsKHR,
  vkGetPipelineExecutableInternalRepresentationsKHR: nvk.vkGetPipelineExecutableInternalRepresentationsKHR,
  vkCmdSetLineStippleEXT: nvk.vkCmdSetLineStippleEXT,
  vkGetPhysicalDeviceToolPropertiesEXT: nvk.vkGetPhysicalDeviceToolPropertiesEXT,
  vkCreateAccelerationStructureKHR: nvk.vkCreateAccelerationStructureKHR,
  vkCmdBuildAccelerationStructuresKHR: nvk.vkCmdBuildAccelerationStructuresKHR,
  vkCmdBuildAccelerationStructuresIndirectKHR: nvk.vkCmdBuildAccelerationStructuresIndirectKHR,
  vkBuildAccelerationStructuresKHR: nvk.vkBuildAccelerationStructuresKHR,
  vkGetAccelerationStructureDeviceAddressKHR: nvk.vkGetAccelerationStructureDeviceAddressKHR,
  vkCreateDeferredOperationKHR: nvk.vkCreateDeferredOperationKHR,
  vkDestroyDeferredOperationKHR: nvk.vkDestroyDeferredOperationKHR,
  vkGetDeferredOperationMaxConcurrencyKHR: nvk.vkGetDeferredOperationMaxConcurrencyKHR,
  vkGetDeferredOperationResultKHR: nvk.vkGetDeferredOperationResultKHR,
  vkDeferredOperationJoinKHR: nvk.vkDeferredOperationJoinKHR,
  vkCmdSetCullModeEXT: nvk.vkCmdSetCullModeEXT,
  vkCmdSetFrontFaceEXT: nvk.vkCmdSetFrontFaceEXT,
  vkCmdSetPrimitiveTopologyEXT: nvk.vkCmdSetPrimitiveTopologyEXT,
  vkCmdSetViewportWithCountEXT: nvk.vkCmdSetViewportWithCountEXT,
  vkCmdSetScissorWithCountEXT: nvk.vkCmdSetScissorWithCountEXT,
  vkCmdBindVertexBuffers2EXT: nvk.vkCmdBindVertexBuffers2EXT,
  vkCmdSetDepthTestEnableEXT: nvk.vkCmdSetDepthTestEnableEXT,
  vkCmdSetDepthWriteEnableEXT: nvk.vkCmdSetDepthWriteEnableEXT,
  vkCmdSetDepthCompareOpEXT: nvk.vkCmdSetDepthCompareOpEXT,
  vkCmdSetDepthBoundsTestEnableEXT: nvk.vkCmdSetDepthBoundsTestEnableEXT,
  vkCmdSetStencilTestEnableEXT: nvk.vkCmdSetStencilTestEnableEXT,
  vkCmdSetStencilOpEXT: nvk.vkCmdSetStencilOpEXT,
  vkCreatePrivateDataSlotEXT: nvk.vkCreatePrivateDataSlotEXT,
  vkDestroyPrivateDataSlotEXT: nvk.vkDestroyPrivateDataSlotEXT,
  vkSetPrivateDataEXT: nvk.vkSetPrivateDataEXT,
  vkGetPrivateDataEXT: nvk.vkGetPrivateDataEXT,
  vkCmdCopyBuffer2KHR: nvk.vkCmdCopyBuffer2KHR,
  vkCmdCopyImage2KHR: nvk.vkCmdCopyImage2KHR,
  vkCmdBlitImage2KHR: nvk.vkCmdBlitImage2KHR,
  vkCmdCopyBufferToImage2KHR: nvk.vkCmdCopyBufferToImage2KHR,
  vkCmdCopyImageToBuffer2KHR: nvk.vkCmdCopyImageToBuffer2KHR,
  vkCmdResolveImage2KHR: nvk.vkCmdResolveImage2KHR,
  vkCmdSetFragmentShadingRateKHR: nvk.vkCmdSetFragmentShadingRateKHR,
  vkGetPhysicalDeviceFragmentShadingRatesKHR: nvk.vkGetPhysicalDeviceFragmentShadingRatesKHR,
  vkCmdSetFragmentShadingRateEnumNV: nvk.vkCmdSetFragmentShadingRateEnumNV,
  vkGetAccelerationStructureBuildSizesKHR: nvk.vkGetAccelerationStructureBuildSizesKHR,
  VkInstance,
  VkPhysicalDevice,
  VkDevice,
  VkQueue,
  VkCommandBuffer,
  VkDeviceMemory,
  VkCommandPool,
  VkBuffer,
  VkBufferView,
  VkImage,
  VkImageView,
  VkShaderModule,
  VkPipeline,
  VkPipelineLayout,
  VkSampler,
  VkDescriptorSet,
  VkDescriptorSetLayout,
  VkDescriptorPool,
  VkFence,
  VkSemaphore,
  VkEvent,
  VkQueryPool,
  VkFramebuffer,
  VkRenderPass,
  VkPipelineCache,
  VkIndirectCommandsLayoutNV,
  VkDescriptorUpdateTemplate,
  VkSamplerYcbcrConversion,
  VkValidationCacheEXT,
  VkAccelerationStructureKHR,
  VkAccelerationStructureNV,
  VkPerformanceConfigurationINTEL,
  VkDeferredOperationKHR,
  VkPrivateDataSlotEXT,
  VkDisplayKHR,
  VkDisplayModeKHR,
  VkSurfaceKHR,
  VkSwapchainKHR,
  VkDebugReportCallbackEXT,
  VkDebugUtilsMessengerEXT,
  VkClearColorValue,
  VkClearValue,
  VkPerformanceCounterResultKHR,
  VkPerformanceValueDataINTEL,
  VkPipelineExecutableStatisticValueKHR,
  VkDeviceOrHostAddressKHR,
  VkDeviceOrHostAddressConstKHR,
  VkAccelerationStructureGeometryDataKHR,
  VkBaseOutStructure,
  VkBaseInStructure,
  VkOffset2D,
  VkOffset3D,
  VkExtent2D,
  VkExtent3D,
  VkViewport,
  VkRect2D,
  VkClearRect,
  VkComponentMapping,
  VkPhysicalDeviceProperties,
  VkExtensionProperties,
  VkLayerProperties,
  VkApplicationInfo,
  VkAllocationCallbacks,
  VkDeviceQueueCreateInfo,
  VkDeviceCreateInfo,
  VkInstanceCreateInfo,
  VkQueueFamilyProperties,
  VkPhysicalDeviceMemoryProperties,
  VkMemoryAllocateInfo,
  VkMemoryRequirements,
  VkSparseImageFormatProperties,
  VkSparseImageMemoryRequirements,
  VkMemoryType,
  VkMemoryHeap,
  VkMappedMemoryRange,
  VkFormatProperties,
  VkImageFormatProperties,
  VkDescriptorBufferInfo,
  VkDescriptorImageInfo,
  VkWriteDescriptorSet,
  VkCopyDescriptorSet,
  VkBufferCreateInfo,
  VkBufferViewCreateInfo,
  VkImageSubresource,
  VkImageSubresourceLayers,
  VkImageSubresourceRange,
  VkMemoryBarrier,
  VkBufferMemoryBarrier,
  VkImageMemoryBarrier,
  VkImageCreateInfo,
  VkSubresourceLayout,
  VkImageViewCreateInfo,
  VkBufferCopy,
  VkSparseMemoryBind,
  VkSparseImageMemoryBind,
  VkSparseBufferMemoryBindInfo,
  VkSparseImageOpaqueMemoryBindInfo,
  VkSparseImageMemoryBindInfo,
  VkBindSparseInfo,
  VkImageCopy,
  VkImageBlit,
  VkBufferImageCopy,
  VkImageResolve,
  VkShaderModuleCreateInfo,
  VkDescriptorSetLayoutBinding,
  VkDescriptorSetLayoutCreateInfo,
  VkDescriptorPoolSize,
  VkDescriptorPoolCreateInfo,
  VkDescriptorSetAllocateInfo,
  VkSpecializationMapEntry,
  VkSpecializationInfo,
  VkPipelineShaderStageCreateInfo,
  VkComputePipelineCreateInfo,
  VkVertexInputBindingDescription,
  VkVertexInputAttributeDescription,
  VkPipelineVertexInputStateCreateInfo,
  VkPipelineInputAssemblyStateCreateInfo,
  VkPipelineTessellationStateCreateInfo,
  VkPipelineViewportStateCreateInfo,
  VkPipelineRasterizationStateCreateInfo,
  VkPipelineMultisampleStateCreateInfo,
  VkPipelineColorBlendAttachmentState,
  VkPipelineColorBlendStateCreateInfo,
  VkPipelineDynamicStateCreateInfo,
  VkStencilOpState,
  VkPipelineDepthStencilStateCreateInfo,
  VkGraphicsPipelineCreateInfo,
  VkPipelineCacheCreateInfo,
  VkPushConstantRange,
  VkPipelineLayoutCreateInfo,
  VkSamplerCreateInfo,
  VkCommandPoolCreateInfo,
  VkCommandBufferAllocateInfo,
  VkCommandBufferInheritanceInfo,
  VkCommandBufferBeginInfo,
  VkRenderPassBeginInfo,
  VkClearDepthStencilValue,
  VkClearAttachment,
  VkAttachmentDescription,
  VkAttachmentReference,
  VkSubpassDescription,
  VkSubpassDependency,
  VkRenderPassCreateInfo,
  VkEventCreateInfo,
  VkFenceCreateInfo,
  VkPhysicalDeviceFeatures,
  VkPhysicalDeviceSparseProperties,
  VkPhysicalDeviceLimits,
  VkSemaphoreCreateInfo,
  VkQueryPoolCreateInfo,
  VkFramebufferCreateInfo,
  VkDrawIndirectCommand,
  VkDrawIndexedIndirectCommand,
  VkDispatchIndirectCommand,
  VkSubmitInfo,
  VkDisplayPropertiesKHR,
  VkDisplayPlanePropertiesKHR,
  VkDisplayModeParametersKHR,
  VkDisplayModePropertiesKHR,
  VkDisplayModeCreateInfoKHR,
  VkDisplayPlaneCapabilitiesKHR,
  VkDisplaySurfaceCreateInfoKHR,
  VkDisplayPresentInfoKHR,
  VkSurfaceCapabilitiesKHR,
  VkWin32SurfaceCreateInfoKHR,
  VkSurfaceFormatKHR,
  VkSwapchainCreateInfoKHR,
  VkPresentInfoKHR,
  VkDebugReportCallbackCreateInfoEXT,
  VkValidationFlagsEXT,
  VkValidationFeaturesEXT,
  VkPipelineRasterizationStateRasterizationOrderAMD,
  VkDebugMarkerObjectNameInfoEXT,
  VkDebugMarkerObjectTagInfoEXT,
  VkDebugMarkerMarkerInfoEXT,
  VkDedicatedAllocationImageCreateInfoNV,
  VkDedicatedAllocationBufferCreateInfoNV,
  VkDedicatedAllocationMemoryAllocateInfoNV,
  VkExternalImageFormatPropertiesNV,
  VkExternalMemoryImageCreateInfoNV,
  VkExportMemoryAllocateInfoNV,
  VkImportMemoryWin32HandleInfoNV,
  VkExportMemoryWin32HandleInfoNV,
  VkWin32KeyedMutexAcquireReleaseInfoNV,
  VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
  VkDevicePrivateDataCreateInfoEXT,
  VkPrivateDataSlotCreateInfoEXT,
  VkPhysicalDevicePrivateDataFeaturesEXT,
  VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
  VkGraphicsShaderGroupCreateInfoNV,
  VkGraphicsPipelineShaderGroupsCreateInfoNV,
  VkBindShaderGroupIndirectCommandNV,
  VkBindIndexBufferIndirectCommandNV,
  VkBindVertexBufferIndirectCommandNV,
  VkSetStateFlagsIndirectCommandNV,
  VkIndirectCommandsStreamNV,
  VkIndirectCommandsLayoutTokenNV,
  VkIndirectCommandsLayoutCreateInfoNV,
  VkGeneratedCommandsInfoNV,
  VkGeneratedCommandsMemoryRequirementsInfoNV,
  VkPhysicalDeviceFeatures2,
  VkPhysicalDeviceFeatures2KHR,
  VkPhysicalDeviceProperties2,
  VkPhysicalDeviceProperties2KHR,
  VkFormatProperties2,
  VkFormatProperties2KHR,
  VkImageFormatProperties2,
  VkImageFormatProperties2KHR,
  VkPhysicalDeviceImageFormatInfo2,
  VkPhysicalDeviceImageFormatInfo2KHR,
  VkQueueFamilyProperties2,
  VkQueueFamilyProperties2KHR,
  VkPhysicalDeviceMemoryProperties2,
  VkPhysicalDeviceMemoryProperties2KHR,
  VkSparseImageFormatProperties2,
  VkSparseImageFormatProperties2KHR,
  VkPhysicalDeviceSparseImageFormatInfo2,
  VkPhysicalDeviceSparseImageFormatInfo2KHR,
  VkPhysicalDevicePushDescriptorPropertiesKHR,
  VkConformanceVersion,
  VkConformanceVersionKHR,
  VkPhysicalDeviceDriverProperties,
  VkPhysicalDeviceDriverPropertiesKHR,
  VkPresentRegionsKHR,
  VkPresentRegionKHR,
  VkRectLayerKHR,
  VkPhysicalDeviceVariablePointersFeatures,
  VkPhysicalDeviceVariablePointersFeaturesKHR,
  VkPhysicalDeviceVariablePointerFeaturesKHR,
  VkPhysicalDeviceVariablePointerFeatures,
  VkExternalMemoryProperties,
  VkExternalMemoryPropertiesKHR,
  VkPhysicalDeviceExternalImageFormatInfo,
  VkPhysicalDeviceExternalImageFormatInfoKHR,
  VkExternalImageFormatProperties,
  VkExternalImageFormatPropertiesKHR,
  VkPhysicalDeviceExternalBufferInfo,
  VkPhysicalDeviceExternalBufferInfoKHR,
  VkExternalBufferProperties,
  VkExternalBufferPropertiesKHR,
  VkPhysicalDeviceIDProperties,
  VkPhysicalDeviceIDPropertiesKHR,
  VkExternalMemoryImageCreateInfo,
  VkExternalMemoryImageCreateInfoKHR,
  VkExternalMemoryBufferCreateInfo,
  VkExternalMemoryBufferCreateInfoKHR,
  VkExportMemoryAllocateInfo,
  VkExportMemoryAllocateInfoKHR,
  VkImportMemoryWin32HandleInfoKHR,
  VkExportMemoryWin32HandleInfoKHR,
  VkMemoryWin32HandlePropertiesKHR,
  VkMemoryGetWin32HandleInfoKHR,
  VkImportMemoryFdInfoKHR,
  VkMemoryFdPropertiesKHR,
  VkMemoryGetFdInfoKHR,
  VkWin32KeyedMutexAcquireReleaseInfoKHR,
  VkPhysicalDeviceExternalSemaphoreInfo,
  VkPhysicalDeviceExternalSemaphoreInfoKHR,
  VkExternalSemaphoreProperties,
  VkExternalSemaphorePropertiesKHR,
  VkExportSemaphoreCreateInfo,
  VkExportSemaphoreCreateInfoKHR,
  VkImportSemaphoreWin32HandleInfoKHR,
  VkExportSemaphoreWin32HandleInfoKHR,
  VkD3D12FenceSubmitInfoKHR,
  VkSemaphoreGetWin32HandleInfoKHR,
  VkImportSemaphoreFdInfoKHR,
  VkSemaphoreGetFdInfoKHR,
  VkPhysicalDeviceExternalFenceInfo,
  VkPhysicalDeviceExternalFenceInfoKHR,
  VkExternalFenceProperties,
  VkExternalFencePropertiesKHR,
  VkExportFenceCreateInfo,
  VkExportFenceCreateInfoKHR,
  VkImportFenceWin32HandleInfoKHR,
  VkExportFenceWin32HandleInfoKHR,
  VkFenceGetWin32HandleInfoKHR,
  VkImportFenceFdInfoKHR,
  VkFenceGetFdInfoKHR,
  VkPhysicalDeviceMultiviewFeatures,
  VkPhysicalDeviceMultiviewFeaturesKHR,
  VkPhysicalDeviceMultiviewProperties,
  VkPhysicalDeviceMultiviewPropertiesKHR,
  VkRenderPassMultiviewCreateInfo,
  VkRenderPassMultiviewCreateInfoKHR,
  VkSurfaceCapabilities2EXT,
  VkDisplayPowerInfoEXT,
  VkDeviceEventInfoEXT,
  VkDisplayEventInfoEXT,
  VkSwapchainCounterCreateInfoEXT,
  VkPhysicalDeviceGroupProperties,
  VkPhysicalDeviceGroupPropertiesKHR,
  VkMemoryAllocateFlagsInfo,
  VkMemoryAllocateFlagsInfoKHR,
  VkBindBufferMemoryInfo,
  VkBindBufferMemoryInfoKHR,
  VkBindBufferMemoryDeviceGroupInfo,
  VkBindBufferMemoryDeviceGroupInfoKHR,
  VkBindImageMemoryInfo,
  VkBindImageMemoryInfoKHR,
  VkBindImageMemoryDeviceGroupInfo,
  VkBindImageMemoryDeviceGroupInfoKHR,
  VkDeviceGroupRenderPassBeginInfo,
  VkDeviceGroupRenderPassBeginInfoKHR,
  VkDeviceGroupCommandBufferBeginInfo,
  VkDeviceGroupCommandBufferBeginInfoKHR,
  VkDeviceGroupSubmitInfo,
  VkDeviceGroupSubmitInfoKHR,
  VkDeviceGroupBindSparseInfo,
  VkDeviceGroupBindSparseInfoKHR,
  VkDeviceGroupPresentCapabilitiesKHR,
  VkImageSwapchainCreateInfoKHR,
  VkBindImageMemorySwapchainInfoKHR,
  VkAcquireNextImageInfoKHR,
  VkDeviceGroupPresentInfoKHR,
  VkDeviceGroupDeviceCreateInfo,
  VkDeviceGroupDeviceCreateInfoKHR,
  VkDeviceGroupSwapchainCreateInfoKHR,
  VkDescriptorUpdateTemplateEntry,
  VkDescriptorUpdateTemplateEntryKHR,
  VkDescriptorUpdateTemplateCreateInfo,
  VkDescriptorUpdateTemplateCreateInfoKHR,
  VkXYColorEXT,
  VkHdrMetadataEXT,
  VkDisplayNativeHdrSurfaceCapabilitiesAMD,
  VkSwapchainDisplayNativeHdrCreateInfoAMD,
  VkRefreshCycleDurationGOOGLE,
  VkPastPresentationTimingGOOGLE,
  VkPresentTimesInfoGOOGLE,
  VkPresentTimeGOOGLE,
  VkViewportWScalingNV,
  VkPipelineViewportWScalingStateCreateInfoNV,
  VkViewportSwizzleNV,
  VkPipelineViewportSwizzleStateCreateInfoNV,
  VkPhysicalDeviceDiscardRectanglePropertiesEXT,
  VkPipelineDiscardRectangleStateCreateInfoEXT,
  VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
  VkInputAttachmentAspectReference,
  VkInputAttachmentAspectReferenceKHR,
  VkRenderPassInputAttachmentAspectCreateInfo,
  VkRenderPassInputAttachmentAspectCreateInfoKHR,
  VkPhysicalDeviceSurfaceInfo2KHR,
  VkSurfaceCapabilities2KHR,
  VkSurfaceFormat2KHR,
  VkDisplayProperties2KHR,
  VkDisplayPlaneProperties2KHR,
  VkDisplayModeProperties2KHR,
  VkDisplayPlaneInfo2KHR,
  VkDisplayPlaneCapabilities2KHR,
  VkSharedPresentSurfaceCapabilitiesKHR,
  VkPhysicalDevice16BitStorageFeatures,
  VkPhysicalDevice16BitStorageFeaturesKHR,
  VkPhysicalDeviceSubgroupProperties,
  VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
  VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR,
  VkBufferMemoryRequirementsInfo2,
  VkBufferMemoryRequirementsInfo2KHR,
  VkImageMemoryRequirementsInfo2,
  VkImageMemoryRequirementsInfo2KHR,
  VkImageSparseMemoryRequirementsInfo2,
  VkImageSparseMemoryRequirementsInfo2KHR,
  VkMemoryRequirements2,
  VkMemoryRequirements2KHR,
  VkSparseImageMemoryRequirements2,
  VkSparseImageMemoryRequirements2KHR,
  VkPhysicalDevicePointClippingProperties,
  VkPhysicalDevicePointClippingPropertiesKHR,
  VkMemoryDedicatedRequirements,
  VkMemoryDedicatedRequirementsKHR,
  VkMemoryDedicatedAllocateInfo,
  VkMemoryDedicatedAllocateInfoKHR,
  VkImageViewUsageCreateInfo,
  VkImageViewUsageCreateInfoKHR,
  VkPipelineTessellationDomainOriginStateCreateInfo,
  VkPipelineTessellationDomainOriginStateCreateInfoKHR,
  VkSamplerYcbcrConversionInfo,
  VkSamplerYcbcrConversionInfoKHR,
  VkSamplerYcbcrConversionCreateInfo,
  VkSamplerYcbcrConversionCreateInfoKHR,
  VkBindImagePlaneMemoryInfo,
  VkBindImagePlaneMemoryInfoKHR,
  VkImagePlaneMemoryRequirementsInfo,
  VkImagePlaneMemoryRequirementsInfoKHR,
  VkPhysicalDeviceSamplerYcbcrConversionFeatures,
  VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR,
  VkSamplerYcbcrConversionImageFormatProperties,
  VkSamplerYcbcrConversionImageFormatPropertiesKHR,
  VkTextureLODGatherFormatPropertiesAMD,
  VkConditionalRenderingBeginInfoEXT,
  VkProtectedSubmitInfo,
  VkPhysicalDeviceProtectedMemoryFeatures,
  VkPhysicalDeviceProtectedMemoryProperties,
  VkDeviceQueueInfo2,
  VkPipelineCoverageToColorStateCreateInfoNV,
  VkPhysicalDeviceSamplerFilterMinmaxProperties,
  VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT,
  VkSampleLocationEXT,
  VkSampleLocationsInfoEXT,
  VkAttachmentSampleLocationsEXT,
  VkSubpassSampleLocationsEXT,
  VkRenderPassSampleLocationsBeginInfoEXT,
  VkPipelineSampleLocationsStateCreateInfoEXT,
  VkPhysicalDeviceSampleLocationsPropertiesEXT,
  VkMultisamplePropertiesEXT,
  VkSamplerReductionModeCreateInfo,
  VkSamplerReductionModeCreateInfoEXT,
  VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
  VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
  VkPipelineColorBlendAdvancedStateCreateInfoEXT,
  VkPhysicalDeviceInlineUniformBlockFeaturesEXT,
  VkPhysicalDeviceInlineUniformBlockPropertiesEXT,
  VkWriteDescriptorSetInlineUniformBlockEXT,
  VkDescriptorPoolInlineUniformBlockCreateInfoEXT,
  VkPipelineCoverageModulationStateCreateInfoNV,
  VkImageFormatListCreateInfo,
  VkImageFormatListCreateInfoKHR,
  VkValidationCacheCreateInfoEXT,
  VkShaderModuleValidationCacheCreateInfoEXT,
  VkPhysicalDeviceMaintenance3Properties,
  VkPhysicalDeviceMaintenance3PropertiesKHR,
  VkDescriptorSetLayoutSupport,
  VkDescriptorSetLayoutSupportKHR,
  VkPhysicalDeviceShaderDrawParametersFeatures,
  VkPhysicalDeviceShaderDrawParameterFeatures,
  VkPhysicalDeviceShaderFloat16Int8Features,
  VkPhysicalDeviceShaderFloat16Int8FeaturesKHR,
  VkPhysicalDeviceFloat16Int8FeaturesKHR,
  VkPhysicalDeviceFloatControlsProperties,
  VkPhysicalDeviceFloatControlsPropertiesKHR,
  VkPhysicalDeviceHostQueryResetFeatures,
  VkPhysicalDeviceHostQueryResetFeaturesEXT,
  VkShaderResourceUsageAMD,
  VkShaderStatisticsInfoAMD,
  VkDeviceQueueGlobalPriorityCreateInfoEXT,
  VkDebugUtilsObjectNameInfoEXT,
  VkDebugUtilsObjectTagInfoEXT,
  VkDebugUtilsLabelEXT,
  VkDebugUtilsMessengerCreateInfoEXT,
  VkDebugUtilsMessengerCallbackDataEXT,
  VkPhysicalDeviceDeviceMemoryReportFeaturesEXT,
  VkDeviceDeviceMemoryReportCreateInfoEXT,
  VkDeviceMemoryReportCallbackDataEXT,
  VkImportMemoryHostPointerInfoEXT,
  VkMemoryHostPointerPropertiesEXT,
  VkPhysicalDeviceExternalMemoryHostPropertiesEXT,
  VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
  VkCalibratedTimestampInfoEXT,
  VkPhysicalDeviceShaderCorePropertiesAMD,
  VkPhysicalDeviceShaderCoreProperties2AMD,
  VkPipelineRasterizationConservativeStateCreateInfoEXT,
  VkPhysicalDeviceDescriptorIndexingFeatures,
  VkPhysicalDeviceDescriptorIndexingFeaturesEXT,
  VkPhysicalDeviceDescriptorIndexingProperties,
  VkPhysicalDeviceDescriptorIndexingPropertiesEXT,
  VkDescriptorSetLayoutBindingFlagsCreateInfo,
  VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,
  VkDescriptorSetVariableDescriptorCountAllocateInfo,
  VkDescriptorSetVariableDescriptorCountAllocateInfoEXT,
  VkDescriptorSetVariableDescriptorCountLayoutSupport,
  VkDescriptorSetVariableDescriptorCountLayoutSupportEXT,
  VkAttachmentDescription2,
  VkAttachmentDescription2KHR,
  VkAttachmentReference2,
  VkAttachmentReference2KHR,
  VkSubpassDescription2,
  VkSubpassDescription2KHR,
  VkSubpassDependency2,
  VkSubpassDependency2KHR,
  VkRenderPassCreateInfo2,
  VkRenderPassCreateInfo2KHR,
  VkSubpassBeginInfo,
  VkSubpassBeginInfoKHR,
  VkSubpassEndInfo,
  VkSubpassEndInfoKHR,
  VkPhysicalDeviceTimelineSemaphoreFeatures,
  VkPhysicalDeviceTimelineSemaphoreFeaturesKHR,
  VkPhysicalDeviceTimelineSemaphoreProperties,
  VkPhysicalDeviceTimelineSemaphorePropertiesKHR,
  VkSemaphoreTypeCreateInfo,
  VkSemaphoreTypeCreateInfoKHR,
  VkTimelineSemaphoreSubmitInfo,
  VkTimelineSemaphoreSubmitInfoKHR,
  VkSemaphoreWaitInfo,
  VkSemaphoreWaitInfoKHR,
  VkSemaphoreSignalInfo,
  VkSemaphoreSignalInfoKHR,
  VkVertexInputBindingDivisorDescriptionEXT,
  VkPipelineVertexInputDivisorStateCreateInfoEXT,
  VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,
  VkPhysicalDevicePCIBusInfoPropertiesEXT,
  VkCommandBufferInheritanceConditionalRenderingInfoEXT,
  VkPhysicalDevice8BitStorageFeatures,
  VkPhysicalDevice8BitStorageFeaturesKHR,
  VkPhysicalDeviceConditionalRenderingFeaturesEXT,
  VkPhysicalDeviceVulkanMemoryModelFeatures,
  VkPhysicalDeviceVulkanMemoryModelFeaturesKHR,
  VkPhysicalDeviceShaderAtomicInt64Features,
  VkPhysicalDeviceShaderAtomicInt64FeaturesKHR,
  VkPhysicalDeviceShaderAtomicFloatFeaturesEXT,
  VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,
  VkQueueFamilyCheckpointPropertiesNV,
  VkCheckpointDataNV,
  VkPhysicalDeviceDepthStencilResolveProperties,
  VkPhysicalDeviceDepthStencilResolvePropertiesKHR,
  VkSubpassDescriptionDepthStencilResolve,
  VkSubpassDescriptionDepthStencilResolveKHR,
  VkImageViewASTCDecodeModeEXT,
  VkPhysicalDeviceASTCDecodeFeaturesEXT,
  VkPhysicalDeviceTransformFeedbackFeaturesEXT,
  VkPhysicalDeviceTransformFeedbackPropertiesEXT,
  VkPipelineRasterizationStateStreamCreateInfoEXT,
  VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,
  VkPipelineRepresentativeFragmentTestStateCreateInfoNV,
  VkPhysicalDeviceExclusiveScissorFeaturesNV,
  VkPipelineViewportExclusiveScissorStateCreateInfoNV,
  VkPhysicalDeviceCornerSampledImageFeaturesNV,
  VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,
  VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV,
  VkPhysicalDeviceShaderImageFootprintFeaturesNV,
  VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
  VkShadingRatePaletteNV,
  VkPipelineViewportShadingRateImageStateCreateInfoNV,
  VkPhysicalDeviceShadingRateImageFeaturesNV,
  VkPhysicalDeviceShadingRateImagePropertiesNV,
  VkCoarseSampleLocationNV,
  VkCoarseSampleOrderCustomNV,
  VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,
  VkPhysicalDeviceMeshShaderFeaturesNV,
  VkPhysicalDeviceMeshShaderPropertiesNV,
  VkDrawMeshTasksIndirectCommandNV,
  VkRayTracingShaderGroupCreateInfoNV,
  VkRayTracingShaderGroupCreateInfoKHR,
  VkRayTracingPipelineCreateInfoNV,
  VkRayTracingPipelineCreateInfoKHR,
  VkGeometryTrianglesNV,
  VkGeometryAABBNV,
  VkGeometryDataNV,
  VkGeometryNV,
  VkAccelerationStructureInfoNV,
  VkAccelerationStructureCreateInfoNV,
  VkBindAccelerationStructureMemoryInfoNV,
  VkWriteDescriptorSetAccelerationStructureKHR,
  VkWriteDescriptorSetAccelerationStructureNV,
  VkAccelerationStructureMemoryRequirementsInfoNV,
  VkPhysicalDeviceAccelerationStructureFeaturesKHR,
  VkPhysicalDeviceRayTracingPipelineFeaturesKHR,
  VkPhysicalDeviceRayQueryFeaturesKHR,
  VkPhysicalDeviceAccelerationStructurePropertiesKHR,
  VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
  VkPhysicalDeviceRayTracingPropertiesNV,
  VkStridedDeviceAddressRegionKHR,
  VkTraceRaysIndirectCommandKHR,
  VkDrmFormatModifierPropertiesListEXT,
  VkDrmFormatModifierPropertiesEXT,
  VkPhysicalDeviceImageDrmFormatModifierInfoEXT,
  VkImageDrmFormatModifierListCreateInfoEXT,
  VkImageDrmFormatModifierExplicitCreateInfoEXT,
  VkImageDrmFormatModifierPropertiesEXT,
  VkImageStencilUsageCreateInfo,
  VkImageStencilUsageCreateInfoEXT,
  VkDeviceMemoryOverallocationCreateInfoAMD,
  VkPhysicalDeviceFragmentDensityMapFeaturesEXT,
  VkPhysicalDeviceFragmentDensityMap2FeaturesEXT,
  VkPhysicalDeviceFragmentDensityMapPropertiesEXT,
  VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,
  VkRenderPassFragmentDensityMapCreateInfoEXT,
  VkPhysicalDeviceScalarBlockLayoutFeatures,
  VkPhysicalDeviceScalarBlockLayoutFeaturesEXT,
  VkSurfaceProtectedCapabilitiesKHR,
  VkPhysicalDeviceUniformBufferStandardLayoutFeatures,
  VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR,
  VkPhysicalDeviceDepthClipEnableFeaturesEXT,
  VkPipelineRasterizationDepthClipStateCreateInfoEXT,
  VkPhysicalDeviceMemoryBudgetPropertiesEXT,
  VkPhysicalDeviceMemoryPriorityFeaturesEXT,
  VkMemoryPriorityAllocateInfoEXT,
  VkPhysicalDeviceBufferDeviceAddressFeatures,
  VkPhysicalDeviceBufferDeviceAddressFeaturesKHR,
  VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,
  VkPhysicalDeviceBufferAddressFeaturesEXT,
  VkBufferDeviceAddressInfo,
  VkBufferDeviceAddressInfoKHR,
  VkBufferDeviceAddressInfoEXT,
  VkBufferOpaqueCaptureAddressCreateInfo,
  VkBufferOpaqueCaptureAddressCreateInfoKHR,
  VkBufferDeviceAddressCreateInfoEXT,
  VkPhysicalDeviceImageViewImageFormatInfoEXT,
  VkFilterCubicImageViewImageFormatPropertiesEXT,
  VkPhysicalDeviceImagelessFramebufferFeatures,
  VkPhysicalDeviceImagelessFramebufferFeaturesKHR,
  VkFramebufferAttachmentsCreateInfo,
  VkFramebufferAttachmentsCreateInfoKHR,
  VkFramebufferAttachmentImageInfo,
  VkFramebufferAttachmentImageInfoKHR,
  VkRenderPassAttachmentBeginInfo,
  VkRenderPassAttachmentBeginInfoKHR,
  VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT,
  VkPhysicalDeviceCooperativeMatrixFeaturesNV,
  VkPhysicalDeviceCooperativeMatrixPropertiesNV,
  VkCooperativeMatrixPropertiesNV,
  VkPhysicalDeviceYcbcrImageArraysFeaturesEXT,
  VkImageViewHandleInfoNVX,
  VkImageViewAddressPropertiesNVX,
  VkPipelineCreationFeedbackEXT,
  VkPipelineCreationFeedbackCreateInfoEXT,
  VkSurfaceFullScreenExclusiveInfoEXT,
  VkSurfaceFullScreenExclusiveWin32InfoEXT,
  VkSurfaceCapabilitiesFullScreenExclusiveEXT,
  VkPhysicalDevicePerformanceQueryFeaturesKHR,
  VkPhysicalDevicePerformanceQueryPropertiesKHR,
  VkPerformanceCounterKHR,
  VkPerformanceCounterDescriptionKHR,
  VkQueryPoolPerformanceCreateInfoKHR,
  VkAcquireProfilingLockInfoKHR,
  VkPerformanceQuerySubmitInfoKHR,
  VkHeadlessSurfaceCreateInfoEXT,
  VkPhysicalDeviceCoverageReductionModeFeaturesNV,
  VkPipelineCoverageReductionStateCreateInfoNV,
  VkFramebufferMixedSamplesCombinationNV,
  VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
  VkPerformanceValueINTEL,
  VkInitializePerformanceApiInfoINTEL,
  VkQueryPoolPerformanceQueryCreateInfoINTEL,
  VkQueryPoolCreateInfoINTEL,
  VkPerformanceMarkerInfoINTEL,
  VkPerformanceStreamMarkerInfoINTEL,
  VkPerformanceOverrideInfoINTEL,
  VkPerformanceConfigurationAcquireInfoINTEL,
  VkPhysicalDeviceShaderClockFeaturesKHR,
  VkPhysicalDeviceIndexTypeUint8FeaturesEXT,
  VkPhysicalDeviceShaderSMBuiltinsPropertiesNV,
  VkPhysicalDeviceShaderSMBuiltinsFeaturesNV,
  VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,
  VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,
  VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR,
  VkAttachmentReferenceStencilLayout,
  VkAttachmentReferenceStencilLayoutKHR,
  VkAttachmentDescriptionStencilLayout,
  VkAttachmentDescriptionStencilLayoutKHR,
  VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
  VkPipelineInfoKHR,
  VkPipelineExecutablePropertiesKHR,
  VkPipelineExecutableInfoKHR,
  VkPipelineExecutableStatisticKHR,
  VkPipelineExecutableInternalRepresentationKHR,
  VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT,
  VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT,
  VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT,
  VkPhysicalDeviceSubgroupSizeControlFeaturesEXT,
  VkPhysicalDeviceSubgroupSizeControlPropertiesEXT,
  VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT,
  VkMemoryOpaqueCaptureAddressAllocateInfo,
  VkMemoryOpaqueCaptureAddressAllocateInfoKHR,
  VkDeviceMemoryOpaqueCaptureAddressInfo,
  VkDeviceMemoryOpaqueCaptureAddressInfoKHR,
  VkPhysicalDeviceLineRasterizationFeaturesEXT,
  VkPhysicalDeviceLineRasterizationPropertiesEXT,
  VkPipelineRasterizationLineStateCreateInfoEXT,
  VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT,
  VkPhysicalDeviceVulkan11Features,
  VkPhysicalDeviceVulkan11Properties,
  VkPhysicalDeviceVulkan12Features,
  VkPhysicalDeviceVulkan12Properties,
  VkPipelineCompilerControlCreateInfoAMD,
  VkPhysicalDeviceCoherentMemoryFeaturesAMD,
  VkPhysicalDeviceToolPropertiesEXT,
  VkSamplerCustomBorderColorCreateInfoEXT,
  VkPhysicalDeviceCustomBorderColorPropertiesEXT,
  VkPhysicalDeviceCustomBorderColorFeaturesEXT,
  VkAccelerationStructureGeometryTrianglesDataKHR,
  VkAccelerationStructureGeometryAabbsDataKHR,
  VkAccelerationStructureGeometryInstancesDataKHR,
  VkAccelerationStructureGeometryKHR,
  VkAccelerationStructureBuildGeometryInfoKHR,
  VkAccelerationStructureBuildRangeInfoKHR,
  VkAccelerationStructureCreateInfoKHR,
  VkAabbPositionsKHR,
  VkAabbPositionsNV,
  VkTransformMatrixKHR,
  VkTransformMatrixNV,
  VkAccelerationStructureInstanceKHR,
  VkAccelerationStructureInstanceNV,
  VkAccelerationStructureDeviceAddressInfoKHR,
  VkAccelerationStructureVersionInfoKHR,
  VkCopyAccelerationStructureInfoKHR,
  VkCopyAccelerationStructureToMemoryInfoKHR,
  VkCopyMemoryToAccelerationStructureInfoKHR,
  VkRayTracingPipelineInterfaceCreateInfoKHR,
  VkPipelineLibraryCreateInfoKHR,
  VkPhysicalDeviceExtendedDynamicStateFeaturesEXT,
  VkRenderPassTransformBeginInfoQCOM,
  VkCopyCommandTransformInfoQCOM,
  VkCommandBufferInheritanceRenderPassTransformInfoQCOM,
  VkPhysicalDeviceDiagnosticsConfigFeaturesNV,
  VkDeviceDiagnosticsConfigCreateInfoNV,
  VkPhysicalDeviceRobustness2FeaturesEXT,
  VkPhysicalDeviceRobustness2PropertiesEXT,
  VkPhysicalDeviceImageRobustnessFeaturesEXT,
  VkPhysicalDevice4444FormatsFeaturesEXT,
  VkBufferCopy2KHR,
  VkImageCopy2KHR,
  VkImageBlit2KHR,
  VkBufferImageCopy2KHR,
  VkImageResolve2KHR,
  VkCopyBufferInfo2KHR,
  VkCopyImageInfo2KHR,
  VkBlitImageInfo2KHR,
  VkCopyBufferToImageInfo2KHR,
  VkCopyImageToBufferInfo2KHR,
  VkResolveImageInfo2KHR,
  VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
  VkFragmentShadingRateAttachmentInfoKHR,
  VkPipelineFragmentShadingRateStateCreateInfoKHR,
  VkPhysicalDeviceFragmentShadingRateFeaturesKHR,
  VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
  VkPhysicalDeviceFragmentShadingRateKHR,
  VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR,
  VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
  VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV,
  VkPipelineFragmentShadingRateEnumStateCreateInfoNV,
  VkAccelerationStructureBuildSizesInfoKHR
};
