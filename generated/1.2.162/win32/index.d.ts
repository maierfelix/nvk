/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY nvk v0.8.0
 */
type BigUint64Array = Float32Array
declare const BigUint64Array: typeof Float32Array

export interface ObjectConstructor {
  assign(...objects: Object[]): Object;
}

export interface CustomArrayBufferConstructor extends ArrayBufferConstructor {
  fromAddress: (ptr: bigint, size: number) => ArrayBuffer;
  getAddress: (data: ArrayBuffer) => bigint;
}
declare var ArrayBuffer: CustomArrayBufferConstructor;

declare var VkInout: { $: number | boolean; }
export interface VkInout { $: number | boolean; }

declare var VkInoutAddress: { $: bigint; }
export interface VkInoutAddress { $: bigint; }


/**
  * 
  * @member VK_KHR_SURFACE_EXTENSION_NAME
  * @member VK_KHR_SWAPCHAIN_EXTENSION_NAME
  * @member VK_KHR_DISPLAY_EXTENSION_NAME
  * @member VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME
  * @member VK_KHR_XLIB_SURFACE_EXTENSION_NAME
  * @member VK_KHR_XCB_SURFACE_EXTENSION_NAME
  * @member VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME
  * @member VK_KHR_MIR_SURFACE_EXTENSION_NAME
  * @member VK_KHR_ANDROID_SURFACE_EXTENSION_NAME
  * @member VK_KHR_WIN32_SURFACE_EXTENSION_NAME
  * @member VK_ANDROID_NATIVE_BUFFER_NAME
  * @member VK_EXT_DEBUG_REPORT_EXTENSION_NAME
  * @member VK_NV_GLSL_SHADER_EXTENSION_NAME
  * @member VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME
  * @member VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME
  * @member VK_IMG_FILTER_CUBIC_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_17_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_18_EXTENSION_NAME
  * @member VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_20_EXTENSION_NAME
  * @member VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME
  * @member VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME
  * @member VK_EXT_DEBUG_MARKER_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_24_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_25_EXTENSION_NAME
  * @member VK_AMD_GCN_SHADER_EXTENSION_NAME
  * @member VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_28_EXTENSION_NAME
  * @member VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME
  * @member VK_NVX_EXTENSION_30_EXTENSION_NAME
  * @member VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_32_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_33_EXTENSION_NAME
  * @member VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_35_EXTENSION_NAME
  * @member VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME
  * @member VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME
  * @member VK_AMD_SHADER_BALLOT_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_39_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_40_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_41_EXTENSION_NAME
  * @member VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME
  * @member VK_AMD_SHADER_INFO_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_44_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_45_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_46_EXTENSION_NAME
  * @member VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME
  * @member VK_NVX_EXTENSION_48_EXTENSION_NAME
  * @member VK_GOOGLE_EXTENSION_49_EXTENSION_NAME
  * @member VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME
  * @member VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME
  * @member VK_NV_EXTENSION_52_EXTENSION_NAME
  * @member VK_NV_EXTENSION_53_EXTENSION_NAME
  * @member VK_KHR_MULTIVIEW_EXTENSION_NAME
  * @member VK_IMG_FORMAT_PVRTC_EXTENSION_NAME
  * @member VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
  * @member VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME
  * @member VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME
  * @member VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME
  * @member VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME
  * @member VK_KHR_DEVICE_GROUP_EXTENSION_NAME
  * @member VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME
  * @member VK_NN_VI_SURFACE_EXTENSION_NAME
  * @member VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME
  * @member VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME
  * @member VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME
  * @member VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME
  * @member VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME
  * @member VK_IMG_EXTENSION_69_EXTENSION_NAME
  * @member VK_KHR_MAINTENANCE1_EXTENSION_NAME
  * @member VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME
  * @member VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME
  * @member VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME
  * @member VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME
  * @member VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME
  * @member VK_KHR_16BIT_STORAGE_EXTENSION_NAME
  * @member VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME
  * @member VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME
  * @member VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
  * @member VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME
  * @member VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME
  * @member VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME
  * @member VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME
  * @member VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME
  * @member VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME
  * @member VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME
  * @member VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME
  * @member VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME
  * @member VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME
  * @member VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME
  * @member VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME
  * @member VK_NV_EXTENSION_101_EXTENSION_NAME
  * @member VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME
  * @member VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME
  * @member VK_NV_EXTENSION_104_EXTENSION_NAME
  * @member VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME
  * @member VK_EXT_HDR_METADATA_EXTENSION_NAME
  * @member VK_IMG_EXTENSION_107_EXTENSION_NAME
  * @member VK_IMG_EXTENSION_108_EXTENSION_NAME
  * @member VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME
  * @member VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME
  * @member VK_IMG_EXTENSION_111_EXTENSION_NAME
  * @member VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME
  * @member VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME
  * @member VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
  * @member VK_KHR_MAINTENANCE2_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_119_EXTENSION_NAME
  * @member VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME
  * @member VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME
  * @member VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME
  * @member VK_MVK_IOS_SURFACE_EXTENSION_NAME
  * @member VK_MVK_MACOS_SURFACE_EXTENSION_NAME
  * @member VK_MVK_MOLTENVK_EXTENSION_NAME
  * @member VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME
  * @member VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME
  * @member VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME
  * @member VK_EXT_DEBUG_UTILS_EXTENSION_NAME
  * @member VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME
  * @member VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME
  * @member VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME
  * @member VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_134_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_135_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_136_EXTENSION_NAME
  * @member VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME
  * @member VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME
  * @member VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_140_EXTENSION_NAME
  * @member VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_142_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_143_EXTENSION_NAME
  * @member VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME
  * @member VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME
  * @member VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME
  * @member VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME
  * @member VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME
  * @member VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME
  * @member VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
  * @member VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME
  * @member VK_KHR_RAY_QUERY_EXTENSION_NAME
  * @member VK_NV_EXTENSION_152_EXTENSION_NAME
  * @member VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME
  * @member VK_NV_FILL_RECTANGLE_EXTENSION_NAME
  * @member VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME
  * @member VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME
  * @member VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME
  * @member VK_KHR_BIND_MEMORY_2_EXTENSION_NAME
  * @member VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_160_EXTENSION_NAME
  * @member VK_EXT_VALIDATION_CACHE_EXTENSION_NAME
  * @member VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME
  * @member VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME
  * @member VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME
  * @member VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME
  * @member VK_NV_RAY_TRACING_EXTENSION_NAME
  * @member VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_168_EXTENSION_NAME
  * @member VK_KHR_MAINTENANCE3_EXTENSION_NAME
  * @member VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME
  * @member VK_EXT_FILTER_CUBIC_EXTENSION_NAME
  * @member VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME
  * @member VK_QCOM_extension_173_EXTENSION_NAME
  * @member VK_QCOM_extension_174_EXTENSION_NAME
  * @member VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME
  * @member VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_177_EXTENSION_NAME
  * @member VK_KHR_8BIT_STORAGE_EXTENSION_NAME
  * @member VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME
  * @member VK_AMD_BUFFER_MARKER_EXTENSION_NAME
  * @member VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME
  * @member VK_KHR_SHADER_CLOCK_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_183_EXTENSION_NAME
  * @member VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME
  * @member VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME
  * @member VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_187_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_188_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_189_EXTENSION_NAME
  * @member VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME
  * @member VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME
  * @member VK_GGP_FRAME_TOKEN_EXTENSION_NAME
  * @member VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME
  * @member VK_GOOGLE_EXTENSION_194_EXTENSION_NAME
  * @member VK_GOOGLE_EXTENSION_195_EXTENSION_NAME
  * @member VK_GOOGLE_EXTENSION_196_EXTENSION_NAME
  * @member VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME
  * @member VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME
  * @member VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME
  * @member VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME
  * @member VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME
  * @member VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME
  * @member VK_NV_MESH_SHADER_EXTENSION_NAME
  * @member VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME
  * @member VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME
  * @member VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME
  * @member VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME
  * @member VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_209_EXTENSION_NAME
  * @member VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME
  * @member VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME
  * @member VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME
  * @member VK_EXT_PCI_BUS_INFO_EXTENSION_NAME
  * @member VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME
  * @member VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME
  * @member VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_217_EXTENSION_NAME
  * @member VK_EXT_METAL_SURFACE_EXTENSION_NAME
  * @member VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_220_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_221_EXTENSION_NAME
  * @member VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_223_EXTENSION_NAME
  * @member VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME
  * @member VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME
  * @member VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME
  * @member VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME
  * @member VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_229_EXTENSION_NAME
  * @member VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_231_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_232_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_233_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_234_EXTENSION_NAME
  * @member VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_236_EXTENSION_NAME
  * @member VK_KHR_SPIRV_1_4_EXTENSION_NAME
  * @member VK_EXT_MEMORY_BUDGET_EXTENSION_NAME
  * @member VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME
  * @member VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME
  * @member VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME
  * @member VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME
  * @member VK_INTEL_EXTENSION_243_EXTENSION_NAME
  * @member VK_MESA_EXTENSION_244_EXTENSION_NAME
  * @member VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
  * @member VK_EXT_TOOLING_INFO_EXTENSION_NAME
  * @member VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME
  * @member VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_249_EXTENSION_NAME
  * @member VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME
  * @member VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME
  * @member VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME
  * @member VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME
  * @member VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_255_EXTENSION_NAME
  * @member VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME
  * @member VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME
  * @member VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_259_EXTENSION_NAME
  * @member VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME
  * @member VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME
  * @member VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME
  * @member VK_GOOGLE_EXTENSION_263_EXTENSION_NAME
  * @member VK_BRCM_EXTENSION_264_EXTENSION_NAME
  * @member VK_BRCM_EXTENSION_265_EXTENSION_NAME
  * @member VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME
  * @member VK_EXT_extension_267
  * @member VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME
  * @member VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME
  * @member VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME
  * @member VK_INTEL_extension_271
  * @member VK_INTEL_extension_272
  * @member VK_INTEL_extension_273
  * @member VK_INTEL_extension_274
  * @member VK_KHR_extension_275
  * @member VK_KHR_extension_276
  * @member VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME
  * @member VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
  * @member VK_NV_extension_279
  * @member VK_KHR_extension_280
  * @member VK_ARM_extension_281
  * @member VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME
  * @member VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME
  * @member VK_EXT_extension_284
  * @member VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME
  * @member VK_EXT_extension_286
  * @member VK_EXT_ROBUSTNESS_2_EXTENSION_NAME
  * @member VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_289_EXTENSION_NAME
  * @member VK_GOOGLE_USER_TYPE_EXTENSION_NAME
  * @member VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME
  * @member VK_NV_EXTENSION_292_EXTENSION_NAME
  * @member VK_NV_EXTENSION_293_EXTENSION_NAME
  * @member VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_295_EXTENSION_NAME
  * @member VK_EXT_PRIVATE_DATA_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_297_EXTENSION_NAME
  * @member VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_299_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_300_EXTENSION_NAME
  * @member VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME
  * @member VK_QCOM_render_pass_store_ops_EXTENSION_NAME
  * @member VK_QCOM_extension_303_EXTENSION_NAME
  * @member VK_QCOM_extension_304_EXTENSION_NAME
  * @member VK_QCOM_extension_305_EXTENSION_NAME
  * @member VK_QCOM_extension_306_EXTENSION_NAME
  * @member VK_QCOM_extension_307_EXTENSION_NAME
  * @member VK_NV_EXTENSION_308_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_309_EXTENSION_NAME
  * @member VK_QCOM_extension_310_EXTENSION_NAME
  * @member VK_NV_EXTENSION_311_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_312_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_313_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_314_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_315_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_316_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_317_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_318_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_319_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_320_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_321_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_322_EXTENSION_NAME
  * @member VK_AMD_EXTENSION_323_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_324_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_325_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_326_EXTENSION_NAME
  * @member VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME
  * @member VK_NV_EXTENSION_328_EXTENSION_NAME
  * @member VK_NV_EXTENSION_329_EXTENSION_NAME
  * @member VK_NV_EXTENSION_330_EXTENSION_NAME
  * @member VK_NV_EXTENSION_331_EXTENSION_NAME
  * @member VK_NV_EXTENSION_332_EXTENSION_NAME
  * @member VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME
  * @member VK_QCOM_rotated_copy_commands_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_335_EXTENSION_NAME
  * @member VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_337_EXTENSION_NAME
  * @member VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME
  * @member VK_ARM_EXTENSION_339_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_340_EXTENSION_NAME
  * @member VK_EXT_4444_FORMATS_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_342_EXTENSION_NAME
  * @member VK_ARM_EXTENSION_343_EXTENSION_NAME
  * @member VK_ARM_EXTENSION_344_EXTENSION_NAME
  * @member VK_ARM_EXTENSION_345_EXTENSION_NAME
  * @member VK_NV_EXTENSION_346_EXTENSION_NAME
  * @member VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME
  * @member VK_KHR_EXTENSION_350_EXTENSION_NAME
  * @member VK_NV_EXTENSION_351_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_352_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_353_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_354_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_355_EXTENSION_NAME
  * @member VK_EXT_VERTEX_ATTRIBUTE_ALIASING_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_357
  * @member VK_KHR_EXTENSION_358_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_359
  * @member VK_EXT_EXTENSION_360
  * @member VK_EXT_EXTENSION_361
  * @member VK_EXT_EXTENSION_362_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_363_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_364_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_365_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_366_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_367_EXTENSION_NAME
  * @member VK_EXT_EXTENSION_368_EXTENSION_NAME
  * @member VK_QCOM_EXTENSION_369_EXTENSION_NAME
  * @member VK_HUAWEI_EXTENSION_370_EXTENSION_NAME
  * @member VK_HUAWEI_EXTENSION_371_EXTENSION_NAME
  * @member VK_NV_EXTENSION_372_EXTENSION_NAME
  */
export enum API_Extensions_Strings {
  VK_KHR_SURFACE_EXTENSION_NAME,
  VK_KHR_SWAPCHAIN_EXTENSION_NAME,
  VK_KHR_DISPLAY_EXTENSION_NAME,
  VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME,
  VK_KHR_XLIB_SURFACE_EXTENSION_NAME,
  VK_KHR_XCB_SURFACE_EXTENSION_NAME,
  VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME,
  VK_KHR_MIR_SURFACE_EXTENSION_NAME,
  VK_KHR_ANDROID_SURFACE_EXTENSION_NAME,
  VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
  VK_ANDROID_NATIVE_BUFFER_NAME,
  VK_EXT_DEBUG_REPORT_EXTENSION_NAME,
  VK_NV_GLSL_SHADER_EXTENSION_NAME,
  VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME,
  VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME,
  VK_IMG_FILTER_CUBIC_EXTENSION_NAME,
  VK_AMD_EXTENSION_17_EXTENSION_NAME,
  VK_AMD_EXTENSION_18_EXTENSION_NAME,
  VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME,
  VK_AMD_EXTENSION_20_EXTENSION_NAME,
  VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME,
  VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME,
  VK_EXT_DEBUG_MARKER_EXTENSION_NAME,
  VK_AMD_EXTENSION_24_EXTENSION_NAME,
  VK_AMD_EXTENSION_25_EXTENSION_NAME,
  VK_AMD_GCN_SHADER_EXTENSION_NAME,
  VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME,
  VK_EXT_EXTENSION_28_EXTENSION_NAME,
  VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME,
  VK_NVX_EXTENSION_30_EXTENSION_NAME,
  VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME,
  VK_AMD_EXTENSION_32_EXTENSION_NAME,
  VK_AMD_EXTENSION_33_EXTENSION_NAME,
  VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME,
  VK_AMD_EXTENSION_35_EXTENSION_NAME,
  VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME,
  VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME,
  VK_AMD_SHADER_BALLOT_EXTENSION_NAME,
  VK_AMD_EXTENSION_39_EXTENSION_NAME,
  VK_AMD_EXTENSION_40_EXTENSION_NAME,
  VK_AMD_EXTENSION_41_EXTENSION_NAME,
  VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME,
  VK_AMD_SHADER_INFO_EXTENSION_NAME,
  VK_AMD_EXTENSION_44_EXTENSION_NAME,
  VK_AMD_EXTENSION_45_EXTENSION_NAME,
  VK_AMD_EXTENSION_46_EXTENSION_NAME,
  VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME,
  VK_NVX_EXTENSION_48_EXTENSION_NAME,
  VK_GOOGLE_EXTENSION_49_EXTENSION_NAME,
  VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME,
  VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME,
  VK_NV_EXTENSION_52_EXTENSION_NAME,
  VK_NV_EXTENSION_53_EXTENSION_NAME,
  VK_KHR_MULTIVIEW_EXTENSION_NAME,
  VK_IMG_FORMAT_PVRTC_EXTENSION_NAME,
  VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME,
  VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME,
  VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME,
  VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME,
  VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,
  VK_KHR_DEVICE_GROUP_EXTENSION_NAME,
  VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME,
  VK_NN_VI_SURFACE_EXTENSION_NAME,
  VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME,
  VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME,
  VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME,
  VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME,
  VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME,
  VK_IMG_EXTENSION_69_EXTENSION_NAME,
  VK_KHR_MAINTENANCE1_EXTENSION_NAME,
  VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME,
  VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME,
  VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME,
  VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME,
  VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME,
  VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME,
  VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME,
  VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME,
  VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME,
  VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME,
  VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME,
  VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME,
  VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME,
  VK_KHR_16BIT_STORAGE_EXTENSION_NAME,
  VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME,
  VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME,
  VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME,
  VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME,
  VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME,
  VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME,
  VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME,
  VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME,
  VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME,
  VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME,
  VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME,
  VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME,
  VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME,
  VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME,
  VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME,
  VK_NV_EXTENSION_101_EXTENSION_NAME,
  VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME,
  VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME,
  VK_NV_EXTENSION_104_EXTENSION_NAME,
  VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME,
  VK_EXT_HDR_METADATA_EXTENSION_NAME,
  VK_IMG_EXTENSION_107_EXTENSION_NAME,
  VK_IMG_EXTENSION_108_EXTENSION_NAME,
  VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME,
  VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME,
  VK_IMG_EXTENSION_111_EXTENSION_NAME,
  VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME,
  VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME,
  VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME,
  VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME,
  VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME,
  VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME,
  VK_KHR_MAINTENANCE2_EXTENSION_NAME,
  VK_KHR_EXTENSION_119_EXTENSION_NAME,
  VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME,
  VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME,
  VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME,
  VK_MVK_IOS_SURFACE_EXTENSION_NAME,
  VK_MVK_MACOS_SURFACE_EXTENSION_NAME,
  VK_MVK_MOLTENVK_EXTENSION_NAME,
  VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME,
  VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME,
  VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME,
  VK_EXT_DEBUG_UTILS_EXTENSION_NAME,
  VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME,
  VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME,
  VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME,
  VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME,
  VK_AMD_EXTENSION_134_EXTENSION_NAME,
  VK_AMD_EXTENSION_135_EXTENSION_NAME,
  VK_AMD_EXTENSION_136_EXTENSION_NAME,
  VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME,
  VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME,
  VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME,
  VK_AMD_EXTENSION_140_EXTENSION_NAME,
  VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME,
  VK_AMD_EXTENSION_142_EXTENSION_NAME,
  VK_AMD_EXTENSION_143_EXTENSION_NAME,
  VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME,
  VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME,
  VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME,
  VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME,
  VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME,
  VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME,
  VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME,
  VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME,
  VK_KHR_RAY_QUERY_EXTENSION_NAME,
  VK_NV_EXTENSION_152_EXTENSION_NAME,
  VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME,
  VK_NV_FILL_RECTANGLE_EXTENSION_NAME,
  VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME,
  VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME,
  VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME,
  VK_KHR_BIND_MEMORY_2_EXTENSION_NAME,
  VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME,
  VK_EXT_EXTENSION_160_EXTENSION_NAME,
  VK_EXT_VALIDATION_CACHE_EXTENSION_NAME,
  VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME,
  VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME,
  VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME,
  VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME,
  VK_NV_RAY_TRACING_EXTENSION_NAME,
  VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME,
  VK_EXT_EXTENSION_168_EXTENSION_NAME,
  VK_KHR_MAINTENANCE3_EXTENSION_NAME,
  VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME,
  VK_EXT_FILTER_CUBIC_EXTENSION_NAME,
  VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME,
  VK_QCOM_extension_173_EXTENSION_NAME,
  VK_QCOM_extension_174_EXTENSION_NAME,
  VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME,
  VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME,
  VK_KHR_EXTENSION_177_EXTENSION_NAME,
  VK_KHR_8BIT_STORAGE_EXTENSION_NAME,
  VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME,
  VK_AMD_BUFFER_MARKER_EXTENSION_NAME,
  VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME,
  VK_KHR_SHADER_CLOCK_EXTENSION_NAME,
  VK_KHR_EXTENSION_183_EXTENSION_NAME,
  VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME,
  VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME,
  VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME,
  VK_KHR_EXTENSION_187_EXTENSION_NAME,
  VK_KHR_EXTENSION_188_EXTENSION_NAME,
  VK_KHR_EXTENSION_189_EXTENSION_NAME,
  VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME,
  VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME,
  VK_GGP_FRAME_TOKEN_EXTENSION_NAME,
  VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME,
  VK_GOOGLE_EXTENSION_194_EXTENSION_NAME,
  VK_GOOGLE_EXTENSION_195_EXTENSION_NAME,
  VK_GOOGLE_EXTENSION_196_EXTENSION_NAME,
  VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME,
  VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME,
  VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME,
  VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME,
  VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME,
  VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME,
  VK_NV_MESH_SHADER_EXTENSION_NAME,
  VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME,
  VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME,
  VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME,
  VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME,
  VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME,
  VK_KHR_EXTENSION_209_EXTENSION_NAME,
  VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME,
  VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME,
  VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME,
  VK_EXT_PCI_BUS_INFO_EXTENSION_NAME,
  VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME,
  VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME,
  VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME,
  VK_KHR_EXTENSION_217_EXTENSION_NAME,
  VK_EXT_METAL_SURFACE_EXTENSION_NAME,
  VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME,
  VK_EXT_EXTENSION_220_EXTENSION_NAME,
  VK_KHR_EXTENSION_221_EXTENSION_NAME,
  VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME,
  VK_EXT_EXTENSION_223_EXTENSION_NAME,
  VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME,
  VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME,
  VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME,
  VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME,
  VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME,
  VK_AMD_EXTENSION_229_EXTENSION_NAME,
  VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME,
  VK_AMD_EXTENSION_231_EXTENSION_NAME,
  VK_AMD_EXTENSION_232_EXTENSION_NAME,
  VK_AMD_EXTENSION_233_EXTENSION_NAME,
  VK_AMD_EXTENSION_234_EXTENSION_NAME,
  VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME,
  VK_AMD_EXTENSION_236_EXTENSION_NAME,
  VK_KHR_SPIRV_1_4_EXTENSION_NAME,
  VK_EXT_MEMORY_BUDGET_EXTENSION_NAME,
  VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME,
  VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME,
  VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME,
  VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME,
  VK_INTEL_EXTENSION_243_EXTENSION_NAME,
  VK_MESA_EXTENSION_244_EXTENSION_NAME,
  VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME,
  VK_EXT_TOOLING_INFO_EXTENSION_NAME,
  VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME,
  VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME,
  VK_KHR_EXTENSION_249_EXTENSION_NAME,
  VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME,
  VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME,
  VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME,
  VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME,
  VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME,
  VK_EXT_EXTENSION_255_EXTENSION_NAME,
  VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME,
  VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME,
  VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME,
  VK_EXT_EXTENSION_259_EXTENSION_NAME,
  VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME,
  VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME,
  VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME,
  VK_GOOGLE_EXTENSION_263_EXTENSION_NAME,
  VK_BRCM_EXTENSION_264_EXTENSION_NAME,
  VK_BRCM_EXTENSION_265_EXTENSION_NAME,
  VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME,
  VK_EXT_extension_267,
  VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME,
  VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME,
  VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME,
  VK_INTEL_extension_271,
  VK_INTEL_extension_272,
  VK_INTEL_extension_273,
  VK_INTEL_extension_274,
  VK_KHR_extension_275,
  VK_KHR_extension_276,
  VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME,
  VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME,
  VK_NV_extension_279,
  VK_KHR_extension_280,
  VK_ARM_extension_281,
  VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME,
  VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME,
  VK_EXT_extension_284,
  VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME,
  VK_EXT_extension_286,
  VK_EXT_ROBUSTNESS_2_EXTENSION_NAME,
  VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME,
  VK_EXT_EXTENSION_289_EXTENSION_NAME,
  VK_GOOGLE_USER_TYPE_EXTENSION_NAME,
  VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME,
  VK_NV_EXTENSION_292_EXTENSION_NAME,
  VK_NV_EXTENSION_293_EXTENSION_NAME,
  VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME,
  VK_KHR_EXTENSION_295_EXTENSION_NAME,
  VK_EXT_PRIVATE_DATA_EXTENSION_NAME,
  VK_KHR_EXTENSION_297_EXTENSION_NAME,
  VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME,
  VK_KHR_EXTENSION_299_EXTENSION_NAME,
  VK_KHR_EXTENSION_300_EXTENSION_NAME,
  VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME,
  VK_QCOM_render_pass_store_ops_EXTENSION_NAME,
  VK_QCOM_extension_303_EXTENSION_NAME,
  VK_QCOM_extension_304_EXTENSION_NAME,
  VK_QCOM_extension_305_EXTENSION_NAME,
  VK_QCOM_extension_306_EXTENSION_NAME,
  VK_QCOM_extension_307_EXTENSION_NAME,
  VK_NV_EXTENSION_308_EXTENSION_NAME,
  VK_KHR_EXTENSION_309_EXTENSION_NAME,
  VK_QCOM_extension_310_EXTENSION_NAME,
  VK_NV_EXTENSION_311_EXTENSION_NAME,
  VK_EXT_EXTENSION_312_EXTENSION_NAME,
  VK_EXT_EXTENSION_313_EXTENSION_NAME,
  VK_AMD_EXTENSION_314_EXTENSION_NAME,
  VK_AMD_EXTENSION_315_EXTENSION_NAME,
  VK_AMD_EXTENSION_316_EXTENSION_NAME,
  VK_AMD_EXTENSION_317_EXTENSION_NAME,
  VK_AMD_EXTENSION_318_EXTENSION_NAME,
  VK_AMD_EXTENSION_319_EXTENSION_NAME,
  VK_AMD_EXTENSION_320_EXTENSION_NAME,
  VK_AMD_EXTENSION_321_EXTENSION_NAME,
  VK_AMD_EXTENSION_322_EXTENSION_NAME,
  VK_AMD_EXTENSION_323_EXTENSION_NAME,
  VK_KHR_EXTENSION_324_EXTENSION_NAME,
  VK_KHR_EXTENSION_325_EXTENSION_NAME,
  VK_KHR_EXTENSION_326_EXTENSION_NAME,
  VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME,
  VK_NV_EXTENSION_328_EXTENSION_NAME,
  VK_NV_EXTENSION_329_EXTENSION_NAME,
  VK_NV_EXTENSION_330_EXTENSION_NAME,
  VK_NV_EXTENSION_331_EXTENSION_NAME,
  VK_NV_EXTENSION_332_EXTENSION_NAME,
  VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME,
  VK_QCOM_rotated_copy_commands_EXTENSION_NAME,
  VK_KHR_EXTENSION_335_EXTENSION_NAME,
  VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME,
  VK_KHR_EXTENSION_337_EXTENSION_NAME,
  VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME,
  VK_ARM_EXTENSION_339_EXTENSION_NAME,
  VK_EXT_EXTENSION_340_EXTENSION_NAME,
  VK_EXT_4444_FORMATS_EXTENSION_NAME,
  VK_EXT_EXTENSION_342_EXTENSION_NAME,
  VK_ARM_EXTENSION_343_EXTENSION_NAME,
  VK_ARM_EXTENSION_344_EXTENSION_NAME,
  VK_ARM_EXTENSION_345_EXTENSION_NAME,
  VK_NV_EXTENSION_346_EXTENSION_NAME,
  VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME,
  VK_KHR_EXTENSION_350_EXTENSION_NAME,
  VK_NV_EXTENSION_351_EXTENSION_NAME,
  VK_EXT_EXTENSION_352_EXTENSION_NAME,
  VK_EXT_EXTENSION_353_EXTENSION_NAME,
  VK_EXT_EXTENSION_354_EXTENSION_NAME,
  VK_EXT_EXTENSION_355_EXTENSION_NAME,
  VK_EXT_VERTEX_ATTRIBUTE_ALIASING_EXTENSION_NAME,
  VK_EXT_EXTENSION_357,
  VK_KHR_EXTENSION_358_EXTENSION_NAME,
  VK_EXT_EXTENSION_359,
  VK_EXT_EXTENSION_360,
  VK_EXT_EXTENSION_361,
  VK_EXT_EXTENSION_362_EXTENSION_NAME,
  VK_EXT_EXTENSION_363_EXTENSION_NAME,
  VK_EXT_EXTENSION_364_EXTENSION_NAME,
  VK_EXT_EXTENSION_365_EXTENSION_NAME,
  VK_EXT_EXTENSION_366_EXTENSION_NAME,
  VK_EXT_EXTENSION_367_EXTENSION_NAME,
  VK_EXT_EXTENSION_368_EXTENSION_NAME,
  VK_QCOM_EXTENSION_369_EXTENSION_NAME,
  VK_HUAWEI_EXTENSION_370_EXTENSION_NAME,
  VK_HUAWEI_EXTENSION_371_EXTENSION_NAME,
  VK_NV_EXTENSION_372_EXTENSION_NAME,
  
}

declare const VK_KHR_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SWAPCHAIN_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_DISPLAY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_XLIB_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_XCB_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_MIR_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_ANDROID_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_WIN32_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_ANDROID_NATIVE_BUFFER_NAME: API_Extensions_Strings;
declare const VK_EXT_DEBUG_REPORT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_GLSL_SHADER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_IMG_FILTER_CUBIC_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_17_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_18_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_20_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_DEBUG_MARKER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_24_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_25_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_GCN_SHADER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_28_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NVX_EXTENSION_30_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_32_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_33_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_35_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_SHADER_BALLOT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_39_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_40_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_41_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_SHADER_INFO_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_44_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_45_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_46_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NVX_EXTENSION_48_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GOOGLE_EXTENSION_49_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_52_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_53_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_MULTIVIEW_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_IMG_FORMAT_PVRTC_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_DEVICE_GROUP_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NN_VI_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_IMG_EXTENSION_69_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_MAINTENANCE1_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_16BIT_STORAGE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_101_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_104_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_HDR_METADATA_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_IMG_EXTENSION_107_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_IMG_EXTENSION_108_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_IMG_EXTENSION_111_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_MAINTENANCE2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_119_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_MVK_IOS_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_MVK_MACOS_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_MVK_MOLTENVK_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_DEBUG_UTILS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_134_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_135_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_136_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_140_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_142_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_143_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_RAY_QUERY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_152_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_FILL_RECTANGLE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_BIND_MEMORY_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_160_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_VALIDATION_CACHE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_RAY_TRACING_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_168_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_MAINTENANCE3_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_FILTER_CUBIC_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_extension_173_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_extension_174_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_177_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_8BIT_STORAGE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_BUFFER_MARKER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SHADER_CLOCK_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_183_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_187_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_188_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_189_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GGP_FRAME_TOKEN_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GOOGLE_EXTENSION_194_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GOOGLE_EXTENSION_195_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GOOGLE_EXTENSION_196_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_MESH_SHADER_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_209_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_PCI_BUS_INFO_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_217_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_METAL_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_220_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_221_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_223_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_229_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_231_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_232_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_233_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_234_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_236_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SPIRV_1_4_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_MEMORY_BUDGET_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_INTEL_EXTENSION_243_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_MESA_EXTENSION_244_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_TOOLING_INFO_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_249_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_255_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_259_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GOOGLE_EXTENSION_263_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_BRCM_EXTENSION_264_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_BRCM_EXTENSION_265_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_extension_267: API_Extensions_Strings;
declare const VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_INTEL_extension_271: API_Extensions_Strings;
declare const VK_INTEL_extension_272: API_Extensions_Strings;
declare const VK_INTEL_extension_273: API_Extensions_Strings;
declare const VK_INTEL_extension_274: API_Extensions_Strings;
declare const VK_KHR_extension_275: API_Extensions_Strings;
declare const VK_KHR_extension_276: API_Extensions_Strings;
declare const VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_extension_279: API_Extensions_Strings;
declare const VK_KHR_extension_280: API_Extensions_Strings;
declare const VK_ARM_extension_281: API_Extensions_Strings;
declare const VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_extension_284: API_Extensions_Strings;
declare const VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_extension_286: API_Extensions_Strings;
declare const VK_EXT_ROBUSTNESS_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_289_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_GOOGLE_USER_TYPE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_292_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_293_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_295_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_PRIVATE_DATA_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_297_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_299_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_300_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_render_pass_store_ops_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_extension_303_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_extension_304_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_extension_305_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_extension_306_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_extension_307_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_308_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_309_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_extension_310_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_311_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_312_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_313_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_314_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_315_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_316_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_317_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_318_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_319_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_320_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_321_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_322_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_AMD_EXTENSION_323_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_324_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_325_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_326_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_328_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_329_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_330_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_331_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_332_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_rotated_copy_commands_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_335_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_337_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_ARM_EXTENSION_339_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_340_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_4444_FORMATS_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_342_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_ARM_EXTENSION_343_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_ARM_EXTENSION_344_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_ARM_EXTENSION_345_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_346_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_350_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_351_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_352_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_353_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_354_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_355_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_VERTEX_ATTRIBUTE_ALIASING_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_357: API_Extensions_Strings;
declare const VK_KHR_EXTENSION_358_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_359: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_360: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_361: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_362_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_363_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_364_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_365_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_366_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_367_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_EXT_EXTENSION_368_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_QCOM_EXTENSION_369_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_HUAWEI_EXTENSION_370_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_HUAWEI_EXTENSION_371_EXTENSION_NAME: API_Extensions_Strings;
declare const VK_NV_EXTENSION_372_EXTENSION_NAME: API_Extensions_Strings;



/**
  * 
  * @member VK_KHR_SURFACE_SPEC_VERSION
  * @member VK_KHR_SWAPCHAIN_SPEC_VERSION
  * @member VK_KHR_DISPLAY_SPEC_VERSION
  * @member VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION
  * @member VK_KHR_XLIB_SURFACE_SPEC_VERSION
  * @member VK_KHR_XCB_SURFACE_SPEC_VERSION
  * @member VK_KHR_WAYLAND_SURFACE_SPEC_VERSION
  * @member VK_KHR_MIR_SURFACE_SPEC_VERSION
  * @member VK_KHR_ANDROID_SURFACE_SPEC_VERSION
  * @member VK_KHR_WIN32_SURFACE_SPEC_VERSION
  * @member VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION
  * @member VK_ANDROID_NATIVE_BUFFER_NUMBER
  * @member VK_EXT_DEBUG_REPORT_SPEC_VERSION
  * @member VK_NV_GLSL_SHADER_SPEC_VERSION
  * @member VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION
  * @member VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION
  * @member VK_IMG_FILTER_CUBIC_SPEC_VERSION
  * @member VK_AMD_EXTENSION_17_SPEC_VERSION
  * @member VK_AMD_EXTENSION_18_SPEC_VERSION
  * @member VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION
  * @member VK_AMD_EXTENSION_20_SPEC_VERSION
  * @member VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION
  * @member VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION
  * @member VK_EXT_DEBUG_MARKER_SPEC_VERSION
  * @member VK_AMD_EXTENSION_24_SPEC_VERSION
  * @member VK_AMD_EXTENSION_25_SPEC_VERSION
  * @member VK_AMD_GCN_SHADER_SPEC_VERSION
  * @member VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION
  * @member VK_EXT_EXTENSION_28_SPEC_VERSION
  * @member VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION
  * @member VK_NVX_EXTENSION_30_SPEC_VERSION
  * @member VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION
  * @member VK_AMD_EXTENSION_32_SPEC_VERSION
  * @member VK_AMD_EXTENSION_33_SPEC_VERSION
  * @member VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION
  * @member VK_AMD_EXTENSION_35_SPEC_VERSION
  * @member VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION
  * @member VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION
  * @member VK_AMD_SHADER_BALLOT_SPEC_VERSION
  * @member VK_AMD_EXTENSION_39_SPEC_VERSION
  * @member VK_AMD_EXTENSION_40_SPEC_VERSION
  * @member VK_AMD_EXTENSION_41_SPEC_VERSION
  * @member VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION
  * @member VK_AMD_SHADER_INFO_SPEC_VERSION
  * @member VK_AMD_EXTENSION_44_SPEC_VERSION
  * @member VK_AMD_EXTENSION_45_SPEC_VERSION
  * @member VK_AMD_EXTENSION_46_SPEC_VERSION
  * @member VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION
  * @member VK_NVX_EXTENSION_48_SPEC_VERSION
  * @member VK_GOOGLE_EXTENSION_49_SPEC_VERSION
  * @member VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION
  * @member VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION
  * @member VK_NV_EXTENSION_52_SPEC_VERSION
  * @member VK_NV_EXTENSION_53_SPEC_VERSION
  * @member VK_KHR_MULTIVIEW_SPEC_VERSION
  * @member VK_IMG_FORMAT_PVRTC_SPEC_VERSION
  * @member VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION
  * @member VK_NV_EXTERNAL_MEMORY_SPEC_VERSION
  * @member VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION
  * @member VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION
  * @member VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION
  * @member VK_KHR_DEVICE_GROUP_SPEC_VERSION
  * @member VK_EXT_VALIDATION_FLAGS_SPEC_VERSION
  * @member VK_NN_VI_SURFACE_SPEC_VERSION
  * @member VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION
  * @member VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION
  * @member VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION
  * @member VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION
  * @member VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION
  * @member VK_IMG_EXTENSION_69_SPEC_VERSION
  * @member VK_KHR_MAINTENANCE1_SPEC_VERSION
  * @member VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION
  * @member VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION
  * @member VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION
  * @member VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION
  * @member VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION
  * @member VK_KHR_16BIT_STORAGE_SPEC_VERSION
  * @member VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION
  * @member VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION
  * @member VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION
  * @member VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION
  * @member VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION
  * @member VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION
  * @member VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION
  * @member VK_EXT_DISPLAY_CONTROL_SPEC_VERSION
  * @member VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION
  * @member VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION
  * @member VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION
  * @member VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION
  * @member VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION
  * @member VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION
  * @member VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION
  * @member VK_NV_EXTENSION_101_SPEC_VERSION
  * @member VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION
  * @member VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION
  * @member VK_NV_EXTENSION_104_SPEC_VERSION
  * @member VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION
  * @member VK_EXT_HDR_METADATA_SPEC_VERSION
  * @member VK_IMG_EXTENSION_107_SPEC_VERSION
  * @member VK_IMG_EXTENSION_108_SPEC_VERSION
  * @member VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION
  * @member VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION
  * @member VK_IMG_EXTENSION_111_SPEC_VERSION
  * @member VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_FENCE_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION
  * @member VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION
  * @member VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION
  * @member VK_KHR_MAINTENANCE2_SPEC_VERSION
  * @member VK_KHR_EXTENSION_119_SPEC_VERSION
  * @member VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION
  * @member VK_KHR_VARIABLE_POINTERS_SPEC_VERSION
  * @member VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION
  * @member VK_MVK_IOS_SURFACE_SPEC_VERSION
  * @member VK_MVK_MACOS_SURFACE_SPEC_VERSION
  * @member VK_MVK_MOLTENVK_SPEC_VERSION
  * @member VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION
  * @member VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION
  * @member VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION
  * @member VK_EXT_DEBUG_UTILS_SPEC_VERSION
  * @member VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION
  * @member VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION
  * @member VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION
  * @member VK_AMD_GPU_SHADER_INT16_SPEC_VERSION
  * @member VK_AMD_EXTENSION_134_SPEC_VERSION
  * @member VK_AMD_EXTENSION_135_SPEC_VERSION
  * @member VK_AMD_EXTENSION_136_SPEC_VERSION
  * @member VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION
  * @member VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION
  * @member VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION
  * @member VK_AMD_EXTENSION_140_SPEC_VERSION
  * @member VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION
  * @member VK_AMD_EXTENSION_142_SPEC_VERSION
  * @member VK_AMD_EXTENSION_143_SPEC_VERSION
  * @member VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION
  * @member VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION
  * @member VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION
  * @member VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION
  * @member VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION
  * @member VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION
  * @member VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION
  * @member VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION
  * @member VK_KHR_RAY_QUERY_SPEC_VERSION
  * @member VK_NV_EXTENSION_152_SPEC_VERSION
  * @member VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION
  * @member VK_NV_FILL_RECTANGLE_SPEC_VERSION
  * @member VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION
  * @member VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION
  * @member VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION
  * @member VK_KHR_BIND_MEMORY_2_SPEC_VERSION
  * @member VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION
  * @member VK_EXT_EXTENSION_160_SPEC_VERSION
  * @member VK_EXT_VALIDATION_CACHE_SPEC_VERSION
  * @member VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION
  * @member VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION
  * @member VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION
  * @member VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION
  * @member VK_NV_RAY_TRACING_SPEC_VERSION
  * @member VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION
  * @member VK_EXT_EXTENSION_168_SPEC_VERSION
  * @member VK_KHR_MAINTENANCE3_SPEC_VERSION
  * @member VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION
  * @member VK_EXT_FILTER_CUBIC_SPEC_VERSION
  * @member VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION
  * @member VK_QCOM_extension_173_SPEC_VERSION
  * @member VK_QCOM_extension_174_SPEC_VERSION
  * @member VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION
  * @member VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION
  * @member VK_KHR_EXTENSION_177_SPEC_VERSION
  * @member VK_KHR_8BIT_STORAGE_SPEC_VERSION
  * @member VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION
  * @member VK_AMD_BUFFER_MARKER_SPEC_VERSION
  * @member VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION
  * @member VK_KHR_SHADER_CLOCK_SPEC_VERSION
  * @member VK_KHR_EXTENSION_183_SPEC_VERSION
  * @member VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION
  * @member VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION
  * @member VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION
  * @member VK_KHR_EXTENSION_187_SPEC_VERSION
  * @member VK_KHR_EXTENSION_188_SPEC_VERSION
  * @member VK_KHR_EXTENSION_189_SPEC_VERSION
  * @member VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION
  * @member VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION
  * @member VK_GGP_FRAME_TOKEN_SPEC_VERSION
  * @member VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION
  * @member VK_GOOGLE_EXTENSION_194_SPEC_VERSION
  * @member VK_GOOGLE_EXTENSION_195_SPEC_VERSION
  * @member VK_GOOGLE_EXTENSION_196_SPEC_VERSION
  * @member VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION
  * @member VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION
  * @member VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION
  * @member VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION
  * @member VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION
  * @member VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION
  * @member VK_NV_MESH_SHADER_SPEC_VERSION
  * @member VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION
  * @member VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION
  * @member VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION
  * @member VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION
  * @member VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION
  * @member VK_KHR_EXTENSION_209_SPEC_VERSION
  * @member VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION
  * @member VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION
  * @member VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION
  * @member VK_EXT_PCI_BUS_INFO_SPEC_VERSION
  * @member VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION
  * @member VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION
  * @member VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION
  * @member VK_KHR_EXTENSION_217_SPEC_VERSION
  * @member VK_EXT_METAL_SURFACE_SPEC_VERSION
  * @member VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION
  * @member VK_EXT_EXTENSION_220_SPEC_VERSION
  * @member VK_KHR_EXTENSION_221_SPEC_VERSION
  * @member VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION
  * @member VK_EXT_EXTENSION_223_SPEC_VERSION
  * @member VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION
  * @member VK_GOOGLE_DECORATE_STRING_SPEC_VERSION
  * @member VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION
  * @member VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION
  * @member VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION
  * @member VK_AMD_EXTENSION_229_SPEC_VERSION
  * @member VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION
  * @member VK_AMD_EXTENSION_231_SPEC_VERSION
  * @member VK_AMD_EXTENSION_232_SPEC_VERSION
  * @member VK_AMD_EXTENSION_233_SPEC_VERSION
  * @member VK_AMD_EXTENSION_234_SPEC_VERSION
  * @member VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION
  * @member VK_AMD_EXTENSION_236_SPEC_VERSION
  * @member VK_KHR_SPIRV_1_4_SPEC_VERSION
  * @member VK_EXT_MEMORY_BUDGET_SPEC_VERSION
  * @member VK_EXT_MEMORY_PRIORITY_SPEC_VERSION
  * @member VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION
  * @member VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION
  * @member VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION
  * @member VK_INTEL_EXTENSION_243_SPEC_VERSION
  * @member VK_MESA_EXTENSION_244_SPEC_VERSION
  * @member VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION
  * @member VK_EXT_TOOLING_INFO_SPEC_VERSION
  * @member VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION
  * @member VK_EXT_VALIDATION_FEATURES_SPEC_VERSION
  * @member VK_KHR_EXTENSION_249_SPEC_VERSION
  * @member VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION
  * @member VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION
  * @member VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION
  * @member VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION
  * @member VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION
  * @member VK_EXT_EXTENSION_255_SPEC_VERSION
  * @member VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION
  * @member VK_EXT_HEADLESS_SURFACE_SPEC_VERSION
  * @member VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION
  * @member VK_EXT_EXTENSION_259_SPEC_VERSION
  * @member VK_EXT_LINE_RASTERIZATION_SPEC_VERSION
  * @member VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION
  * @member VK_EXT_HOST_QUERY_RESET_SPEC_VERSION
  * @member VK_GOOGLE_EXTENSION_263_SPEC_VERSION
  * @member VK_BRCM_EXTENSION_264_SPEC_VERSION
  * @member VK_BRCM_EXTENSION_265_SPEC_VERSION
  * @member VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION
  * @member VK_EXT_EXTENSION_267_SPEC_VERSION
  * @member VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION
  * @member VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION
  * @member VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION
  * @member VK_INTEL_EXTENSION_271_SPEC_VERSION
  * @member VK_INTEL_EXTENSION_272_SPEC_VERSION
  * @member VK_INTEL_EXTENSION_273_SPEC_VERSION
  * @member VK_INTEL_EXTENSION_274_SPEC_VERSION
  * @member VK_KHR_EXTENSION_275_SPEC_VERSION
  * @member VK_KHR_EXTENSION_276_SPEC_VERSION
  * @member VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION
  * @member VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION
  * @member VK_NV_EXTENSION_279_SPEC_VERSION
  * @member VK_KHR_EXTENSION_280_SPEC_VERSION
  * @member VK_ARM_EXTENSION_281_SPEC_VERSION
  * @member VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION
  * @member VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION
  * @member VK_EXT_EXTENSION_284_SPEC_VERSION
  * @member VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION
  * @member VK_EXT_EXTENSION_286_SPEC_VERSION
  * @member VK_EXT_ROBUSTNESS_2_SPEC_VERSION
  * @member VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION
  * @member VK_EXT_EXTENSION_289_SPEC_VERSION
  * @member VK_GOOGLE_USER_TYPE_SPEC_VERSION
  * @member VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION
  * @member VK_NV_EXTENSION_292_SPEC_VERSION
  * @member VK_NV_EXTENSION_293_SPEC_VERSION
  * @member VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION
  * @member VK_KHR_EXTENSION_295_SPEC_VERSION
  * @member VK_EXT_PRIVATE_DATA_SPEC_VERSION
  * @member VK_KHR_EXTENSION_297_SPEC_VERSION
  * @member VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION
  * @member VK_KHR_EXTENSION_299_SPEC_VERSION
  * @member VK_KHR_EXTENSION_300_SPEC_VERSION
  * @member VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION
  * @member VK_QCOM_render_pass_store_ops_SPEC_VERSION
  * @member VK_QCOM_extension_303_SPEC_VERSION
  * @member VK_QCOM_extension_304_SPEC_VERSION
  * @member VK_QCOM_extension_305_SPEC_VERSION
  * @member VK_QCOM_extension_306_SPEC_VERSION
  * @member VK_QCOM_extension_307_SPEC_VERSION
  * @member VK_NV_EXTENSION_308_SPEC_VERSION
  * @member VK_KHR_EXTENSION_309_SPEC_VERSION
  * @member VK_QCOM_extension_310_SPEC_VERSION
  * @member VK_NV_EXTENSION_311_SPEC_VERSION
  * @member VK_EXT_EXTENSION_312_SPEC_VERSION
  * @member VK_EXT_EXTENSION_313_SPEC_VERSION
  * @member VK_AMD_EXTENSION_314_SPEC_VERSION
  * @member VK_AMD_EXTENSION_315_SPEC_VERSION
  * @member VK_AMD_EXTENSION_316_SPEC_VERSION
  * @member VK_AMD_EXTENSION_317_SPEC_VERSION
  * @member VK_AMD_EXTENSION_318_SPEC_VERSION
  * @member VK_AMD_EXTENSION_319_SPEC_VERSION
  * @member VK_AMD_EXTENSION_320_SPEC_VERSION
  * @member VK_AMD_EXTENSION_321_SPEC_VERSION
  * @member VK_AMD_EXTENSION_322_SPEC_VERSION
  * @member VK_AMD_EXTENSION_323_SPEC_VERSION
  * @member VK_KHR_EXTENSION_324_SPEC_VERSION
  * @member VK_KHR_EXTENSION_325_SPEC_VERSION
  * @member VK_KHR_EXTENSION_326_SPEC_VERSION
  * @member VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION
  * @member VK_NV_EXTENSION_328_SPEC_VERSION
  * @member VK_NV_EXTENSION_329_SPEC_VERSION
  * @member VK_NV_EXTENSION_330_SPEC_VERSION
  * @member VK_NV_EXTENSION_331_SPEC_VERSION
  * @member VK_NV_EXTENSION_332_SPEC_VERSION
  * @member VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION
  * @member VK_QCOM_rotated_copy_commands_SPEC_VERSION
  * @member VK_KHR_EXTENSION_335_SPEC_VERSION
  * @member VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION
  * @member VK_KHR_EXTENSION_337_SPEC_VERSION
  * @member VK_KHR_COPY_COMMANDS_2_SPEC_VERSION
  * @member VK_ARM_EXTENSION_339_SPEC_VERSION
  * @member VK_EXT_EXTENSION_340_SPEC_VERSION
  * @member VK_EXT_4444_FORMATS_SPEC_VERSION
  * @member VK_EXT_EXTENSION_342_SPEC_VERSION
  * @member VK_ARM_EXTENSION_343_SPEC_VERSION
  * @member VK_ARM_EXTENSION_344_SPEC_VERSION
  * @member VK_ARM_EXTENSION_345_SPEC_VERSION
  * @member VK_NV_EXTENSION_346_SPEC_VERSION
  * @member VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION
  * @member VK_KHR_EXTENSION_350_SPEC_VERSION
  * @member VK_NV_EXTENSION_351_SPEC_VERSION
  * @member VK_EXT_EXTENSION_352_SPEC_VERSION
  * @member VK_EXT_EXTENSION_353_SPEC_VERSION
  * @member VK_EXT_EXTENSION_354_SPEC_VERSION
  * @member VK_EXT_EXTENSION_355_SPEC_VERSION
  * @member VK_EXT_VERTEX_ATTRIBUTE_ALIASING_SPEC_VERSION
  * @member VK_EXT_EXTENSION_357
  * @member VK_KHR_EXTENSION_358_SPEC_VERSION
  * @member VK_EXT_EXTENSION_359
  * @member VK_EXT_EXTENSION_360
  * @member VK_EXT_EXTENSION_361
  * @member VK_EXT_EXTENSION_362_SPEC_VERSION
  * @member VK_EXT_EXTENSION_363_SPEC_VERSION
  * @member VK_EXT_EXTENSION_364_SPEC_VERSION
  * @member VK_EXT_EXTENSION_365_SPEC_VERSION
  * @member VK_EXT_EXTENSION_366_SPEC_VERSION
  * @member VK_EXT_EXTENSION_367_SPEC_VERSION
  * @member VK_EXT_EXTENSION_368_SPEC_VERSION
  * @member VK_QCOM_EXTENSION_369_SPEC_VERSION
  * @member VK_HUAWEI_EXTENSION_370_SPEC_VERSION
  * @member VK_HUAWEI_EXTENSION_371_SPEC_VERSION
  * @member VK_NV_EXTENSION_372_SPEC_VERSION
  */
export enum API_Extensions {
  VK_KHR_SURFACE_SPEC_VERSION,
  VK_KHR_SWAPCHAIN_SPEC_VERSION,
  VK_KHR_DISPLAY_SPEC_VERSION,
  VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION,
  VK_KHR_XLIB_SURFACE_SPEC_VERSION,
  VK_KHR_XCB_SURFACE_SPEC_VERSION,
  VK_KHR_WAYLAND_SURFACE_SPEC_VERSION,
  VK_KHR_MIR_SURFACE_SPEC_VERSION,
  VK_KHR_ANDROID_SURFACE_SPEC_VERSION,
  VK_KHR_WIN32_SURFACE_SPEC_VERSION,
  VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION,
  VK_ANDROID_NATIVE_BUFFER_NUMBER,
  VK_EXT_DEBUG_REPORT_SPEC_VERSION,
  VK_NV_GLSL_SHADER_SPEC_VERSION,
  VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION,
  VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION,
  VK_IMG_FILTER_CUBIC_SPEC_VERSION,
  VK_AMD_EXTENSION_17_SPEC_VERSION,
  VK_AMD_EXTENSION_18_SPEC_VERSION,
  VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION,
  VK_AMD_EXTENSION_20_SPEC_VERSION,
  VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION,
  VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION,
  VK_EXT_DEBUG_MARKER_SPEC_VERSION,
  VK_AMD_EXTENSION_24_SPEC_VERSION,
  VK_AMD_EXTENSION_25_SPEC_VERSION,
  VK_AMD_GCN_SHADER_SPEC_VERSION,
  VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION,
  VK_EXT_EXTENSION_28_SPEC_VERSION,
  VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION,
  VK_NVX_EXTENSION_30_SPEC_VERSION,
  VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION,
  VK_AMD_EXTENSION_32_SPEC_VERSION,
  VK_AMD_EXTENSION_33_SPEC_VERSION,
  VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION,
  VK_AMD_EXTENSION_35_SPEC_VERSION,
  VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION,
  VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION,
  VK_AMD_SHADER_BALLOT_SPEC_VERSION,
  VK_AMD_EXTENSION_39_SPEC_VERSION,
  VK_AMD_EXTENSION_40_SPEC_VERSION,
  VK_AMD_EXTENSION_41_SPEC_VERSION,
  VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION,
  VK_AMD_SHADER_INFO_SPEC_VERSION,
  VK_AMD_EXTENSION_44_SPEC_VERSION,
  VK_AMD_EXTENSION_45_SPEC_VERSION,
  VK_AMD_EXTENSION_46_SPEC_VERSION,
  VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION,
  VK_NVX_EXTENSION_48_SPEC_VERSION,
  VK_GOOGLE_EXTENSION_49_SPEC_VERSION,
  VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION,
  VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION,
  VK_NV_EXTENSION_52_SPEC_VERSION,
  VK_NV_EXTENSION_53_SPEC_VERSION,
  VK_KHR_MULTIVIEW_SPEC_VERSION,
  VK_IMG_FORMAT_PVRTC_SPEC_VERSION,
  VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION,
  VK_NV_EXTERNAL_MEMORY_SPEC_VERSION,
  VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION,
  VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION,
  VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION,
  VK_KHR_DEVICE_GROUP_SPEC_VERSION,
  VK_EXT_VALIDATION_FLAGS_SPEC_VERSION,
  VK_NN_VI_SURFACE_SPEC_VERSION,
  VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION,
  VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION,
  VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION,
  VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION,
  VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION,
  VK_IMG_EXTENSION_69_SPEC_VERSION,
  VK_KHR_MAINTENANCE1_SPEC_VERSION,
  VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION,
  VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION,
  VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION,
  VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION,
  VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION,
  VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION,
  VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION,
  VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION,
  VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION,
  VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION,
  VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION,
  VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION,
  VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION,
  VK_KHR_16BIT_STORAGE_SPEC_VERSION,
  VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION,
  VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION,
  VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION,
  VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION,
  VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION,
  VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION,
  VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION,
  VK_EXT_DISPLAY_CONTROL_SPEC_VERSION,
  VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION,
  VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION,
  VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION,
  VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION,
  VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION,
  VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION,
  VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION,
  VK_NV_EXTENSION_101_SPEC_VERSION,
  VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION,
  VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION,
  VK_NV_EXTENSION_104_SPEC_VERSION,
  VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION,
  VK_EXT_HDR_METADATA_SPEC_VERSION,
  VK_IMG_EXTENSION_107_SPEC_VERSION,
  VK_IMG_EXTENSION_108_SPEC_VERSION,
  VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION,
  VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION,
  VK_IMG_EXTENSION_111_SPEC_VERSION,
  VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION,
  VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION,
  VK_KHR_EXTERNAL_FENCE_SPEC_VERSION,
  VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION,
  VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION,
  VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION,
  VK_KHR_MAINTENANCE2_SPEC_VERSION,
  VK_KHR_EXTENSION_119_SPEC_VERSION,
  VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION,
  VK_KHR_VARIABLE_POINTERS_SPEC_VERSION,
  VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION,
  VK_MVK_IOS_SURFACE_SPEC_VERSION,
  VK_MVK_MACOS_SURFACE_SPEC_VERSION,
  VK_MVK_MOLTENVK_SPEC_VERSION,
  VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION,
  VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION,
  VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION,
  VK_EXT_DEBUG_UTILS_SPEC_VERSION,
  VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION,
  VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION,
  VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION,
  VK_AMD_GPU_SHADER_INT16_SPEC_VERSION,
  VK_AMD_EXTENSION_134_SPEC_VERSION,
  VK_AMD_EXTENSION_135_SPEC_VERSION,
  VK_AMD_EXTENSION_136_SPEC_VERSION,
  VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION,
  VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION,
  VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION,
  VK_AMD_EXTENSION_140_SPEC_VERSION,
  VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION,
  VK_AMD_EXTENSION_142_SPEC_VERSION,
  VK_AMD_EXTENSION_143_SPEC_VERSION,
  VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION,
  VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION,
  VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION,
  VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION,
  VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION,
  VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION,
  VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION,
  VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION,
  VK_KHR_RAY_QUERY_SPEC_VERSION,
  VK_NV_EXTENSION_152_SPEC_VERSION,
  VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION,
  VK_NV_FILL_RECTANGLE_SPEC_VERSION,
  VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION,
  VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION,
  VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION,
  VK_KHR_BIND_MEMORY_2_SPEC_VERSION,
  VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION,
  VK_EXT_EXTENSION_160_SPEC_VERSION,
  VK_EXT_VALIDATION_CACHE_SPEC_VERSION,
  VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION,
  VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION,
  VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION,
  VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION,
  VK_NV_RAY_TRACING_SPEC_VERSION,
  VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION,
  VK_EXT_EXTENSION_168_SPEC_VERSION,
  VK_KHR_MAINTENANCE3_SPEC_VERSION,
  VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION,
  VK_EXT_FILTER_CUBIC_SPEC_VERSION,
  VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION,
  VK_QCOM_extension_173_SPEC_VERSION,
  VK_QCOM_extension_174_SPEC_VERSION,
  VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION,
  VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION,
  VK_KHR_EXTENSION_177_SPEC_VERSION,
  VK_KHR_8BIT_STORAGE_SPEC_VERSION,
  VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION,
  VK_AMD_BUFFER_MARKER_SPEC_VERSION,
  VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION,
  VK_KHR_SHADER_CLOCK_SPEC_VERSION,
  VK_KHR_EXTENSION_183_SPEC_VERSION,
  VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION,
  VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION,
  VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION,
  VK_KHR_EXTENSION_187_SPEC_VERSION,
  VK_KHR_EXTENSION_188_SPEC_VERSION,
  VK_KHR_EXTENSION_189_SPEC_VERSION,
  VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION,
  VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION,
  VK_GGP_FRAME_TOKEN_SPEC_VERSION,
  VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION,
  VK_GOOGLE_EXTENSION_194_SPEC_VERSION,
  VK_GOOGLE_EXTENSION_195_SPEC_VERSION,
  VK_GOOGLE_EXTENSION_196_SPEC_VERSION,
  VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION,
  VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION,
  VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION,
  VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION,
  VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION,
  VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION,
  VK_NV_MESH_SHADER_SPEC_VERSION,
  VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION,
  VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION,
  VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION,
  VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION,
  VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION,
  VK_KHR_EXTENSION_209_SPEC_VERSION,
  VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION,
  VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION,
  VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION,
  VK_EXT_PCI_BUS_INFO_SPEC_VERSION,
  VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION,
  VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION,
  VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION,
  VK_KHR_EXTENSION_217_SPEC_VERSION,
  VK_EXT_METAL_SURFACE_SPEC_VERSION,
  VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION,
  VK_EXT_EXTENSION_220_SPEC_VERSION,
  VK_KHR_EXTENSION_221_SPEC_VERSION,
  VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION,
  VK_EXT_EXTENSION_223_SPEC_VERSION,
  VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION,
  VK_GOOGLE_DECORATE_STRING_SPEC_VERSION,
  VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION,
  VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION,
  VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION,
  VK_AMD_EXTENSION_229_SPEC_VERSION,
  VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION,
  VK_AMD_EXTENSION_231_SPEC_VERSION,
  VK_AMD_EXTENSION_232_SPEC_VERSION,
  VK_AMD_EXTENSION_233_SPEC_VERSION,
  VK_AMD_EXTENSION_234_SPEC_VERSION,
  VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION,
  VK_AMD_EXTENSION_236_SPEC_VERSION,
  VK_KHR_SPIRV_1_4_SPEC_VERSION,
  VK_EXT_MEMORY_BUDGET_SPEC_VERSION,
  VK_EXT_MEMORY_PRIORITY_SPEC_VERSION,
  VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION,
  VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION,
  VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION,
  VK_INTEL_EXTENSION_243_SPEC_VERSION,
  VK_MESA_EXTENSION_244_SPEC_VERSION,
  VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION,
  VK_EXT_TOOLING_INFO_SPEC_VERSION,
  VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION,
  VK_EXT_VALIDATION_FEATURES_SPEC_VERSION,
  VK_KHR_EXTENSION_249_SPEC_VERSION,
  VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION,
  VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION,
  VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION,
  VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION,
  VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION,
  VK_EXT_EXTENSION_255_SPEC_VERSION,
  VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION,
  VK_EXT_HEADLESS_SURFACE_SPEC_VERSION,
  VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION,
  VK_EXT_EXTENSION_259_SPEC_VERSION,
  VK_EXT_LINE_RASTERIZATION_SPEC_VERSION,
  VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION,
  VK_EXT_HOST_QUERY_RESET_SPEC_VERSION,
  VK_GOOGLE_EXTENSION_263_SPEC_VERSION,
  VK_BRCM_EXTENSION_264_SPEC_VERSION,
  VK_BRCM_EXTENSION_265_SPEC_VERSION,
  VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION,
  VK_EXT_EXTENSION_267_SPEC_VERSION,
  VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION,
  VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION,
  VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION,
  VK_INTEL_EXTENSION_271_SPEC_VERSION,
  VK_INTEL_EXTENSION_272_SPEC_VERSION,
  VK_INTEL_EXTENSION_273_SPEC_VERSION,
  VK_INTEL_EXTENSION_274_SPEC_VERSION,
  VK_KHR_EXTENSION_275_SPEC_VERSION,
  VK_KHR_EXTENSION_276_SPEC_VERSION,
  VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION,
  VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION,
  VK_NV_EXTENSION_279_SPEC_VERSION,
  VK_KHR_EXTENSION_280_SPEC_VERSION,
  VK_ARM_EXTENSION_281_SPEC_VERSION,
  VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION,
  VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION,
  VK_EXT_EXTENSION_284_SPEC_VERSION,
  VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION,
  VK_EXT_EXTENSION_286_SPEC_VERSION,
  VK_EXT_ROBUSTNESS_2_SPEC_VERSION,
  VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION,
  VK_EXT_EXTENSION_289_SPEC_VERSION,
  VK_GOOGLE_USER_TYPE_SPEC_VERSION,
  VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION,
  VK_NV_EXTENSION_292_SPEC_VERSION,
  VK_NV_EXTENSION_293_SPEC_VERSION,
  VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION,
  VK_KHR_EXTENSION_295_SPEC_VERSION,
  VK_EXT_PRIVATE_DATA_SPEC_VERSION,
  VK_KHR_EXTENSION_297_SPEC_VERSION,
  VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION,
  VK_KHR_EXTENSION_299_SPEC_VERSION,
  VK_KHR_EXTENSION_300_SPEC_VERSION,
  VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION,
  VK_QCOM_render_pass_store_ops_SPEC_VERSION,
  VK_QCOM_extension_303_SPEC_VERSION,
  VK_QCOM_extension_304_SPEC_VERSION,
  VK_QCOM_extension_305_SPEC_VERSION,
  VK_QCOM_extension_306_SPEC_VERSION,
  VK_QCOM_extension_307_SPEC_VERSION,
  VK_NV_EXTENSION_308_SPEC_VERSION,
  VK_KHR_EXTENSION_309_SPEC_VERSION,
  VK_QCOM_extension_310_SPEC_VERSION,
  VK_NV_EXTENSION_311_SPEC_VERSION,
  VK_EXT_EXTENSION_312_SPEC_VERSION,
  VK_EXT_EXTENSION_313_SPEC_VERSION,
  VK_AMD_EXTENSION_314_SPEC_VERSION,
  VK_AMD_EXTENSION_315_SPEC_VERSION,
  VK_AMD_EXTENSION_316_SPEC_VERSION,
  VK_AMD_EXTENSION_317_SPEC_VERSION,
  VK_AMD_EXTENSION_318_SPEC_VERSION,
  VK_AMD_EXTENSION_319_SPEC_VERSION,
  VK_AMD_EXTENSION_320_SPEC_VERSION,
  VK_AMD_EXTENSION_321_SPEC_VERSION,
  VK_AMD_EXTENSION_322_SPEC_VERSION,
  VK_AMD_EXTENSION_323_SPEC_VERSION,
  VK_KHR_EXTENSION_324_SPEC_VERSION,
  VK_KHR_EXTENSION_325_SPEC_VERSION,
  VK_KHR_EXTENSION_326_SPEC_VERSION,
  VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION,
  VK_NV_EXTENSION_328_SPEC_VERSION,
  VK_NV_EXTENSION_329_SPEC_VERSION,
  VK_NV_EXTENSION_330_SPEC_VERSION,
  VK_NV_EXTENSION_331_SPEC_VERSION,
  VK_NV_EXTENSION_332_SPEC_VERSION,
  VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION,
  VK_QCOM_rotated_copy_commands_SPEC_VERSION,
  VK_KHR_EXTENSION_335_SPEC_VERSION,
  VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION,
  VK_KHR_EXTENSION_337_SPEC_VERSION,
  VK_KHR_COPY_COMMANDS_2_SPEC_VERSION,
  VK_ARM_EXTENSION_339_SPEC_VERSION,
  VK_EXT_EXTENSION_340_SPEC_VERSION,
  VK_EXT_4444_FORMATS_SPEC_VERSION,
  VK_EXT_EXTENSION_342_SPEC_VERSION,
  VK_ARM_EXTENSION_343_SPEC_VERSION,
  VK_ARM_EXTENSION_344_SPEC_VERSION,
  VK_ARM_EXTENSION_345_SPEC_VERSION,
  VK_NV_EXTENSION_346_SPEC_VERSION,
  VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION,
  VK_KHR_EXTENSION_350_SPEC_VERSION,
  VK_NV_EXTENSION_351_SPEC_VERSION,
  VK_EXT_EXTENSION_352_SPEC_VERSION,
  VK_EXT_EXTENSION_353_SPEC_VERSION,
  VK_EXT_EXTENSION_354_SPEC_VERSION,
  VK_EXT_EXTENSION_355_SPEC_VERSION,
  VK_EXT_VERTEX_ATTRIBUTE_ALIASING_SPEC_VERSION,
  VK_EXT_EXTENSION_357,
  VK_KHR_EXTENSION_358_SPEC_VERSION,
  VK_EXT_EXTENSION_359,
  VK_EXT_EXTENSION_360,
  VK_EXT_EXTENSION_361,
  VK_EXT_EXTENSION_362_SPEC_VERSION,
  VK_EXT_EXTENSION_363_SPEC_VERSION,
  VK_EXT_EXTENSION_364_SPEC_VERSION,
  VK_EXT_EXTENSION_365_SPEC_VERSION,
  VK_EXT_EXTENSION_366_SPEC_VERSION,
  VK_EXT_EXTENSION_367_SPEC_VERSION,
  VK_EXT_EXTENSION_368_SPEC_VERSION,
  VK_QCOM_EXTENSION_369_SPEC_VERSION,
  VK_HUAWEI_EXTENSION_370_SPEC_VERSION,
  VK_HUAWEI_EXTENSION_371_SPEC_VERSION,
  VK_NV_EXTENSION_372_SPEC_VERSION,
  
}

declare const VK_KHR_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SWAPCHAIN_SPEC_VERSION: API_Extensions;
declare const VK_KHR_DISPLAY_SPEC_VERSION: API_Extensions;
declare const VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION: API_Extensions;
declare const VK_KHR_XLIB_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_XCB_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_WAYLAND_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_MIR_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_ANDROID_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_WIN32_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION: API_Extensions;
declare const VK_ANDROID_NATIVE_BUFFER_NUMBER: API_Extensions;
declare const VK_EXT_DEBUG_REPORT_SPEC_VERSION: API_Extensions;
declare const VK_NV_GLSL_SHADER_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION: API_Extensions;
declare const VK_IMG_FILTER_CUBIC_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_17_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_18_SPEC_VERSION: API_Extensions;
declare const VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_20_SPEC_VERSION: API_Extensions;
declare const VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION: API_Extensions;
declare const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DEBUG_MARKER_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_24_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_25_SPEC_VERSION: API_Extensions;
declare const VK_AMD_GCN_SHADER_SPEC_VERSION: API_Extensions;
declare const VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_28_SPEC_VERSION: API_Extensions;
declare const VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION: API_Extensions;
declare const VK_NVX_EXTENSION_30_SPEC_VERSION: API_Extensions;
declare const VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_32_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_33_SPEC_VERSION: API_Extensions;
declare const VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_35_SPEC_VERSION: API_Extensions;
declare const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION: API_Extensions;
declare const VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION: API_Extensions;
declare const VK_AMD_SHADER_BALLOT_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_39_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_40_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_41_SPEC_VERSION: API_Extensions;
declare const VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION: API_Extensions;
declare const VK_AMD_SHADER_INFO_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_44_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_45_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_46_SPEC_VERSION: API_Extensions;
declare const VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION: API_Extensions;
declare const VK_NVX_EXTENSION_48_SPEC_VERSION: API_Extensions;
declare const VK_GOOGLE_EXTENSION_49_SPEC_VERSION: API_Extensions;
declare const VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_52_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_53_SPEC_VERSION: API_Extensions;
declare const VK_KHR_MULTIVIEW_SPEC_VERSION: API_Extensions;
declare const VK_IMG_FORMAT_PVRTC_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTERNAL_MEMORY_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION: API_Extensions;
declare const VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION: API_Extensions;
declare const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION: API_Extensions;
declare const VK_KHR_DEVICE_GROUP_SPEC_VERSION: API_Extensions;
declare const VK_EXT_VALIDATION_FLAGS_SPEC_VERSION: API_Extensions;
declare const VK_NN_VI_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION: API_Extensions;
declare const VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION: API_Extensions;
declare const VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION: API_Extensions;
declare const VK_IMG_EXTENSION_69_SPEC_VERSION: API_Extensions;
declare const VK_KHR_MAINTENANCE1_SPEC_VERSION: API_Extensions;
declare const VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION: API_Extensions;
declare const VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION: API_Extensions;
declare const VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION: API_Extensions;
declare const VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION: API_Extensions;
declare const VK_KHR_16BIT_STORAGE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION: API_Extensions;
declare const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION: API_Extensions;
declare const VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION: API_Extensions;
declare const VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION: API_Extensions;
declare const VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DISPLAY_CONTROL_SPEC_VERSION: API_Extensions;
declare const VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION: API_Extensions;
declare const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION: API_Extensions;
declare const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION: API_Extensions;
declare const VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION: API_Extensions;
declare const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION: API_Extensions;
declare const VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_101_SPEC_VERSION: API_Extensions;
declare const VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_104_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION: API_Extensions;
declare const VK_EXT_HDR_METADATA_SPEC_VERSION: API_Extensions;
declare const VK_IMG_EXTENSION_107_SPEC_VERSION: API_Extensions;
declare const VK_IMG_EXTENSION_108_SPEC_VERSION: API_Extensions;
declare const VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION: API_Extensions;
declare const VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION: API_Extensions;
declare const VK_IMG_EXTENSION_111_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_FENCE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION: API_Extensions;
declare const VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION: API_Extensions;
declare const VK_KHR_MAINTENANCE2_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_119_SPEC_VERSION: API_Extensions;
declare const VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION: API_Extensions;
declare const VK_KHR_VARIABLE_POINTERS_SPEC_VERSION: API_Extensions;
declare const VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION: API_Extensions;
declare const VK_MVK_IOS_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_MVK_MACOS_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_MVK_MOLTENVK_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION: API_Extensions;
declare const VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION: API_Extensions;
declare const VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DEBUG_UTILS_SPEC_VERSION: API_Extensions;
declare const VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION: API_Extensions;
declare const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION: API_Extensions;
declare const VK_AMD_GPU_SHADER_INT16_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_134_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_135_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_136_SPEC_VERSION: API_Extensions;
declare const VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION: API_Extensions;
declare const VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION: API_Extensions;
declare const VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_140_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_142_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_143_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION: API_Extensions;
declare const VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION: API_Extensions;
declare const VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION: API_Extensions;
declare const VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION: API_Extensions;
declare const VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION: API_Extensions;
declare const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION: API_Extensions;
declare const VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_RAY_QUERY_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_152_SPEC_VERSION: API_Extensions;
declare const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION: API_Extensions;
declare const VK_NV_FILL_RECTANGLE_SPEC_VERSION: API_Extensions;
declare const VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION: API_Extensions;
declare const VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION: API_Extensions;
declare const VK_KHR_BIND_MEMORY_2_SPEC_VERSION: API_Extensions;
declare const VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_160_SPEC_VERSION: API_Extensions;
declare const VK_EXT_VALIDATION_CACHE_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION: API_Extensions;
declare const VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION: API_Extensions;
declare const VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION: API_Extensions;
declare const VK_NV_RAY_TRACING_SPEC_VERSION: API_Extensions;
declare const VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_168_SPEC_VERSION: API_Extensions;
declare const VK_KHR_MAINTENANCE3_SPEC_VERSION: API_Extensions;
declare const VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION: API_Extensions;
declare const VK_EXT_FILTER_CUBIC_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_extension_173_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_extension_174_SPEC_VERSION: API_Extensions;
declare const VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_177_SPEC_VERSION: API_Extensions;
declare const VK_KHR_8BIT_STORAGE_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION: API_Extensions;
declare const VK_AMD_BUFFER_MARKER_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SHADER_CLOCK_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_183_SPEC_VERSION: API_Extensions;
declare const VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION: API_Extensions;
declare const VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION: API_Extensions;
declare const VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_187_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_188_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_189_SPEC_VERSION: API_Extensions;
declare const VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION: API_Extensions;
declare const VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION: API_Extensions;
declare const VK_GGP_FRAME_TOKEN_SPEC_VERSION: API_Extensions;
declare const VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION: API_Extensions;
declare const VK_GOOGLE_EXTENSION_194_SPEC_VERSION: API_Extensions;
declare const VK_GOOGLE_EXTENSION_195_SPEC_VERSION: API_Extensions;
declare const VK_GOOGLE_EXTENSION_196_SPEC_VERSION: API_Extensions;
declare const VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION: API_Extensions;
declare const VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION: API_Extensions;
declare const VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION: API_Extensions;
declare const VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION: API_Extensions;
declare const VK_NV_MESH_SHADER_SPEC_VERSION: API_Extensions;
declare const VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION: API_Extensions;
declare const VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION: API_Extensions;
declare const VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION: API_Extensions;
declare const VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION: API_Extensions;
declare const VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_209_SPEC_VERSION: API_Extensions;
declare const VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION: API_Extensions;
declare const VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION: API_Extensions;
declare const VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION: API_Extensions;
declare const VK_EXT_PCI_BUS_INFO_SPEC_VERSION: API_Extensions;
declare const VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION: API_Extensions;
declare const VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_217_SPEC_VERSION: API_Extensions;
declare const VK_EXT_METAL_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_220_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_221_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_223_SPEC_VERSION: API_Extensions;
declare const VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION: API_Extensions;
declare const VK_GOOGLE_DECORATE_STRING_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION: API_Extensions;
declare const VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION: API_Extensions;
declare const VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_229_SPEC_VERSION: API_Extensions;
declare const VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_231_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_232_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_233_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_234_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_236_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SPIRV_1_4_SPEC_VERSION: API_Extensions;
declare const VK_EXT_MEMORY_BUDGET_SPEC_VERSION: API_Extensions;
declare const VK_EXT_MEMORY_PRIORITY_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION: API_Extensions;
declare const VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION: API_Extensions;
declare const VK_INTEL_EXTENSION_243_SPEC_VERSION: API_Extensions;
declare const VK_MESA_EXTENSION_244_SPEC_VERSION: API_Extensions;
declare const VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION: API_Extensions;
declare const VK_EXT_TOOLING_INFO_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION: API_Extensions;
declare const VK_EXT_VALIDATION_FEATURES_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_249_SPEC_VERSION: API_Extensions;
declare const VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION: API_Extensions;
declare const VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION: API_Extensions;
declare const VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION: API_Extensions;
declare const VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION: API_Extensions;
declare const VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_255_SPEC_VERSION: API_Extensions;
declare const VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION: API_Extensions;
declare const VK_EXT_HEADLESS_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_259_SPEC_VERSION: API_Extensions;
declare const VK_EXT_LINE_RASTERIZATION_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION: API_Extensions;
declare const VK_EXT_HOST_QUERY_RESET_SPEC_VERSION: API_Extensions;
declare const VK_GOOGLE_EXTENSION_263_SPEC_VERSION: API_Extensions;
declare const VK_BRCM_EXTENSION_264_SPEC_VERSION: API_Extensions;
declare const VK_BRCM_EXTENSION_265_SPEC_VERSION: API_Extensions;
declare const VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_267_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION: API_Extensions;
declare const VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION: API_Extensions;
declare const VK_INTEL_EXTENSION_271_SPEC_VERSION: API_Extensions;
declare const VK_INTEL_EXTENSION_272_SPEC_VERSION: API_Extensions;
declare const VK_INTEL_EXTENSION_273_SPEC_VERSION: API_Extensions;
declare const VK_INTEL_EXTENSION_274_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_275_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_276_SPEC_VERSION: API_Extensions;
declare const VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION: API_Extensions;
declare const VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_279_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_280_SPEC_VERSION: API_Extensions;
declare const VK_ARM_EXTENSION_281_SPEC_VERSION: API_Extensions;
declare const VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_284_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_286_SPEC_VERSION: API_Extensions;
declare const VK_EXT_ROBUSTNESS_2_SPEC_VERSION: API_Extensions;
declare const VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_289_SPEC_VERSION: API_Extensions;
declare const VK_GOOGLE_USER_TYPE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_292_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_293_SPEC_VERSION: API_Extensions;
declare const VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_295_SPEC_VERSION: API_Extensions;
declare const VK_EXT_PRIVATE_DATA_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_297_SPEC_VERSION: API_Extensions;
declare const VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_299_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_300_SPEC_VERSION: API_Extensions;
declare const VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_render_pass_store_ops_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_extension_303_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_extension_304_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_extension_305_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_extension_306_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_extension_307_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_308_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_309_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_extension_310_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_311_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_312_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_313_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_314_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_315_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_316_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_317_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_318_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_319_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_320_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_321_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_322_SPEC_VERSION: API_Extensions;
declare const VK_AMD_EXTENSION_323_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_324_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_325_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_326_SPEC_VERSION: API_Extensions;
declare const VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_328_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_329_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_330_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_331_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_332_SPEC_VERSION: API_Extensions;
declare const VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_rotated_copy_commands_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_335_SPEC_VERSION: API_Extensions;
declare const VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_337_SPEC_VERSION: API_Extensions;
declare const VK_KHR_COPY_COMMANDS_2_SPEC_VERSION: API_Extensions;
declare const VK_ARM_EXTENSION_339_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_340_SPEC_VERSION: API_Extensions;
declare const VK_EXT_4444_FORMATS_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_342_SPEC_VERSION: API_Extensions;
declare const VK_ARM_EXTENSION_343_SPEC_VERSION: API_Extensions;
declare const VK_ARM_EXTENSION_344_SPEC_VERSION: API_Extensions;
declare const VK_ARM_EXTENSION_345_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_346_SPEC_VERSION: API_Extensions;
declare const VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION: API_Extensions;
declare const VK_KHR_EXTENSION_350_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_351_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_352_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_353_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_354_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_355_SPEC_VERSION: API_Extensions;
declare const VK_EXT_VERTEX_ATTRIBUTE_ALIASING_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_357: API_Extensions;
declare const VK_KHR_EXTENSION_358_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_359: API_Extensions;
declare const VK_EXT_EXTENSION_360: API_Extensions;
declare const VK_EXT_EXTENSION_361: API_Extensions;
declare const VK_EXT_EXTENSION_362_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_363_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_364_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_365_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_366_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_367_SPEC_VERSION: API_Extensions;
declare const VK_EXT_EXTENSION_368_SPEC_VERSION: API_Extensions;
declare const VK_QCOM_EXTENSION_369_SPEC_VERSION: API_Extensions;
declare const VK_HUAWEI_EXTENSION_370_SPEC_VERSION: API_Extensions;
declare const VK_HUAWEI_EXTENSION_371_SPEC_VERSION: API_Extensions;
declare const VK_NV_EXTENSION_372_SPEC_VERSION: API_Extensions;



/**
  * 
  * @member VK_MAX_PHYSICAL_DEVICE_NAME_SIZE
  * @member VK_UUID_SIZE
  * @member VK_LUID_SIZE
  * @member VK_LUID_SIZE_KHR
  * @member VK_MAX_EXTENSION_NAME_SIZE
  * @member VK_MAX_DESCRIPTION_SIZE
  * @member VK_MAX_MEMORY_TYPES
  * @member VK_MAX_MEMORY_HEAPS
  * @member VK_LOD_CLAMP_NONE
  * @member VK_REMAINING_MIP_LEVELS
  * @member VK_REMAINING_ARRAY_LAYERS
  * @member VK_WHOLE_SIZE
  * @member VK_ATTACHMENT_UNUSED
  * @member VK_TRUE
  * @member VK_FALSE
  * @member VK_QUEUE_FAMILY_IGNORED
  * @member VK_QUEUE_FAMILY_EXTERNAL
  * @member VK_QUEUE_FAMILY_EXTERNAL_KHR
  * @member VK_QUEUE_FAMILY_FOREIGN_EXT
  * @member VK_SUBPASS_EXTERNAL
  * @member VK_MAX_DEVICE_GROUP_SIZE
  * @member VK_MAX_DEVICE_GROUP_SIZE_KHR
  * @member VK_MAX_DRIVER_NAME_SIZE
  * @member VK_MAX_DRIVER_NAME_SIZE_KHR
  * @member VK_MAX_DRIVER_INFO_SIZE
  * @member VK_MAX_DRIVER_INFO_SIZE_KHR
  * @member VK_SHADER_UNUSED_KHR
  * @member VK_SHADER_UNUSED_NV
  * @member VK_NULL_HANDLE
  */
export enum API_Constants {
  VK_MAX_PHYSICAL_DEVICE_NAME_SIZE,
  VK_UUID_SIZE,
  VK_LUID_SIZE,
  VK_LUID_SIZE_KHR,
  VK_MAX_EXTENSION_NAME_SIZE,
  VK_MAX_DESCRIPTION_SIZE,
  VK_MAX_MEMORY_TYPES,
  VK_MAX_MEMORY_HEAPS,
  VK_LOD_CLAMP_NONE,
  VK_REMAINING_MIP_LEVELS,
  VK_REMAINING_ARRAY_LAYERS,
  VK_WHOLE_SIZE,
  VK_ATTACHMENT_UNUSED,
  VK_TRUE,
  VK_FALSE,
  VK_QUEUE_FAMILY_IGNORED,
  VK_QUEUE_FAMILY_EXTERNAL,
  VK_QUEUE_FAMILY_EXTERNAL_KHR,
  VK_QUEUE_FAMILY_FOREIGN_EXT,
  VK_SUBPASS_EXTERNAL,
  VK_MAX_DEVICE_GROUP_SIZE,
  VK_MAX_DEVICE_GROUP_SIZE_KHR,
  VK_MAX_DRIVER_NAME_SIZE,
  VK_MAX_DRIVER_NAME_SIZE_KHR,
  VK_MAX_DRIVER_INFO_SIZE,
  VK_MAX_DRIVER_INFO_SIZE_KHR,
  VK_SHADER_UNUSED_KHR,
  VK_SHADER_UNUSED_NV,
  VK_NULL_HANDLE,
  
}

declare const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE: API_Constants;
declare const VK_UUID_SIZE: API_Constants;
declare const VK_LUID_SIZE: API_Constants;
declare const VK_LUID_SIZE_KHR: API_Constants;
declare const VK_MAX_EXTENSION_NAME_SIZE: API_Constants;
declare const VK_MAX_DESCRIPTION_SIZE: API_Constants;
declare const VK_MAX_MEMORY_TYPES: API_Constants;
declare const VK_MAX_MEMORY_HEAPS: API_Constants;
declare const VK_LOD_CLAMP_NONE: API_Constants;
declare const VK_REMAINING_MIP_LEVELS: API_Constants;
declare const VK_REMAINING_ARRAY_LAYERS: API_Constants;
declare const VK_WHOLE_SIZE: API_Constants;
declare const VK_ATTACHMENT_UNUSED: API_Constants;
declare const VK_TRUE: API_Constants;
declare const VK_FALSE: API_Constants;
declare const VK_QUEUE_FAMILY_IGNORED: API_Constants;
declare const VK_QUEUE_FAMILY_EXTERNAL: API_Constants;
declare const VK_QUEUE_FAMILY_EXTERNAL_KHR: API_Constants;
declare const VK_QUEUE_FAMILY_FOREIGN_EXT: API_Constants;
declare const VK_SUBPASS_EXTERNAL: API_Constants;
declare const VK_MAX_DEVICE_GROUP_SIZE: API_Constants;
declare const VK_MAX_DEVICE_GROUP_SIZE_KHR: API_Constants;
declare const VK_MAX_DRIVER_NAME_SIZE: API_Constants;
declare const VK_MAX_DRIVER_NAME_SIZE_KHR: API_Constants;
declare const VK_MAX_DRIVER_INFO_SIZE: API_Constants;
declare const VK_MAX_DRIVER_INFO_SIZE_KHR: API_Constants;
declare const VK_SHADER_UNUSED_KHR: API_Constants;
declare const VK_SHADER_UNUSED_NV: API_Constants;
declare const VK_NULL_HANDLE: API_Constants;



/**
  * Layout of image and image subresources
  * @member VK_IMAGE_LAYOUT_UNDEFINED does not support device access. This layout 'must' only be used as the 'initialLayout' member of 'VkImageCreateInfo' or 'VkAttachmentDescription', or as the 'oldLayout' in an image transition. When transitioning out of this layout, the contents of the memory are not guaranteed to be preserved.
  * @member VK_IMAGE_LAYOUT_GENERAL supports all types of device access.
  * @member VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL 'must' only be used as a color or resolve attachment in a 'VkFramebuffer'. This layout is valid only for image subresources of images created with the 'VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT' usage bit enabled.
  * @member VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL specifies a layout for both the depth and stencil aspects of a depth/stencil format image allowing read and write access as a depth/stencil attachment. It is equivalent to 'VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL' and 'VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL'.
  * @member VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL
  * @member VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
  * @member VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL
  * @member VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
  * @member VK_IMAGE_LAYOUT_PREINITIALIZED does not support device access. This layout 'must' only be used as the 'initialLayout' member of 'VkImageCreateInfo' or 'VkAttachmentDescription', or as the 'oldLayout' in an image transition. When transitioning out of this layout, the contents of the memory are preserved. This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data 'can' be written to memory immediately, without first executing a layout transition. Currently, 'VK_IMAGE_LAYOUT_PREINITIALIZED' is only useful with <<glossary-linear-resource,linear>> images because there is not a standard layout defined for 'VK_IMAGE_TILING_OPTIMAL' images.
  * @member VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL
  * @member VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL
  * @member VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL
  * @member VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL
  * @member VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL
  * @member VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL
  * @member VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
  * @member VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR
  * @member VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV
  * @member VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT
  * @member VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR
  * @member VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR
  * @member VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR
  * @member VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR
  * @member VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR
  * @member VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR
  * @member VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR
  */
export enum VkImageLayout {
  VK_IMAGE_LAYOUT_UNDEFINED,
  VK_IMAGE_LAYOUT_GENERAL,
  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
  VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
  VK_IMAGE_LAYOUT_PREINITIALIZED,
  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
  VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
  VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
  VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
  VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
  VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
  VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
  VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV,
  VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,
  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR,
  VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR,
  VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,
  VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR,
  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR,
  VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR,
  VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR,
  
}

declare const VK_IMAGE_LAYOUT_UNDEFINED: VkImageLayout;
declare const VK_IMAGE_LAYOUT_GENERAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_PREINITIALIZED: VkImageLayout;
declare const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout;
declare const VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: VkImageLayout;
declare const VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR: VkImageLayout;
declare const VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV: VkImageLayout;
declare const VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: VkImageLayout;
declare const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout;
declare const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout;
declare const VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR: VkImageLayout;
declare const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR: VkImageLayout;
declare const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR: VkImageLayout;
declare const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout;
declare const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout;



/**
  * Specify how contents of an attachment are treated at the beginning of a subpass
  * @member VK_ATTACHMENT_LOAD_OP_LOAD specifies that the previous contents of the image within the render area will be preserved. For attachments with a depth/stencil format, this uses the access type 'VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT'. For attachments with a color format, this uses the access type 'VK_ACCESS_COLOR_ATTACHMENT_READ_BIT'.
  * @member VK_ATTACHMENT_LOAD_OP_CLEAR specifies that the contents within the render area will be cleared to a uniform value, which is specified when a render pass instance is begun. For attachments with a depth/stencil format, this uses the access type 'VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT'. For attachments with a color format, this uses the access type 'VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT'.
  * @member VK_ATTACHMENT_LOAD_OP_DONT_CARE specifies that the previous contents within the area need not be preserved; the contents of the attachment will be 'undefined' inside the render area. For attachments with a depth/stencil format, this uses the access type 'VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT'. For attachments with a color format, this uses the access type 'VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT'.
  */
export enum VkAttachmentLoadOp {
  VK_ATTACHMENT_LOAD_OP_LOAD,
  VK_ATTACHMENT_LOAD_OP_CLEAR,
  VK_ATTACHMENT_LOAD_OP_DONT_CARE,
  
}

declare const VK_ATTACHMENT_LOAD_OP_LOAD: VkAttachmentLoadOp;
declare const VK_ATTACHMENT_LOAD_OP_CLEAR: VkAttachmentLoadOp;
declare const VK_ATTACHMENT_LOAD_OP_DONT_CARE: VkAttachmentLoadOp;



/**
  * Specify how contents of an attachment are treated at the end of a subpass
  * @member VK_ATTACHMENT_STORE_OP_STORE specifies the contents generated during the render pass and within the render area are written to memory. For attachments with a depth/stencil format, this uses the access type 'VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT'. For attachments with a color format, this uses the access type 'VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT'.
  * @member VK_ATTACHMENT_STORE_OP_DONT_CARE specifies the contents within the render area are not needed after rendering, and 'may' be discarded; the contents of the attachment will be 'undefined' inside the render area. For attachments with a depth/stencil format, this uses the access type 'VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT'. For attachments with a color format, this uses the access type 'VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT'.
  * @member VK_ATTACHMENT_STORE_OP_NONE_QCOM specifies that the contents within the render area were not written during rendering, and 'may' not be written to memory. If the attachment was written to during the renderpass, the contents of the attachment will be 'undefined' inside the render area.
  */
export enum VkAttachmentStoreOp {
  VK_ATTACHMENT_STORE_OP_STORE,
  VK_ATTACHMENT_STORE_OP_DONT_CARE,
  VK_ATTACHMENT_STORE_OP_NONE_QCOM,
  
}

declare const VK_ATTACHMENT_STORE_OP_STORE: VkAttachmentStoreOp;
declare const VK_ATTACHMENT_STORE_OP_DONT_CARE: VkAttachmentStoreOp;
declare const VK_ATTACHMENT_STORE_OP_NONE_QCOM: VkAttachmentStoreOp;



/**
  * Specifies the type of an image object
  * @member VK_IMAGE_TYPE_1D specifies a one-dimensional image.
  * @member VK_IMAGE_TYPE_2D specifies a two-dimensional image.
  * @member VK_IMAGE_TYPE_3D specifies a three-dimensional image.
  */
export enum VkImageType {
  VK_IMAGE_TYPE_1D,
  VK_IMAGE_TYPE_2D,
  VK_IMAGE_TYPE_3D,
  
}

declare const VK_IMAGE_TYPE_1D: VkImageType;
declare const VK_IMAGE_TYPE_2D: VkImageType;
declare const VK_IMAGE_TYPE_3D: VkImageType;



/**
  * Specifies the tiling arrangement of data in an image
  * @member VK_IMAGE_TILING_OPTIMAL specifies optimal tiling (texels are laid out in an implementation-dependent arrangement, for more optimal memory access).
  * @member VK_IMAGE_TILING_LINEAR specifies linear tiling (texels are laid out in memory in row-major order, possibly with some padding on each row).
  * @member VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT indicates that the image's tiling is defined by a <<glossary-drm-format-modifier,Linux DRM format modifier>>. The modifier is specified at image creation with 'VkImageDrmFormatModifierListCreateInfoEXT' or 'VkImageDrmFormatModifierExplicitCreateInfoEXT', and 'can' be queried with 'vkGetImageDrmFormatModifierPropertiesEXT'.
  */
export enum VkImageTiling {
  VK_IMAGE_TILING_OPTIMAL,
  VK_IMAGE_TILING_LINEAR,
  VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
  
}

declare const VK_IMAGE_TILING_OPTIMAL: VkImageTiling;
declare const VK_IMAGE_TILING_LINEAR: VkImageTiling;
declare const VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT: VkImageTiling;



/**
  * Image view types
  * @member VK_IMAGE_VIEW_TYPE_1D
  * @member VK_IMAGE_VIEW_TYPE_2D
  * @member VK_IMAGE_VIEW_TYPE_3D
  * @member VK_IMAGE_VIEW_TYPE_CUBE
  * @member VK_IMAGE_VIEW_TYPE_1D_ARRAY
  * @member VK_IMAGE_VIEW_TYPE_2D_ARRAY
  * @member VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
  */
export enum VkImageViewType {
  VK_IMAGE_VIEW_TYPE_1D,
  VK_IMAGE_VIEW_TYPE_2D,
  VK_IMAGE_VIEW_TYPE_3D,
  VK_IMAGE_VIEW_TYPE_CUBE,
  VK_IMAGE_VIEW_TYPE_1D_ARRAY,
  VK_IMAGE_VIEW_TYPE_2D_ARRAY,
  VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
  
}

declare const VK_IMAGE_VIEW_TYPE_1D: VkImageViewType;
declare const VK_IMAGE_VIEW_TYPE_2D: VkImageViewType;
declare const VK_IMAGE_VIEW_TYPE_3D: VkImageViewType;
declare const VK_IMAGE_VIEW_TYPE_CUBE: VkImageViewType;
declare const VK_IMAGE_VIEW_TYPE_1D_ARRAY: VkImageViewType;
declare const VK_IMAGE_VIEW_TYPE_2D_ARRAY: VkImageViewType;
declare const VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: VkImageViewType;



/**
  * Enumerant specifying a command buffer level
  * @member VK_COMMAND_BUFFER_LEVEL_PRIMARY specifies a primary command buffer.
  * @member VK_COMMAND_BUFFER_LEVEL_SECONDARY specifies a secondary command buffer.
  */
export enum VkCommandBufferLevel {
  VK_COMMAND_BUFFER_LEVEL_PRIMARY,
  VK_COMMAND_BUFFER_LEVEL_SECONDARY,
  
}

declare const VK_COMMAND_BUFFER_LEVEL_PRIMARY: VkCommandBufferLevel;
declare const VK_COMMAND_BUFFER_LEVEL_SECONDARY: VkCommandBufferLevel;



/**
  * Specify how a component is swizzled
  * @member VK_COMPONENT_SWIZZLE_IDENTITY specifies that the component is set to the identity swizzle.
  * @member VK_COMPONENT_SWIZZLE_ZERO specifies that the component is set to zero.
  * @member VK_COMPONENT_SWIZZLE_ONE specifies that the component is set to either 1 or 1.0, depending on whether the type of the image view format is integer or floating-point respectively, as determined by the <<formats-definition,Format Definition>> section for each 'VkFormat'.
  * @member VK_COMPONENT_SWIZZLE_R specifies that the component is set to the value of the R component of the image.
  * @member VK_COMPONENT_SWIZZLE_G specifies that the component is set to the value of the G component of the image.
  * @member VK_COMPONENT_SWIZZLE_B specifies that the component is set to the value of the B component of the image.
  * @member VK_COMPONENT_SWIZZLE_A specifies that the component is set to the value of the A component of the image.
  */
export enum VkComponentSwizzle {
  VK_COMPONENT_SWIZZLE_IDENTITY,
  VK_COMPONENT_SWIZZLE_ZERO,
  VK_COMPONENT_SWIZZLE_ONE,
  VK_COMPONENT_SWIZZLE_R,
  VK_COMPONENT_SWIZZLE_G,
  VK_COMPONENT_SWIZZLE_B,
  VK_COMPONENT_SWIZZLE_A,
  
}

declare const VK_COMPONENT_SWIZZLE_IDENTITY: VkComponentSwizzle;
declare const VK_COMPONENT_SWIZZLE_ZERO: VkComponentSwizzle;
declare const VK_COMPONENT_SWIZZLE_ONE: VkComponentSwizzle;
declare const VK_COMPONENT_SWIZZLE_R: VkComponentSwizzle;
declare const VK_COMPONENT_SWIZZLE_G: VkComponentSwizzle;
declare const VK_COMPONENT_SWIZZLE_B: VkComponentSwizzle;
declare const VK_COMPONENT_SWIZZLE_A: VkComponentSwizzle;



/**
  * Specifies the type of a descriptor in a descriptor set
  * @member VK_DESCRIPTOR_TYPE_SAMPLER specifies a <<descriptorsets-sampler, sampler descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER specifies a <<descriptorsets-combinedimagesampler, combined image sampler descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE specifies a <<descriptorsets-sampledimage, sampled image descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_STORAGE_IMAGE specifies a <<descriptorsets-storageimage, storage image descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER specifies a <<descriptorsets-uniformtexelbuffer, uniform texel buffer descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER specifies a <<descriptorsets-storagetexelbuffer, storage texel buffer descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER specifies a <<descriptorsets-uniformbuffer, uniform buffer descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_STORAGE_BUFFER specifies a <<descriptorsets-storagebuffer, storage buffer descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC specifies a <<descriptorsets-uniformbufferdynamic, dynamic uniform buffer descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC specifies a <<descriptorsets-storagebufferdynamic, dynamic storage buffer descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT specifies an <<descriptorsets-inputattachment, input attachment descriptor>>.
  * @member VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT specifies an <<descriptorsets-inlineuniformblock, inline uniform block>>.
  * @member VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR
  * @member VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV
  */
export enum VkDescriptorType {
  VK_DESCRIPTOR_TYPE_SAMPLER,
  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
  VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
  VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
  VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
  VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
  VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
  VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT,
  VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,
  VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV,
  
}

declare const VK_DESCRIPTOR_TYPE_SAMPLER: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR: VkDescriptorType;
declare const VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV: VkDescriptorType;



/**
  * Specify the type of queries managed by a query pool
  * @member VK_QUERY_TYPE_OCCLUSION specifies an <<queries-occlusion, occlusion query>>.
  * @member VK_QUERY_TYPE_PIPELINE_STATISTICS specifies a <<queries-pipestats, pipeline statistics query>>.
  * @member VK_QUERY_TYPE_TIMESTAMP specifies a <<queries-timestamps, timestamp query>>.
  * @member VK_QUERY_TYPE_RESERVED_8
  * @member VK_QUERY_TYPE_RESERVED_4
  * @member VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT
  * @member VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR specifies a <<queries-performance, performance query>>.
  * @member VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR
  * @member VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR
  * @member VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV
  * @member VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL
  */
export enum VkQueryType {
  VK_QUERY_TYPE_OCCLUSION,
  VK_QUERY_TYPE_PIPELINE_STATISTICS,
  VK_QUERY_TYPE_TIMESTAMP,
  VK_QUERY_TYPE_RESERVED_8,
  VK_QUERY_TYPE_RESERVED_4,
  VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT,
  VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV,
  VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL,
  
}

declare const VK_QUERY_TYPE_OCCLUSION: VkQueryType;
declare const VK_QUERY_TYPE_PIPELINE_STATISTICS: VkQueryType;
declare const VK_QUERY_TYPE_TIMESTAMP: VkQueryType;
declare const VK_QUERY_TYPE_RESERVED_8: VkQueryType;
declare const VK_QUERY_TYPE_RESERVED_4: VkQueryType;
declare const VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT: VkQueryType;
declare const VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR: VkQueryType;
declare const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR: VkQueryType;
declare const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR: VkQueryType;
declare const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV: VkQueryType;
declare const VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL: VkQueryType;



/**
  * Specify border color used for texture lookups
  * @member VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK specifies a transparent, floating-point format, black color.
  * @member VK_BORDER_COLOR_INT_TRANSPARENT_BLACK specifies a transparent, integer format, black color.
  * @member VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK specifies an opaque, floating-point format, black color.
  * @member VK_BORDER_COLOR_INT_OPAQUE_BLACK specifies an opaque, integer format, black color.
  * @member VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE specifies an opaque, floating-point format, white color.
  * @member VK_BORDER_COLOR_INT_OPAQUE_WHITE specifies an opaque, integer format, white color.
  * @member VK_BORDER_COLOR_FLOAT_CUSTOM_EXT indicates that a 'VkSamplerCustomBorderColorCreateInfoEXT' structure is present in the 'VkSamplerCreateInfo'::'pNext' chain which contains the color data in floating-point format.
  * @member VK_BORDER_COLOR_INT_CUSTOM_EXT indicates that a 'VkSamplerCustomBorderColorCreateInfoEXT' structure is present in the 'VkSamplerCreateInfo'::'pNext' chain which contains the color data in integer format.
  */
export enum VkBorderColor {
  VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
  VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
  VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
  VK_BORDER_COLOR_INT_OPAQUE_BLACK,
  VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
  VK_BORDER_COLOR_INT_OPAQUE_WHITE,
  VK_BORDER_COLOR_FLOAT_CUSTOM_EXT,
  VK_BORDER_COLOR_INT_CUSTOM_EXT,
  
}

declare const VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK: VkBorderColor;
declare const VK_BORDER_COLOR_INT_TRANSPARENT_BLACK: VkBorderColor;
declare const VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK: VkBorderColor;
declare const VK_BORDER_COLOR_INT_OPAQUE_BLACK: VkBorderColor;
declare const VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE: VkBorderColor;
declare const VK_BORDER_COLOR_INT_OPAQUE_WHITE: VkBorderColor;
declare const VK_BORDER_COLOR_FLOAT_CUSTOM_EXT: VkBorderColor;
declare const VK_BORDER_COLOR_INT_CUSTOM_EXT: VkBorderColor;



/**
  * Specify the bind point of a pipeline object to a command buffer
  * @member VK_PIPELINE_BIND_POINT_GRAPHICS specifies binding as a graphics pipeline.
  * @member VK_PIPELINE_BIND_POINT_COMPUTE specifies binding as a compute pipeline.
  * @member VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR specifies binding as a ray tracing pipeline.
  * @member VK_PIPELINE_BIND_POINT_RAY_TRACING_NV
  */
export enum VkPipelineBindPoint {
  VK_PIPELINE_BIND_POINT_GRAPHICS,
  VK_PIPELINE_BIND_POINT_COMPUTE,
  VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
  VK_PIPELINE_BIND_POINT_RAY_TRACING_NV,
  
}

declare const VK_PIPELINE_BIND_POINT_GRAPHICS: VkPipelineBindPoint;
declare const VK_PIPELINE_BIND_POINT_COMPUTE: VkPipelineBindPoint;
declare const VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR: VkPipelineBindPoint;
declare const VK_PIPELINE_BIND_POINT_RAY_TRACING_NV: VkPipelineBindPoint;



/**
  * Encode pipeline cache version
  * @member VK_PIPELINE_CACHE_HEADER_VERSION_ONE
  */
export enum VkPipelineCacheHeaderVersion {
  VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
  
}

declare const VK_PIPELINE_CACHE_HEADER_VERSION_ONE: VkPipelineCacheHeaderVersion;



/**
  * Supported primitive topologies
  * @member VK_PRIMITIVE_TOPOLOGY_POINT_LIST specifies a series of <<drawing-point-lists,separate point primitives>>.
  * @member VK_PRIMITIVE_TOPOLOGY_LINE_LIST specifies a series of <<drawing-line-lists,separate line primitives>>.
  * @member VK_PRIMITIVE_TOPOLOGY_LINE_STRIP specifies a series of <<drawing-line-strips,connected line primitives>> with consecutive lines sharing a vertex.
  * @member VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST specifies a series of <<drawing-triangle-lists,separate triangle primitives>>.
  * @member VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP specifies a series of <<drawing-triangle-strips,connected triangle primitives>> with consecutive triangles sharing an edge.
  * @member VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN specifies a series of <<drawing-triangle-fans,connected triangle primitives>> with all triangles sharing a common vertex. If the `<<VK_KHR_portability_subset>>` extension is enabled, and 'VkPhysicalDevicePortabilitySubsetFeaturesKHR'::'triangleFans' is 'VK_FALSE', then triangle fans are not supported by the implementation, and 'VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN' 'must' not be used.
  * @member VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY
  * @member VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY
  * @member VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY
  * @member VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY
  * @member VK_PRIMITIVE_TOPOLOGY_PATCH_LIST
  */
export enum VkPrimitiveTopology {
  VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
  VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
  
}

declare const VK_PRIMITIVE_TOPOLOGY_POINT_LIST: VkPrimitiveTopology;
declare const VK_PRIMITIVE_TOPOLOGY_LINE_LIST: VkPrimitiveTopology;
declare const VK_PRIMITIVE_TOPOLOGY_LINE_STRIP: VkPrimitiveTopology;
declare const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST: VkPrimitiveTopology;
declare const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP: VkPrimitiveTopology;
declare const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN: VkPrimitiveTopology;
declare const VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY: VkPrimitiveTopology;
declare const VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY: VkPrimitiveTopology;
declare const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY: VkPrimitiveTopology;
declare const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY: VkPrimitiveTopology;
declare const VK_PRIMITIVE_TOPOLOGY_PATCH_LIST: VkPrimitiveTopology;



/**
  * Buffer and image sharing modes
  * @member VK_SHARING_MODE_EXCLUSIVE specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time.
  * @member VK_SHARING_MODE_CONCURRENT specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported.
  */
export enum VkSharingMode {
  VK_SHARING_MODE_EXCLUSIVE,
  VK_SHARING_MODE_CONCURRENT,
  
}

declare const VK_SHARING_MODE_EXCLUSIVE: VkSharingMode;
declare const VK_SHARING_MODE_CONCURRENT: VkSharingMode;



/**
  * Type of index buffer indices
  * @member VK_INDEX_TYPE_UINT16 specifies that indices are 16-bit unsigned integer values.
  * @member VK_INDEX_TYPE_UINT32 specifies that indices are 32-bit unsigned integer values.
  * @member VK_INDEX_TYPE_NONE_KHR specifies that no indices are provided.
  * @member VK_INDEX_TYPE_UINT8_EXT
  * @member VK_INDEX_TYPE_NONE_NV
  */
export enum VkIndexType {
  VK_INDEX_TYPE_UINT16,
  VK_INDEX_TYPE_UINT32,
  VK_INDEX_TYPE_NONE_KHR,
  VK_INDEX_TYPE_UINT8_EXT,
  VK_INDEX_TYPE_NONE_NV,
  
}

declare const VK_INDEX_TYPE_UINT16: VkIndexType;
declare const VK_INDEX_TYPE_UINT32: VkIndexType;
declare const VK_INDEX_TYPE_NONE_KHR: VkIndexType;
declare const VK_INDEX_TYPE_UINT8_EXT: VkIndexType;
declare const VK_INDEX_TYPE_NONE_NV: VkIndexType;



/**
  * Specify filters used for texture lookups
  * @member VK_FILTER_NEAREST specifies nearest filtering.
  * @member VK_FILTER_LINEAR specifies linear filtering.
  * @member VK_FILTER_CUBIC_IMG
  * @member VK_FILTER_CUBIC_EXT
  */
export enum VkFilter {
  VK_FILTER_NEAREST,
  VK_FILTER_LINEAR,
  VK_FILTER_CUBIC_IMG,
  VK_FILTER_CUBIC_EXT,
  
}

declare const VK_FILTER_NEAREST: VkFilter;
declare const VK_FILTER_LINEAR: VkFilter;
declare const VK_FILTER_CUBIC_IMG: VkFilter;
declare const VK_FILTER_CUBIC_EXT: VkFilter;



/**
  * Specify mipmap mode used for texture lookups
  * @member VK_SAMPLER_MIPMAP_MODE_NEAREST specifies nearest filtering.
  * @member VK_SAMPLER_MIPMAP_MODE_LINEAR specifies linear filtering.
  */
export enum VkSamplerMipmapMode {
  VK_SAMPLER_MIPMAP_MODE_NEAREST,
  VK_SAMPLER_MIPMAP_MODE_LINEAR,
  
}

declare const VK_SAMPLER_MIPMAP_MODE_NEAREST: VkSamplerMipmapMode;
declare const VK_SAMPLER_MIPMAP_MODE_LINEAR: VkSamplerMipmapMode;



/**
  * Specify behavior of sampling with texture coordinates outside an image
  * @member VK_SAMPLER_ADDRESS_MODE_REPEAT specifies that the repeat wrap mode will be used.
  * @member VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT specifies that the mirrored repeat wrap mode will be used.
  * @member VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE specifies that the clamp to edge wrap mode will be used.
  * @member VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER specifies that the clamp to border wrap mode will be used.
  * @member VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE specifies that the mirror clamp to edge wrap mode will be used. This is only valid ififdef::VK_VERSION_1_2[<<features-samplerMirrorClampToEdge,samplerMirrorClampToEdge>> is enabled, or if] the `<<VK_KHR_sampler_mirror_clamp_to_edge>>` extension is enabled.
  * @member VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR
  */
export enum VkSamplerAddressMode {
  VK_SAMPLER_ADDRESS_MODE_REPEAT,
  VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
  VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
  VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR,
  
}

declare const VK_SAMPLER_ADDRESS_MODE_REPEAT: VkSamplerAddressMode;
declare const VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT: VkSamplerAddressMode;
declare const VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE: VkSamplerAddressMode;
declare const VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: VkSamplerAddressMode;
declare const VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE: VkSamplerAddressMode;
declare const VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR: VkSamplerAddressMode;



/**
  * Stencil comparison function
  * @member VK_COMPARE_OP_NEVER
  * @member VK_COMPARE_OP_LESS
  * @member VK_COMPARE_OP_EQUAL
  * @member VK_COMPARE_OP_LESS_OR_EQUAL
  * @member VK_COMPARE_OP_GREATER
  * @member VK_COMPARE_OP_NOT_EQUAL
  * @member VK_COMPARE_OP_GREATER_OR_EQUAL
  * @member VK_COMPARE_OP_ALWAYS specifies that the test evaluates to true.
  */
export enum VkCompareOp {
  VK_COMPARE_OP_NEVER,
  VK_COMPARE_OP_LESS,
  VK_COMPARE_OP_EQUAL,
  VK_COMPARE_OP_LESS_OR_EQUAL,
  VK_COMPARE_OP_GREATER,
  VK_COMPARE_OP_NOT_EQUAL,
  VK_COMPARE_OP_GREATER_OR_EQUAL,
  VK_COMPARE_OP_ALWAYS,
  
}

declare const VK_COMPARE_OP_NEVER: VkCompareOp;
declare const VK_COMPARE_OP_LESS: VkCompareOp;
declare const VK_COMPARE_OP_EQUAL: VkCompareOp;
declare const VK_COMPARE_OP_LESS_OR_EQUAL: VkCompareOp;
declare const VK_COMPARE_OP_GREATER: VkCompareOp;
declare const VK_COMPARE_OP_NOT_EQUAL: VkCompareOp;
declare const VK_COMPARE_OP_GREATER_OR_EQUAL: VkCompareOp;
declare const VK_COMPARE_OP_ALWAYS: VkCompareOp;



/**
  * Control polygon rasterization mode
  * @member VK_POLYGON_MODE_FILL specifies that polygons are rendered using the polygon rasterization rules in this section.
  * @member VK_POLYGON_MODE_LINE specifies that polygon edges are drawn as line segments.
  * @member VK_POLYGON_MODE_POINT specifies that polygon vertices are drawn as reference.
  * @member VK_POLYGON_MODE_FILL_RECTANGLE_NV specifies that polygons are rendered using polygon rasterization rules, modified to consider a sample within the primitive if the sample location is inside the axis-aligned bounding box of the triangle after projection. Note that the barycentric weights used in attribute interpolation 'can' extend outside the range [eq]#[0,1]# when these primitives are shaded. Special treatment is given to a sample position on the boundary edge of the bounding box. In such a case, if two rectangles lie on either side of a common edge (with identical endreference) on which a sample position lies, then exactly one of the triangles 'must' produce a fragment that covers that sample during rasterization.+Polygons rendered in 'VK_POLYGON_MODE_FILL_RECTANGLE_NV' mode 'may' be clipped by the frustum or by user clip planes. If clipping is applied, the triangle is culled rather than clipped.+Area calculation and facingness are determined for 'VK_POLYGON_MODE_FILL_RECTANGLE_NV' mode using the triangle's vertices.
  */
export enum VkPolygonMode {
  VK_POLYGON_MODE_FILL,
  VK_POLYGON_MODE_LINE,
  VK_POLYGON_MODE_POINT,
  VK_POLYGON_MODE_FILL_RECTANGLE_NV,
  
}

declare const VK_POLYGON_MODE_FILL: VkPolygonMode;
declare const VK_POLYGON_MODE_LINE: VkPolygonMode;
declare const VK_POLYGON_MODE_POINT: VkPolygonMode;
declare const VK_POLYGON_MODE_FILL_RECTANGLE_NV: VkPolygonMode;



/**
  * Interpret polygon front-facing orientation
  * @member VK_FRONT_FACE_COUNTER_CLOCKWISE specifies that a triangle with positive area is considered front-facing.
  * @member VK_FRONT_FACE_CLOCKWISE specifies that a triangle with negative area is considered front-facing.
  */
export enum VkFrontFace {
  VK_FRONT_FACE_COUNTER_CLOCKWISE,
  VK_FRONT_FACE_CLOCKWISE,
  
}

declare const VK_FRONT_FACE_COUNTER_CLOCKWISE: VkFrontFace;
declare const VK_FRONT_FACE_CLOCKWISE: VkFrontFace;



/**
  * Framebuffer blending factors
  * @member VK_BLEND_FACTOR_ZERO
  * @member VK_BLEND_FACTOR_ONE
  * @member VK_BLEND_FACTOR_SRC_COLOR
  * @member VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR
  * @member VK_BLEND_FACTOR_DST_COLOR
  * @member VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR
  * @member VK_BLEND_FACTOR_SRC_ALPHA
  * @member VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA
  * @member VK_BLEND_FACTOR_DST_ALPHA
  * @member VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA
  * @member VK_BLEND_FACTOR_CONSTANT_COLOR
  * @member VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR
  * @member VK_BLEND_FACTOR_CONSTANT_ALPHA
  * @member VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA
  * @member VK_BLEND_FACTOR_SRC_ALPHA_SATURATE
  * @member VK_BLEND_FACTOR_SRC1_COLOR
  * @member VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR
  * @member VK_BLEND_FACTOR_SRC1_ALPHA
  * @member VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA
  */
export enum VkBlendFactor {
  VK_BLEND_FACTOR_ZERO,
  VK_BLEND_FACTOR_ONE,
  VK_BLEND_FACTOR_SRC_COLOR,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
  VK_BLEND_FACTOR_DST_COLOR,
  VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
  VK_BLEND_FACTOR_SRC_ALPHA,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
  VK_BLEND_FACTOR_DST_ALPHA,
  VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
  VK_BLEND_FACTOR_CONSTANT_COLOR,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
  VK_BLEND_FACTOR_CONSTANT_ALPHA,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
  VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
  VK_BLEND_FACTOR_SRC1_COLOR,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
  VK_BLEND_FACTOR_SRC1_ALPHA,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
  
}

declare const VK_BLEND_FACTOR_ZERO: VkBlendFactor;
declare const VK_BLEND_FACTOR_ONE: VkBlendFactor;
declare const VK_BLEND_FACTOR_SRC_COLOR: VkBlendFactor;
declare const VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR: VkBlendFactor;
declare const VK_BLEND_FACTOR_DST_COLOR: VkBlendFactor;
declare const VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR: VkBlendFactor;
declare const VK_BLEND_FACTOR_SRC_ALPHA: VkBlendFactor;
declare const VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA: VkBlendFactor;
declare const VK_BLEND_FACTOR_DST_ALPHA: VkBlendFactor;
declare const VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA: VkBlendFactor;
declare const VK_BLEND_FACTOR_CONSTANT_COLOR: VkBlendFactor;
declare const VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR: VkBlendFactor;
declare const VK_BLEND_FACTOR_CONSTANT_ALPHA: VkBlendFactor;
declare const VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA: VkBlendFactor;
declare const VK_BLEND_FACTOR_SRC_ALPHA_SATURATE: VkBlendFactor;
declare const VK_BLEND_FACTOR_SRC1_COLOR: VkBlendFactor;
declare const VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR: VkBlendFactor;
declare const VK_BLEND_FACTOR_SRC1_ALPHA: VkBlendFactor;
declare const VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA: VkBlendFactor;



/**
  * Framebuffer blending operations
  * @member VK_BLEND_OP_ADD
  * @member VK_BLEND_OP_SUBTRACT
  * @member VK_BLEND_OP_REVERSE_SUBTRACT
  * @member VK_BLEND_OP_MIN
  * @member VK_BLEND_OP_MAX
  * @member VK_BLEND_OP_ZERO_EXT
  * @member VK_BLEND_OP_SRC_EXT
  * @member VK_BLEND_OP_DST_EXT
  * @member VK_BLEND_OP_SRC_OVER_EXT
  * @member VK_BLEND_OP_DST_OVER_EXT
  * @member VK_BLEND_OP_SRC_IN_EXT
  * @member VK_BLEND_OP_DST_IN_EXT
  * @member VK_BLEND_OP_SRC_OUT_EXT
  * @member VK_BLEND_OP_DST_OUT_EXT
  * @member VK_BLEND_OP_SRC_ATOP_EXT
  * @member VK_BLEND_OP_DST_ATOP_EXT
  * @member VK_BLEND_OP_XOR_EXT
  * @member VK_BLEND_OP_MULTIPLY_EXT
  * @member VK_BLEND_OP_SCREEN_EXT
  * @member VK_BLEND_OP_OVERLAY_EXT
  * @member VK_BLEND_OP_DARKEN_EXT
  * @member VK_BLEND_OP_LIGHTEN_EXT
  * @member VK_BLEND_OP_COLORDODGE_EXT
  * @member VK_BLEND_OP_COLORBURN_EXT
  * @member VK_BLEND_OP_HARDLIGHT_EXT
  * @member VK_BLEND_OP_SOFTLIGHT_EXT
  * @member VK_BLEND_OP_DIFFERENCE_EXT
  * @member VK_BLEND_OP_EXCLUSION_EXT
  * @member VK_BLEND_OP_INVERT_EXT
  * @member VK_BLEND_OP_INVERT_RGB_EXT
  * @member VK_BLEND_OP_LINEARDODGE_EXT
  * @member VK_BLEND_OP_LINEARBURN_EXT
  * @member VK_BLEND_OP_VIVIDLIGHT_EXT
  * @member VK_BLEND_OP_LINEARLIGHT_EXT
  * @member VK_BLEND_OP_PINLIGHT_EXT
  * @member VK_BLEND_OP_HARDMIX_EXT
  * @member VK_BLEND_OP_HSL_HUE_EXT
  * @member VK_BLEND_OP_HSL_SATURATION_EXT
  * @member VK_BLEND_OP_HSL_COLOR_EXT
  * @member VK_BLEND_OP_HSL_LUMINOSITY_EXT
  * @member VK_BLEND_OP_PLUS_EXT
  * @member VK_BLEND_OP_PLUS_CLAMPED_EXT
  * @member VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT
  * @member VK_BLEND_OP_PLUS_DARKER_EXT
  * @member VK_BLEND_OP_MINUS_EXT
  * @member VK_BLEND_OP_MINUS_CLAMPED_EXT
  * @member VK_BLEND_OP_CONTRAST_EXT
  * @member VK_BLEND_OP_INVERT_OVG_EXT
  * @member VK_BLEND_OP_RED_EXT
  * @member VK_BLEND_OP_GREEN_EXT
  * @member VK_BLEND_OP_BLUE_EXT
  */
export enum VkBlendOp {
  VK_BLEND_OP_ADD,
  VK_BLEND_OP_SUBTRACT,
  VK_BLEND_OP_REVERSE_SUBTRACT,
  VK_BLEND_OP_MIN,
  VK_BLEND_OP_MAX,
  VK_BLEND_OP_ZERO_EXT,
  VK_BLEND_OP_SRC_EXT,
  VK_BLEND_OP_DST_EXT,
  VK_BLEND_OP_SRC_OVER_EXT,
  VK_BLEND_OP_DST_OVER_EXT,
  VK_BLEND_OP_SRC_IN_EXT,
  VK_BLEND_OP_DST_IN_EXT,
  VK_BLEND_OP_SRC_OUT_EXT,
  VK_BLEND_OP_DST_OUT_EXT,
  VK_BLEND_OP_SRC_ATOP_EXT,
  VK_BLEND_OP_DST_ATOP_EXT,
  VK_BLEND_OP_XOR_EXT,
  VK_BLEND_OP_MULTIPLY_EXT,
  VK_BLEND_OP_SCREEN_EXT,
  VK_BLEND_OP_OVERLAY_EXT,
  VK_BLEND_OP_DARKEN_EXT,
  VK_BLEND_OP_LIGHTEN_EXT,
  VK_BLEND_OP_COLORDODGE_EXT,
  VK_BLEND_OP_COLORBURN_EXT,
  VK_BLEND_OP_HARDLIGHT_EXT,
  VK_BLEND_OP_SOFTLIGHT_EXT,
  VK_BLEND_OP_DIFFERENCE_EXT,
  VK_BLEND_OP_EXCLUSION_EXT,
  VK_BLEND_OP_INVERT_EXT,
  VK_BLEND_OP_INVERT_RGB_EXT,
  VK_BLEND_OP_LINEARDODGE_EXT,
  VK_BLEND_OP_LINEARBURN_EXT,
  VK_BLEND_OP_VIVIDLIGHT_EXT,
  VK_BLEND_OP_LINEARLIGHT_EXT,
  VK_BLEND_OP_PINLIGHT_EXT,
  VK_BLEND_OP_HARDMIX_EXT,
  VK_BLEND_OP_HSL_HUE_EXT,
  VK_BLEND_OP_HSL_SATURATION_EXT,
  VK_BLEND_OP_HSL_COLOR_EXT,
  VK_BLEND_OP_HSL_LUMINOSITY_EXT,
  VK_BLEND_OP_PLUS_EXT,
  VK_BLEND_OP_PLUS_CLAMPED_EXT,
  VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT,
  VK_BLEND_OP_PLUS_DARKER_EXT,
  VK_BLEND_OP_MINUS_EXT,
  VK_BLEND_OP_MINUS_CLAMPED_EXT,
  VK_BLEND_OP_CONTRAST_EXT,
  VK_BLEND_OP_INVERT_OVG_EXT,
  VK_BLEND_OP_RED_EXT,
  VK_BLEND_OP_GREEN_EXT,
  VK_BLEND_OP_BLUE_EXT,
  
}

declare const VK_BLEND_OP_ADD: VkBlendOp;
declare const VK_BLEND_OP_SUBTRACT: VkBlendOp;
declare const VK_BLEND_OP_REVERSE_SUBTRACT: VkBlendOp;
declare const VK_BLEND_OP_MIN: VkBlendOp;
declare const VK_BLEND_OP_MAX: VkBlendOp;
declare const VK_BLEND_OP_ZERO_EXT: VkBlendOp;
declare const VK_BLEND_OP_SRC_EXT: VkBlendOp;
declare const VK_BLEND_OP_DST_EXT: VkBlendOp;
declare const VK_BLEND_OP_SRC_OVER_EXT: VkBlendOp;
declare const VK_BLEND_OP_DST_OVER_EXT: VkBlendOp;
declare const VK_BLEND_OP_SRC_IN_EXT: VkBlendOp;
declare const VK_BLEND_OP_DST_IN_EXT: VkBlendOp;
declare const VK_BLEND_OP_SRC_OUT_EXT: VkBlendOp;
declare const VK_BLEND_OP_DST_OUT_EXT: VkBlendOp;
declare const VK_BLEND_OP_SRC_ATOP_EXT: VkBlendOp;
declare const VK_BLEND_OP_DST_ATOP_EXT: VkBlendOp;
declare const VK_BLEND_OP_XOR_EXT: VkBlendOp;
declare const VK_BLEND_OP_MULTIPLY_EXT: VkBlendOp;
declare const VK_BLEND_OP_SCREEN_EXT: VkBlendOp;
declare const VK_BLEND_OP_OVERLAY_EXT: VkBlendOp;
declare const VK_BLEND_OP_DARKEN_EXT: VkBlendOp;
declare const VK_BLEND_OP_LIGHTEN_EXT: VkBlendOp;
declare const VK_BLEND_OP_COLORDODGE_EXT: VkBlendOp;
declare const VK_BLEND_OP_COLORBURN_EXT: VkBlendOp;
declare const VK_BLEND_OP_HARDLIGHT_EXT: VkBlendOp;
declare const VK_BLEND_OP_SOFTLIGHT_EXT: VkBlendOp;
declare const VK_BLEND_OP_DIFFERENCE_EXT: VkBlendOp;
declare const VK_BLEND_OP_EXCLUSION_EXT: VkBlendOp;
declare const VK_BLEND_OP_INVERT_EXT: VkBlendOp;
declare const VK_BLEND_OP_INVERT_RGB_EXT: VkBlendOp;
declare const VK_BLEND_OP_LINEARDODGE_EXT: VkBlendOp;
declare const VK_BLEND_OP_LINEARBURN_EXT: VkBlendOp;
declare const VK_BLEND_OP_VIVIDLIGHT_EXT: VkBlendOp;
declare const VK_BLEND_OP_LINEARLIGHT_EXT: VkBlendOp;
declare const VK_BLEND_OP_PINLIGHT_EXT: VkBlendOp;
declare const VK_BLEND_OP_HARDMIX_EXT: VkBlendOp;
declare const VK_BLEND_OP_HSL_HUE_EXT: VkBlendOp;
declare const VK_BLEND_OP_HSL_SATURATION_EXT: VkBlendOp;
declare const VK_BLEND_OP_HSL_COLOR_EXT: VkBlendOp;
declare const VK_BLEND_OP_HSL_LUMINOSITY_EXT: VkBlendOp;
declare const VK_BLEND_OP_PLUS_EXT: VkBlendOp;
declare const VK_BLEND_OP_PLUS_CLAMPED_EXT: VkBlendOp;
declare const VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT: VkBlendOp;
declare const VK_BLEND_OP_PLUS_DARKER_EXT: VkBlendOp;
declare const VK_BLEND_OP_MINUS_EXT: VkBlendOp;
declare const VK_BLEND_OP_MINUS_CLAMPED_EXT: VkBlendOp;
declare const VK_BLEND_OP_CONTRAST_EXT: VkBlendOp;
declare const VK_BLEND_OP_INVERT_OVG_EXT: VkBlendOp;
declare const VK_BLEND_OP_RED_EXT: VkBlendOp;
declare const VK_BLEND_OP_GREEN_EXT: VkBlendOp;
declare const VK_BLEND_OP_BLUE_EXT: VkBlendOp;



/**
  * Stencil comparison function
  * @member VK_STENCIL_OP_KEEP keeps the current value.
  * @member VK_STENCIL_OP_ZERO sets the value to 0.
  * @member VK_STENCIL_OP_REPLACE
  * @member VK_STENCIL_OP_INCREMENT_AND_CLAMP increments the current value and clamps to the maximum representable unsigned value.
  * @member VK_STENCIL_OP_DECREMENT_AND_CLAMP decrements the current value and clamps to 0.
  * @member VK_STENCIL_OP_INVERT bitwise-inverts the current value.
  * @member VK_STENCIL_OP_INCREMENT_AND_WRAP increments the current value and wraps to 0 when the maximum value would have been exceeded.
  * @member VK_STENCIL_OP_DECREMENT_AND_WRAP decrements the current value and wraps to the maximum possible value when the value would go below 0.
  */
export enum VkStencilOp {
  VK_STENCIL_OP_KEEP,
  VK_STENCIL_OP_ZERO,
  VK_STENCIL_OP_REPLACE,
  VK_STENCIL_OP_INCREMENT_AND_CLAMP,
  VK_STENCIL_OP_DECREMENT_AND_CLAMP,
  VK_STENCIL_OP_INVERT,
  VK_STENCIL_OP_INCREMENT_AND_WRAP,
  VK_STENCIL_OP_DECREMENT_AND_WRAP,
  
}

declare const VK_STENCIL_OP_KEEP: VkStencilOp;
declare const VK_STENCIL_OP_ZERO: VkStencilOp;
declare const VK_STENCIL_OP_REPLACE: VkStencilOp;
declare const VK_STENCIL_OP_INCREMENT_AND_CLAMP: VkStencilOp;
declare const VK_STENCIL_OP_DECREMENT_AND_CLAMP: VkStencilOp;
declare const VK_STENCIL_OP_INVERT: VkStencilOp;
declare const VK_STENCIL_OP_INCREMENT_AND_WRAP: VkStencilOp;
declare const VK_STENCIL_OP_DECREMENT_AND_WRAP: VkStencilOp;



/**
  * Framebuffer logical operations
  * @member VK_LOGIC_OP_CLEAR
  * @member VK_LOGIC_OP_AND
  * @member VK_LOGIC_OP_AND_REVERSE
  * @member VK_LOGIC_OP_COPY
  * @member VK_LOGIC_OP_AND_INVERTED
  * @member VK_LOGIC_OP_NO_OP
  * @member VK_LOGIC_OP_XOR
  * @member VK_LOGIC_OP_OR
  * @member VK_LOGIC_OP_NOR
  * @member VK_LOGIC_OP_EQUIVALENT
  * @member VK_LOGIC_OP_INVERT
  * @member VK_LOGIC_OP_OR_REVERSE
  * @member VK_LOGIC_OP_COPY_INVERTED
  * @member VK_LOGIC_OP_OR_INVERTED
  * @member VK_LOGIC_OP_NAND
  * @member VK_LOGIC_OP_SET
  */
export enum VkLogicOp {
  VK_LOGIC_OP_CLEAR,
  VK_LOGIC_OP_AND,
  VK_LOGIC_OP_AND_REVERSE,
  VK_LOGIC_OP_COPY,
  VK_LOGIC_OP_AND_INVERTED,
  VK_LOGIC_OP_NO_OP,
  VK_LOGIC_OP_XOR,
  VK_LOGIC_OP_OR,
  VK_LOGIC_OP_NOR,
  VK_LOGIC_OP_EQUIVALENT,
  VK_LOGIC_OP_INVERT,
  VK_LOGIC_OP_OR_REVERSE,
  VK_LOGIC_OP_COPY_INVERTED,
  VK_LOGIC_OP_OR_INVERTED,
  VK_LOGIC_OP_NAND,
  VK_LOGIC_OP_SET,
  
}

declare const VK_LOGIC_OP_CLEAR: VkLogicOp;
declare const VK_LOGIC_OP_AND: VkLogicOp;
declare const VK_LOGIC_OP_AND_REVERSE: VkLogicOp;
declare const VK_LOGIC_OP_COPY: VkLogicOp;
declare const VK_LOGIC_OP_AND_INVERTED: VkLogicOp;
declare const VK_LOGIC_OP_NO_OP: VkLogicOp;
declare const VK_LOGIC_OP_XOR: VkLogicOp;
declare const VK_LOGIC_OP_OR: VkLogicOp;
declare const VK_LOGIC_OP_NOR: VkLogicOp;
declare const VK_LOGIC_OP_EQUIVALENT: VkLogicOp;
declare const VK_LOGIC_OP_INVERT: VkLogicOp;
declare const VK_LOGIC_OP_OR_REVERSE: VkLogicOp;
declare const VK_LOGIC_OP_COPY_INVERTED: VkLogicOp;
declare const VK_LOGIC_OP_OR_INVERTED: VkLogicOp;
declare const VK_LOGIC_OP_NAND: VkLogicOp;
declare const VK_LOGIC_OP_SET: VkLogicOp;



/**
  * Allocation type
  * @member VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE specifies that the allocation is intended for execution by the host.
  */
export enum VkInternalAllocationType {
  VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
  
}

declare const VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE: VkInternalAllocationType;



/**
  * Allocation scope
  * @member VK_SYSTEM_ALLOCATION_SCOPE_COMMAND specifies that the allocation is scoped to the duration of the Vulkan command.
  * @member VK_SYSTEM_ALLOCATION_SCOPE_OBJECT specifies that the allocation is scoped to the lifetime of the Vulkan object that is being created or used.
  * @member VK_SYSTEM_ALLOCATION_SCOPE_CACHE specifies that the allocation is scoped to the lifetime of a 'VkPipelineCache' or 'VkValidationCacheEXT'
  * @member VK_SYSTEM_ALLOCATION_SCOPE_DEVICE
  * @member VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE
  */
export enum VkSystemAllocationScope {
  VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
  VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
  VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
  VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
  VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
  
}

declare const VK_SYSTEM_ALLOCATION_SCOPE_COMMAND: VkSystemAllocationScope;
declare const VK_SYSTEM_ALLOCATION_SCOPE_OBJECT: VkSystemAllocationScope;
declare const VK_SYSTEM_ALLOCATION_SCOPE_CACHE: VkSystemAllocationScope;
declare const VK_SYSTEM_ALLOCATION_SCOPE_DEVICE: VkSystemAllocationScope;
declare const VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE: VkSystemAllocationScope;



/**
  * Supported physical device types
  * @member VK_PHYSICAL_DEVICE_TYPE_OTHER - the device does not match any other available types.
  * @member VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU - the device is typically one embedded in or tightly coupled with the host.
  * @member VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU - the device is typically a separate processor connected to the host via an interlink.
  * @member VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU - the device is typically a virtual node in a virtualization environment.
  * @member VK_PHYSICAL_DEVICE_TYPE_CPU - the device is typically running on the same processors as the host.
  */
export enum VkPhysicalDeviceType {
  VK_PHYSICAL_DEVICE_TYPE_OTHER,
  VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
  VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
  VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
  VK_PHYSICAL_DEVICE_TYPE_CPU,
  
}

declare const VK_PHYSICAL_DEVICE_TYPE_OTHER: VkPhysicalDeviceType;
declare const VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: VkPhysicalDeviceType;
declare const VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU: VkPhysicalDeviceType;
declare const VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU: VkPhysicalDeviceType;
declare const VK_PHYSICAL_DEVICE_TYPE_CPU: VkPhysicalDeviceType;



/**
  * Specify rate at which vertex attributes are pulled from buffers
  * @member VK_VERTEX_INPUT_RATE_VERTEX specifies that vertex attribute addressing is a function of the vertex index.
  * @member VK_VERTEX_INPUT_RATE_INSTANCE specifies that vertex attribute addressing is a function of the instance index.
  */
export enum VkVertexInputRate {
  VK_VERTEX_INPUT_RATE_VERTEX,
  VK_VERTEX_INPUT_RATE_INSTANCE,
  
}

declare const VK_VERTEX_INPUT_RATE_VERTEX: VkVertexInputRate;
declare const VK_VERTEX_INPUT_RATE_INSTANCE: VkVertexInputRate;



/**
  * Available image formats
  * @member VK_FORMAT_UNDEFINED specifies that the format is not specified.
  * @member VK_FORMAT_R4G4_UNORM_PACK8 specifies a two-component, 8-bit packed unsigned normalized format that has a 4-bit R component in bits 4..7, and a 4-bit G component in bits 0..3.
  * @member VK_FORMAT_R4G4B4A4_UNORM_PACK16 specifies a four-component, 16-bit packed unsigned normalized format that has a 4-bit R component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit B component in bits 4..7, and a 4-bit A component in bits 0..3.
  * @member VK_FORMAT_B4G4R4A4_UNORM_PACK16 specifies a four-component, 16-bit packed unsigned normalized format that has a 4-bit B component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit R component in bits 4..7, and a 4-bit A component in bits 0..3.
  * @member VK_FORMAT_R5G6B5_UNORM_PACK16
  * @member VK_FORMAT_B5G6R5_UNORM_PACK16
  * @member VK_FORMAT_R5G5B5A1_UNORM_PACK16
  * @member VK_FORMAT_B5G5R5A1_UNORM_PACK16
  * @member VK_FORMAT_A1R5G5B5_UNORM_PACK16
  * @member VK_FORMAT_R8_UNORM
  * @member VK_FORMAT_R8_SNORM
  * @member VK_FORMAT_R8_USCALED
  * @member VK_FORMAT_R8_SSCALED
  * @member VK_FORMAT_R8_UINT
  * @member VK_FORMAT_R8_SINT
  * @member VK_FORMAT_R8_SRGB
  * @member VK_FORMAT_R8G8_UNORM
  * @member VK_FORMAT_R8G8_SNORM
  * @member VK_FORMAT_R8G8_USCALED
  * @member VK_FORMAT_R8G8_SSCALED
  * @member VK_FORMAT_R8G8_UINT
  * @member VK_FORMAT_R8G8_SINT
  * @member VK_FORMAT_R8G8_SRGB
  * @member VK_FORMAT_R8G8B8_UNORM
  * @member VK_FORMAT_R8G8B8_SNORM
  * @member VK_FORMAT_R8G8B8_USCALED
  * @member VK_FORMAT_R8G8B8_SSCALED
  * @member VK_FORMAT_R8G8B8_UINT
  * @member VK_FORMAT_R8G8B8_SINT
  * @member VK_FORMAT_R8G8B8_SRGB
  * @member VK_FORMAT_B8G8R8_UNORM
  * @member VK_FORMAT_B8G8R8_SNORM
  * @member VK_FORMAT_B8G8R8_USCALED
  * @member VK_FORMAT_B8G8R8_SSCALED
  * @member VK_FORMAT_B8G8R8_UINT
  * @member VK_FORMAT_B8G8R8_SINT
  * @member VK_FORMAT_B8G8R8_SRGB
  * @member VK_FORMAT_R8G8B8A8_UNORM
  * @member VK_FORMAT_R8G8B8A8_SNORM
  * @member VK_FORMAT_R8G8B8A8_USCALED
  * @member VK_FORMAT_R8G8B8A8_SSCALED
  * @member VK_FORMAT_R8G8B8A8_UINT
  * @member VK_FORMAT_R8G8B8A8_SINT
  * @member VK_FORMAT_R8G8B8A8_SRGB
  * @member VK_FORMAT_B8G8R8A8_UNORM
  * @member VK_FORMAT_B8G8R8A8_SNORM
  * @member VK_FORMAT_B8G8R8A8_USCALED
  * @member VK_FORMAT_B8G8R8A8_SSCALED
  * @member VK_FORMAT_B8G8R8A8_UINT
  * @member VK_FORMAT_B8G8R8A8_SINT
  * @member VK_FORMAT_B8G8R8A8_SRGB
  * @member VK_FORMAT_A8B8G8R8_UNORM_PACK32
  * @member VK_FORMAT_A8B8G8R8_SNORM_PACK32
  * @member VK_FORMAT_A8B8G8R8_USCALED_PACK32
  * @member VK_FORMAT_A8B8G8R8_SSCALED_PACK32
  * @member VK_FORMAT_A8B8G8R8_UINT_PACK32
  * @member VK_FORMAT_A8B8G8R8_SINT_PACK32
  * @member VK_FORMAT_A8B8G8R8_SRGB_PACK32
  * @member VK_FORMAT_A2R10G10B10_UNORM_PACK32
  * @member VK_FORMAT_A2R10G10B10_SNORM_PACK32
  * @member VK_FORMAT_A2R10G10B10_USCALED_PACK32
  * @member VK_FORMAT_A2R10G10B10_SSCALED_PACK32
  * @member VK_FORMAT_A2R10G10B10_UINT_PACK32
  * @member VK_FORMAT_A2R10G10B10_SINT_PACK32
  * @member VK_FORMAT_A2B10G10R10_UNORM_PACK32
  * @member VK_FORMAT_A2B10G10R10_SNORM_PACK32
  * @member VK_FORMAT_A2B10G10R10_USCALED_PACK32
  * @member VK_FORMAT_A2B10G10R10_SSCALED_PACK32
  * @member VK_FORMAT_A2B10G10R10_UINT_PACK32
  * @member VK_FORMAT_A2B10G10R10_SINT_PACK32
  * @member VK_FORMAT_R16_UNORM
  * @member VK_FORMAT_R16_SNORM
  * @member VK_FORMAT_R16_USCALED
  * @member VK_FORMAT_R16_SSCALED
  * @member VK_FORMAT_R16_UINT
  * @member VK_FORMAT_R16_SINT
  * @member VK_FORMAT_R16_SFLOAT
  * @member VK_FORMAT_R16G16_UNORM
  * @member VK_FORMAT_R16G16_SNORM
  * @member VK_FORMAT_R16G16_USCALED
  * @member VK_FORMAT_R16G16_SSCALED
  * @member VK_FORMAT_R16G16_UINT
  * @member VK_FORMAT_R16G16_SINT
  * @member VK_FORMAT_R16G16_SFLOAT
  * @member VK_FORMAT_R16G16B16_UNORM
  * @member VK_FORMAT_R16G16B16_SNORM
  * @member VK_FORMAT_R16G16B16_USCALED
  * @member VK_FORMAT_R16G16B16_SSCALED
  * @member VK_FORMAT_R16G16B16_UINT
  * @member VK_FORMAT_R16G16B16_SINT
  * @member VK_FORMAT_R16G16B16_SFLOAT
  * @member VK_FORMAT_R16G16B16A16_UNORM
  * @member VK_FORMAT_R16G16B16A16_SNORM
  * @member VK_FORMAT_R16G16B16A16_USCALED
  * @member VK_FORMAT_R16G16B16A16_SSCALED
  * @member VK_FORMAT_R16G16B16A16_UINT
  * @member VK_FORMAT_R16G16B16A16_SINT
  * @member VK_FORMAT_R16G16B16A16_SFLOAT
  * @member VK_FORMAT_R32_UINT
  * @member VK_FORMAT_R32_SINT
  * @member VK_FORMAT_R32_SFLOAT
  * @member VK_FORMAT_R32G32_UINT
  * @member VK_FORMAT_R32G32_SINT
  * @member VK_FORMAT_R32G32_SFLOAT
  * @member VK_FORMAT_R32G32B32_UINT
  * @member VK_FORMAT_R32G32B32_SINT
  * @member VK_FORMAT_R32G32B32_SFLOAT
  * @member VK_FORMAT_R32G32B32A32_UINT
  * @member VK_FORMAT_R32G32B32A32_SINT
  * @member VK_FORMAT_R32G32B32A32_SFLOAT
  * @member VK_FORMAT_R64_UINT
  * @member VK_FORMAT_R64_SINT
  * @member VK_FORMAT_R64_SFLOAT
  * @member VK_FORMAT_R64G64_UINT
  * @member VK_FORMAT_R64G64_SINT
  * @member VK_FORMAT_R64G64_SFLOAT
  * @member VK_FORMAT_R64G64B64_UINT
  * @member VK_FORMAT_R64G64B64_SINT
  * @member VK_FORMAT_R64G64B64_SFLOAT
  * @member VK_FORMAT_R64G64B64A64_UINT
  * @member VK_FORMAT_R64G64B64A64_SINT
  * @member VK_FORMAT_R64G64B64A64_SFLOAT
  * @member VK_FORMAT_B10G11R11_UFLOAT_PACK32
  * @member VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
  * @member VK_FORMAT_D16_UNORM
  * @member VK_FORMAT_X8_D24_UNORM_PACK32
  * @member VK_FORMAT_D32_SFLOAT
  * @member VK_FORMAT_S8_UINT
  * @member VK_FORMAT_D16_UNORM_S8_UINT
  * @member VK_FORMAT_D24_UNORM_S8_UINT
  * @member VK_FORMAT_D32_SFLOAT_S8_UINT
  * @member VK_FORMAT_BC1_RGB_UNORM_BLOCK
  * @member VK_FORMAT_BC1_RGB_SRGB_BLOCK
  * @member VK_FORMAT_BC1_RGBA_UNORM_BLOCK
  * @member VK_FORMAT_BC1_RGBA_SRGB_BLOCK
  * @member VK_FORMAT_BC2_UNORM_BLOCK
  * @member VK_FORMAT_BC2_SRGB_BLOCK
  * @member VK_FORMAT_BC3_UNORM_BLOCK
  * @member VK_FORMAT_BC3_SRGB_BLOCK
  * @member VK_FORMAT_BC4_UNORM_BLOCK
  * @member VK_FORMAT_BC4_SNORM_BLOCK
  * @member VK_FORMAT_BC5_UNORM_BLOCK
  * @member VK_FORMAT_BC5_SNORM_BLOCK
  * @member VK_FORMAT_BC6H_UFLOAT_BLOCK
  * @member VK_FORMAT_BC6H_SFLOAT_BLOCK
  * @member VK_FORMAT_BC7_UNORM_BLOCK
  * @member VK_FORMAT_BC7_SRGB_BLOCK
  * @member VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
  * @member VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
  * @member VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
  * @member VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
  * @member VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
  * @member VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
  * @member VK_FORMAT_EAC_R11_UNORM_BLOCK
  * @member VK_FORMAT_EAC_R11_SNORM_BLOCK
  * @member VK_FORMAT_EAC_R11G11_UNORM_BLOCK
  * @member VK_FORMAT_EAC_R11G11_SNORM_BLOCK
  * @member VK_FORMAT_ASTC_4x4_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_4x4_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_5x4_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_5x4_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_5x5_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_5x5_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_6x5_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_6x5_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_6x6_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_6x6_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_8x5_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_8x5_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_8x6_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_8x6_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_8x8_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_8x8_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_10x5_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_10x5_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_10x6_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_10x6_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_10x8_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_10x8_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_10x10_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_10x10_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_12x10_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_12x10_SRGB_BLOCK
  * @member VK_FORMAT_ASTC_12x12_UNORM_BLOCK
  * @member VK_FORMAT_ASTC_12x12_SRGB_BLOCK
  * @member VK_FORMAT_G8B8G8R8_422_UNORM
  * @member VK_FORMAT_B8G8R8G8_422_UNORM
  * @member VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
  * @member VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
  * @member VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM
  * @member VK_FORMAT_G8_B8R8_2PLANE_422_UNORM
  * @member VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM
  * @member VK_FORMAT_R10X6_UNORM_PACK16
  * @member VK_FORMAT_R10X6G10X6_UNORM_2PACK16
  * @member VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16
  * @member VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16
  * @member VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16
  * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16
  * @member VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16
  * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16
  * @member VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16
  * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16
  * @member VK_FORMAT_R12X4_UNORM_PACK16
  * @member VK_FORMAT_R12X4G12X4_UNORM_2PACK16
  * @member VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16
  * @member VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16
  * @member VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16
  * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16
  * @member VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16
  * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16
  * @member VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16
  * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16
  * @member VK_FORMAT_G16B16G16R16_422_UNORM
  * @member VK_FORMAT_B16G16R16G16_422_UNORM
  * @member VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM
  * @member VK_FORMAT_G16_B16R16_2PLANE_420_UNORM
  * @member VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM
  * @member VK_FORMAT_G16_B16R16_2PLANE_422_UNORM
  * @member VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM
  * @member VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG
  * @member VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG
  * @member VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG
  * @member VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG
  * @member VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG
  * @member VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG
  * @member VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG
  * @member VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG
  * @member VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT
  * @member VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT
  * @member VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT
  * @member VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT
  * @member VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT
  * @member VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT
  * @member VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT
  * @member VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT
  * @member VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT
  * @member VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT
  * @member VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT
  * @member VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT specifies a four-component, 16-bit packed unsigned normalized format that has a 4-bit A component in bits 12..15, a 4-bit R component in bits 8..11, a 4-bit G component in bits 4..7, and a 4-bit B component in bits 0..3.
  * @member VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT specifies a four-component, 16-bit packed unsigned normalized format that has a 4-bit A component in bits 12..15, a 4-bit B component in bits 8..11, a 4-bit G component in bits 4..7, and a 4-bit R component in bits 0..3.
  * @member VK_FORMAT_G8B8G8R8_422_UNORM_KHR
  * @member VK_FORMAT_B8G8R8G8_422_UNORM_KHR
  * @member VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR
  * @member VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR
  * @member VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR
  * @member VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR
  * @member VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR
  * @member VK_FORMAT_R10X6_UNORM_PACK16_KHR
  * @member VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR
  * @member VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR
  * @member VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR
  * @member VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR
  * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR
  * @member VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR
  * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR
  * @member VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR
  * @member VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR
  * @member VK_FORMAT_R12X4_UNORM_PACK16_KHR
  * @member VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR
  * @member VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR
  * @member VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR
  * @member VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR
  * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR
  * @member VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR
  * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR
  * @member VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR
  * @member VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR
  * @member VK_FORMAT_G16B16G16R16_422_UNORM_KHR
  * @member VK_FORMAT_B16G16R16G16_422_UNORM_KHR
  * @member VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR
  * @member VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR
  * @member VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR
  * @member VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR
  * @member VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR
  */
export enum VkFormat {
  VK_FORMAT_UNDEFINED,
  VK_FORMAT_R4G4_UNORM_PACK8,
  VK_FORMAT_R4G4B4A4_UNORM_PACK16,
  VK_FORMAT_B4G4R4A4_UNORM_PACK16,
  VK_FORMAT_R5G6B5_UNORM_PACK16,
  VK_FORMAT_B5G6R5_UNORM_PACK16,
  VK_FORMAT_R5G5B5A1_UNORM_PACK16,
  VK_FORMAT_B5G5R5A1_UNORM_PACK16,
  VK_FORMAT_A1R5G5B5_UNORM_PACK16,
  VK_FORMAT_R8_UNORM,
  VK_FORMAT_R8_SNORM,
  VK_FORMAT_R8_USCALED,
  VK_FORMAT_R8_SSCALED,
  VK_FORMAT_R8_UINT,
  VK_FORMAT_R8_SINT,
  VK_FORMAT_R8_SRGB,
  VK_FORMAT_R8G8_UNORM,
  VK_FORMAT_R8G8_SNORM,
  VK_FORMAT_R8G8_USCALED,
  VK_FORMAT_R8G8_SSCALED,
  VK_FORMAT_R8G8_UINT,
  VK_FORMAT_R8G8_SINT,
  VK_FORMAT_R8G8_SRGB,
  VK_FORMAT_R8G8B8_UNORM,
  VK_FORMAT_R8G8B8_SNORM,
  VK_FORMAT_R8G8B8_USCALED,
  VK_FORMAT_R8G8B8_SSCALED,
  VK_FORMAT_R8G8B8_UINT,
  VK_FORMAT_R8G8B8_SINT,
  VK_FORMAT_R8G8B8_SRGB,
  VK_FORMAT_B8G8R8_UNORM,
  VK_FORMAT_B8G8R8_SNORM,
  VK_FORMAT_B8G8R8_USCALED,
  VK_FORMAT_B8G8R8_SSCALED,
  VK_FORMAT_B8G8R8_UINT,
  VK_FORMAT_B8G8R8_SINT,
  VK_FORMAT_B8G8R8_SRGB,
  VK_FORMAT_R8G8B8A8_UNORM,
  VK_FORMAT_R8G8B8A8_SNORM,
  VK_FORMAT_R8G8B8A8_USCALED,
  VK_FORMAT_R8G8B8A8_SSCALED,
  VK_FORMAT_R8G8B8A8_UINT,
  VK_FORMAT_R8G8B8A8_SINT,
  VK_FORMAT_R8G8B8A8_SRGB,
  VK_FORMAT_B8G8R8A8_UNORM,
  VK_FORMAT_B8G8R8A8_SNORM,
  VK_FORMAT_B8G8R8A8_USCALED,
  VK_FORMAT_B8G8R8A8_SSCALED,
  VK_FORMAT_B8G8R8A8_UINT,
  VK_FORMAT_B8G8R8A8_SINT,
  VK_FORMAT_B8G8R8A8_SRGB,
  VK_FORMAT_A8B8G8R8_UNORM_PACK32,
  VK_FORMAT_A8B8G8R8_SNORM_PACK32,
  VK_FORMAT_A8B8G8R8_USCALED_PACK32,
  VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
  VK_FORMAT_A8B8G8R8_UINT_PACK32,
  VK_FORMAT_A8B8G8R8_SINT_PACK32,
  VK_FORMAT_A8B8G8R8_SRGB_PACK32,
  VK_FORMAT_A2R10G10B10_UNORM_PACK32,
  VK_FORMAT_A2R10G10B10_SNORM_PACK32,
  VK_FORMAT_A2R10G10B10_USCALED_PACK32,
  VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
  VK_FORMAT_A2R10G10B10_UINT_PACK32,
  VK_FORMAT_A2R10G10B10_SINT_PACK32,
  VK_FORMAT_A2B10G10R10_UNORM_PACK32,
  VK_FORMAT_A2B10G10R10_SNORM_PACK32,
  VK_FORMAT_A2B10G10R10_USCALED_PACK32,
  VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
  VK_FORMAT_A2B10G10R10_UINT_PACK32,
  VK_FORMAT_A2B10G10R10_SINT_PACK32,
  VK_FORMAT_R16_UNORM,
  VK_FORMAT_R16_SNORM,
  VK_FORMAT_R16_USCALED,
  VK_FORMAT_R16_SSCALED,
  VK_FORMAT_R16_UINT,
  VK_FORMAT_R16_SINT,
  VK_FORMAT_R16_SFLOAT,
  VK_FORMAT_R16G16_UNORM,
  VK_FORMAT_R16G16_SNORM,
  VK_FORMAT_R16G16_USCALED,
  VK_FORMAT_R16G16_SSCALED,
  VK_FORMAT_R16G16_UINT,
  VK_FORMAT_R16G16_SINT,
  VK_FORMAT_R16G16_SFLOAT,
  VK_FORMAT_R16G16B16_UNORM,
  VK_FORMAT_R16G16B16_SNORM,
  VK_FORMAT_R16G16B16_USCALED,
  VK_FORMAT_R16G16B16_SSCALED,
  VK_FORMAT_R16G16B16_UINT,
  VK_FORMAT_R16G16B16_SINT,
  VK_FORMAT_R16G16B16_SFLOAT,
  VK_FORMAT_R16G16B16A16_UNORM,
  VK_FORMAT_R16G16B16A16_SNORM,
  VK_FORMAT_R16G16B16A16_USCALED,
  VK_FORMAT_R16G16B16A16_SSCALED,
  VK_FORMAT_R16G16B16A16_UINT,
  VK_FORMAT_R16G16B16A16_SINT,
  VK_FORMAT_R16G16B16A16_SFLOAT,
  VK_FORMAT_R32_UINT,
  VK_FORMAT_R32_SINT,
  VK_FORMAT_R32_SFLOAT,
  VK_FORMAT_R32G32_UINT,
  VK_FORMAT_R32G32_SINT,
  VK_FORMAT_R32G32_SFLOAT,
  VK_FORMAT_R32G32B32_UINT,
  VK_FORMAT_R32G32B32_SINT,
  VK_FORMAT_R32G32B32_SFLOAT,
  VK_FORMAT_R32G32B32A32_UINT,
  VK_FORMAT_R32G32B32A32_SINT,
  VK_FORMAT_R32G32B32A32_SFLOAT,
  VK_FORMAT_R64_UINT,
  VK_FORMAT_R64_SINT,
  VK_FORMAT_R64_SFLOAT,
  VK_FORMAT_R64G64_UINT,
  VK_FORMAT_R64G64_SINT,
  VK_FORMAT_R64G64_SFLOAT,
  VK_FORMAT_R64G64B64_UINT,
  VK_FORMAT_R64G64B64_SINT,
  VK_FORMAT_R64G64B64_SFLOAT,
  VK_FORMAT_R64G64B64A64_UINT,
  VK_FORMAT_R64G64B64A64_SINT,
  VK_FORMAT_R64G64B64A64_SFLOAT,
  VK_FORMAT_B10G11R11_UFLOAT_PACK32,
  VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
  VK_FORMAT_D16_UNORM,
  VK_FORMAT_X8_D24_UNORM_PACK32,
  VK_FORMAT_D32_SFLOAT,
  VK_FORMAT_S8_UINT,
  VK_FORMAT_D16_UNORM_S8_UINT,
  VK_FORMAT_D24_UNORM_S8_UINT,
  VK_FORMAT_D32_SFLOAT_S8_UINT,
  VK_FORMAT_BC1_RGB_UNORM_BLOCK,
  VK_FORMAT_BC1_RGB_SRGB_BLOCK,
  VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
  VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
  VK_FORMAT_BC2_UNORM_BLOCK,
  VK_FORMAT_BC2_SRGB_BLOCK,
  VK_FORMAT_BC3_UNORM_BLOCK,
  VK_FORMAT_BC3_SRGB_BLOCK,
  VK_FORMAT_BC4_UNORM_BLOCK,
  VK_FORMAT_BC4_SNORM_BLOCK,
  VK_FORMAT_BC5_UNORM_BLOCK,
  VK_FORMAT_BC5_SNORM_BLOCK,
  VK_FORMAT_BC6H_UFLOAT_BLOCK,
  VK_FORMAT_BC6H_SFLOAT_BLOCK,
  VK_FORMAT_BC7_UNORM_BLOCK,
  VK_FORMAT_BC7_SRGB_BLOCK,
  VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
  VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
  VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
  VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
  VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
  VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
  VK_FORMAT_EAC_R11_UNORM_BLOCK,
  VK_FORMAT_EAC_R11_SNORM_BLOCK,
  VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
  VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
  VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
  VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
  VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
  VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
  VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
  VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
  VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
  VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
  VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
  VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
  VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
  VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
  VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
  VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
  VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
  VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
  VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
  VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
  VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
  VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
  VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
  VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
  VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
  VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
  VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
  VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
  VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
  VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
  VK_FORMAT_G8B8G8R8_422_UNORM,
  VK_FORMAT_B8G8R8G8_422_UNORM,
  VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
  VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
  VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
  VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
  VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
  VK_FORMAT_R10X6_UNORM_PACK16,
  VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
  VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
  VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
  VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
  VK_FORMAT_R12X4_UNORM_PACK16,
  VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
  VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
  VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
  VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
  VK_FORMAT_G16B16G16R16_422_UNORM,
  VK_FORMAT_B16G16R16G16_422_UNORM,
  VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
  VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
  VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
  VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
  VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
  VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,
  VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,
  VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,
  VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,
  VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,
  VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,
  VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,
  VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG,
  VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT,
  VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT,
  VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT,
  VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT,
  VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT,
  VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT,
  VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT,
  VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT,
  VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT,
  VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT,
  VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT,
  VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT,
  VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT,
  VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT,
  VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT,
  VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT,
  VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT,
  VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT,
  VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT,
  VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT,
  VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT,
  VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT,
  VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT,
  VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT,
  VK_FORMAT_G8B8G8R8_422_UNORM_KHR,
  VK_FORMAT_B8G8R8G8_422_UNORM_KHR,
  VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR,
  VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR,
  VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR,
  VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR,
  VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR,
  VK_FORMAT_R10X6_UNORM_PACK16_KHR,
  VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR,
  VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR,
  VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR,
  VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR,
  VK_FORMAT_R12X4_UNORM_PACK16_KHR,
  VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR,
  VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR,
  VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR,
  VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR,
  VK_FORMAT_G16B16G16R16_422_UNORM_KHR,
  VK_FORMAT_B16G16R16G16_422_UNORM_KHR,
  VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR,
  VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR,
  VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR,
  VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR,
  VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR,
  
}

declare const VK_FORMAT_UNDEFINED: VkFormat;
declare const VK_FORMAT_R4G4_UNORM_PACK8: VkFormat;
declare const VK_FORMAT_R4G4B4A4_UNORM_PACK16: VkFormat;
declare const VK_FORMAT_B4G4R4A4_UNORM_PACK16: VkFormat;
declare const VK_FORMAT_R5G6B5_UNORM_PACK16: VkFormat;
declare const VK_FORMAT_B5G6R5_UNORM_PACK16: VkFormat;
declare const VK_FORMAT_R5G5B5A1_UNORM_PACK16: VkFormat;
declare const VK_FORMAT_B5G5R5A1_UNORM_PACK16: VkFormat;
declare const VK_FORMAT_A1R5G5B5_UNORM_PACK16: VkFormat;
declare const VK_FORMAT_R8_UNORM: VkFormat;
declare const VK_FORMAT_R8_SNORM: VkFormat;
declare const VK_FORMAT_R8_USCALED: VkFormat;
declare const VK_FORMAT_R8_SSCALED: VkFormat;
declare const VK_FORMAT_R8_UINT: VkFormat;
declare const VK_FORMAT_R8_SINT: VkFormat;
declare const VK_FORMAT_R8_SRGB: VkFormat;
declare const VK_FORMAT_R8G8_UNORM: VkFormat;
declare const VK_FORMAT_R8G8_SNORM: VkFormat;
declare const VK_FORMAT_R8G8_USCALED: VkFormat;
declare const VK_FORMAT_R8G8_SSCALED: VkFormat;
declare const VK_FORMAT_R8G8_UINT: VkFormat;
declare const VK_FORMAT_R8G8_SINT: VkFormat;
declare const VK_FORMAT_R8G8_SRGB: VkFormat;
declare const VK_FORMAT_R8G8B8_UNORM: VkFormat;
declare const VK_FORMAT_R8G8B8_SNORM: VkFormat;
declare const VK_FORMAT_R8G8B8_USCALED: VkFormat;
declare const VK_FORMAT_R8G8B8_SSCALED: VkFormat;
declare const VK_FORMAT_R8G8B8_UINT: VkFormat;
declare const VK_FORMAT_R8G8B8_SINT: VkFormat;
declare const VK_FORMAT_R8G8B8_SRGB: VkFormat;
declare const VK_FORMAT_B8G8R8_UNORM: VkFormat;
declare const VK_FORMAT_B8G8R8_SNORM: VkFormat;
declare const VK_FORMAT_B8G8R8_USCALED: VkFormat;
declare const VK_FORMAT_B8G8R8_SSCALED: VkFormat;
declare const VK_FORMAT_B8G8R8_UINT: VkFormat;
declare const VK_FORMAT_B8G8R8_SINT: VkFormat;
declare const VK_FORMAT_B8G8R8_SRGB: VkFormat;
declare const VK_FORMAT_R8G8B8A8_UNORM: VkFormat;
declare const VK_FORMAT_R8G8B8A8_SNORM: VkFormat;
declare const VK_FORMAT_R8G8B8A8_USCALED: VkFormat;
declare const VK_FORMAT_R8G8B8A8_SSCALED: VkFormat;
declare const VK_FORMAT_R8G8B8A8_UINT: VkFormat;
declare const VK_FORMAT_R8G8B8A8_SINT: VkFormat;
declare const VK_FORMAT_R8G8B8A8_SRGB: VkFormat;
declare const VK_FORMAT_B8G8R8A8_UNORM: VkFormat;
declare const VK_FORMAT_B8G8R8A8_SNORM: VkFormat;
declare const VK_FORMAT_B8G8R8A8_USCALED: VkFormat;
declare const VK_FORMAT_B8G8R8A8_SSCALED: VkFormat;
declare const VK_FORMAT_B8G8R8A8_UINT: VkFormat;
declare const VK_FORMAT_B8G8R8A8_SINT: VkFormat;
declare const VK_FORMAT_B8G8R8A8_SRGB: VkFormat;
declare const VK_FORMAT_A8B8G8R8_UNORM_PACK32: VkFormat;
declare const VK_FORMAT_A8B8G8R8_SNORM_PACK32: VkFormat;
declare const VK_FORMAT_A8B8G8R8_USCALED_PACK32: VkFormat;
declare const VK_FORMAT_A8B8G8R8_SSCALED_PACK32: VkFormat;
declare const VK_FORMAT_A8B8G8R8_UINT_PACK32: VkFormat;
declare const VK_FORMAT_A8B8G8R8_SINT_PACK32: VkFormat;
declare const VK_FORMAT_A8B8G8R8_SRGB_PACK32: VkFormat;
declare const VK_FORMAT_A2R10G10B10_UNORM_PACK32: VkFormat;
declare const VK_FORMAT_A2R10G10B10_SNORM_PACK32: VkFormat;
declare const VK_FORMAT_A2R10G10B10_USCALED_PACK32: VkFormat;
declare const VK_FORMAT_A2R10G10B10_SSCALED_PACK32: VkFormat;
declare const VK_FORMAT_A2R10G10B10_UINT_PACK32: VkFormat;
declare const VK_FORMAT_A2R10G10B10_SINT_PACK32: VkFormat;
declare const VK_FORMAT_A2B10G10R10_UNORM_PACK32: VkFormat;
declare const VK_FORMAT_A2B10G10R10_SNORM_PACK32: VkFormat;
declare const VK_FORMAT_A2B10G10R10_USCALED_PACK32: VkFormat;
declare const VK_FORMAT_A2B10G10R10_SSCALED_PACK32: VkFormat;
declare const VK_FORMAT_A2B10G10R10_UINT_PACK32: VkFormat;
declare const VK_FORMAT_A2B10G10R10_SINT_PACK32: VkFormat;
declare const VK_FORMAT_R16_UNORM: VkFormat;
declare const VK_FORMAT_R16_SNORM: VkFormat;
declare const VK_FORMAT_R16_USCALED: VkFormat;
declare const VK_FORMAT_R16_SSCALED: VkFormat;
declare const VK_FORMAT_R16_UINT: VkFormat;
declare const VK_FORMAT_R16_SINT: VkFormat;
declare const VK_FORMAT_R16_SFLOAT: VkFormat;
declare const VK_FORMAT_R16G16_UNORM: VkFormat;
declare const VK_FORMAT_R16G16_SNORM: VkFormat;
declare const VK_FORMAT_R16G16_USCALED: VkFormat;
declare const VK_FORMAT_R16G16_SSCALED: VkFormat;
declare const VK_FORMAT_R16G16_UINT: VkFormat;
declare const VK_FORMAT_R16G16_SINT: VkFormat;
declare const VK_FORMAT_R16G16_SFLOAT: VkFormat;
declare const VK_FORMAT_R16G16B16_UNORM: VkFormat;
declare const VK_FORMAT_R16G16B16_SNORM: VkFormat;
declare const VK_FORMAT_R16G16B16_USCALED: VkFormat;
declare const VK_FORMAT_R16G16B16_SSCALED: VkFormat;
declare const VK_FORMAT_R16G16B16_UINT: VkFormat;
declare const VK_FORMAT_R16G16B16_SINT: VkFormat;
declare const VK_FORMAT_R16G16B16_SFLOAT: VkFormat;
declare const VK_FORMAT_R16G16B16A16_UNORM: VkFormat;
declare const VK_FORMAT_R16G16B16A16_SNORM: VkFormat;
declare const VK_FORMAT_R16G16B16A16_USCALED: VkFormat;
declare const VK_FORMAT_R16G16B16A16_SSCALED: VkFormat;
declare const VK_FORMAT_R16G16B16A16_UINT: VkFormat;
declare const VK_FORMAT_R16G16B16A16_SINT: VkFormat;
declare const VK_FORMAT_R16G16B16A16_SFLOAT: VkFormat;
declare const VK_FORMAT_R32_UINT: VkFormat;
declare const VK_FORMAT_R32_SINT: VkFormat;
declare const VK_FORMAT_R32_SFLOAT: VkFormat;
declare const VK_FORMAT_R32G32_UINT: VkFormat;
declare const VK_FORMAT_R32G32_SINT: VkFormat;
declare const VK_FORMAT_R32G32_SFLOAT: VkFormat;
declare const VK_FORMAT_R32G32B32_UINT: VkFormat;
declare const VK_FORMAT_R32G32B32_SINT: VkFormat;
declare const VK_FORMAT_R32G32B32_SFLOAT: VkFormat;
declare const VK_FORMAT_R32G32B32A32_UINT: VkFormat;
declare const VK_FORMAT_R32G32B32A32_SINT: VkFormat;
declare const VK_FORMAT_R32G32B32A32_SFLOAT: VkFormat;
declare const VK_FORMAT_R64_UINT: VkFormat;
declare const VK_FORMAT_R64_SINT: VkFormat;
declare const VK_FORMAT_R64_SFLOAT: VkFormat;
declare const VK_FORMAT_R64G64_UINT: VkFormat;
declare const VK_FORMAT_R64G64_SINT: VkFormat;
declare const VK_FORMAT_R64G64_SFLOAT: VkFormat;
declare const VK_FORMAT_R64G64B64_UINT: VkFormat;
declare const VK_FORMAT_R64G64B64_SINT: VkFormat;
declare const VK_FORMAT_R64G64B64_SFLOAT: VkFormat;
declare const VK_FORMAT_R64G64B64A64_UINT: VkFormat;
declare const VK_FORMAT_R64G64B64A64_SINT: VkFormat;
declare const VK_FORMAT_R64G64B64A64_SFLOAT: VkFormat;
declare const VK_FORMAT_B10G11R11_UFLOAT_PACK32: VkFormat;
declare const VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: VkFormat;
declare const VK_FORMAT_D16_UNORM: VkFormat;
declare const VK_FORMAT_X8_D24_UNORM_PACK32: VkFormat;
declare const VK_FORMAT_D32_SFLOAT: VkFormat;
declare const VK_FORMAT_S8_UINT: VkFormat;
declare const VK_FORMAT_D16_UNORM_S8_UINT: VkFormat;
declare const VK_FORMAT_D24_UNORM_S8_UINT: VkFormat;
declare const VK_FORMAT_D32_SFLOAT_S8_UINT: VkFormat;
declare const VK_FORMAT_BC1_RGB_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_BC1_RGB_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_BC1_RGBA_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_BC1_RGBA_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_BC2_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_BC2_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_BC3_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_BC3_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_BC4_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_BC4_SNORM_BLOCK: VkFormat;
declare const VK_FORMAT_BC5_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_BC5_SNORM_BLOCK: VkFormat;
declare const VK_FORMAT_BC6H_UFLOAT_BLOCK: VkFormat;
declare const VK_FORMAT_BC6H_SFLOAT_BLOCK: VkFormat;
declare const VK_FORMAT_BC7_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_BC7_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_EAC_R11_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_EAC_R11_SNORM_BLOCK: VkFormat;
declare const VK_FORMAT_EAC_R11G11_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_EAC_R11G11_SNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_4x4_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_4x4_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_5x4_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_5x4_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_5x5_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_5x5_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_6x5_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_6x5_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_6x6_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_6x6_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_8x5_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_8x5_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_8x6_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_8x6_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_8x8_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_8x8_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_10x5_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_10x5_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_10x6_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_10x6_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_10x8_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_10x8_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_10x10_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_10x10_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_12x10_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_12x10_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_12x12_UNORM_BLOCK: VkFormat;
declare const VK_FORMAT_ASTC_12x12_SRGB_BLOCK: VkFormat;
declare const VK_FORMAT_G8B8G8R8_422_UNORM: VkFormat;
declare const VK_FORMAT_B8G8R8G8_422_UNORM: VkFormat;
declare const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM: VkFormat;
declare const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM: VkFormat;
declare const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM: VkFormat;
declare const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM: VkFormat;
declare const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM: VkFormat;
declare const VK_FORMAT_R10X6_UNORM_PACK16: VkFormat;
declare const VK_FORMAT_R10X6G10X6_UNORM_2PACK16: VkFormat;
declare const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: VkFormat;
declare const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: VkFormat;
declare const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: VkFormat;
declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: VkFormat;
declare const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: VkFormat;
declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: VkFormat;
declare const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: VkFormat;
declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: VkFormat;
declare const VK_FORMAT_R12X4_UNORM_PACK16: VkFormat;
declare const VK_FORMAT_R12X4G12X4_UNORM_2PACK16: VkFormat;
declare const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: VkFormat;
declare const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: VkFormat;
declare const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: VkFormat;
declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: VkFormat;
declare const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: VkFormat;
declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: VkFormat;
declare const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: VkFormat;
declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: VkFormat;
declare const VK_FORMAT_G16B16G16R16_422_UNORM: VkFormat;
declare const VK_FORMAT_B16G16R16G16_422_UNORM: VkFormat;
declare const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM: VkFormat;
declare const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM: VkFormat;
declare const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM: VkFormat;
declare const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM: VkFormat;
declare const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM: VkFormat;
declare const VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: VkFormat;
declare const VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: VkFormat;
declare const VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: VkFormat;
declare const VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: VkFormat;
declare const VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: VkFormat;
declare const VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: VkFormat;
declare const VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: VkFormat;
declare const VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: VkFormat;
declare const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT: VkFormat;
declare const VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: VkFormat;
declare const VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: VkFormat;
declare const VK_FORMAT_G8B8G8R8_422_UNORM_KHR: VkFormat;
declare const VK_FORMAT_B8G8R8G8_422_UNORM_KHR: VkFormat;
declare const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR: VkFormat;
declare const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR: VkFormat;
declare const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR: VkFormat;
declare const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR: VkFormat;
declare const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR: VkFormat;
declare const VK_FORMAT_R10X6_UNORM_PACK16_KHR: VkFormat;
declare const VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR: VkFormat;
declare const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: VkFormat;
declare const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: VkFormat;
declare const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: VkFormat;
declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: VkFormat;
declare const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: VkFormat;
declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: VkFormat;
declare const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: VkFormat;
declare const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: VkFormat;
declare const VK_FORMAT_R12X4_UNORM_PACK16_KHR: VkFormat;
declare const VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR: VkFormat;
declare const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: VkFormat;
declare const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: VkFormat;
declare const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: VkFormat;
declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: VkFormat;
declare const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: VkFormat;
declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: VkFormat;
declare const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: VkFormat;
declare const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: VkFormat;
declare const VK_FORMAT_G16B16G16R16_422_UNORM_KHR: VkFormat;
declare const VK_FORMAT_B16G16R16G16_422_UNORM_KHR: VkFormat;
declare const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR: VkFormat;
declare const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR: VkFormat;
declare const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR: VkFormat;
declare const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR: VkFormat;
declare const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR: VkFormat;



/**
  * Vulkan structure types ({#0#})
  * @member VK_STRUCTURE_TYPE_APPLICATION_INFO
  * @member VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_SUBMIT_INFO
  * @member VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
  * @member VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE
  * @member VK_STRUCTURE_TYPE_BIND_SPARSE_INFO
  * @member VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_EVENT_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
  * @member VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
  * @member VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET
  * @member VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
  * @member VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO
  * @member VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
  * @member VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER
  * @member VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
  * @member VK_STRUCTURE_TYPE_MEMORY_BARRIER
  * @member VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES
  * @member VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO
  * @member VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES
  * @member VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS
  * @member VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO
  * @member VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO
  * @member VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO
  * @member VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2
  * @member VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2
  * @member VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2
  * @member VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2
  * @member VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
  * @member VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2
  * @member VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2
  * @member VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2
  * @member VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES
  * @member VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES
  * @member VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2
  * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO
  * @member VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO
  * @member VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES
  * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO
  * @member VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO
  * @member VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
  * @member VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO
  * @member VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES
  * @member VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO
  * @member VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES
  * @member VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2
  * @member VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2
  * @member VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2
  * @member VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2
  * @member VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO
  * @member VK_STRUCTURE_TYPE_SUBPASS_END_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES
  * @member VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES
  * @member VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES
  * @member VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES
  * @member VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES
  * @member VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT
  * @member VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES
  * @member VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO
  * @member VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO
  * @member VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES
  * @member VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO
  * @member VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO
  * @member VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO
  * @member VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO
  * @member VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR
  * @member VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR
  * @member VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR
  * @member VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID
  * @member VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID
  * @member VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD
  * @member VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT
  * @member VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT
  * @member VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT
  * @member VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX
  * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX
  * @member VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD
  * @member VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV
  * @member VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV
  * @member VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV
  * @member VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
  * @member VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR
  * @member VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR
  * @member VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR
  * @member VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR
  * @member VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT
  * @member VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT
  * @member VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT
  * @member VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT
  * @member VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT
  * @member VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX
  * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_HDR_METADATA_EXT
  * @member VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR
  * @member VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR
  * @member VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR
  * @member VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR
  * @member VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR
  * @member VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR
  * @member VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR
  * @member VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR
  * @member VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR
  * @member VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR
  * @member VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK
  * @member VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK
  * @member VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT
  * @member VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT
  * @member VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT
  * @member VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT
  * @member VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID
  * @member VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID
  * @member VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID
  * @member VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
  * @member VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
  * @member VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR
  * @member VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR
  * @member VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV
  * @member VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT
  * @member VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV
  * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_GEOMETRY_NV
  * @member VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV
  * @member VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV
  * @member VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV
  * @member VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV
  * @member VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT
  * @member VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT
  * @member VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD
  * @member VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD
  * @member VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP
  * @member VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV
  * @member VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL
  * @member VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL
  * @member VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL
  * @member VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL
  * @member VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL
  * @member VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL
  * @member VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL
  * @member VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD
  * @member VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD
  * @member VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT
  * @member VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT
  * @member VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV
  * @member VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV
  * @member VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV
  * @member VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_RESERVED_QCOM
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV
  * @member VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR
  * @member VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR
  * @member VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR
  * @member VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR
  * @member VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR
  * @member VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR
  * @member VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR
  * @member VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR
  * @member VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR
  * @member VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR
  * @member VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR
  * @member VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR
  * @member VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR
  * @member VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR
  * @member VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR
  * @member VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR
  * @member VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR
  * @member VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR
  * @member VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR
  * @member VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR
  * @member VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR
  * @member VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR
  * @member VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR
  * @member VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR
  * @member VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR
  * @member VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR
  * @member VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR
  * @member VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT
  * @member VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR
  * @member VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR
  * @member VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR
  * @member VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR
  * @member VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT
  */
export enum VkStructureType {
  VK_STRUCTURE_TYPE_APPLICATION_INFO,
  VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
  VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
  VK_STRUCTURE_TYPE_SUBMIT_INFO,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
  VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
  VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
  VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
  VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
  VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
  VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
  VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
  VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
  VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
  VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
  VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
  VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
  VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
  VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
  VK_STRUCTURE_TYPE_MEMORY_BARRIER,
  VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
  VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
  VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
  VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
  VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
  VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
  VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
  VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
  VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
  VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
  VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
  VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
  VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
  VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
  VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
  VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
  VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
  VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
  VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
  VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO,
  VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
  VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
  VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
  VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
  VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
  VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
  VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
  VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
  VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
  VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
  VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
  VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
  VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
  VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
  VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
  VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
  VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
  VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID,
  VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID,
  VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX,
  VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
  VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
  VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
  VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
  VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
  VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
  VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
  VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
  VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
  VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
  VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
  VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
  VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT,
  VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT,
  VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT,
  VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT,
  VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
  VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
  VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
  VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
  VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR,
  VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
  VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
  VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR,
  VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR,
  VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
  VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR,
  VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR,
  VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR,
  VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR,
  VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR,
  VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR,
  VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK,
  VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
  VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
  VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
  VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
  VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR,
  VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR,
  VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,
  VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
  VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
  VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_GEOMETRY_NV,
  VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV,
  VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV,
  VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
  VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
  VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
  VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
  VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
  VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP,
  VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
  VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
  VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL,
  VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL,
  VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL,
  VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL,
  VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL,
  VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
  VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
  VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR,
  VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT,
  VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
  VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
  VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT,
  VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
  VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
  VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
  VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
  VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
  VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV,
  VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV,
  VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV,
  VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM,
  VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
  VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT,
  VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
  VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_RESERVED_QCOM,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV,
  VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT,
  VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR,
  VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR,
  VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR,
  VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR,
  VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR,
  VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR,
  VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR,
  VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR,
  VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR,
  VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR,
  VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
  VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR,
  VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR,
  VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR,
  VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR,
  VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR,
  VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR,
  VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR,
  VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR,
  VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR,
  VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR,
  VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR,
  VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR,
  VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR,
  VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR,
  VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR,
  VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR,
  VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR,
  VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR,
  VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR,
  VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR,
  VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR,
  VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR,
  VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR,
  VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT,
  VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR,
  VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR,
  VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR,
  VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT,
  
}

declare const VK_STRUCTURE_TYPE_APPLICATION_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBMIT_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: VkStructureType;
declare const VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: VkStructureType;
declare const VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_BARRIER: VkStructureType;
declare const VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBPASS_END_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: VkStructureType;
declare const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: VkStructureType;
declare const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO: VkStructureType;
declare const VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: VkStructureType;
declare const VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: VkStructureType;
declare const VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: VkStructureType;
declare const VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_HDR_METADATA_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK: VkStructureType;
declare const VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: VkStructureType;
declare const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: VkStructureType;
declare const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_GEOMETRY_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: VkStructureType;
declare const VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: VkStructureType;
declare const VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: VkStructureType;
declare const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL: VkStructureType;
declare const VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL: VkStructureType;
declare const VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL: VkStructureType;
declare const VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL: VkStructureType;
declare const VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL: VkStructureType;
declare const VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD: VkStructureType;
declare const VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_RESERVED_QCOM: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR: VkStructureType;
declare const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT: VkStructureType;



/**
  * Specify how commands in the first subpass of a render pass are provided
  * @member VK_SUBPASS_CONTENTS_INLINE specifies that the contents of the subpass will be recorded inline in the primary command buffer, and secondary command buffers 'must' not be executed within the subpass.
  * @member VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS specifies that the contents are recorded in secondary command buffers that will be called from the primary command buffer, and 'vkCmdExecuteCommands' is the only valid command on the command buffer until 'vkCmdNextSubpass' or 'vkCmdEndRenderPass'.
  */
export enum VkSubpassContents {
  VK_SUBPASS_CONTENTS_INLINE,
  VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
  
}

declare const VK_SUBPASS_CONTENTS_INLINE: VkSubpassContents;
declare const VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS: VkSubpassContents;



/**
  * Vulkan command return codes
  * @member VK_SUCCESS Command successfully completed
  * @member VK_NOT_READY A fence or query has not yet completed
  * @member VK_TIMEOUT A wait operation has not completed in the specified time
  * @member VK_EVENT_SET An event is signaled
  * @member VK_EVENT_RESET An event is unsignaled
  * @member VK_INCOMPLETE A return array was too small for the result
  * @member VK_ERROR_OUT_OF_HOST_MEMORY
  * @member VK_ERROR_OUT_OF_DEVICE_MEMORY
  * @member VK_ERROR_INITIALIZATION_FAILED
  * @member VK_ERROR_DEVICE_LOST
  * @member VK_ERROR_MEMORY_MAP_FAILED
  * @member VK_ERROR_LAYER_NOT_PRESENT
  * @member VK_ERROR_EXTENSION_NOT_PRESENT
  * @member VK_ERROR_FEATURE_NOT_PRESENT
  * @member VK_ERROR_INCOMPATIBLE_DRIVER
  * @member VK_ERROR_TOO_MANY_OBJECTS
  * @member VK_ERROR_FORMAT_NOT_SUPPORTED
  * @member VK_ERROR_FRAGMENTED_POOL
  * @member VK_ERROR_UNKNOWN
  * @member VK_ERROR_OUT_OF_POOL_MEMORY
  * @member VK_ERROR_INVALID_EXTERNAL_HANDLE
  * @member VK_ERROR_FRAGMENTATION
  * @member VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS
  * @member VK_ERROR_SURFACE_LOST_KHR
  * @member VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
  * @member VK_SUBOPTIMAL_KHR A swapchain no longer matches the surface properties exactly, but 'can' still be used to present to the surface successfully.
  * @member VK_ERROR_OUT_OF_DATE_KHR
  * @member VK_ERROR_INCOMPATIBLE_DISPLAY_KHR
  * @member VK_ERROR_VALIDATION_FAILED_EXT
  * @member VK_ERROR_INVALID_SHADER_NV
  * @member VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT
  * @member VK_ERROR_NOT_PERMITTED_EXT
  * @member VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
  * @member VK_THREAD_IDLE_KHR
  * @member VK_THREAD_DONE_KHR
  * @member VK_OPERATION_DEFERRED_KHR
  * @member VK_OPERATION_NOT_DEFERRED_KHR
  * @member VK_PIPELINE_COMPILE_REQUIRED_EXT
  * @member VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT
  * @member VK_ERROR_OUT_OF_POOL_MEMORY_KHR
  * @member VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR
  * @member VK_ERROR_FRAGMENTATION_EXT
  * @member VK_ERROR_INVALID_DEVICE_ADDRESS_EXT
  * @member VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR
  */
export enum VkResult {
  VK_SUCCESS,
  VK_NOT_READY,
  VK_TIMEOUT,
  VK_EVENT_SET,
  VK_EVENT_RESET,
  VK_INCOMPLETE,
  VK_ERROR_OUT_OF_HOST_MEMORY,
  VK_ERROR_OUT_OF_DEVICE_MEMORY,
  VK_ERROR_INITIALIZATION_FAILED,
  VK_ERROR_DEVICE_LOST,
  VK_ERROR_MEMORY_MAP_FAILED,
  VK_ERROR_LAYER_NOT_PRESENT,
  VK_ERROR_EXTENSION_NOT_PRESENT,
  VK_ERROR_FEATURE_NOT_PRESENT,
  VK_ERROR_INCOMPATIBLE_DRIVER,
  VK_ERROR_TOO_MANY_OBJECTS,
  VK_ERROR_FORMAT_NOT_SUPPORTED,
  VK_ERROR_FRAGMENTED_POOL,
  VK_ERROR_UNKNOWN,
  VK_ERROR_OUT_OF_POOL_MEMORY,
  VK_ERROR_INVALID_EXTERNAL_HANDLE,
  VK_ERROR_FRAGMENTATION,
  VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
  VK_ERROR_SURFACE_LOST_KHR,
  VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,
  VK_SUBOPTIMAL_KHR,
  VK_ERROR_OUT_OF_DATE_KHR,
  VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,
  VK_ERROR_VALIDATION_FAILED_EXT,
  VK_ERROR_INVALID_SHADER_NV,
  VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT,
  VK_ERROR_NOT_PERMITTED_EXT,
  VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,
  VK_THREAD_IDLE_KHR,
  VK_THREAD_DONE_KHR,
  VK_OPERATION_DEFERRED_KHR,
  VK_OPERATION_NOT_DEFERRED_KHR,
  VK_PIPELINE_COMPILE_REQUIRED_EXT,
  VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT,
  VK_ERROR_OUT_OF_POOL_MEMORY_KHR,
  VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,
  VK_ERROR_FRAGMENTATION_EXT,
  VK_ERROR_INVALID_DEVICE_ADDRESS_EXT,
  VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,
  
}

declare const VK_SUCCESS: VkResult;
declare const VK_NOT_READY: VkResult;
declare const VK_TIMEOUT: VkResult;
declare const VK_EVENT_SET: VkResult;
declare const VK_EVENT_RESET: VkResult;
declare const VK_INCOMPLETE: VkResult;
declare const VK_ERROR_OUT_OF_HOST_MEMORY: VkResult;
declare const VK_ERROR_OUT_OF_DEVICE_MEMORY: VkResult;
declare const VK_ERROR_INITIALIZATION_FAILED: VkResult;
declare const VK_ERROR_DEVICE_LOST: VkResult;
declare const VK_ERROR_MEMORY_MAP_FAILED: VkResult;
declare const VK_ERROR_LAYER_NOT_PRESENT: VkResult;
declare const VK_ERROR_EXTENSION_NOT_PRESENT: VkResult;
declare const VK_ERROR_FEATURE_NOT_PRESENT: VkResult;
declare const VK_ERROR_INCOMPATIBLE_DRIVER: VkResult;
declare const VK_ERROR_TOO_MANY_OBJECTS: VkResult;
declare const VK_ERROR_FORMAT_NOT_SUPPORTED: VkResult;
declare const VK_ERROR_FRAGMENTED_POOL: VkResult;
declare const VK_ERROR_UNKNOWN: VkResult;
declare const VK_ERROR_OUT_OF_POOL_MEMORY: VkResult;
declare const VK_ERROR_INVALID_EXTERNAL_HANDLE: VkResult;
declare const VK_ERROR_FRAGMENTATION: VkResult;
declare const VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: VkResult;
declare const VK_ERROR_SURFACE_LOST_KHR: VkResult;
declare const VK_ERROR_NATIVE_WINDOW_IN_USE_KHR: VkResult;
declare const VK_SUBOPTIMAL_KHR: VkResult;
declare const VK_ERROR_OUT_OF_DATE_KHR: VkResult;
declare const VK_ERROR_INCOMPATIBLE_DISPLAY_KHR: VkResult;
declare const VK_ERROR_VALIDATION_FAILED_EXT: VkResult;
declare const VK_ERROR_INVALID_SHADER_NV: VkResult;
declare const VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: VkResult;
declare const VK_ERROR_NOT_PERMITTED_EXT: VkResult;
declare const VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT: VkResult;
declare const VK_THREAD_IDLE_KHR: VkResult;
declare const VK_THREAD_DONE_KHR: VkResult;
declare const VK_OPERATION_DEFERRED_KHR: VkResult;
declare const VK_OPERATION_NOT_DEFERRED_KHR: VkResult;
declare const VK_PIPELINE_COMPILE_REQUIRED_EXT: VkResult;
declare const VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT: VkResult;
declare const VK_ERROR_OUT_OF_POOL_MEMORY_KHR: VkResult;
declare const VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR: VkResult;
declare const VK_ERROR_FRAGMENTATION_EXT: VkResult;
declare const VK_ERROR_INVALID_DEVICE_ADDRESS_EXT: VkResult;
declare const VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR: VkResult;



/**
  * Indicate which dynamic state is taken from dynamic state commands
  * @member VK_DYNAMIC_STATE_VIEWPORT
  * @member VK_DYNAMIC_STATE_SCISSOR
  * @member VK_DYNAMIC_STATE_LINE_WIDTH
  * @member VK_DYNAMIC_STATE_DEPTH_BIAS specifies that the 'depthBiasConstantFactor', 'depthBiasClamp' and 'depthBiasSlopeFactor' states in 'VkPipelineRasterizationStateCreateInfo' will be ignored and 'must' be set dynamically with 'vkCmdSetDepthBias' before any draws are performed with 'depthBiasEnable' in 'VkPipelineRasterizationStateCreateInfo' set to 'VK_TRUE'.
  * @member VK_DYNAMIC_STATE_BLEND_CONSTANTS specifies that the 'blendConstants' state in 'VkPipelineColorBlendStateCreateInfo' will be ignored and 'must' be set dynamically with 'vkCmdSetBlendConstants' before any draws are performed with a pipeline state with 'VkPipelineColorBlendAttachmentState' member 'blendEnable' set to 'VK_TRUE' and any of the blend functions using a constant blend color.
  * @member VK_DYNAMIC_STATE_DEPTH_BOUNDS specifies that the 'minDepthBounds' and 'maxDepthBounds' states of 'VkPipelineDepthStencilStateCreateInfo' will be ignored and 'must' be set dynamically with 'vkCmdSetDepthBounds' before any draws are performed with a pipeline state with 'VkPipelineDepthStencilStateCreateInfo' member 'depthBoundsTestEnable' set to 'VK_TRUE'.
  * @member VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK specifies that the 'compareMask' state in 'VkPipelineDepthStencilStateCreateInfo' for both 'front' and 'back' will be ignored and 'must' be set dynamically with 'vkCmdSetStencilCompareMask' before any draws are performed with a pipeline state with 'VkPipelineDepthStencilStateCreateInfo' member 'stencilTestEnable' set to 'VK_TRUE'
  * @member VK_DYNAMIC_STATE_STENCIL_WRITE_MASK specifies that the 'writeMask' state in 'VkPipelineDepthStencilStateCreateInfo' for both 'front' and 'back' will be ignored and 'must' be set dynamically with 'vkCmdSetStencilWriteMask' before any draws are performed with a pipeline state with 'VkPipelineDepthStencilStateCreateInfo' member 'stencilTestEnable' set to 'VK_TRUE'
  * @member VK_DYNAMIC_STATE_STENCIL_REFERENCE specifies that the 'reference' state in 'VkPipelineDepthStencilStateCreateInfo' for both 'front' and 'back' will be ignored and 'must' be set dynamically with 'vkCmdSetStencilReference' before any draws are performed with a pipeline state with 'VkPipelineDepthStencilStateCreateInfo' member 'stencilTestEnable' set to 'VK_TRUE'
  * @member VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV specifies that the 'pViewportScalings' state in 'VkPipelineViewportWScalingStateCreateInfoNV' will be ignored and 'must' be set dynamically with 'vkCmdSetViewportWScalingNV' before any draws are performed with a pipeline state with 'VkPipelineViewportWScalingStateCreateInfoNV' member 'viewportScalingEnable' set to 'VK_TRUE'
  * @member VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT
  * @member VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT
  * @member VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR
  * @member VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV
  * @member VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV
  * @member VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV
  * @member VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR
  * @member VK_DYNAMIC_STATE_LINE_STIPPLE_EXT
  * @member VK_DYNAMIC_STATE_CULL_MODE_EXT
  * @member VK_DYNAMIC_STATE_FRONT_FACE_EXT
  * @member VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT
  * @member VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT
  * @member VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT
  * @member VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT
  * @member VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT
  * @member VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT
  * @member VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT
  * @member VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT
  * @member VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT
  * @member VK_DYNAMIC_STATE_STENCIL_OP_EXT
  */
export enum VkDynamicState {
  VK_DYNAMIC_STATE_VIEWPORT,
  VK_DYNAMIC_STATE_SCISSOR,
  VK_DYNAMIC_STATE_LINE_WIDTH,
  VK_DYNAMIC_STATE_DEPTH_BIAS,
  VK_DYNAMIC_STATE_BLEND_CONSTANTS,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS,
  VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
  VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
  VK_DYNAMIC_STATE_STENCIL_REFERENCE,
  VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV,
  VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT,
  VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT,
  VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR,
  VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV,
  VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV,
  VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV,
  VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR,
  VK_DYNAMIC_STATE_LINE_STIPPLE_EXT,
  VK_DYNAMIC_STATE_CULL_MODE_EXT,
  VK_DYNAMIC_STATE_FRONT_FACE_EXT,
  VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT,
  VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT,
  VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT,
  VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT,
  VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT,
  VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT,
  VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT,
  VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT,
  VK_DYNAMIC_STATE_STENCIL_OP_EXT,
  
}

declare const VK_DYNAMIC_STATE_VIEWPORT: VkDynamicState;
declare const VK_DYNAMIC_STATE_SCISSOR: VkDynamicState;
declare const VK_DYNAMIC_STATE_LINE_WIDTH: VkDynamicState;
declare const VK_DYNAMIC_STATE_DEPTH_BIAS: VkDynamicState;
declare const VK_DYNAMIC_STATE_BLEND_CONSTANTS: VkDynamicState;
declare const VK_DYNAMIC_STATE_DEPTH_BOUNDS: VkDynamicState;
declare const VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK: VkDynamicState;
declare const VK_DYNAMIC_STATE_STENCIL_WRITE_MASK: VkDynamicState;
declare const VK_DYNAMIC_STATE_STENCIL_REFERENCE: VkDynamicState;
declare const VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV: VkDynamicState;
declare const VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR: VkDynamicState;
declare const VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV: VkDynamicState;
declare const VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV: VkDynamicState;
declare const VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV: VkDynamicState;
declare const VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR: VkDynamicState;
declare const VK_DYNAMIC_STATE_LINE_STIPPLE_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_CULL_MODE_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_FRONT_FACE_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT: VkDynamicState;
declare const VK_DYNAMIC_STATE_STENCIL_OP_EXT: VkDynamicState;



/**
  * Indicates the valid usage of the descriptor update template
  * @member VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET
  * @member VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
  * @member VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR
  */
export enum VkDescriptorUpdateTemplateType {
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR,
  
}

declare const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET: VkDescriptorUpdateTemplateType;
declare const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR: VkDescriptorUpdateTemplateType;
declare const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR: VkDescriptorUpdateTemplateType;



/**
  * Specify an enumeration to track object handle types
  * @member VK_OBJECT_TYPE_UNKNOWN
  * @member VK_OBJECT_TYPE_INSTANCE
  * @member VK_OBJECT_TYPE_PHYSICAL_DEVICE
  * @member VK_OBJECT_TYPE_DEVICE
  * @member VK_OBJECT_TYPE_QUEUE
  * @member VK_OBJECT_TYPE_SEMAPHORE
  * @member VK_OBJECT_TYPE_COMMAND_BUFFER
  * @member VK_OBJECT_TYPE_FENCE
  * @member VK_OBJECT_TYPE_DEVICE_MEMORY
  * @member VK_OBJECT_TYPE_BUFFER
  * @member VK_OBJECT_TYPE_IMAGE
  * @member VK_OBJECT_TYPE_EVENT
  * @member VK_OBJECT_TYPE_QUERY_POOL
  * @member VK_OBJECT_TYPE_BUFFER_VIEW
  * @member VK_OBJECT_TYPE_IMAGE_VIEW
  * @member VK_OBJECT_TYPE_SHADER_MODULE
  * @member VK_OBJECT_TYPE_PIPELINE_CACHE
  * @member VK_OBJECT_TYPE_PIPELINE_LAYOUT
  * @member VK_OBJECT_TYPE_RENDER_PASS
  * @member VK_OBJECT_TYPE_PIPELINE
  * @member VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT
  * @member VK_OBJECT_TYPE_SAMPLER
  * @member VK_OBJECT_TYPE_DESCRIPTOR_POOL
  * @member VK_OBJECT_TYPE_DESCRIPTOR_SET
  * @member VK_OBJECT_TYPE_FRAMEBUFFER
  * @member VK_OBJECT_TYPE_COMMAND_POOL
  * @member VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION
  * @member VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE
  * @member VK_OBJECT_TYPE_SURFACE_KHR
  * @member VK_OBJECT_TYPE_SWAPCHAIN_KHR
  * @member VK_OBJECT_TYPE_DISPLAY_KHR
  * @member VK_OBJECT_TYPE_DISPLAY_MODE_KHR
  * @member VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT
  * @member VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT
  * @member VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR
  * @member VK_OBJECT_TYPE_VALIDATION_CACHE_EXT
  * @member VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV
  * @member VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL
  * @member VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR
  * @member VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV
  * @member VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT
  * @member VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR
  * @member VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR
  */
export enum VkObjectType {
  VK_OBJECT_TYPE_UNKNOWN,
  VK_OBJECT_TYPE_INSTANCE,
  VK_OBJECT_TYPE_PHYSICAL_DEVICE,
  VK_OBJECT_TYPE_DEVICE,
  VK_OBJECT_TYPE_QUEUE,
  VK_OBJECT_TYPE_SEMAPHORE,
  VK_OBJECT_TYPE_COMMAND_BUFFER,
  VK_OBJECT_TYPE_FENCE,
  VK_OBJECT_TYPE_DEVICE_MEMORY,
  VK_OBJECT_TYPE_BUFFER,
  VK_OBJECT_TYPE_IMAGE,
  VK_OBJECT_TYPE_EVENT,
  VK_OBJECT_TYPE_QUERY_POOL,
  VK_OBJECT_TYPE_BUFFER_VIEW,
  VK_OBJECT_TYPE_IMAGE_VIEW,
  VK_OBJECT_TYPE_SHADER_MODULE,
  VK_OBJECT_TYPE_PIPELINE_CACHE,
  VK_OBJECT_TYPE_PIPELINE_LAYOUT,
  VK_OBJECT_TYPE_RENDER_PASS,
  VK_OBJECT_TYPE_PIPELINE,
  VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
  VK_OBJECT_TYPE_SAMPLER,
  VK_OBJECT_TYPE_DESCRIPTOR_POOL,
  VK_OBJECT_TYPE_DESCRIPTOR_SET,
  VK_OBJECT_TYPE_FRAMEBUFFER,
  VK_OBJECT_TYPE_COMMAND_POOL,
  VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
  VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
  VK_OBJECT_TYPE_SURFACE_KHR,
  VK_OBJECT_TYPE_SWAPCHAIN_KHR,
  VK_OBJECT_TYPE_DISPLAY_KHR,
  VK_OBJECT_TYPE_DISPLAY_MODE_KHR,
  VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT,
  VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
  VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR,
  VK_OBJECT_TYPE_VALIDATION_CACHE_EXT,
  VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV,
  VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL,
  VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR,
  VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV,
  VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT,
  VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR,
  VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR,
  
}

declare const VK_OBJECT_TYPE_UNKNOWN: VkObjectType;
declare const VK_OBJECT_TYPE_INSTANCE: VkObjectType;
declare const VK_OBJECT_TYPE_PHYSICAL_DEVICE: VkObjectType;
declare const VK_OBJECT_TYPE_DEVICE: VkObjectType;
declare const VK_OBJECT_TYPE_QUEUE: VkObjectType;
declare const VK_OBJECT_TYPE_SEMAPHORE: VkObjectType;
declare const VK_OBJECT_TYPE_COMMAND_BUFFER: VkObjectType;
declare const VK_OBJECT_TYPE_FENCE: VkObjectType;
declare const VK_OBJECT_TYPE_DEVICE_MEMORY: VkObjectType;
declare const VK_OBJECT_TYPE_BUFFER: VkObjectType;
declare const VK_OBJECT_TYPE_IMAGE: VkObjectType;
declare const VK_OBJECT_TYPE_EVENT: VkObjectType;
declare const VK_OBJECT_TYPE_QUERY_POOL: VkObjectType;
declare const VK_OBJECT_TYPE_BUFFER_VIEW: VkObjectType;
declare const VK_OBJECT_TYPE_IMAGE_VIEW: VkObjectType;
declare const VK_OBJECT_TYPE_SHADER_MODULE: VkObjectType;
declare const VK_OBJECT_TYPE_PIPELINE_CACHE: VkObjectType;
declare const VK_OBJECT_TYPE_PIPELINE_LAYOUT: VkObjectType;
declare const VK_OBJECT_TYPE_RENDER_PASS: VkObjectType;
declare const VK_OBJECT_TYPE_PIPELINE: VkObjectType;
declare const VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT: VkObjectType;
declare const VK_OBJECT_TYPE_SAMPLER: VkObjectType;
declare const VK_OBJECT_TYPE_DESCRIPTOR_POOL: VkObjectType;
declare const VK_OBJECT_TYPE_DESCRIPTOR_SET: VkObjectType;
declare const VK_OBJECT_TYPE_FRAMEBUFFER: VkObjectType;
declare const VK_OBJECT_TYPE_COMMAND_POOL: VkObjectType;
declare const VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION: VkObjectType;
declare const VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE: VkObjectType;
declare const VK_OBJECT_TYPE_SURFACE_KHR: VkObjectType;
declare const VK_OBJECT_TYPE_SWAPCHAIN_KHR: VkObjectType;
declare const VK_OBJECT_TYPE_DISPLAY_KHR: VkObjectType;
declare const VK_OBJECT_TYPE_DISPLAY_MODE_KHR: VkObjectType;
declare const VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT: VkObjectType;
declare const VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT: VkObjectType;
declare const VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR: VkObjectType;
declare const VK_OBJECT_TYPE_VALIDATION_CACHE_EXT: VkObjectType;
declare const VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV: VkObjectType;
declare const VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL: VkObjectType;
declare const VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR: VkObjectType;
declare const VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV: VkObjectType;
declare const VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT: VkObjectType;
declare const VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR: VkObjectType;
declare const VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR: VkObjectType;



/**
  * Sepcifies the type of a semaphore object
  * @member VK_SEMAPHORE_TYPE_BINARY
  * @member VK_SEMAPHORE_TYPE_TIMELINE
  * @member VK_SEMAPHORE_TYPE_BINARY_KHR
  * @member VK_SEMAPHORE_TYPE_TIMELINE_KHR
  */
export enum VkSemaphoreType {
  VK_SEMAPHORE_TYPE_BINARY,
  VK_SEMAPHORE_TYPE_TIMELINE,
  VK_SEMAPHORE_TYPE_BINARY_KHR,
  VK_SEMAPHORE_TYPE_TIMELINE_KHR,
  
}

declare const VK_SEMAPHORE_TYPE_BINARY: VkSemaphoreType;
declare const VK_SEMAPHORE_TYPE_TIMELINE: VkSemaphoreType;
declare const VK_SEMAPHORE_TYPE_BINARY_KHR: VkSemaphoreType;
declare const VK_SEMAPHORE_TYPE_TIMELINE_KHR: VkSemaphoreType;



/**
  * presentation mode supported for a surface
  * @member VK_PRESENT_MODE_IMMEDIATE_KHR specifies that the presentation engine does not wait for a vertical blanking period to update the current image, meaning this mode 'may' result in visible tearing. No internal queuing of presentation requests is needed, as the requests are applied immediately.
  * @member VK_PRESENT_MODE_MAILBOX_KHR specifies that the presentation engine waits for the next vertical blanking period to update the current image. Tearing 'cannot' be observed. An internal single-entry queue is used to hold pending presentation requests. If the queue is full when a new presentation request is received, the new request replaces the existing entry, and any images associated with the prior entry become available for re-use by the application. One request is removed from the queue and processed during each vertical blanking period in which the queue is non-empty.
  * @member VK_PRESENT_MODE_FIFO_KHR specifies that the presentation engine waits for the next vertical blanking period to update the current image. Tearing 'cannot' be observed. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during each vertical blanking period in which the queue is non-empty. This is the only value of 'presentMode' that is 'required' to be supported.
  * @member VK_PRESENT_MODE_FIFO_RELAXED_KHR specifies that the presentation engine generally waits for the next vertical blanking period to update the current image. If a vertical blanking period has already passed since the last update of the current image then the presentation engine does not wait for another vertical blanking period for the update, meaning this mode 'may' result in visible tearing in this case. This mode is useful for reducing visual stutter with an application that will mostly present a new image before the next vertical blanking period, but may occasionally be late, and present a new image just after the next vertical blanking period. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during or after each vertical blanking period in which the queue is non-empty.
  * @member VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR specifies that the presentation engine and application have concurrent access to a single image, which is referred to as a _shared presentable image_. The presentation engine is only required to update the current image after a new presentation request is received. Therefore the application 'must' make a presentation request whenever an update is required. However, the presentation engine 'may' update the current image at any point, meaning this mode 'may' result in visible tearing.
  * @member VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR specifies that the presentation engine and application have concurrent access to a single image, which is referred to as a _shared presentable image_. The presentation engine periodically updates the current image on its regular refresh cycle. The application is only required to make one initial presentation request, after which the presentation engine 'must' update the current image without any need for further presentation requests. The application 'can' indicate the image contents have been updated by making a presentation request, but this does not guarantee the timing of when it will be updated. This mode 'may' result in visible tearing if rendering to the image is not timed correctly.
  */
export enum VkPresentModeKHR {
  VK_PRESENT_MODE_IMMEDIATE_KHR,
  VK_PRESENT_MODE_MAILBOX_KHR,
  VK_PRESENT_MODE_FIFO_KHR,
  VK_PRESENT_MODE_FIFO_RELAXED_KHR,
  VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,
  VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR,
  
}

declare const VK_PRESENT_MODE_IMMEDIATE_KHR: VkPresentModeKHR;
declare const VK_PRESENT_MODE_MAILBOX_KHR: VkPresentModeKHR;
declare const VK_PRESENT_MODE_FIFO_KHR: VkPresentModeKHR;
declare const VK_PRESENT_MODE_FIFO_RELAXED_KHR: VkPresentModeKHR;
declare const VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR: VkPresentModeKHR;
declare const VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR: VkPresentModeKHR;



/**
  * supported color space of the presentation engine
  * @member VK_COLOR_SPACE_SRGB_NONLINEAR_KHR specifies support for the sRGB color space.
  * @member VK_COLORSPACE_SRGB_NONLINEAR_KHR
  * @member VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT specifies support for the Display-P3 color space to be displayed using an sRGB-like EOTF (defined below).
  * @member VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT specifies support for the extended sRGB color space to be displayed using a linear EOTF.
  * @member VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT specifies support for the Display-P3 color space to be displayed using a linear EOTF.
  * @member VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT specifies support for the DCI-P3 color space to be displayed using the DCI-P3 EOTF. Note that values in such an image are interpreted as XYZ encoded color data by the presentation engine.
  * @member VK_COLOR_SPACE_BT709_LINEAR_EXT specifies support for the BT709 color space to be displayed using a linear EOTF.
  * @member VK_COLOR_SPACE_BT709_NONLINEAR_EXT specifies support for the BT709 color space to be displayed using the SMPTE 170M EOTF.
  * @member VK_COLOR_SPACE_BT2020_LINEAR_EXT specifies support for the BT2020 color space to be displayed using a linear EOTF.
  * @member VK_COLOR_SPACE_HDR10_ST2084_EXT specifies support for the HDR10 (BT2020 color) space to be displayed using the SMPTE ST2084 Perceptual Quantizer (PQ) EOTF.
  * @member VK_COLOR_SPACE_DOLBYVISION_EXT specifies support for the Dolby Vision (BT2020 color space), proprietary encoding, to be displayed using the SMPTE ST2084 EOTF.
  * @member VK_COLOR_SPACE_HDR10_HLG_EXT specifies support for the HDR10 (BT2020 color space) to be displayed using the Hybrid Log Gamma (HLG) EOTF.
  * @member VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT specifies support for the AdobeRGB color space to be displayed using a linear EOTF.
  * @member VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT specifies support for the AdobeRGB color space to be displayed using the Gamma 2.2 EOTF.
  * @member VK_COLOR_SPACE_PASS_THROUGH_EXT specifies that color components are used "`as is`". This is intended to allow applications to supply data for color spaces not described here.ifdef::VK_AMD_display_native_hdr[]
  * @member VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT specifies support for the extended sRGB color space to be displayed using an sRGB EOTF.
  * @member VK_COLOR_SPACE_DCI_P3_LINEAR_EXT
  * @member VK_COLOR_SPACE_DISPLAY_NATIVE_AMD specifies support for the display's native color space. This matches the color space expectations of AMD's FreeSync2 standard, for displays supporting it.
  */
export enum VkColorSpaceKHR {
  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
  VK_COLORSPACE_SRGB_NONLINEAR_KHR,
  VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,
  VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,
  VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
  VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,
  VK_COLOR_SPACE_BT709_LINEAR_EXT,
  VK_COLOR_SPACE_BT709_NONLINEAR_EXT,
  VK_COLOR_SPACE_BT2020_LINEAR_EXT,
  VK_COLOR_SPACE_HDR10_ST2084_EXT,
  VK_COLOR_SPACE_DOLBYVISION_EXT,
  VK_COLOR_SPACE_HDR10_HLG_EXT,
  VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,
  VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,
  VK_COLOR_SPACE_PASS_THROUGH_EXT,
  VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,
  VK_COLOR_SPACE_DCI_P3_LINEAR_EXT,
  VK_COLOR_SPACE_DISPLAY_NATIVE_AMD,
  
}

declare const VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: VkColorSpaceKHR;
declare const VK_COLORSPACE_SRGB_NONLINEAR_KHR: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_BT709_LINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_BT709_NONLINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_BT2020_LINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_HDR10_ST2084_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_DOLBYVISION_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_HDR10_HLG_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_PASS_THROUGH_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_DCI_P3_LINEAR_EXT: VkColorSpaceKHR;
declare const VK_COLOR_SPACE_DISPLAY_NATIVE_AMD: VkColorSpaceKHR;



/**
  * Supported time domains
  * @member VK_TIME_DOMAIN_DEVICE_EXT specifies the device time domain. Timestamp values in this time domain use the same units and are comparable with device timestamp values captured using 'vkCmdWriteTimestamp' and are defined to be incrementing according to the <<limits-timestampPeriod,timestampPeriod>> of the device.
  * @member VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT
  * @member VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT
  * @member VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT
  */
export enum VkTimeDomainEXT {
  VK_TIME_DOMAIN_DEVICE_EXT,
  VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT,
  VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT,
  VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT,
  
}

declare const VK_TIME_DOMAIN_DEVICE_EXT: VkTimeDomainEXT;
declare const VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT: VkTimeDomainEXT;
declare const VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT: VkTimeDomainEXT;
declare const VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT: VkTimeDomainEXT;



/**
  * Specify the type of an object handle
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT
  * @member VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT
  */
export enum VkDebugReportObjectTypeEXT {
  VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT,
  
}

declare const VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT: VkDebugReportObjectTypeEXT;
declare const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT: VkDebugReportObjectTypeEXT;



/**
  * Events that can occur on a device memory object
  * @member VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT specifies this event corresponds to the allocation of an internal device memory object or a 'VkDeviceMemory'.
  * @member VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT specifies this event corresponds to the deallocation of an internally-allocated device memory object or a 'VkDeviceMemory'.
  * @member VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT specifies this event corresponds to the import of an external memory object.
  * @member VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT specifies this event is the release of an imported external memory object.
  * @member VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT specifies this event corresponds to the failed allocation of an internal device memory object or a 'VkDeviceMemory'.
  */
export enum VkDeviceMemoryReportEventTypeEXT {
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT,
  
}

declare const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT: VkDeviceMemoryReportEventTypeEXT;
declare const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT: VkDeviceMemoryReportEventTypeEXT;
declare const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT: VkDeviceMemoryReportEventTypeEXT;
declare const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT: VkDeviceMemoryReportEventTypeEXT;
declare const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT: VkDeviceMemoryReportEventTypeEXT;



/**
  * Specify rasterization order for a graphics pipeline
  * @member VK_RASTERIZATION_ORDER_STRICT_AMD specifies that operations for each primitive in a subpass 'must' occur in <<drawing-primitive-order, primitive order>>.
  * @member VK_RASTERIZATION_ORDER_RELAXED_AMD specifies that operations for each primitive in a subpass 'may' not occur in <<drawing-primitive-order, primitive order>>.
  */
export enum VkRasterizationOrderAMD {
  VK_RASTERIZATION_ORDER_STRICT_AMD,
  VK_RASTERIZATION_ORDER_RELAXED_AMD,
  
}

declare const VK_RASTERIZATION_ORDER_STRICT_AMD: VkRasterizationOrderAMD;
declare const VK_RASTERIZATION_ORDER_RELAXED_AMD: VkRasterizationOrderAMD;



/**
  * Specify validation checks to disable
  * @member VK_VALIDATION_CHECK_ALL_EXT specifies that all validation checks are disabled.
  * @member VK_VALIDATION_CHECK_SHADERS_EXT specifies that shader validation is disabled.
  */
export enum VkValidationCheckEXT {
  VK_VALIDATION_CHECK_ALL_EXT,
  VK_VALIDATION_CHECK_SHADERS_EXT,
  
}

declare const VK_VALIDATION_CHECK_ALL_EXT: VkValidationCheckEXT;
declare const VK_VALIDATION_CHECK_SHADERS_EXT: VkValidationCheckEXT;



/**
  * Specify validation features to enable
  * @member VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT specifies that GPU-assisted validation is enabled. Activating this feature instruments shader programs to generate additional diagnostic data. This feature is disabled by default.
  * @member VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT specifies that the validation layers reserve a descriptor set binding slot for their own use. The layer reports a value for 'VkPhysicalDeviceLimits'::'maxBoundDescriptorSets' that is one less than the value reported by the device. If the device supports the binding of only one descriptor set, the validation layer does not perform GPU-assisted validation. This feature is disabled by default.
  * @member VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT specifies that Vulkan best-practices validation is enabled. Activating this feature enables the output of warnings related to common misuse of the API, but which are not explicitly prohibited by the specification. This feature is disabled by default.
  * @member VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT specifies that the layers will process 'debugPrintfEXT' operations in shaders and send the resulting output to the debug callback. This feature is disabled by default.
  * @member VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT specifies that Vulkan synchronization validation is enabled. This feature reports resource access conflicts due to missing or incorrect synchronization operations between actions (Draw, Copy, Dispatch, Blit) reading or writing the same regions of memory. This feature is disabled by default.
  */
export enum VkValidationFeatureEnableEXT {
  VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
  VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
  VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,
  VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT,
  VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT,
  
}

declare const VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT: VkValidationFeatureEnableEXT;
declare const VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT: VkValidationFeatureEnableEXT;
declare const VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT: VkValidationFeatureEnableEXT;
declare const VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT: VkValidationFeatureEnableEXT;
declare const VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT: VkValidationFeatureEnableEXT;



/**
  * Specify validation features to disable
  * @member VK_VALIDATION_FEATURE_DISABLE_ALL_EXT specifies that all validation checks are disabled.
  * @member VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT specifies that shader validation is disabled. This feature is enabled by default.
  * @member VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT specifies that thread safety validation is disabled. This feature is enabled by default.
  * @member VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT specifies that stateless parameter validation is disabled. This feature is enabled by default.
  * @member VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT specifies that object lifetime validation is disabled. This feature is enabled by default.
  * @member VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT specifies that core validation checks are disabled. This feature is enabled by default. If this feature is disabled, the shader validation and GPU-assisted validation features are also disabled.
  * @member VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT specifies that protection against duplicate non-dispatchable object handles is disabled. This feature is enabled by default.
  */
export enum VkValidationFeatureDisableEXT {
  VK_VALIDATION_FEATURE_DISABLE_ALL_EXT,
  VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
  VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT,
  VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT,
  VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT,
  VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT,
  VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT,
  
}

declare const VK_VALIDATION_FEATURE_DISABLE_ALL_EXT: VkValidationFeatureDisableEXT;
declare const VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT: VkValidationFeatureDisableEXT;
declare const VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT: VkValidationFeatureDisableEXT;
declare const VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT: VkValidationFeatureDisableEXT;
declare const VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT: VkValidationFeatureDisableEXT;
declare const VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT: VkValidationFeatureDisableEXT;
declare const VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT: VkValidationFeatureDisableEXT;



/**
  * Enum specifying token commands
  * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV
  * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV
  * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV
  * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV
  * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV
  * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV
  * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV
  * @member VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV
  */
export enum VkIndirectCommandsTokenTypeNV {
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
  
}

declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV: VkIndirectCommandsTokenTypeNV;
declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV: VkIndirectCommandsTokenTypeNV;
declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV: VkIndirectCommandsTokenTypeNV;
declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV: VkIndirectCommandsTokenTypeNV;
declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV: VkIndirectCommandsTokenTypeNV;
declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV: VkIndirectCommandsTokenTypeNV;
declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV: VkIndirectCommandsTokenTypeNV;
declare const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV: VkIndirectCommandsTokenTypeNV;



/**
  * Possible power states for a display
  * @member VK_DISPLAY_POWER_STATE_OFF_EXT specifies that the display is powered down.
  * @member VK_DISPLAY_POWER_STATE_SUSPEND_EXT specifies that the display is put into a low power mode, from which it 'may' be able to transition back to 'VK_DISPLAY_POWER_STATE_ON_EXT' more quickly than if it were in 'VK_DISPLAY_POWER_STATE_OFF_EXT'. This state 'may' be the same as 'VK_DISPLAY_POWER_STATE_OFF_EXT'.
  * @member VK_DISPLAY_POWER_STATE_ON_EXT specifies that the display is powered on.
  */
export enum VkDisplayPowerStateEXT {
  VK_DISPLAY_POWER_STATE_OFF_EXT,
  VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
  VK_DISPLAY_POWER_STATE_ON_EXT,
  
}

declare const VK_DISPLAY_POWER_STATE_OFF_EXT: VkDisplayPowerStateEXT;
declare const VK_DISPLAY_POWER_STATE_SUSPEND_EXT: VkDisplayPowerStateEXT;
declare const VK_DISPLAY_POWER_STATE_ON_EXT: VkDisplayPowerStateEXT;



/**
  * Events that can occur on a device object
  * @member VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT specifies that the fence is signaled when a display is plugged into or unplugged from the specified device. Applications 'can' use this notification to determine when they need to re-enumerate the available displays on a device.
  */
export enum VkDeviceEventTypeEXT {
  VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
  
}

declare const VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT: VkDeviceEventTypeEXT;



/**
  * Events that can occur on a display object
  * @member VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT specifies that the fence is signaled when the first pixel of the next display refresh cycle leaves the display engine for the display.
  */
export enum VkDisplayEventTypeEXT {
  VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
  
}

declare const VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT: VkDisplayEventTypeEXT;



/**
  * Specify how a viewport coordinate is swizzled
  * @member VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV
  * @member VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV
  * @member VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV
  * @member VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV
  * @member VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV
  * @member VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV
  * @member VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV
  * @member VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV
  */
export enum VkViewportCoordinateSwizzleNV {
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
  
}

declare const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV: VkViewportCoordinateSwizzleNV;
declare const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV: VkViewportCoordinateSwizzleNV;
declare const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV: VkViewportCoordinateSwizzleNV;
declare const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV: VkViewportCoordinateSwizzleNV;
declare const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV: VkViewportCoordinateSwizzleNV;
declare const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV: VkViewportCoordinateSwizzleNV;
declare const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV: VkViewportCoordinateSwizzleNV;
declare const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV: VkViewportCoordinateSwizzleNV;



/**
  * Specify the discard rectangle mode
  * @member VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT specifies that the discard rectangle test is inclusive.
  * @member VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT specifies that the discard rectangle test is exclusive.
  */
export enum VkDiscardRectangleModeEXT {
  VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
  VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
  
}

declare const VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT: VkDiscardRectangleModeEXT;
declare const VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT: VkDiscardRectangleModeEXT;



/**
  * Enum specifying the point clipping behavior
  * @member VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES
  * @member VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY
  * @member VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR
  * @member VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR
  */
export enum VkPointClippingBehavior {
  VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
  VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
  VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR,
  VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR,
  
}

declare const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES: VkPointClippingBehavior;
declare const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY: VkPointClippingBehavior;
declare const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR: VkPointClippingBehavior;
declare const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR: VkPointClippingBehavior;



/**
  * Specify reduction mode for texture filtering
  * @member VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE
  * @member VK_SAMPLER_REDUCTION_MODE_MIN
  * @member VK_SAMPLER_REDUCTION_MODE_MAX
  * @member VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT
  * @member VK_SAMPLER_REDUCTION_MODE_MIN_EXT
  * @member VK_SAMPLER_REDUCTION_MODE_MAX_EXT
  */
export enum VkSamplerReductionMode {
  VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
  VK_SAMPLER_REDUCTION_MODE_MIN,
  VK_SAMPLER_REDUCTION_MODE_MAX,
  VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT,
  VK_SAMPLER_REDUCTION_MODE_MIN_EXT,
  VK_SAMPLER_REDUCTION_MODE_MAX_EXT,
  
}

declare const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE: VkSamplerReductionMode;
declare const VK_SAMPLER_REDUCTION_MODE_MIN: VkSamplerReductionMode;
declare const VK_SAMPLER_REDUCTION_MODE_MAX: VkSamplerReductionMode;
declare const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT: VkSamplerReductionMode;
declare const VK_SAMPLER_REDUCTION_MODE_MIN_EXT: VkSamplerReductionMode;
declare const VK_SAMPLER_REDUCTION_MODE_MAX_EXT: VkSamplerReductionMode;



/**
  * Enum describing tessellation domain origin
  * @member VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT
  * @member VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT
  * @member VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR
  * @member VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR
  */
export enum VkTessellationDomainOrigin {
  VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
  VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
  VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR,
  VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR,
  
}

declare const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT: VkTessellationDomainOrigin;
declare const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT: VkTessellationDomainOrigin;
declare const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR: VkTessellationDomainOrigin;
declare const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR: VkTessellationDomainOrigin;



/**
  * Color model component of a color space
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR
  */
export enum VkSamplerYcbcrModelConversion {
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR,
  
}

declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY: VkSamplerYcbcrModelConversion;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY: VkSamplerYcbcrModelConversion;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709: VkSamplerYcbcrModelConversion;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601: VkSamplerYcbcrModelConversion;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020: VkSamplerYcbcrModelConversion;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR: VkSamplerYcbcrModelConversion;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR: VkSamplerYcbcrModelConversion;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR: VkSamplerYcbcrModelConversion;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR: VkSamplerYcbcrModelConversion;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR: VkSamplerYcbcrModelConversion;



/**
  * Range of encoded values in a color space
  * @member VK_SAMPLER_YCBCR_RANGE_ITU_FULL
  * @member VK_SAMPLER_YCBCR_RANGE_ITU_NARROW
  * @member VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR
  * @member VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR
  */
export enum VkSamplerYcbcrRange {
  VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
  VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
  VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR,
  VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR,
  
}

declare const VK_SAMPLER_YCBCR_RANGE_ITU_FULL: VkSamplerYcbcrRange;
declare const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW: VkSamplerYcbcrRange;
declare const VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR: VkSamplerYcbcrRange;
declare const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR: VkSamplerYcbcrRange;



/**
  * Position of downsampled chroma samples
  * @member VK_CHROMA_LOCATION_COSITED_EVEN
  * @member VK_CHROMA_LOCATION_MIDPOINT
  * @member VK_CHROMA_LOCATION_COSITED_EVEN_KHR
  * @member VK_CHROMA_LOCATION_MIDPOINT_KHR
  */
export enum VkChromaLocation {
  VK_CHROMA_LOCATION_COSITED_EVEN,
  VK_CHROMA_LOCATION_MIDPOINT,
  VK_CHROMA_LOCATION_COSITED_EVEN_KHR,
  VK_CHROMA_LOCATION_MIDPOINT_KHR,
  
}

declare const VK_CHROMA_LOCATION_COSITED_EVEN: VkChromaLocation;
declare const VK_CHROMA_LOCATION_MIDPOINT: VkChromaLocation;
declare const VK_CHROMA_LOCATION_COSITED_EVEN_KHR: VkChromaLocation;
declare const VK_CHROMA_LOCATION_MIDPOINT_KHR: VkChromaLocation;



/**
  * Enumerant specifying the blend overlap parameter
  * @member VK_BLEND_OVERLAP_UNCORRELATED_EXT specifies that there is no correlation between the source and destination coverage.
  * @member VK_BLEND_OVERLAP_DISJOINT_EXT specifies that the source and destination coverage are considered to have minimal overlap.
  * @member VK_BLEND_OVERLAP_CONJOINT_EXT specifies that the source and destination coverage are considered to have maximal overlap.
  */
export enum VkBlendOverlapEXT {
  VK_BLEND_OVERLAP_UNCORRELATED_EXT,
  VK_BLEND_OVERLAP_DISJOINT_EXT,
  VK_BLEND_OVERLAP_CONJOINT_EXT,
  
}

declare const VK_BLEND_OVERLAP_UNCORRELATED_EXT: VkBlendOverlapEXT;
declare const VK_BLEND_OVERLAP_DISJOINT_EXT: VkBlendOverlapEXT;
declare const VK_BLEND_OVERLAP_CONJOINT_EXT: VkBlendOverlapEXT;



/**
  * Specify the coverage modulation mode
  * @member VK_COVERAGE_MODULATION_MODE_NONE_NV
  * @member VK_COVERAGE_MODULATION_MODE_RGB_NV
  * @member VK_COVERAGE_MODULATION_MODE_ALPHA_NV
  * @member VK_COVERAGE_MODULATION_MODE_RGBA_NV
  */
export enum VkCoverageModulationModeNV {
  VK_COVERAGE_MODULATION_MODE_NONE_NV,
  VK_COVERAGE_MODULATION_MODE_RGB_NV,
  VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
  VK_COVERAGE_MODULATION_MODE_RGBA_NV,
  
}

declare const VK_COVERAGE_MODULATION_MODE_NONE_NV: VkCoverageModulationModeNV;
declare const VK_COVERAGE_MODULATION_MODE_RGB_NV: VkCoverageModulationModeNV;
declare const VK_COVERAGE_MODULATION_MODE_ALPHA_NV: VkCoverageModulationModeNV;
declare const VK_COVERAGE_MODULATION_MODE_RGBA_NV: VkCoverageModulationModeNV;



/**
  * Specify the coverage reduction mode
  * @member VK_COVERAGE_REDUCTION_MODE_MERGE_NV
  * @member VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV
  */
export enum VkCoverageReductionModeNV {
  VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
  VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
  
}

declare const VK_COVERAGE_REDUCTION_MODE_MERGE_NV: VkCoverageReductionModeNV;
declare const VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV: VkCoverageReductionModeNV;



/**
  * Encode validation cache version
  * @member VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT
  */
export enum VkValidationCacheHeaderVersionEXT {
  VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT,
  
}

declare const VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT: VkValidationCacheHeaderVersionEXT;



/**
  * Enum specifying which type of shader info to query
  * @member VK_SHADER_INFO_TYPE_STATISTICS_AMD
  * @member VK_SHADER_INFO_TYPE_BINARY_AMD
  * @member VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD
  */
export enum VkShaderInfoTypeAMD {
  VK_SHADER_INFO_TYPE_STATISTICS_AMD,
  VK_SHADER_INFO_TYPE_BINARY_AMD,
  VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
  
}

declare const VK_SHADER_INFO_TYPE_STATISTICS_AMD: VkShaderInfoTypeAMD;
declare const VK_SHADER_INFO_TYPE_BINARY_AMD: VkShaderInfoTypeAMD;
declare const VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD: VkShaderInfoTypeAMD;



/**
  * Values specifying a system-wide queue priority
  * @member VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT
  * @member VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT
  * @member VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT
  * @member VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT
  */
export enum VkQueueGlobalPriorityEXT {
  VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT,
  VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT,
  VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT,
  VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT,
  
}

declare const VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT: VkQueueGlobalPriorityEXT;
declare const VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT: VkQueueGlobalPriorityEXT;
declare const VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT: VkQueueGlobalPriorityEXT;
declare const VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT: VkQueueGlobalPriorityEXT;



/**
  * Specify the conservative rasterization mode
  * @member VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT specifies that conservative rasterization is disabled and rasterization proceeds as normal.
  * @member VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT specifies that conservative rasterization is enabled in overestimation mode.
  * @member VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT specifies that conservative rasterization is enabled in underestimation mode.
  */
export enum VkConservativeRasterizationModeEXT {
  VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
  VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
  VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
  
}

declare const VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT: VkConservativeRasterizationModeEXT;
declare const VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT: VkConservativeRasterizationModeEXT;
declare const VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT: VkConservativeRasterizationModeEXT;



/**
  * Khronos vendor IDs
  * @member VK_VENDOR_ID_VIV
  * @member VK_VENDOR_ID_VSI
  * @member VK_VENDOR_ID_KAZAN
  * @member VK_VENDOR_ID_CODEPLAY
  * @member VK_VENDOR_ID_MESA
  */
export enum VkVendorId {
  VK_VENDOR_ID_VIV,
  VK_VENDOR_ID_VSI,
  VK_VENDOR_ID_KAZAN,
  VK_VENDOR_ID_CODEPLAY,
  VK_VENDOR_ID_MESA,
  
}

declare const VK_VENDOR_ID_VIV: VkVendorId;
declare const VK_VENDOR_ID_VSI: VkVendorId;
declare const VK_VENDOR_ID_KAZAN: VkVendorId;
declare const VK_VENDOR_ID_CODEPLAY: VkVendorId;
declare const VK_VENDOR_ID_MESA: VkVendorId;



/**
  * Khronos driver IDs
  * @member VK_DRIVER_ID_AMD_PROPRIETARY
  * @member VK_DRIVER_ID_AMD_OPEN_SOURCE
  * @member VK_DRIVER_ID_MESA_RADV
  * @member VK_DRIVER_ID_NVIDIA_PROPRIETARY
  * @member VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS
  * @member VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA
  * @member VK_DRIVER_ID_IMAGINATION_PROPRIETARY
  * @member VK_DRIVER_ID_QUALCOMM_PROPRIETARY
  * @member VK_DRIVER_ID_ARM_PROPRIETARY
  * @member VK_DRIVER_ID_GOOGLE_SWIFTSHADER
  * @member VK_DRIVER_ID_GGP_PROPRIETARY
  * @member VK_DRIVER_ID_BROADCOM_PROPRIETARY
  * @member VK_DRIVER_ID_MESA_LLVMPIPE
  * @member VK_DRIVER_ID_MOLTENVK
  * @member VK_DRIVER_ID_AMD_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR
  * @member VK_DRIVER_ID_MESA_RADV_KHR
  * @member VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR
  * @member VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR
  * @member VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_ARM_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR
  * @member VK_DRIVER_ID_GGP_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR
  */
export enum VkDriverId {
  VK_DRIVER_ID_AMD_PROPRIETARY,
  VK_DRIVER_ID_AMD_OPEN_SOURCE,
  VK_DRIVER_ID_MESA_RADV,
  VK_DRIVER_ID_NVIDIA_PROPRIETARY,
  VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
  VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
  VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
  VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
  VK_DRIVER_ID_ARM_PROPRIETARY,
  VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
  VK_DRIVER_ID_GGP_PROPRIETARY,
  VK_DRIVER_ID_BROADCOM_PROPRIETARY,
  VK_DRIVER_ID_MESA_LLVMPIPE,
  VK_DRIVER_ID_MOLTENVK,
  VK_DRIVER_ID_AMD_PROPRIETARY_KHR,
  VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR,
  VK_DRIVER_ID_MESA_RADV_KHR,
  VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR,
  VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR,
  VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR,
  VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR,
  VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR,
  VK_DRIVER_ID_ARM_PROPRIETARY_KHR,
  VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR,
  VK_DRIVER_ID_GGP_PROPRIETARY_KHR,
  VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR,
  
}

declare const VK_DRIVER_ID_AMD_PROPRIETARY: VkDriverId;
declare const VK_DRIVER_ID_AMD_OPEN_SOURCE: VkDriverId;
declare const VK_DRIVER_ID_MESA_RADV: VkDriverId;
declare const VK_DRIVER_ID_NVIDIA_PROPRIETARY: VkDriverId;
declare const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS: VkDriverId;
declare const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA: VkDriverId;
declare const VK_DRIVER_ID_IMAGINATION_PROPRIETARY: VkDriverId;
declare const VK_DRIVER_ID_QUALCOMM_PROPRIETARY: VkDriverId;
declare const VK_DRIVER_ID_ARM_PROPRIETARY: VkDriverId;
declare const VK_DRIVER_ID_GOOGLE_SWIFTSHADER: VkDriverId;
declare const VK_DRIVER_ID_GGP_PROPRIETARY: VkDriverId;
declare const VK_DRIVER_ID_BROADCOM_PROPRIETARY: VkDriverId;
declare const VK_DRIVER_ID_MESA_LLVMPIPE: VkDriverId;
declare const VK_DRIVER_ID_MOLTENVK: VkDriverId;
declare const VK_DRIVER_ID_AMD_PROPRIETARY_KHR: VkDriverId;
declare const VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR: VkDriverId;
declare const VK_DRIVER_ID_MESA_RADV_KHR: VkDriverId;
declare const VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR: VkDriverId;
declare const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR: VkDriverId;
declare const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR: VkDriverId;
declare const VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR: VkDriverId;
declare const VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR: VkDriverId;
declare const VK_DRIVER_ID_ARM_PROPRIETARY_KHR: VkDriverId;
declare const VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR: VkDriverId;
declare const VK_DRIVER_ID_GGP_PROPRIETARY_KHR: VkDriverId;
declare const VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR: VkDriverId;



/**
  * Shading rate image palette entry types
  * @member VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV
  * @member VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV
  */
export enum VkShadingRatePaletteEntryNV {
  VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
  
}

declare const VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV: VkShadingRatePaletteEntryNV;
declare const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV: VkShadingRatePaletteEntryNV;



/**
  * Shading rate image sample ordering types
  * @member VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV specifies that coverage samples will be ordered in an implementation-dependent manner.
  * @member VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV specifies that coverage samples will be ordered according to the array of custom orderings provided in either the 'pCustomSampleOrders' member of 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV' or the 'pCustomSampleOrders' member of 'vkCmdSetCoarseSampleOrderNV'.
  * @member VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV specifies that coverage samples will be ordered sequentially, sorted first by pixel coordinate (in row-major order) and then by <<primsrast-multisampling-coverage-mask, sample index>>.
  * @member VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV specifies that coverage samples will be ordered sequentially, sorted first by <<primsrast-multisampling-coverage-mask, sample index>> and then by pixel coordinate (in row-major order).
  */
export enum VkCoarseSampleOrderTypeNV {
  VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
  VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
  VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
  VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
  
}

declare const VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV: VkCoarseSampleOrderTypeNV;
declare const VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV: VkCoarseSampleOrderTypeNV;
declare const VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV: VkCoarseSampleOrderTypeNV;
declare const VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV: VkCoarseSampleOrderTypeNV;



/**
  * Acceleration structure copy mode
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV
  */
export enum VkCopyAccelerationStructureModeKHR {
  VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV,
  
}

declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR: VkCopyAccelerationStructureModeKHR;
declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR: VkCopyAccelerationStructureModeKHR;
declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR: VkCopyAccelerationStructureModeKHR;
declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR: VkCopyAccelerationStructureModeKHR;
declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV: VkCopyAccelerationStructureModeKHR;
declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV: VkCopyAccelerationStructureModeKHR;



/**
  * Enum specifying the type of build operation to perform
  * @member VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR
  */
export enum VkBuildAccelerationStructureModeKHR {
  VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
  
}

declare const VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR: VkBuildAccelerationStructureModeKHR;
declare const VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR: VkBuildAccelerationStructureModeKHR;



/**
  * Type of acceleration structure
  * @member VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR
  * @member VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
  * @member VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR
  * @member VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV
  * @member VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV
  */
export enum VkAccelerationStructureTypeKHR {
  VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
  VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
  VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
  VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV,
  VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV,
  
}

declare const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR: VkAccelerationStructureTypeKHR;
declare const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR: VkAccelerationStructureTypeKHR;
declare const VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR: VkAccelerationStructureTypeKHR;
declare const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV: VkAccelerationStructureTypeKHR;
declare const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV: VkAccelerationStructureTypeKHR;



/**
  * Enum specifying which type of geometry is provided
  * @member VK_GEOMETRY_TYPE_TRIANGLES_KHR
  * @member VK_GEOMETRY_TYPE_AABBS_KHR
  * @member VK_GEOMETRY_TYPE_INSTANCES_KHR
  * @member VK_GEOMETRY_TYPE_TRIANGLES_NV
  * @member VK_GEOMETRY_TYPE_AABBS_NV
  */
export enum VkGeometryTypeKHR {
  VK_GEOMETRY_TYPE_TRIANGLES_KHR,
  VK_GEOMETRY_TYPE_AABBS_KHR,
  VK_GEOMETRY_TYPE_INSTANCES_KHR,
  VK_GEOMETRY_TYPE_TRIANGLES_NV,
  VK_GEOMETRY_TYPE_AABBS_NV,
  
}

declare const VK_GEOMETRY_TYPE_TRIANGLES_KHR: VkGeometryTypeKHR;
declare const VK_GEOMETRY_TYPE_AABBS_KHR: VkGeometryTypeKHR;
declare const VK_GEOMETRY_TYPE_INSTANCES_KHR: VkGeometryTypeKHR;
declare const VK_GEOMETRY_TYPE_TRIANGLES_NV: VkGeometryTypeKHR;
declare const VK_GEOMETRY_TYPE_AABBS_NV: VkGeometryTypeKHR;



/**
  * Acceleration structure memory requirement type
  * @member VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV requests the memory requirement for the 'VkAccelerationStructureNV' backing store.
  * @member VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV requests the memory requirement for scratch space during the initial build.
  * @member VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV requests the memory requirement for scratch space during an update.
  */
export enum VkAccelerationStructureMemoryRequirementsTypeNV {
  VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
  VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
  VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
  
}

declare const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV: VkAccelerationStructureMemoryRequirementsTypeNV;
declare const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV: VkAccelerationStructureMemoryRequirementsTypeNV;
declare const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV: VkAccelerationStructureMemoryRequirementsTypeNV;



/**
  * Acceleration structure build type
  * @member VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR requests the memory requirement for operations performed by the host.
  * @member VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR requests the memory requirement for operations performed by the device.
  * @member VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR requests the memory requirement for operations performed by either the host, or the device.
  */
export enum VkAccelerationStructureBuildTypeKHR {
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
  
}

declare const VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR: VkAccelerationStructureBuildTypeKHR;
declare const VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR: VkAccelerationStructureBuildTypeKHR;
declare const VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR: VkAccelerationStructureBuildTypeKHR;



/**
  * Shader group types
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV
  */
export enum VkRayTracingShaderGroupTypeKHR {
  VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV,
  
}

declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR: VkRayTracingShaderGroupTypeKHR;
declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR: VkRayTracingShaderGroupTypeKHR;
declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR: VkRayTracingShaderGroupTypeKHR;
declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV: VkRayTracingShaderGroupTypeKHR;
declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV: VkRayTracingShaderGroupTypeKHR;
declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV: VkRayTracingShaderGroupTypeKHR;



/**
  * Acceleration structure compatibility
  * @member VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR when the 'pVersion' version acceleration structure is compatibile with 'device'.
  * @member VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR when the 'pVersion' version acceleration structure is not compatibile with 'device'.
  */
export enum VkAccelerationStructureCompatibilityKHR {
  VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
  VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
  
}

declare const VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR: VkAccelerationStructureCompatibilityKHR;
declare const VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR: VkAccelerationStructureCompatibilityKHR;



/**
  * Shader group shaders
  * @member VK_SHADER_GROUP_SHADER_GENERAL_KHR uses the shader specified in the group with 'VkRayTracingShaderGroupCreateInfoKHR'::'generalShader'
  * @member VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR uses the shader specified in the group with 'VkRayTracingShaderGroupCreateInfoKHR'::'closestHitShader'
  * @member VK_SHADER_GROUP_SHADER_ANY_HIT_KHR uses the shader specified in the group with 'VkRayTracingShaderGroupCreateInfoKHR'::'anyHitShader'
  * @member VK_SHADER_GROUP_SHADER_INTERSECTION_KHR uses the shader specified in the group with 'VkRayTracingShaderGroupCreateInfoKHR'::'intersectionShader'
  */
export enum VkShaderGroupShaderKHR {
  VK_SHADER_GROUP_SHADER_GENERAL_KHR,
  VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
  VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
  VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
  
}

declare const VK_SHADER_GROUP_SHADER_GENERAL_KHR: VkShaderGroupShaderKHR;
declare const VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR: VkShaderGroupShaderKHR;
declare const VK_SHADER_GROUP_SHADER_ANY_HIT_KHR: VkShaderGroupShaderKHR;
declare const VK_SHADER_GROUP_SHADER_INTERSECTION_KHR: VkShaderGroupShaderKHR;



/**
  * Specify memory overallocation behavior
  * @member VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD lets the implementation decide if overallocation is allowed.
  * @member VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD specifies overallocation is allowed if platform permits.
  * @member VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD specifies the application is not allowed to allocate device memory beyond the heap sizes reported by 'VkPhysicalDeviceMemoryProperties'. Allocations that are not explicitly made by the application within the scope of the Vulkan instance are not accounted for.
  */
export enum VkMemoryOverallocationBehaviorAMD {
  VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
  VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
  VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
  
}

declare const VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD: VkMemoryOverallocationBehaviorAMD;
declare const VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD: VkMemoryOverallocationBehaviorAMD;
declare const VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD: VkMemoryOverallocationBehaviorAMD;



/**
  * Specify SPIR-V scope
  * @member VK_SCOPE_DEVICE_NV corresponds to SPIR-V 'Device' scope.
  * @member VK_SCOPE_WORKGROUP_NV corresponds to SPIR-V 'Workgroup' scope.
  * @member VK_SCOPE_SUBGROUP_NV corresponds to SPIR-V 'Subgroup' scope.
  * @member VK_SCOPE_QUEUE_FAMILY_NV corresponds to SPIR-V 'QueueFamily' scope.
  */
export enum VkScopeNV {
  VK_SCOPE_DEVICE_NV,
  VK_SCOPE_WORKGROUP_NV,
  VK_SCOPE_SUBGROUP_NV,
  VK_SCOPE_QUEUE_FAMILY_NV,
  
}

declare const VK_SCOPE_DEVICE_NV: VkScopeNV;
declare const VK_SCOPE_WORKGROUP_NV: VkScopeNV;
declare const VK_SCOPE_SUBGROUP_NV: VkScopeNV;
declare const VK_SCOPE_QUEUE_FAMILY_NV: VkScopeNV;



/**
  * Specify SPIR-V cooperative matrix component type
  * @member VK_COMPONENT_TYPE_FLOAT16_NV
  * @member VK_COMPONENT_TYPE_FLOAT32_NV
  * @member VK_COMPONENT_TYPE_FLOAT64_NV
  * @member VK_COMPONENT_TYPE_SINT8_NV
  * @member VK_COMPONENT_TYPE_SINT16_NV
  * @member VK_COMPONENT_TYPE_SINT32_NV
  * @member VK_COMPONENT_TYPE_SINT64_NV
  * @member VK_COMPONENT_TYPE_UINT8_NV
  * @member VK_COMPONENT_TYPE_UINT16_NV
  * @member VK_COMPONENT_TYPE_UINT32_NV
  * @member VK_COMPONENT_TYPE_UINT64_NV
  */
export enum VkComponentTypeNV {
  VK_COMPONENT_TYPE_FLOAT16_NV,
  VK_COMPONENT_TYPE_FLOAT32_NV,
  VK_COMPONENT_TYPE_FLOAT64_NV,
  VK_COMPONENT_TYPE_SINT8_NV,
  VK_COMPONENT_TYPE_SINT16_NV,
  VK_COMPONENT_TYPE_SINT32_NV,
  VK_COMPONENT_TYPE_SINT64_NV,
  VK_COMPONENT_TYPE_UINT8_NV,
  VK_COMPONENT_TYPE_UINT16_NV,
  VK_COMPONENT_TYPE_UINT32_NV,
  VK_COMPONENT_TYPE_UINT64_NV,
  
}

declare const VK_COMPONENT_TYPE_FLOAT16_NV: VkComponentTypeNV;
declare const VK_COMPONENT_TYPE_FLOAT32_NV: VkComponentTypeNV;
declare const VK_COMPONENT_TYPE_FLOAT64_NV: VkComponentTypeNV;
declare const VK_COMPONENT_TYPE_SINT8_NV: VkComponentTypeNV;
declare const VK_COMPONENT_TYPE_SINT16_NV: VkComponentTypeNV;
declare const VK_COMPONENT_TYPE_SINT32_NV: VkComponentTypeNV;
declare const VK_COMPONENT_TYPE_SINT64_NV: VkComponentTypeNV;
declare const VK_COMPONENT_TYPE_UINT8_NV: VkComponentTypeNV;
declare const VK_COMPONENT_TYPE_UINT16_NV: VkComponentTypeNV;
declare const VK_COMPONENT_TYPE_UINT32_NV: VkComponentTypeNV;
declare const VK_COMPONENT_TYPE_UINT64_NV: VkComponentTypeNV;



/**
  * Hint values an application can specify affecting full-screen transition behavior
  * @member VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT indicates the implementation 'should' determine the appropriate full-screen method by whatever means it deems appropriate.
  * @member VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT indicates the implementation 'may' use full-screen exclusive mechanisms when available. Such mechanisms 'may' result in better performance and/or the availability of different presentation capabilities, but 'may' require a more disruptive transition during swapchain initialization, first presentation and/or destruction.
  * @member VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT indicates the implementation 'should' avoid using full-screen mechanisms which rely on disruptive transitions.
  * @member VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT indicates the application will manage full-screen exclusive mode by using the 'vkAcquireFullScreenExclusiveModeEXT' and 'vkReleaseFullScreenExclusiveModeEXT' commands.
  */
export enum VkFullScreenExclusiveEXT {
  VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT,
  VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT,
  VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT,
  VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT,
  
}

declare const VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT: VkFullScreenExclusiveEXT;
declare const VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT: VkFullScreenExclusiveEXT;
declare const VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT: VkFullScreenExclusiveEXT;
declare const VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT: VkFullScreenExclusiveEXT;



/**
  * Supported counter scope types
  * @member VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR - the performance counter scope is a single complete command buffer.
  * @member VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR - the performance counter scope is zero or more complete render passes. The performance query containing the performance counter 'must' begin and end outside a render pass instance.
  * @member VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR - the performance counter scope is zero or more commands.
  * @member VK_QUERY_SCOPE_COMMAND_BUFFER_KHR
  * @member VK_QUERY_SCOPE_RENDER_PASS_KHR
  * @member VK_QUERY_SCOPE_COMMAND_KHR
  */
export enum VkPerformanceCounterScopeKHR {
  VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
  VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
  VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
  VK_QUERY_SCOPE_COMMAND_BUFFER_KHR,
  VK_QUERY_SCOPE_RENDER_PASS_KHR,
  VK_QUERY_SCOPE_COMMAND_KHR,
  
}

declare const VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR: VkPerformanceCounterScopeKHR;
declare const VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR: VkPerformanceCounterScopeKHR;
declare const VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR: VkPerformanceCounterScopeKHR;
declare const VK_QUERY_SCOPE_COMMAND_BUFFER_KHR: VkPerformanceCounterScopeKHR;
declare const VK_QUERY_SCOPE_RENDER_PASS_KHR: VkPerformanceCounterScopeKHR;
declare const VK_QUERY_SCOPE_COMMAND_KHR: VkPerformanceCounterScopeKHR;



/**
  * Supported counter unit types
  * @member VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR - the performance counter unit is a generic data point.
  * @member VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR - the performance counter unit is a percentage (%).
  * @member VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR - the performance counter unit is a value of nanoseconds (ns).
  * @member VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR - the performance counter unit is a value of bytes.
  * @member VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR - the performance counter unit is a value of bytes/s.
  * @member VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR - the performance counter unit is a temperature reported in Kelvin.
  * @member VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR - the performance counter unit is a value of watts (W).
  * @member VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR - the performance counter unit is a value of volts (V).
  * @member VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR - the performance counter unit is a value of amps (A).
  * @member VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR - the performance counter unit is a value of hertz (Hz).
  * @member VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR - the performance counter unit is a value of cycles.
  */
export enum VkPerformanceCounterUnitKHR {
  VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
  VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
  VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
  VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
  VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
  VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
  VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
  VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
  VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
  VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
  VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
  
}

declare const VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR: VkPerformanceCounterUnitKHR;
declare const VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR: VkPerformanceCounterUnitKHR;
declare const VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR: VkPerformanceCounterUnitKHR;
declare const VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR: VkPerformanceCounterUnitKHR;
declare const VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR: VkPerformanceCounterUnitKHR;
declare const VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR: VkPerformanceCounterUnitKHR;
declare const VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR: VkPerformanceCounterUnitKHR;
declare const VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR: VkPerformanceCounterUnitKHR;
declare const VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR: VkPerformanceCounterUnitKHR;
declare const VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR: VkPerformanceCounterUnitKHR;
declare const VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR: VkPerformanceCounterUnitKHR;



/**
  * Supported counter storage types
  * @member VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR - the performance counter storage is a 32-bit signed integer.
  * @member VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR - the performance counter storage is a 64-bit signed integer.
  * @member VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR - the performance counter storage is a 32-bit unsigned integer.
  * @member VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR - the performance counter storage is a 64-bit unsigned integer.
  * @member VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR - the performance counter storage is a 32-bit floating-point.
  * @member VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR - the performance counter storage is a 64-bit floating-point.
  */
export enum VkPerformanceCounterStorageKHR {
  VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
  VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
  VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
  VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
  VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
  VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
  
}

declare const VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR: VkPerformanceCounterStorageKHR;
declare const VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR: VkPerformanceCounterStorageKHR;
declare const VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR: VkPerformanceCounterStorageKHR;
declare const VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR: VkPerformanceCounterStorageKHR;
declare const VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR: VkPerformanceCounterStorageKHR;
declare const VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR: VkPerformanceCounterStorageKHR;



/**
  * Type of performance configuration
  * @member VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL
  */
export enum VkPerformanceConfigurationTypeINTEL {
  VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL,
  
}

declare const VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL: VkPerformanceConfigurationTypeINTEL;



/**
  * Enum specifying how performance queries should be captured
  * @member VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL
  */
export enum VkQueryPoolSamplingModeINTEL {
  VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL,
  
}

declare const VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL: VkQueryPoolSamplingModeINTEL;



/**
  * Performance override type
  * @member VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL
  * @member VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL
  */
export enum VkPerformanceOverrideTypeINTEL {
  VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
  VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
  
}

declare const VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL: VkPerformanceOverrideTypeINTEL;
declare const VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL: VkPerformanceOverrideTypeINTEL;



/**
  * Parameters that can be queried
  * @member VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL
  * @member VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL
  */
export enum VkPerformanceParameterTypeINTEL {
  VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
  VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
  
}

declare const VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL: VkPerformanceParameterTypeINTEL;
declare const VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL: VkPerformanceParameterTypeINTEL;



/**
  * Type of the parameters that can be queried
  * @member VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL specifies that unsigned 32-bit integer data is returned in 'data.value32'.
  * @member VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL specifies that unsigned 64-bit integer data is returned in 'data.value64'.
  * @member VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL specifies that floating-point data is returned in 'data.valueFloat'.
  * @member VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL specifies that 'Bool32' data is returned in 'data.valueBool'.
  * @member VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL specifies that a reference to a string is returned in 'data.valueString'. The reference is valid for the lifetime of the 'device' parameter passed to 'vkGetPerformanceParameterINTEL'.
  */
export enum VkPerformanceValueTypeINTEL {
  VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
  VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
  VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
  VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
  VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
  
}

declare const VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL: VkPerformanceValueTypeINTEL;
declare const VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL: VkPerformanceValueTypeINTEL;
declare const VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL: VkPerformanceValueTypeINTEL;
declare const VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL: VkPerformanceValueTypeINTEL;
declare const VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL: VkPerformanceValueTypeINTEL;



/**
  * Enum specifying whether, and how, shader float controls can be set separately
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR
  */
export enum VkShaderFloatControlsIndependence {
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR,
  
}

declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY: VkShaderFloatControlsIndependence;
declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL: VkShaderFloatControlsIndependence;
declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE: VkShaderFloatControlsIndependence;
declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR: VkShaderFloatControlsIndependence;
declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR: VkShaderFloatControlsIndependence;
declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR: VkShaderFloatControlsIndependence;



/**
  * Enum describing a pipeline executable statistic
  * @member VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR specifies that the statistic is returned as a 32-bit boolean value which 'must' be either 'VK_TRUE' or 'VK_FALSE' and 'should' be read from the 'b32' field of 'VkPipelineExecutableStatisticValueKHR'.
  * @member VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR specifies that the statistic is returned as a signed 64-bit integer and 'should' be read from the 'i64' field of 'VkPipelineExecutableStatisticValueKHR'.
  * @member VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR specifies that the statistic is returned as an unsigned 64-bit integer and 'should' be read from the 'u64' field of 'VkPipelineExecutableStatisticValueKHR'.
  * @member VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR specifies that the statistic is returned as a 64-bit floating-point value and 'should' be read from the 'f64' field of 'VkPipelineExecutableStatisticValueKHR'.
  */
export enum VkPipelineExecutableStatisticFormatKHR {
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
  
}

declare const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR: VkPipelineExecutableStatisticFormatKHR;
declare const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR: VkPipelineExecutableStatisticFormatKHR;
declare const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR: VkPipelineExecutableStatisticFormatKHR;
declare const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR: VkPipelineExecutableStatisticFormatKHR;



/**
  * Line rasterization modes
  * @member VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT is equivalent to 'VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT' if 'VkPhysicalDeviceLimits'::'strictLines' is 'VK_TRUE', otherwise lines are drawn as non-'strictLines' parallelograms. Both of these modes are defined in <<primsrast-lines-basic,Basic Line Segment Rasterization>>.
  * @member VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT specifies lines drawn as if they were rectangles extruded from the line
  * @member VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT specifies lines drawn by determining which pixel diamonds the line intersects and exits, as defined in <<primsrast-lines-bresenham,Bresenham Line Segment Rasterization>>.
  * @member VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT specifies lines drawn if they were rectangles extruded from the line, with alpha falloff, as defined in <<primsrast-lines-smooth,Smooth Lines>>.
  */
export enum VkLineRasterizationModeEXT {
  VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT,
  VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT,
  VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT,
  VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT,
  
}

declare const VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT: VkLineRasterizationModeEXT;
declare const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT: VkLineRasterizationModeEXT;
declare const VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT: VkLineRasterizationModeEXT;
declare const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT: VkLineRasterizationModeEXT;



/**
  * Control how fragment shading rates are combined
  * @member VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR specifies a combiner operation of [eq]#combine(A~xy~,B~xy~) = A~xy~#.
  * @member VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR specifies a combiner operation of [eq]#combine(A~xy~,B~xy~) = B~xy~#.
  * @member VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR specifies a combiner operation of [eq]#combine(A~xy~,B~xy~) = min(A~xy~,B~xy~)#.
  * @member VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR specifies a combiner operation of [eq]#combine(A~xy~,B~xy~) = max(A~xy~,B~xy~)#.
  * @member VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR combiner operation of [eq]#combine(A~xy~,B~xy~) = A~xy~
  */
export enum VkFragmentShadingRateCombinerOpKHR {
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
  
}

declare const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR: VkFragmentShadingRateCombinerOpKHR;
declare const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR: VkFragmentShadingRateCombinerOpKHR;
declare const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR: VkFragmentShadingRateCombinerOpKHR;
declare const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR: VkFragmentShadingRateCombinerOpKHR;
declare const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR: VkFragmentShadingRateCombinerOpKHR;



/**
  * Enumeration with fragment shading rates
  * @member VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV specifies a fragment size of 1x1 pixels.
  * @member VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV specifies a fragment size of 1x2 pixels.
  * @member VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV specifies a fragment size of 2x1 pixels.
  * @member VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV specifies a fragment size of 2x2 pixels.
  * @member VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV specifies a fragment size of 2x4 pixels.
  * @member VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV specifies a fragment size of 4x2 pixels.
  * @member VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV specifies a fragment size of 4x4 pixels.
  * @member VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV specifies a fragment size of 1x1 pixels, with two fragment shader invocations per fragment.
  * @member VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV specifies a fragment size of 1x1 pixels, with four fragment shader invocations per fragment.
  * @member VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV specifies a fragment size of 1x1 pixels, with eight fragment shader invocations per fragment.
  * @member VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV specifies a fragment size of 1x1 pixels, with sixteen fragment shader invocations per fragment.
  * @member VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV specifies that any portions of a primitive that use that shading rate should be discarded without invoking any fragment shader.
  */
export enum VkFragmentShadingRateNV {
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV,
  VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
  VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
  VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV,
  VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV,
  VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV,
  
}

declare const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV: VkFragmentShadingRateNV;
declare const VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV: VkFragmentShadingRateNV;



/**
  * Enumeration with fragment shading rate types
  * @member VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV specifies that a graphics pipeline should obtain its pipeline fragment shading rate and shading rate combiner state from the 'VkPipelineFragmentShadingRateStateCreateInfoKHR' structure and that any state specified by the 'VkPipelineFragmentShadingRateEnumStateCreateInfoNV' structure should be ignored.
  * @member VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV specifies that a graphics pipeline should obtain its pipeline fragment shading rate and shading rate combiner state from the 'VkPipelineFragmentShadingRateEnumStateCreateInfoNV' structure and that any state specified by the 'VkPipelineFragmentShadingRateStateCreateInfoKHR' structure should be ignored.
  */
export enum VkFragmentShadingRateTypeNV {
  VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
  VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV,
  
}

declare const VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV: VkFragmentShadingRateTypeNV;
declare const VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV: VkFragmentShadingRateTypeNV;



/**
  * Bitmask specifying the behavior of the pipeline cache
  * @member VK_PIPELINE_CACHE_CREATE_RESERVED_1_BIT_EXT
  * @member VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT specifies that all commands that modify the created 'VkPipelineCache' will be <<fundamentals-threadingbehavior,externally synchronized>>. When set, the implementation 'may' skip any unnecessary processing needed to support simultaneous modification from multiple threads where allowed.
  * @member VK_PIPELINE_CACHE_CREATE_RESERVED_2_BIT_EXT
  */
export enum VkPipelineCacheCreateFlagBits {
  VK_PIPELINE_CACHE_CREATE_RESERVED_1_BIT_EXT,
  VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT,
  VK_PIPELINE_CACHE_CREATE_RESERVED_2_BIT_EXT,
  
}

declare const VK_PIPELINE_CACHE_CREATE_RESERVED_1_BIT_EXT: VkPipelineCacheCreateFlagBits;
declare const VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT: VkPipelineCacheCreateFlagBits;
declare const VK_PIPELINE_CACHE_CREATE_RESERVED_2_BIT_EXT: VkPipelineCacheCreateFlagBits;



/**
  * Bitmask specifying capabilities of queues in a queue family
  * @member VK_QUEUE_GRAPHICS_BIT specifies that queues in this queue family support graphics operations.
  * @member VK_QUEUE_COMPUTE_BIT specifies that queues in this queue family support compute operations.
  * @member VK_QUEUE_TRANSFER_BIT specifies that queues in this queue family support transfer operations.
  * @member VK_QUEUE_SPARSE_BINDING_BIT specifies that queues in this queue family support sparse memory management operations (see <<sparsememory,Sparse Resources>>). If any of the sparse resource features are enabled, then at least one queue family 'must' support this bit.
  * @member VK_QUEUE_PROTECTED_BIT is set, then the queues in this queue family support the 'VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT' bit. (see <<memory-protected-memory,Protected Memory>>). If the physical device supports the 'protectedMemory' feature, at least one of its queue families 'must' support this bit.
  * @member VK_QUEUE_RESERVED_6_BIT_KHR
  * @member VK_QUEUE_RESERVED_5_BIT_KHR
  */
export enum VkQueueFlagBits {
  VK_QUEUE_GRAPHICS_BIT,
  VK_QUEUE_COMPUTE_BIT,
  VK_QUEUE_TRANSFER_BIT,
  VK_QUEUE_SPARSE_BINDING_BIT,
  VK_QUEUE_PROTECTED_BIT,
  VK_QUEUE_RESERVED_6_BIT_KHR,
  VK_QUEUE_RESERVED_5_BIT_KHR,
  
}

declare const VK_QUEUE_GRAPHICS_BIT: VkQueueFlagBits;
declare const VK_QUEUE_COMPUTE_BIT: VkQueueFlagBits;
declare const VK_QUEUE_TRANSFER_BIT: VkQueueFlagBits;
declare const VK_QUEUE_SPARSE_BINDING_BIT: VkQueueFlagBits;
declare const VK_QUEUE_PROTECTED_BIT: VkQueueFlagBits;
declare const VK_QUEUE_RESERVED_6_BIT_KHR: VkQueueFlagBits;
declare const VK_QUEUE_RESERVED_5_BIT_KHR: VkQueueFlagBits;



/**
  * Bitmask controlling triangle culling
  * @member VK_CULL_MODE_NONE specifies that no triangles are discarded
  * @member VK_CULL_MODE_FRONT_BIT specifies that front-facing triangles are discarded
  * @member VK_CULL_MODE_BACK_BIT specifies that back-facing triangles are discarded
  * @member VK_CULL_MODE_FRONT_AND_BACK specifies that all triangles are discarded.
  */
export enum VkCullModeFlagBits {
  VK_CULL_MODE_NONE,
  VK_CULL_MODE_FRONT_BIT,
  VK_CULL_MODE_BACK_BIT,
  VK_CULL_MODE_FRONT_AND_BACK,
  
}

declare const VK_CULL_MODE_NONE: VkCullModeFlagBits;
declare const VK_CULL_MODE_FRONT_BIT: VkCullModeFlagBits;
declare const VK_CULL_MODE_BACK_BIT: VkCullModeFlagBits;
declare const VK_CULL_MODE_FRONT_AND_BACK: VkCullModeFlagBits;



/**
  * Bitmask specifying additional properties of a renderpass
  * @member VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR
  * @member VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM specifies that the created renderpass is compatible with <<vertexpostproc-renderpass-transform, render pass transform>>.
  */
export enum VkRenderPassCreateFlagBits {
  VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR,
  VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM,
  
}

declare const VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR: VkRenderPassCreateFlagBits;
declare const VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM: VkRenderPassCreateFlagBits;



/**
  * Bitmask specifying behavior of the queue
  * @member VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT specifies that the device queue is a protected-capable queue.
  */
export enum VkDeviceQueueCreateFlagBits {
  VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT,
  
}

declare const VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT: VkDeviceQueueCreateFlagBits;



/**
  * Bitmask specifying properties for a memory type
  * @member VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit specifies that memory allocated with this type is the most efficient for device access. This property will be set if and only if the memory type belongs to a heap with the 'VK_MEMORY_HEAP_DEVICE_LOCAL_BIT' set.
  * @member VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT bit specifies that memory allocated with this type 'can' be mapped for host access using 'vkMapMemory'.
  * @member VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bit specifies that the host cache management commands 'vkFlushMappedMemoryRanges' and 'vkInvalidateMappedMemoryRanges' are not needed to flush host writes to the device or make device writes visible to the host, respectively.
  * @member VK_MEMORY_PROPERTY_HOST_CACHED_BIT bit specifies that memory allocated with this type is cached on the host. Host memory accesses to uncached memory are slower than to cached memory, however uncached memory is always host coherent.
  * @member VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit specifies that the memory type only allows device access to the memory. Memory types 'must' not have both 'VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT' and 'VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT' set. Additionally, the object's backing memory 'may' be provided by the implementation lazily as specified in <<memory-device-lazy_allocation, Lazily Allocated Memory>>.
  * @member VK_MEMORY_PROPERTY_PROTECTED_BIT bit specifies that the memory type only allows device access to the memory, and allows protected queue operations to access the memory. Memory types 'must' not have 'VK_MEMORY_PROPERTY_PROTECTED_BIT' set and any of 'VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT' set, or 'VK_MEMORY_PROPERTY_HOST_COHERENT_BIT' set, or 'VK_MEMORY_PROPERTY_HOST_CACHED_BIT' set.
  * @member VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD
  * @member VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD
  */
export enum VkMemoryPropertyFlagBits {
  VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
  VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
  VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
  VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
  VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
  VK_MEMORY_PROPERTY_PROTECTED_BIT,
  VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD,
  VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD,
  
}

declare const VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: VkMemoryPropertyFlagBits;
declare const VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: VkMemoryPropertyFlagBits;
declare const VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: VkMemoryPropertyFlagBits;
declare const VK_MEMORY_PROPERTY_HOST_CACHED_BIT: VkMemoryPropertyFlagBits;
declare const VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: VkMemoryPropertyFlagBits;
declare const VK_MEMORY_PROPERTY_PROTECTED_BIT: VkMemoryPropertyFlagBits;
declare const VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD: VkMemoryPropertyFlagBits;
declare const VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD: VkMemoryPropertyFlagBits;



/**
  * Bitmask specifying attribute flags for a heap
  * @member VK_MEMORY_HEAP_DEVICE_LOCAL_BIT specifies that the heap corresponds to device local memory. Device local memory 'may' have different performance characteristics than host local memory, and 'may' support different memory property flags.
  * @member VK_MEMORY_HEAP_MULTI_INSTANCE_BIT specifies that in a logical device representing more than one physical device, there is a per-physical device instance of the heap memory. By default, an allocation from such a heap will be replicated to each physical device's instance of the heap.
  * @member VK_MEMORY_HEAP_RESERVED_2_BIT_KHR
  * @member VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR
  */
export enum VkMemoryHeapFlagBits {
  VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,
  VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
  VK_MEMORY_HEAP_RESERVED_2_BIT_KHR,
  VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR,
  
}

declare const VK_MEMORY_HEAP_DEVICE_LOCAL_BIT: VkMemoryHeapFlagBits;
declare const VK_MEMORY_HEAP_MULTI_INSTANCE_BIT: VkMemoryHeapFlagBits;
declare const VK_MEMORY_HEAP_RESERVED_2_BIT_KHR: VkMemoryHeapFlagBits;
declare const VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR: VkMemoryHeapFlagBits;



/**
  * Bitmask specifying memory access types that will participate in a memory dependency
  * @member VK_ACCESS_INDIRECT_COMMAND_READ_BIT specifies read access to indirect command data read as part of an indirect build,
  * @member VK_ACCESS_INDEX_READ_BIT
  * @member VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT
  * @member VK_ACCESS_UNIFORM_READ_BIT
  * @member VK_ACCESS_INPUT_ATTACHMENT_READ_BIT
  * @member VK_ACCESS_SHADER_READ_BIT
  * @member VK_ACCESS_SHADER_WRITE_BIT
  * @member VK_ACCESS_COLOR_ATTACHMENT_READ_BIT
  * @member VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
  * @member VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT
  * @member VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
  * @member VK_ACCESS_TRANSFER_READ_BIT
  * @member VK_ACCESS_TRANSFER_WRITE_BIT
  * @member VK_ACCESS_HOST_READ_BIT
  * @member VK_ACCESS_HOST_WRITE_BIT
  * @member VK_ACCESS_MEMORY_READ_BIT
  * @member VK_ACCESS_MEMORY_WRITE_BIT
  * @member VK_ACCESS_RESERVED_30_BIT_KHR
  * @member VK_ACCESS_RESERVED_28_BIT_KHR
  * @member VK_ACCESS_RESERVED_29_BIT_KHR
  * @member VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT
  * @member VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT
  * @member VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT
  * @member VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT
  * @member VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT
  * @member VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR
  * @member VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR
  * @member VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV
  * @member VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT
  * @member VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV
  * @member VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV
  * @member VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV
  * @member VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV
  * @member VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR
  */
export enum VkAccessFlagBits {
  VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
  VK_ACCESS_INDEX_READ_BIT,
  VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
  VK_ACCESS_UNIFORM_READ_BIT,
  VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
  VK_ACCESS_SHADER_READ_BIT,
  VK_ACCESS_SHADER_WRITE_BIT,
  VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
  VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
  VK_ACCESS_TRANSFER_READ_BIT,
  VK_ACCESS_TRANSFER_WRITE_BIT,
  VK_ACCESS_HOST_READ_BIT,
  VK_ACCESS_HOST_WRITE_BIT,
  VK_ACCESS_MEMORY_READ_BIT,
  VK_ACCESS_MEMORY_WRITE_BIT,
  VK_ACCESS_RESERVED_30_BIT_KHR,
  VK_ACCESS_RESERVED_28_BIT_KHR,
  VK_ACCESS_RESERVED_29_BIT_KHR,
  VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT,
  VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT,
  VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT,
  VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT,
  VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,
  VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
  VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
  VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV,
  VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT,
  VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV,
  VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV,
  VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV,
  VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV,
  VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
  
}

declare const VK_ACCESS_INDIRECT_COMMAND_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_INDEX_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_UNIFORM_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_INPUT_ATTACHMENT_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_SHADER_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_SHADER_WRITE_BIT: VkAccessFlagBits;
declare const VK_ACCESS_COLOR_ATTACHMENT_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT: VkAccessFlagBits;
declare const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: VkAccessFlagBits;
declare const VK_ACCESS_TRANSFER_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_TRANSFER_WRITE_BIT: VkAccessFlagBits;
declare const VK_ACCESS_HOST_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_HOST_WRITE_BIT: VkAccessFlagBits;
declare const VK_ACCESS_MEMORY_READ_BIT: VkAccessFlagBits;
declare const VK_ACCESS_MEMORY_WRITE_BIT: VkAccessFlagBits;
declare const VK_ACCESS_RESERVED_30_BIT_KHR: VkAccessFlagBits;
declare const VK_ACCESS_RESERVED_28_BIT_KHR: VkAccessFlagBits;
declare const VK_ACCESS_RESERVED_29_BIT_KHR: VkAccessFlagBits;
declare const VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: VkAccessFlagBits;
declare const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: VkAccessFlagBits;
declare const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: VkAccessFlagBits;
declare const VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT: VkAccessFlagBits;
declare const VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: VkAccessFlagBits;
declare const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR: VkAccessFlagBits;
declare const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR: VkAccessFlagBits;
declare const VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV: VkAccessFlagBits;
declare const VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: VkAccessFlagBits;
declare const VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV: VkAccessFlagBits;
declare const VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV: VkAccessFlagBits;
declare const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV: VkAccessFlagBits;
declare const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV: VkAccessFlagBits;
declare const VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR: VkAccessFlagBits;



/**
  * Bitmask specifying allowed usage of a buffer
  * @member VK_BUFFER_USAGE_TRANSFER_SRC_BIT specifies that the buffer 'can' be used as the source of a _transfer command_ (see the definition of <<synchronization-pipeline-stages-transfer, 'VK_PIPELINE_STAGE_TRANSFER_BIT'>>).
  * @member VK_BUFFER_USAGE_TRANSFER_DST_BIT specifies that the buffer 'can' be used as the destination of a transfer command.
  * @member VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT specifies that the buffer 'can' be used to create a 'VkBufferView' suitable for occupying a 'VkDescriptorSet' slot of type 'VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER'.
  * @member VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT specifies that the buffer 'can' be used to create a 'VkBufferView' suitable for occupying a 'VkDescriptorSet' slot of type 'VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER'.
  * @member VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT specifies that the buffer 'can' be used in a 'VkDescriptorBufferInfo' suitable for occupying a 'VkDescriptorSet' slot either of type 'VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER' or 'VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC'.
  * @member VK_BUFFER_USAGE_STORAGE_BUFFER_BIT specifies that the buffer 'can' be used in a 'VkDescriptorBufferInfo' suitable for occupying a 'VkDescriptorSet' slot either of type 'VK_DESCRIPTOR_TYPE_STORAGE_BUFFER' or 'VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC'.
  * @member VK_BUFFER_USAGE_INDEX_BUFFER_BIT specifies that the buffer is suitable for passing as the 'buffer' parameter to 'vkCmdBindIndexBuffer'.
  * @member VK_BUFFER_USAGE_VERTEX_BUFFER_BIT specifies that the buffer is suitable for passing as an element of the 'pBuffers' array to 'vkCmdBindVertexBuffers'.
  * @member VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT specifies that the buffer is suitable for passing as the 'buffer' parameter to 'vkCmdDrawIndirect', 'vkCmdDrawIndexedIndirect', 'vkCmdDrawMeshTasksIndirectNV', 'vkCmdDrawMeshTasksIndirectCountNV',
  * @member VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
  * @member VK_BUFFER_USAGE_RESERVED_15_BIT_KHR
  * @member VK_BUFFER_USAGE_RESERVED_16_BIT_KHR
  * @member VK_BUFFER_USAGE_RESERVED_13_BIT_KHR
  * @member VK_BUFFER_USAGE_RESERVED_14_BIT_KHR
  * @member VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT
  * @member VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT
  * @member VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT
  * @member VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
  * @member VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR
  * @member VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR
  * @member VK_BUFFER_USAGE_RESERVED_18_BIT_QCOM
  * @member VK_BUFFER_USAGE_RAY_TRACING_BIT_NV
  * @member VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT
  * @member VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR
  */
export enum VkBufferUsageFlagBits {
  VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
  VK_BUFFER_USAGE_TRANSFER_DST_BIT,
  VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
  VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
  VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
  VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
  VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
  VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
  VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
  VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
  VK_BUFFER_USAGE_RESERVED_15_BIT_KHR,
  VK_BUFFER_USAGE_RESERVED_16_BIT_KHR,
  VK_BUFFER_USAGE_RESERVED_13_BIT_KHR,
  VK_BUFFER_USAGE_RESERVED_14_BIT_KHR,
  VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT,
  VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT,
  VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT,
  VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR,
  VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR,
  VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
  VK_BUFFER_USAGE_RESERVED_18_BIT_QCOM,
  VK_BUFFER_USAGE_RAY_TRACING_BIT_NV,
  VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT,
  VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR,
  
}

declare const VK_BUFFER_USAGE_TRANSFER_SRC_BIT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_TRANSFER_DST_BIT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_STORAGE_BUFFER_BIT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_INDEX_BUFFER_BIT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_VERTEX_BUFFER_BIT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_RESERVED_15_BIT_KHR: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_RESERVED_16_BIT_KHR: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_RESERVED_13_BIT_KHR: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_RESERVED_14_BIT_KHR: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_RESERVED_18_BIT_QCOM: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_RAY_TRACING_BIT_NV: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT: VkBufferUsageFlagBits;
declare const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR: VkBufferUsageFlagBits;



/**
  * Bitmask specifying additional parameters of a buffer
  * @member VK_BUFFER_CREATE_SPARSE_BINDING_BIT specifies that the buffer will be backed using sparse memory binding.
  * @member VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT specifies that the buffer 'can' be partially backed using sparse memory binding. Buffers created with this flag 'must' also be created with the 'VK_BUFFER_CREATE_SPARSE_BINDING_BIT' flag.
  * @member VK_BUFFER_CREATE_SPARSE_ALIASED_BIT specifies that the buffer will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another buffer (or another portion of the same buffer). Buffers created with this flag 'must' also be created with the 'VK_BUFFER_CREATE_SPARSE_BINDING_BIT' flag.
  * @member VK_BUFFER_CREATE_PROTECTED_BIT specifies that the buffer is a protected buffer.
  * @member VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
  * @member VK_BUFFER_CREATE_RESERVED_5_BIT_NV
  * @member VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT
  * @member VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
  */
export enum VkBufferCreateFlagBits {
  VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
  VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,
  VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,
  VK_BUFFER_CREATE_PROTECTED_BIT,
  VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
  VK_BUFFER_CREATE_RESERVED_5_BIT_NV,
  VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT,
  VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
  
}

declare const VK_BUFFER_CREATE_SPARSE_BINDING_BIT: VkBufferCreateFlagBits;
declare const VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT: VkBufferCreateFlagBits;
declare const VK_BUFFER_CREATE_SPARSE_ALIASED_BIT: VkBufferCreateFlagBits;
declare const VK_BUFFER_CREATE_PROTECTED_BIT: VkBufferCreateFlagBits;
declare const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: VkBufferCreateFlagBits;
declare const VK_BUFFER_CREATE_RESERVED_5_BIT_NV: VkBufferCreateFlagBits;
declare const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT: VkBufferCreateFlagBits;
declare const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkBufferCreateFlagBits;



/**
  * Bitmask specifying a pipeline stage
  * @member VK_SHADER_STAGE_VERTEX_BIT specifies the vertex stage.
  * @member VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT specifies the tessellation control stage.
  * @member VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT specifies the tessellation evaluation stage.
  * @member VK_SHADER_STAGE_GEOMETRY_BIT specifies the geometry stage.
  * @member VK_SHADER_STAGE_FRAGMENT_BIT specifies the fragment stage.
  * @member VK_SHADER_STAGE_COMPUTE_BIT specifies the compute stage.
  * @member VK_SHADER_STAGE_ALL_GRAPHICS is a combination of bits used as shorthand to specify all graphics stages defined above (excluding the compute stage).
  * @member VK_SHADER_STAGE_ALL is a combination of bits used as shorthand to specify all shader stages supported by the device, including all additional stages which are introduced by extensions.
  * @member VK_SHADER_STAGE_RAYGEN_BIT_KHR
  * @member VK_SHADER_STAGE_ANY_HIT_BIT_KHR
  * @member VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR
  * @member VK_SHADER_STAGE_MISS_BIT_KHR
  * @member VK_SHADER_STAGE_INTERSECTION_BIT_KHR
  * @member VK_SHADER_STAGE_CALLABLE_BIT_KHR
  * @member VK_SHADER_STAGE_TASK_BIT_NV specifies the task stage.
  * @member VK_SHADER_STAGE_MESH_BIT_NV specifies the mesh stage.
  * @member VK_SHADER_STAGE_RAYGEN_BIT_NV
  * @member VK_SHADER_STAGE_ANY_HIT_BIT_NV
  * @member VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV
  * @member VK_SHADER_STAGE_MISS_BIT_NV
  * @member VK_SHADER_STAGE_INTERSECTION_BIT_NV
  * @member VK_SHADER_STAGE_CALLABLE_BIT_NV
  */
export enum VkShaderStageFlagBits {
  VK_SHADER_STAGE_VERTEX_BIT,
  VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
  VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
  VK_SHADER_STAGE_GEOMETRY_BIT,
  VK_SHADER_STAGE_FRAGMENT_BIT,
  VK_SHADER_STAGE_COMPUTE_BIT,
  VK_SHADER_STAGE_ALL_GRAPHICS,
  VK_SHADER_STAGE_ALL,
  VK_SHADER_STAGE_RAYGEN_BIT_KHR,
  VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
  VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
  VK_SHADER_STAGE_MISS_BIT_KHR,
  VK_SHADER_STAGE_INTERSECTION_BIT_KHR,
  VK_SHADER_STAGE_CALLABLE_BIT_KHR,
  VK_SHADER_STAGE_TASK_BIT_NV,
  VK_SHADER_STAGE_MESH_BIT_NV,
  VK_SHADER_STAGE_RAYGEN_BIT_NV,
  VK_SHADER_STAGE_ANY_HIT_BIT_NV,
  VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV,
  VK_SHADER_STAGE_MISS_BIT_NV,
  VK_SHADER_STAGE_INTERSECTION_BIT_NV,
  VK_SHADER_STAGE_CALLABLE_BIT_NV,
  
}

declare const VK_SHADER_STAGE_VERTEX_BIT: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_GEOMETRY_BIT: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_FRAGMENT_BIT: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_COMPUTE_BIT: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_ALL_GRAPHICS: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_ALL: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_RAYGEN_BIT_KHR: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_ANY_HIT_BIT_KHR: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_MISS_BIT_KHR: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_INTERSECTION_BIT_KHR: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_CALLABLE_BIT_KHR: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_TASK_BIT_NV: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_MESH_BIT_NV: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_RAYGEN_BIT_NV: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_ANY_HIT_BIT_NV: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_MISS_BIT_NV: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_INTERSECTION_BIT_NV: VkShaderStageFlagBits;
declare const VK_SHADER_STAGE_CALLABLE_BIT_NV: VkShaderStageFlagBits;



/**
  * Bitmask specifying intended usage of an image
  * @member VK_IMAGE_USAGE_TRANSFER_SRC_BIT specifies that the image 'can' be used as the source of a transfer command.
  * @member VK_IMAGE_USAGE_TRANSFER_DST_BIT specifies that the image 'can' be used as the destination of a transfer command.
  * @member VK_IMAGE_USAGE_SAMPLED_BIT specifies that the image 'can' be used to create a 'VkImageView' suitable for occupying a 'VkDescriptorSet' slot either of type 'VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE' or 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER', and be sampled by a shader.
  * @member VK_IMAGE_USAGE_STORAGE_BIT specifies that the image 'can' be used to create a 'VkImageView' suitable for occupying a 'VkDescriptorSet' slot of type 'VK_DESCRIPTOR_TYPE_STORAGE_IMAGE'.
  * @member VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT specifies that the image 'can' be used to create a 'VkImageView' suitable for use as a color or resolve attachment in a 'VkFramebuffer'.
  * @member VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT specifies that the image 'can' be used to create a 'VkImageView' suitable for use as a depth/stencil or depth/stencil resolve
  * @member VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT
  * @member VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
  * @member VK_IMAGE_USAGE_RESERVED_13_BIT_KHR
  * @member VK_IMAGE_USAGE_RESERVED_14_BIT_KHR
  * @member VK_IMAGE_USAGE_RESERVED_15_BIT_KHR
  * @member VK_IMAGE_USAGE_RESERVED_10_BIT_KHR
  * @member VK_IMAGE_USAGE_RESERVED_11_BIT_KHR
  * @member VK_IMAGE_USAGE_RESERVED_12_BIT_KHR
  * @member VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV
  * @member VK_IMAGE_USAGE_RESERVED_16_BIT_QCOM
  * @member VK_IMAGE_USAGE_RESERVED_17_BIT_QCOM
  * @member VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT
  * @member VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
  */
export enum VkImageUsageFlagBits {
  VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
  VK_IMAGE_USAGE_TRANSFER_DST_BIT,
  VK_IMAGE_USAGE_SAMPLED_BIT,
  VK_IMAGE_USAGE_STORAGE_BIT,
  VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
  VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
  VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
  VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
  VK_IMAGE_USAGE_RESERVED_13_BIT_KHR,
  VK_IMAGE_USAGE_RESERVED_14_BIT_KHR,
  VK_IMAGE_USAGE_RESERVED_15_BIT_KHR,
  VK_IMAGE_USAGE_RESERVED_10_BIT_KHR,
  VK_IMAGE_USAGE_RESERVED_11_BIT_KHR,
  VK_IMAGE_USAGE_RESERVED_12_BIT_KHR,
  VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV,
  VK_IMAGE_USAGE_RESERVED_16_BIT_QCOM,
  VK_IMAGE_USAGE_RESERVED_17_BIT_QCOM,
  VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
  VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
  
}

declare const VK_IMAGE_USAGE_TRANSFER_SRC_BIT: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_TRANSFER_DST_BIT: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_SAMPLED_BIT: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_STORAGE_BIT: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_RESERVED_13_BIT_KHR: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_RESERVED_14_BIT_KHR: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_RESERVED_15_BIT_KHR: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_RESERVED_10_BIT_KHR: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_RESERVED_11_BIT_KHR: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_RESERVED_12_BIT_KHR: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_RESERVED_16_BIT_QCOM: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_RESERVED_17_BIT_QCOM: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT: VkImageUsageFlagBits;
declare const VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkImageUsageFlagBits;



/**
  * Bitmask specifying additional parameters of an image
  * @member VK_IMAGE_CREATE_SPARSE_BINDING_BIT specifies that the image will be backed using sparse memory binding.
  * @member VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT specifies that the image 'can' be partially backed using sparse memory binding. Images created with this flag 'must' also be created with the 'VK_IMAGE_CREATE_SPARSE_BINDING_BIT' flag.
  * @member VK_IMAGE_CREATE_SPARSE_ALIASED_BIT specifies that the image will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another image (or another portion of the same image). Images created with this flag 'must' also be created with the 'VK_IMAGE_CREATE_SPARSE_BINDING_BIT' flag
  * @member VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT specifies that the image 'can' be used to create a 'VkImageView' with a different format from the image. For <<formats-requiring-sampler-ycbcr-conversion,multi-planar>> formats, 'VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT' specifies that a 'VkImageView' can be created of a _plane_ of the image.
  * @member VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT
  * @member VK_IMAGE_CREATE_ALIAS_BIT
  * @member VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
  * @member VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT
  * @member VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT
  * @member VK_IMAGE_CREATE_EXTENDED_USAGE_BIT
  * @member VK_IMAGE_CREATE_PROTECTED_BIT
  * @member VK_IMAGE_CREATE_DISJOINT_BIT
  * @member VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV
  * @member VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT
  * @member VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT
  * @member VK_IMAGE_CREATE_RESERVED_15_BIT_NV
  * @member VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
  * @member VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR
  * @member VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR
  * @member VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR
  * @member VK_IMAGE_CREATE_DISJOINT_BIT_KHR
  * @member VK_IMAGE_CREATE_ALIAS_BIT_KHR
  */
export enum VkImageCreateFlagBits {
  VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
  VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
  VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
  VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
  VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
  VK_IMAGE_CREATE_ALIAS_BIT,
  VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
  VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
  VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
  VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
  VK_IMAGE_CREATE_PROTECTED_BIT,
  VK_IMAGE_CREATE_DISJOINT_BIT,
  VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV,
  VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT,
  VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,
  VK_IMAGE_CREATE_RESERVED_15_BIT_NV,
  VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
  VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR,
  VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR,
  VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR,
  VK_IMAGE_CREATE_DISJOINT_BIT_KHR,
  VK_IMAGE_CREATE_ALIAS_BIT_KHR,
  
}

declare const VK_IMAGE_CREATE_SPARSE_BINDING_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_SPARSE_ALIASED_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_ALIAS_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_EXTENDED_USAGE_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_PROTECTED_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_DISJOINT_BIT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_RESERVED_15_BIT_NV: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_DISJOINT_BIT_KHR: VkImageCreateFlagBits;
declare const VK_IMAGE_CREATE_ALIAS_BIT_KHR: VkImageCreateFlagBits;



/**
  * Bitmask specifying additional parameters of an image view
  * @member VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT specifies that the fragment density map will be read by device during 'VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT'
  * @member VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT
  */
export enum VkImageViewCreateFlagBits {
  VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT,
  VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT,
  
}

declare const VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT: VkImageViewCreateFlagBits;
declare const VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT: VkImageViewCreateFlagBits;



/**
  * Bitmask specifying additional parameters of sampler
  * @member VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT specifies that the sampler will read from an image created with 'flags' containing 'VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT'.
  * @member VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT specifies that the implementation 'may' use approximations when reconstructing a full color value for texture access from a subsampled image.
  */
export enum VkSamplerCreateFlagBits {
  VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT,
  VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT,
  
}

declare const VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT: VkSamplerCreateFlagBits;
declare const VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT: VkSamplerCreateFlagBits;



/**
  * Bitmask controlling how a pipeline is created
  * @member VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT specifies that the created pipeline will not be optimized. Using this flag 'may' reduce the time taken to create the pipeline.
  * @member VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT specifies that the pipeline to be created is allowed to be the parent of a pipeline that will be created in a subsequent pipeline creation call.
  * @member VK_PIPELINE_CREATE_DERIVATIVE_BIT specifies that the pipeline to be created will be a child of a previously created parent pipeline.ifdef::VK_VERSION_1_1,VK_KHR_multiview[]
  * @member VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT specifies that any shader input variables decorated as 'ViewIndex' will be assigned values as if they were decorated as 'DeviceIndex'.
  * @member VK_PIPELINE_CREATE_DISPATCH_BASE_BIT
  * @member VK_PIPELINE_CREATE_DISPATCH_BASE
  * @member VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
  * @member VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
  * @member VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
  * @member VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
  * @member VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
  * @member VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
  * @member VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
  * @member VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV
  * @member VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR
  * @member VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
  * @member VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV
  * @member VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
  * @member VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT
  * @member VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT
  * @member VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR
  * @member VK_PIPELINE_CREATE_DISPATCH_BASE_KHR
  */
export enum VkPipelineCreateFlagBits {
  VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
  VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
  VK_PIPELINE_CREATE_DERIVATIVE_BIT,
  VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
  VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
  VK_PIPELINE_CREATE_DISPATCH_BASE,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR,
  VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR,
  VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR,
  VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR,
  VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV,
  VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR,
  VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR,
  VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV,
  VK_PIPELINE_CREATE_LIBRARY_BIT_KHR,
  VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT,
  VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT,
  VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR,
  VK_PIPELINE_CREATE_DISPATCH_BASE_KHR,
  
}

declare const VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_DERIVATIVE_BIT: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_DISPATCH_BASE_BIT: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_DISPATCH_BASE: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_LIBRARY_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR: VkPipelineCreateFlagBits;
declare const VK_PIPELINE_CREATE_DISPATCH_BASE_KHR: VkPipelineCreateFlagBits;



/**
  * Bitmask controlling how a pipeline shader stage is created
  * @member VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_2_BIT_NV
  * @member VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT specifies that the <<interfaces-builtin-variables-sgs,'SubgroupSize'>> 'may' vary in the shader stage.
  * @member VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT specifies that the subgroup sizes 'must' be launched with all invocations active in the compute stage.
  * @member VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR
  */
export enum VkPipelineShaderStageCreateFlagBits {
  VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_2_BIT_NV,
  VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT,
  VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT,
  VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR,
  
}

declare const VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_2_BIT_NV: VkPipelineShaderStageCreateFlagBits;
declare const VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT: VkPipelineShaderStageCreateFlagBits;
declare const VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT: VkPipelineShaderStageCreateFlagBits;
declare const VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR: VkPipelineShaderStageCreateFlagBits;



/**
  * Bitmask controlling which components are written to the framebuffer
  * @member VK_COLOR_COMPONENT_R_BIT specifies that the [eq]#R# value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
  * @member VK_COLOR_COMPONENT_G_BIT specifies that the [eq]#G# value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
  * @member VK_COLOR_COMPONENT_B_BIT specifies that the [eq]#B# value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
  * @member VK_COLOR_COMPONENT_A_BIT specifies that the [eq]#A# value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
  */
export enum VkColorComponentFlagBits {
  VK_COLOR_COMPONENT_R_BIT,
  VK_COLOR_COMPONENT_G_BIT,
  VK_COLOR_COMPONENT_B_BIT,
  VK_COLOR_COMPONENT_A_BIT,
  
}

declare const VK_COLOR_COMPONENT_R_BIT: VkColorComponentFlagBits;
declare const VK_COLOR_COMPONENT_G_BIT: VkColorComponentFlagBits;
declare const VK_COLOR_COMPONENT_B_BIT: VkColorComponentFlagBits;
declare const VK_COLOR_COMPONENT_A_BIT: VkColorComponentFlagBits;



/**
  * Bitmask specifying initial state and behavior of a fence
  * @member VK_FENCE_CREATE_SIGNALED_BIT specifies that the fence object is created in the signaled state. Otherwise, it is created in the unsignaled state.
  */
export enum VkFenceCreateFlagBits {
  VK_FENCE_CREATE_SIGNALED_BIT,
  
}

declare const VK_FENCE_CREATE_SIGNALED_BIT: VkFenceCreateFlagBits;



/**
  * Bitmask specifying features supported by a buffer
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT specifies that an image view 'can' be <<descriptorsets-sampledimage, sampled from>>.
  * @member VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT specifies that an image view 'can' be used as a <<descriptorsets-storageimage, storage images>>.
  * @member VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT specifies that an image view 'can' be used as storage image that supports atomic operations.
  * @member VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT
  * @member VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT
  * @member VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
  * @member VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT
  * @member VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT specifies that an image view 'can' be used as a framebuffer color attachment and as an input attachment.
  * @member VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT specifies that an image view 'can' be used as a framebuffer color attachment that supports blending and as an input attachment.
  * @member VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT specifies that an image view 'can' be used as a framebuffer depth/stencil attachment and as an input attachment.
  * @member VK_FORMAT_FEATURE_BLIT_SRC_BIT specifies that an image 'can' be used as 'srcImage' for theifndef::VK_KHR_copy_commands2[] 'vkCmdBlitImage' command.endif::VK_KHR_copy_commands2[] 'vkCmdBlitImage2KHR' and 'vkCmdBlitImage' commands.
  * @member VK_FORMAT_FEATURE_BLIT_DST_BIT
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
  * @member VK_FORMAT_FEATURE_TRANSFER_SRC_BIT
  * @member VK_FORMAT_FEATURE_TRANSFER_DST_BIT
  * @member VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
  * @member VK_FORMAT_FEATURE_DISJOINT_BIT
  * @member VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG
  * @member VK_FORMAT_FEATURE_RESERVED_27_BIT_KHR
  * @member VK_FORMAT_FEATURE_RESERVED_28_BIT_KHR
  * @member VK_FORMAT_FEATURE_RESERVED_25_BIT_KHR
  * @member VK_FORMAT_FEATURE_RESERVED_26_BIT_KHR
  * @member VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR
  * @member VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT
  * @member VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
  * @member VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR
  * @member VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT
  * @member VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR
  * @member VK_FORMAT_FEATURE_DISJOINT_BIT_KHR
  * @member VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR
  * @member VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
  */
export enum VkFormatFeatureFlagBits {
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
  VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
  VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
  VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
  VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
  VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
  VK_FORMAT_FEATURE_BLIT_SRC_BIT,
  VK_FORMAT_FEATURE_BLIT_DST_BIT,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
  VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
  VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
  VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
  VK_FORMAT_FEATURE_DISJOINT_BIT,
  VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
  VK_FORMAT_FEATURE_RESERVED_27_BIT_KHR,
  VK_FORMAT_FEATURE_RESERVED_28_BIT_KHR,
  VK_FORMAT_FEATURE_RESERVED_25_BIT_KHR,
  VK_FORMAT_FEATURE_RESERVED_26_BIT_KHR,
  VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR,
  VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT,
  VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
  VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR,
  VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT,
  VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR,
  VK_FORMAT_FEATURE_DISJOINT_BIT_KHR,
  VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT,
  
}

declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_BLIT_SRC_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_BLIT_DST_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_TRANSFER_SRC_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_TRANSFER_DST_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_DISJOINT_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_RESERVED_27_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_RESERVED_28_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_RESERVED_25_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_RESERVED_26_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_DISJOINT_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits;
declare const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT: VkFormatFeatureFlagBits;



/**
  * Bitmask specifying constraints on a query
  * @member VK_QUERY_CONTROL_PRECISE_BIT specifies the precision of <<queries-occlusion, occlusion queries>>.
  */
export enum VkQueryControlFlagBits {
  VK_QUERY_CONTROL_PRECISE_BIT,
  
}

declare const VK_QUERY_CONTROL_PRECISE_BIT: VkQueryControlFlagBits;



/**
  * Bitmask specifying how and when query results are returned
  * @member VK_QUERY_RESULT_64_BIT
  * @member VK_QUERY_RESULT_WAIT_BIT
  * @member VK_QUERY_RESULT_WITH_AVAILABILITY_BIT
  * @member VK_QUERY_RESULT_PARTIAL_BIT
  */
export enum VkQueryResultFlagBits {
  VK_QUERY_RESULT_64_BIT,
  VK_QUERY_RESULT_WAIT_BIT,
  VK_QUERY_RESULT_WITH_AVAILABILITY_BIT,
  VK_QUERY_RESULT_PARTIAL_BIT,
  
}

declare const VK_QUERY_RESULT_64_BIT: VkQueryResultFlagBits;
declare const VK_QUERY_RESULT_WAIT_BIT: VkQueryResultFlagBits;
declare const VK_QUERY_RESULT_WITH_AVAILABILITY_BIT: VkQueryResultFlagBits;
declare const VK_QUERY_RESULT_PARTIAL_BIT: VkQueryResultFlagBits;



/**
  * Bitmask specifying usage behavior for command buffer
  * @member VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT specifies that each recording of the command buffer will only be submitted once, and the command buffer will be reset and recorded again between each submission.
  * @member VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT specifies that a secondary command buffer is considered to be entirely inside a render pass. If this is a primary command buffer, then this bit is ignored.
  * @member VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT specifies that a command buffer 'can' be resubmitted to a queue while it is in the _pending state_, and recorded into multiple primary command buffers.
  */
export enum VkCommandBufferUsageFlagBits {
  VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
  VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
  VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
  
}

declare const VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT: VkCommandBufferUsageFlagBits;
declare const VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT: VkCommandBufferUsageFlagBits;
declare const VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT: VkCommandBufferUsageFlagBits;



/**
  * Bitmask specifying queried pipeline statistics
  * @member VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT specifies that queries managed by the pool will count the number of vertices processed by the <<drawing,input assembly>> stage. Vertices corresponding to incomplete primitives 'may' contribute to the count.
  * @member VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT specifies that queries managed by the pool will count the number of primitives processed by the <<drawing,input assembly>> stage. If primitive restart is enabled, restarting the primitive topology has no effect on the count. Incomplete primitives 'may' be counted.
  * @member VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of vertex shader invocations. This counter's value is incremented each time a vertex shader is <<shaders-vertex-execution,invoked>>.
  * @member VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of geometry shader invocations. This counter's value is incremented each time a geometry shader is <<shaders-geometry-execution,invoked>>. In the case of <<geometry-invocations,instanced geometry shaders>>, the geometry shader invocations count is incremented for each separate instanced invocation.
  * @member VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT specifies that queries managed by the pool will count the number of primitives generated by geometry shader invocations. The counter's value is incremented each time the geometry shader emits a primitive. Restarting primitive topology using the SPIR-V instructions 'OpEndPrimitive' or 'OpEndStreamPrimitive' has no effect on the geometry shader output primitives count.
  * @member VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of primitives processed by the <<vertexpostproc-clipping,Primitive Clipping>> stage of the pipeline. The counter's value is incremented each time a primitive reaches the primitive clipping stage.
  * @member VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT specifies that queries managed by the pool will count the number of primitives output by the <<vertexpostproc-clipping,Primitive Clipping>> stage of the pipeline. The counter's value is incremented each time a primitive passes the primitive clipping stage. The actual number of primitives output by the primitive clipping stage for a particular input primitive is implementation-dependent but 'must' satisfy the following conditions:
  * @member VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of fragment shader invocations. The counter's value is incremented each time the fragment shader is <<shaders-fragment-execution,invoked>>.
  * @member VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT specifies that queries managed by the pool will count the number of patches processed by the tessellation control shader. The counter's value is incremented once for each patch for which a tessellation control shader is <<shaders-tessellation-control-execution,invoked>>.
  * @member VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of invocations of the tessellation evaluation shader. The counter's value is incremented each time the tessellation evaluation shader is <<shaders-tessellation-evaluation-execution,invoked>>.
  * @member VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of compute shader invocations. The counter's value is incremented every time the compute shader is invoked. Implementations 'may' skip the execution of certain compute shader invocations or execute additional compute shader invocations for implementation-dependent reasons as long as the results of rendering otherwise remain unchanged.
  */
export enum VkQueryPipelineStatisticFlagBits {
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
  VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
  VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
  VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT,
  
}

declare const VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT: VkQueryPipelineStatisticFlagBits;
declare const VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT: VkQueryPipelineStatisticFlagBits;
declare const VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits;
declare const VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits;
declare const VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT: VkQueryPipelineStatisticFlagBits;
declare const VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits;
declare const VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT: VkQueryPipelineStatisticFlagBits;
declare const VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits;
declare const VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT: VkQueryPipelineStatisticFlagBits;
declare const VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits;
declare const VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits;



/**
  * Bitmask specifying which aspects of an image are included in a view
  * @member VK_IMAGE_ASPECT_COLOR_BIT specifies the color aspect.
  * @member VK_IMAGE_ASPECT_DEPTH_BIT specifies the depth aspect.
  * @member VK_IMAGE_ASPECT_STENCIL_BIT specifies the stencil aspect.
  * @member VK_IMAGE_ASPECT_METADATA_BIT specifies the metadata aspect, used for sparse <<sparsememory, sparse resource>> operations.
  * @member VK_IMAGE_ASPECT_PLANE_0_BIT specifies plane 0 of a _multi-planar_ image format.
  * @member VK_IMAGE_ASPECT_PLANE_1_BIT specifies plane 1 of a _multi-planar_ image format.
  * @member VK_IMAGE_ASPECT_PLANE_2_BIT specifies plane 2 of a _multi-planar_ image format.
  * @member VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT
  * @member VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT
  * @member VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT
  * @member VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT
  * @member VK_IMAGE_ASPECT_PLANE_0_BIT_KHR
  * @member VK_IMAGE_ASPECT_PLANE_1_BIT_KHR
  * @member VK_IMAGE_ASPECT_PLANE_2_BIT_KHR
  */
export enum VkImageAspectFlagBits {
  VK_IMAGE_ASPECT_COLOR_BIT,
  VK_IMAGE_ASPECT_DEPTH_BIT,
  VK_IMAGE_ASPECT_STENCIL_BIT,
  VK_IMAGE_ASPECT_METADATA_BIT,
  VK_IMAGE_ASPECT_PLANE_0_BIT,
  VK_IMAGE_ASPECT_PLANE_1_BIT,
  VK_IMAGE_ASPECT_PLANE_2_BIT,
  VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT,
  VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT,
  VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT,
  VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT,
  VK_IMAGE_ASPECT_PLANE_0_BIT_KHR,
  VK_IMAGE_ASPECT_PLANE_1_BIT_KHR,
  VK_IMAGE_ASPECT_PLANE_2_BIT_KHR,
  
}

declare const VK_IMAGE_ASPECT_COLOR_BIT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_DEPTH_BIT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_STENCIL_BIT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_METADATA_BIT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_PLANE_0_BIT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_PLANE_1_BIT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_PLANE_2_BIT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_PLANE_0_BIT_KHR: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_PLANE_1_BIT_KHR: VkImageAspectFlagBits;
declare const VK_IMAGE_ASPECT_PLANE_2_BIT_KHR: VkImageAspectFlagBits;



/**
  * Bitmask specifying additional information about a sparse image resource
  * @member VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT specifies that the image uses a single mip tail region for all array layers.
  * @member VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT specifies that the first mip level whose dimensions are not integer multiples of the corresponding dimensions of the sparse image block begins the mip tail region.
  * @member VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT specifies that the image uses non-standard sparse image block dimensions, and the 'imageGranularity' values do not match the standard sparse image block dimensions for the given format.
  */
export enum VkSparseImageFormatFlagBits {
  VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT,
  VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT,
  VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT,
  
}

declare const VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT: VkSparseImageFormatFlagBits;
declare const VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT: VkSparseImageFormatFlagBits;
declare const VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT: VkSparseImageFormatFlagBits;



/**
  * Bitmask specifying usage of a sparse memory binding operation
  * @member VK_SPARSE_MEMORY_BIND_METADATA_BIT specifies that the memory being bound is only for the metadata aspect.
  */
export enum VkSparseMemoryBindFlagBits {
  VK_SPARSE_MEMORY_BIND_METADATA_BIT,
  
}

declare const VK_SPARSE_MEMORY_BIND_METADATA_BIT: VkSparseMemoryBindFlagBits;



/**
  * Bitmask specifying pipeline stages
  * @member VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT is equivalent to 'VK_PIPELINE_STAGE_ALL_COMMANDS_BIT' with 'VkAccessFlags' set to `0` when specified in the second synchronization scope, but specifies no stages in the first scope.
  * @member VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT specifies the stage of the pipeline where Draw/DispatchIndirect/TraceRaysIndirect data structures are consumed. This stage also includes reading commands written by 'vkCmdExecuteGeneratedCommandsNV'.
  * @member VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
  * @member VK_PIPELINE_STAGE_VERTEX_SHADER_BIT
  * @member VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT
  * @member VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
  * @member VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
  * @member VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
  * @member VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
  * @member VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
  * @member VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
  * @member VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
  * @member VK_PIPELINE_STAGE_TRANSFER_BIT
  * @member VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT
  * @member VK_PIPELINE_STAGE_HOST_BIT
  * @member VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT
  * @member VK_PIPELINE_STAGE_ALL_COMMANDS_BIT
  * @member VK_PIPELINE_STAGE_RESERVED_27_BIT_KHR
  * @member VK_PIPELINE_STAGE_RESERVED_26_BIT_KHR
  * @member VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT
  * @member VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT
  * @member VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
  * @member VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR
  * @member VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV
  * @member VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
  * @member VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
  * @member VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT
  * @member VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV
  * @member VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV
  * @member VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV
  * @member VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
  */
export enum VkPipelineStageFlagBits {
  VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
  VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
  VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
  VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
  VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
  VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
  VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
  VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
  VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
  VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
  VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
  VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
  VK_PIPELINE_STAGE_TRANSFER_BIT,
  VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
  VK_PIPELINE_STAGE_HOST_BIT,
  VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
  VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
  VK_PIPELINE_STAGE_RESERVED_27_BIT_KHR,
  VK_PIPELINE_STAGE_RESERVED_26_BIT_KHR,
  VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT,
  VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT,
  VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
  VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
  VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV,
  VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV,
  VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV,
  VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT,
  VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV,
  VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV,
  VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV,
  VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
  
}

declare const VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_TRANSFER_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_HOST_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_RESERVED_27_BIT_KHR: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_RESERVED_26_BIT_KHR: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV: VkPipelineStageFlagBits;
declare const VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkPipelineStageFlagBits;



/**
  * Bitmask specifying usage behavior for a command pool
  * @member VK_COMMAND_POOL_CREATE_TRANSIENT_BIT specifies that command buffers allocated from the pool will be short-lived, meaning that they will be reset or freed in a relatively short timeframe. This flag 'may' be used by the implementation to control memory allocation behavior within the pool.
  * @member VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT allows any command buffer allocated from a pool to be individually reset to the <<commandbuffers-lifecycle, initial state>>; either by calling 'vkResetCommandBuffer', or via the implicit reset when calling 'vkBeginCommandBuffer'. If this flag is not set on a pool, then 'vkResetCommandBuffer' 'must' not be called for any command buffer allocated from that pool.
  * @member VK_COMMAND_POOL_CREATE_PROTECTED_BIT specifies that command buffers allocated from the pool are protected command buffers.
  */
export enum VkCommandPoolCreateFlagBits {
  VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
  VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
  VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
  
}

declare const VK_COMMAND_POOL_CREATE_TRANSIENT_BIT: VkCommandPoolCreateFlagBits;
declare const VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT: VkCommandPoolCreateFlagBits;
declare const VK_COMMAND_POOL_CREATE_PROTECTED_BIT: VkCommandPoolCreateFlagBits;



/**
  * Bitmask controlling behavior of a command pool reset
  * @member VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT specifies that resetting a command pool recycles all of the resources from the command pool back to the system.
  */
export enum VkCommandPoolResetFlagBits {
  VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,
  
}

declare const VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT: VkCommandPoolResetFlagBits;



/**
  * Bitmask controlling behavior of a command buffer reset
  * @member VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT specifies that most or all memory resources currently owned by the command buffer 'should' be returned to the parent command pool. If this flag is not set, then the command buffer 'may' hold onto memory resources and reuse them when recording commands. 'commandBuffer' is moved to the <<commandbuffers-lifecycle, initial state>>.
  */
export enum VkCommandBufferResetFlagBits {
  VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT,
  
}

declare const VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT: VkCommandBufferResetFlagBits;



/**
  * Bitmask specifying sample counts supported for an image used for storage operations
  * @member VK_SAMPLE_COUNT_1_BIT
  * @member VK_SAMPLE_COUNT_2_BIT
  * @member VK_SAMPLE_COUNT_4_BIT
  * @member VK_SAMPLE_COUNT_8_BIT
  * @member VK_SAMPLE_COUNT_16_BIT
  * @member VK_SAMPLE_COUNT_32_BIT
  * @member VK_SAMPLE_COUNT_64_BIT
  */
export enum VkSampleCountFlagBits {
  VK_SAMPLE_COUNT_1_BIT,
  VK_SAMPLE_COUNT_2_BIT,
  VK_SAMPLE_COUNT_4_BIT,
  VK_SAMPLE_COUNT_8_BIT,
  VK_SAMPLE_COUNT_16_BIT,
  VK_SAMPLE_COUNT_32_BIT,
  VK_SAMPLE_COUNT_64_BIT,
  
}

declare const VK_SAMPLE_COUNT_1_BIT: VkSampleCountFlagBits;
declare const VK_SAMPLE_COUNT_2_BIT: VkSampleCountFlagBits;
declare const VK_SAMPLE_COUNT_4_BIT: VkSampleCountFlagBits;
declare const VK_SAMPLE_COUNT_8_BIT: VkSampleCountFlagBits;
declare const VK_SAMPLE_COUNT_16_BIT: VkSampleCountFlagBits;
declare const VK_SAMPLE_COUNT_32_BIT: VkSampleCountFlagBits;
declare const VK_SAMPLE_COUNT_64_BIT: VkSampleCountFlagBits;



/**
  * Bitmask specifying additional properties of an attachment
  * @member VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT specifies that the attachment aliases the same device memory as other attachments.
  */
export enum VkAttachmentDescriptionFlagBits {
  VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
  
}

declare const VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT: VkAttachmentDescriptionFlagBits;



/**
  * Bitmask specifying sets of stencil state for which to update the compare mask
  * @member VK_STENCIL_FACE_FRONT_BIT specifies that only the front set of stencil state is updated.
  * @member VK_STENCIL_FACE_BACK_BIT specifies that only the back set of stencil state is updated.
  * @member VK_STENCIL_FACE_FRONT_AND_BACK is the combination of 'VK_STENCIL_FACE_FRONT_BIT' and 'VK_STENCIL_FACE_BACK_BIT', and specifies that both sets of stencil state are updated.
  * @member VK_STENCIL_FRONT_AND_BACK
  */
export enum VkStencilFaceFlagBits {
  VK_STENCIL_FACE_FRONT_BIT,
  VK_STENCIL_FACE_BACK_BIT,
  VK_STENCIL_FACE_FRONT_AND_BACK,
  VK_STENCIL_FRONT_AND_BACK,
  
}

declare const VK_STENCIL_FACE_FRONT_BIT: VkStencilFaceFlagBits;
declare const VK_STENCIL_FACE_BACK_BIT: VkStencilFaceFlagBits;
declare const VK_STENCIL_FACE_FRONT_AND_BACK: VkStencilFaceFlagBits;
declare const VK_STENCIL_FRONT_AND_BACK: VkStencilFaceFlagBits;



/**
  * Bitmask specifying certain supported operations on a descriptor pool
  * @member VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT specifies that descriptor sets 'can' return their individual allocations to the pool, i.e. all of 'vkAllocateDescriptorSets', 'vkFreeDescriptorSets', and 'vkResetDescriptorPool' are allowed. Otherwise, descriptor sets allocated from the pool 'must' not be individually freed back to the pool, i.e. only 'vkAllocateDescriptorSets' and 'vkResetDescriptorPool' are allowed.
  * @member VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT specifies that descriptor sets allocated from this pool 'can' include bindings with the 'VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT' bit set. It is valid to allocate descriptor sets that have bindings that do not set the 'VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT' bit from a pool that has 'VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT' set.
  * @member VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT
  */
export enum VkDescriptorPoolCreateFlagBits {
  VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
  VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
  VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT,
  
}

declare const VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: VkDescriptorPoolCreateFlagBits;
declare const VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT: VkDescriptorPoolCreateFlagBits;
declare const VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorPoolCreateFlagBits;



/**
  * Bitmask specifying how execution and memory dependencies are formed
  * @member VK_DEPENDENCY_BY_REGION_BIT specifies that dependencies will be <<synchronization-framebuffer-regions, framebuffer-local>>.
  * @member VK_DEPENDENCY_DEVICE_GROUP_BIT
  * @member VK_DEPENDENCY_VIEW_LOCAL_BIT specifies that a <<synchronization-pipeline-barriers-subpass-self-dependencies, subpass has more than one view>>.
  * @member VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR
  * @member VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR
  */
export enum VkDependencyFlagBits {
  VK_DEPENDENCY_BY_REGION_BIT,
  VK_DEPENDENCY_DEVICE_GROUP_BIT,
  VK_DEPENDENCY_VIEW_LOCAL_BIT,
  VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR,
  VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR,
  
}

declare const VK_DEPENDENCY_BY_REGION_BIT: VkDependencyFlagBits;
declare const VK_DEPENDENCY_DEVICE_GROUP_BIT: VkDependencyFlagBits;
declare const VK_DEPENDENCY_VIEW_LOCAL_BIT: VkDependencyFlagBits;
declare const VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR: VkDependencyFlagBits;
declare const VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR: VkDependencyFlagBits;



/**
  * Bitmask specifying additional parameters of a semaphore wait operation
  * @member VK_SEMAPHORE_WAIT_ANY_BIT
  * @member VK_SEMAPHORE_WAIT_ANY_BIT_KHR
  */
export enum VkSemaphoreWaitFlagBits {
  VK_SEMAPHORE_WAIT_ANY_BIT,
  VK_SEMAPHORE_WAIT_ANY_BIT_KHR,
  
}

declare const VK_SEMAPHORE_WAIT_ANY_BIT: VkSemaphoreWaitFlagBits;
declare const VK_SEMAPHORE_WAIT_ANY_BIT_KHR: VkSemaphoreWaitFlagBits;



/**
  * Alpha blending type
  * @member VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR specifies that the source image will be treated as opaque.
  * @member VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR specifies that a global alpha value 'must' be specified that will be applied to all pixels in the source image.
  * @member VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR specifies that the alpha value will be determined by the alpha channel of the source image's pixels. If the source format contains no alpha values, no blending will be applied. The source alpha values are not premultiplied into the source image's other color channels.
  * @member VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR is equivalent to 'VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR', except the source alpha values are assumed to be premultiplied into the source image's other color channels.
  */
export enum VkDisplayPlaneAlphaFlagBitsKHR {
  VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,
  VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR,
  
}

declare const VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR;
declare const VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR;
declare const VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR;
declare const VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR;



/**
  * alpha compositing modes supported on a device
  * @member VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR
  * @member VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR
  * @member VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR
  * @member VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR
  */
export enum VkCompositeAlphaFlagBitsKHR {
  VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
  VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
  VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
  VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
  
}

declare const VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: VkCompositeAlphaFlagBitsKHR;
declare const VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: VkCompositeAlphaFlagBitsKHR;
declare const VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: VkCompositeAlphaFlagBitsKHR;
declare const VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: VkCompositeAlphaFlagBitsKHR;



/**
  * presentation transforms supported on a device
  * @member VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR specifies that image content is presented without being transformed.
  * @member VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR specifies that image content is rotated 90 degrees clockwise.
  * @member VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR specifies that image content is rotated 180 degrees clockwise.
  * @member VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR specifies that image content is rotated 270 degrees clockwise.
  * @member VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR specifies that image content is mirrored horizontally.
  * @member VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR specifies that image content is mirrored horizontally, then rotated 90 degrees clockwise.
  * @member VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR specifies that image content is mirrored horizontally, then rotated 180 degrees clockwise.
  * @member VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR specifies that image content is mirrored horizontally, then rotated 270 degrees clockwise.
  * @member VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR specifies that the presentation transform is not specified, and is instead determined by platform-specific considerations and mechanisms outside Vulkan.
  */
export enum VkSurfaceTransformFlagBitsKHR {
  VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
  VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
  VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
  VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
  VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
  
}

declare const VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR: VkSurfaceTransformFlagBitsKHR;
declare const VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR: VkSurfaceTransformFlagBitsKHR;
declare const VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR: VkSurfaceTransformFlagBitsKHR;
declare const VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR: VkSurfaceTransformFlagBitsKHR;
declare const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR: VkSurfaceTransformFlagBitsKHR;
declare const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR: VkSurfaceTransformFlagBitsKHR;
declare const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: VkSurfaceTransformFlagBitsKHR;
declare const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: VkSurfaceTransformFlagBitsKHR;
declare const VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR: VkSurfaceTransformFlagBitsKHR;



/**
  * 
  * @member VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID
  */
export enum VkSwapchainImageUsageFlagBitsANDROID {
  VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID,
  
}

declare const VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID: VkSwapchainImageUsageFlagBitsANDROID;



/**
  * Bitmask specifying events which cause a debug report callback
  * @member VK_DEBUG_REPORT_INFORMATION_BIT_EXT specifies an informational message such as resource details that may be handy when debugging an application.
  * @member VK_DEBUG_REPORT_WARNING_BIT_EXT specifies use of Vulkan that 'may' expose an app bug. Such cases may not be immediately harmful, such as a fragment shader outputting to a location with no attachment. Other cases 'may' point to behavior that is almost certainly bad when unintended such as using an image whose memory has not been filled. In general if you see a warning but you know that the behavior is intended/desired, then simply ignore the warning.
  * @member VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT specifies a potentially non-optimal use of Vulkan, e.g. using 'vkCmdClearColorImage' when setting 'VkAttachmentDescription'::'loadOp' to 'VK_ATTACHMENT_LOAD_OP_CLEAR' would have worked.
  * @member VK_DEBUG_REPORT_ERROR_BIT_EXT specifies that the application has violated a valid usage condition of the specification.
  * @member VK_DEBUG_REPORT_DEBUG_BIT_EXT specifies diagnostic information from the implementation and layers.
  */
export enum VkDebugReportFlagBitsEXT {
  VK_DEBUG_REPORT_INFORMATION_BIT_EXT,
  VK_DEBUG_REPORT_WARNING_BIT_EXT,
  VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
  VK_DEBUG_REPORT_ERROR_BIT_EXT,
  VK_DEBUG_REPORT_DEBUG_BIT_EXT,
  
}

declare const VK_DEBUG_REPORT_INFORMATION_BIT_EXT: VkDebugReportFlagBitsEXT;
declare const VK_DEBUG_REPORT_WARNING_BIT_EXT: VkDebugReportFlagBitsEXT;
declare const VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT: VkDebugReportFlagBitsEXT;
declare const VK_DEBUG_REPORT_ERROR_BIT_EXT: VkDebugReportFlagBitsEXT;
declare const VK_DEBUG_REPORT_DEBUG_BIT_EXT: VkDebugReportFlagBitsEXT;



/**
  * Bitmask specifying external memory handle types
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV specifies a handle to memory returned by 'vkGetMemoryWin32HandleNV', or one duplicated from such a handle using `DuplicateHandle()`.
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV specifies a handle to memory returned by 'vkGetMemoryWin32HandleNV'.
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV specifies a valid NT handle to memory returned by `IDXGIResource1::CreateSharedHandle`, or a handle duplicated from such a handle using `DuplicateHandle()`.
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV specifies a handle to memory returned by `IDXGIResource::GetSharedHandle()`.
  */
export enum VkExternalMemoryHandleTypeFlagBitsNV {
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV,
  
}

declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV: VkExternalMemoryHandleTypeFlagBitsNV;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV: VkExternalMemoryHandleTypeFlagBitsNV;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV: VkExternalMemoryHandleTypeFlagBitsNV;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV: VkExternalMemoryHandleTypeFlagBitsNV;



/**
  * Bitmask specifying external memory features
  * @member VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV specifies that external memory of the specified type 'must' be created as a dedicated allocation when used in the manner specified.
  * @member VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV specifies that the implementation supports exporting handles of the specified type.
  * @member VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV specifies that the implementation supports importing handles of the specified type.
  */
export enum VkExternalMemoryFeatureFlagBitsNV {
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV,
  
}

declare const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: VkExternalMemoryFeatureFlagBitsNV;
declare const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV: VkExternalMemoryFeatureFlagBitsNV;
declare const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV: VkExternalMemoryFeatureFlagBitsNV;



/**
  * Enum describing what group operations are supported with subgroup scope
  * @member VK_SUBGROUP_FEATURE_BASIC_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniform' capability.
  * @member VK_SUBGROUP_FEATURE_VOTE_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformVote' capability.
  * @member VK_SUBGROUP_FEATURE_ARITHMETIC_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformArithmetic' capability.
  * @member VK_SUBGROUP_FEATURE_BALLOT_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformBallot' capability.
  * @member VK_SUBGROUP_FEATURE_SHUFFLE_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformShuffle' capability.
  * @member VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformShuffleRelative' capability.
  * @member VK_SUBGROUP_FEATURE_CLUSTERED_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformClustered' capability.
  * @member VK_SUBGROUP_FEATURE_QUAD_BIT specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformQuad' capability.
  * @member VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV specifies the device will accept SPIR-V shader modules containing the 'GroupNonUniformPartitionedNV' capability.
  */
export enum VkSubgroupFeatureFlagBits {
  VK_SUBGROUP_FEATURE_BASIC_BIT,
  VK_SUBGROUP_FEATURE_VOTE_BIT,
  VK_SUBGROUP_FEATURE_ARITHMETIC_BIT,
  VK_SUBGROUP_FEATURE_BALLOT_BIT,
  VK_SUBGROUP_FEATURE_SHUFFLE_BIT,
  VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT,
  VK_SUBGROUP_FEATURE_CLUSTERED_BIT,
  VK_SUBGROUP_FEATURE_QUAD_BIT,
  VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV,
  
}

declare const VK_SUBGROUP_FEATURE_BASIC_BIT: VkSubgroupFeatureFlagBits;
declare const VK_SUBGROUP_FEATURE_VOTE_BIT: VkSubgroupFeatureFlagBits;
declare const VK_SUBGROUP_FEATURE_ARITHMETIC_BIT: VkSubgroupFeatureFlagBits;
declare const VK_SUBGROUP_FEATURE_BALLOT_BIT: VkSubgroupFeatureFlagBits;
declare const VK_SUBGROUP_FEATURE_SHUFFLE_BIT: VkSubgroupFeatureFlagBits;
declare const VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: VkSubgroupFeatureFlagBits;
declare const VK_SUBGROUP_FEATURE_CLUSTERED_BIT: VkSubgroupFeatureFlagBits;
declare const VK_SUBGROUP_FEATURE_QUAD_BIT: VkSubgroupFeatureFlagBits;
declare const VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV: VkSubgroupFeatureFlagBits;



/**
  * Bitmask specifying allowed usage of an indirect commands layout
  * @member VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV specifies that the layout is always used with the manual preprocessing step through calling 'vkCmdPreprocessGeneratedCommandsNV' and executed by 'vkCmdExecuteGeneratedCommandsNV' with `isPreprocessed` set to 'VK_TRUE'.
  * @member VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV specifies that the input data for the sequences is not implicitly indexed from 0..sequencesUsed but a user provided 'VkBuffer' encoding the index is provided.
  * @member VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV specifies that the processing of sequences 'can' happen at an implementation-dependent order, which is not: guaranteed to be coherent using the same input data.
  */
export enum VkIndirectCommandsLayoutUsageFlagBitsNV {
  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV,
  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV,
  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV,
  
}

declare const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV: VkIndirectCommandsLayoutUsageFlagBitsNV;
declare const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV: VkIndirectCommandsLayoutUsageFlagBitsNV;
declare const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV: VkIndirectCommandsLayoutUsageFlagBitsNV;



/**
  * Bitmask specifiying state that can be altered on the device
  * @member VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV
  */
export enum VkIndirectStateFlagBitsNV {
  VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV,
  
}

declare const VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV: VkIndirectStateFlagBitsNV;



/**
  * Bitmask specifying additional parameters for private data slot creation
  */
export enum VkPrivateDataSlotCreateFlagBitsEXT {
  
}




/**
  * Bitmask specifying descriptor set layout properties
  * @member VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT
  * @member VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR specifies that descriptor sets 'must' not be allocated using this layout, and descriptors are instead pushed by 'vkCmdPushDescriptorSetKHR'.
  * @member VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT
  */
export enum VkDescriptorSetLayoutCreateFlagBits {
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,
  
}

declare const VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT: VkDescriptorSetLayoutCreateFlagBits;
declare const VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR: VkDescriptorSetLayoutCreateFlagBits;
declare const VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT: VkDescriptorSetLayoutCreateFlagBits;



/**
  * Bit specifying external memory handle types
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR
  */
export enum VkExternalMemoryHandleTypeFlagBits {
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR,
  
}

declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR: VkExternalMemoryHandleTypeFlagBits;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR: VkExternalMemoryHandleTypeFlagBits;



/**
  * Bitmask specifying features of an external memory handle type
  * @member VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT
  * @member VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT
  * @member VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT
  * @member VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR
  */
export enum VkExternalMemoryFeatureFlagBits {
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR,
  
}

declare const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: VkExternalMemoryFeatureFlagBits;
declare const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT: VkExternalMemoryFeatureFlagBits;
declare const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT: VkExternalMemoryFeatureFlagBits;
declare const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR: VkExternalMemoryFeatureFlagBits;
declare const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBits;
declare const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBits;



/**
  * Bitmask of valid external semaphore handle types
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR
  */
export enum VkExternalSemaphoreHandleTypeFlagBits {
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
  
}

declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalSemaphoreHandleTypeFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalSemaphoreHandleTypeFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalSemaphoreHandleTypeFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT: VkExternalSemaphoreHandleTypeFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits;



/**
  * Bitfield describing features of an external semaphore handle type
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR
  */
export enum VkExternalSemaphoreFeatureFlagBits {
  VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
  VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
  VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR,
  
}

declare const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: VkExternalSemaphoreFeatureFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: VkExternalSemaphoreFeatureFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBits;
declare const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBits;



/**
  * Bitmask specifying additional parameters of semaphore payload import
  * @member VK_SEMAPHORE_IMPORT_TEMPORARY_BIT
  * @member VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR
  */
export enum VkSemaphoreImportFlagBits {
  VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
  VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR,
  
}

declare const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: VkSemaphoreImportFlagBits;
declare const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR: VkSemaphoreImportFlagBits;



/**
  * Bitmask of valid external fence handle types
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR
  */
export enum VkExternalFenceHandleTypeFlagBits {
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
  
}

declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalFenceHandleTypeFlagBits;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalFenceHandleTypeFlagBits;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalFenceHandleTypeFlagBits;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT: VkExternalFenceHandleTypeFlagBits;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBits;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalFenceHandleTypeFlagBits;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalFenceHandleTypeFlagBits;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBits;



/**
  * Bitfield describing features of an external fence handle type
  * @member VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT
  * @member VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT
  * @member VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR
  * @member VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR
  */
export enum VkExternalFenceFeatureFlagBits {
  VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
  VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
  VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR,
  VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR,
  
}

declare const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: VkExternalFenceFeatureFlagBits;
declare const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: VkExternalFenceFeatureFlagBits;
declare const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBits;
declare const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBits;



/**
  * Bitmask specifying additional parameters of fence payload import
  * @member VK_FENCE_IMPORT_TEMPORARY_BIT
  * @member VK_FENCE_IMPORT_TEMPORARY_BIT_KHR
  */
export enum VkFenceImportFlagBits {
  VK_FENCE_IMPORT_TEMPORARY_BIT,
  VK_FENCE_IMPORT_TEMPORARY_BIT_KHR,
  
}

declare const VK_FENCE_IMPORT_TEMPORARY_BIT: VkFenceImportFlagBits;
declare const VK_FENCE_IMPORT_TEMPORARY_BIT_KHR: VkFenceImportFlagBits;



/**
  * Surface-relative counter types
  * @member VK_SURFACE_COUNTER_VBLANK_BIT_EXT specifies a counter incrementing once every time a vertical blanking period occurs on the display associated with the surface.
  * @member VK_SURFACE_COUNTER_VBLANK_EXT
  */
export enum VkSurfaceCounterFlagBitsEXT {
  VK_SURFACE_COUNTER_VBLANK_BIT_EXT,
  VK_SURFACE_COUNTER_VBLANK_EXT,
  
}

declare const VK_SURFACE_COUNTER_VBLANK_BIT_EXT: VkSurfaceCounterFlagBitsEXT;
declare const VK_SURFACE_COUNTER_VBLANK_EXT: VkSurfaceCounterFlagBitsEXT;



/**
  * Bitmask specifying supported peer memory features
  * @member VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT
  * @member VK_PEER_MEMORY_FEATURE_COPY_DST_BIT
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT
  * @member VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR
  * @member VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR
  */
export enum VkPeerMemoryFeatureFlagBits {
  VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
  VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
  VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
  VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
  VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR,
  VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR,
  VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR,
  VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR,
  
}

declare const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT: VkPeerMemoryFeatureFlagBits;
declare const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT: VkPeerMemoryFeatureFlagBits;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: VkPeerMemoryFeatureFlagBits;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT: VkPeerMemoryFeatureFlagBits;
declare const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBits;
declare const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR: VkPeerMemoryFeatureFlagBits;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBits;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR: VkPeerMemoryFeatureFlagBits;



/**
  * Bitmask specifying flags for a device memory allocation
  * @member VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
  * @member VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
  */
export enum VkMemoryAllocateFlagBits {
  VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
  VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
  
}

declare const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT: VkMemoryAllocateFlagBits;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT: VkMemoryAllocateFlagBits;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: VkMemoryAllocateFlagBits;
declare const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR: VkMemoryAllocateFlagBits;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR: VkMemoryAllocateFlagBits;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkMemoryAllocateFlagBits;



/**
  * Bitmask specifying supported device group present modes
  * @member VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR specifies that any physical device with a presentation engine 'can' present its own swapchain images.
  * @member VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR specifies that any physical device with a presentation engine 'can' present swapchain images from any physical device in its 'presentMask'.
  * @member VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR specifies that any physical device with a presentation engine 'can' present the sum of swapchain images from any physical devices in its 'presentMask'.
  * @member VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR specifies that multiple physical devices with a presentation engine 'can' each present their own swapchain images.
  */
export enum VkDeviceGroupPresentModeFlagBitsKHR {
  VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR,
  VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR,
  VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR,
  VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR,
  
}

declare const VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR;
declare const VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR;
declare const VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR;
declare const VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR;



/**
  * Bitmask controlling swapchain creation
  * @member VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR specifies that images created from the swapchain (i.e. with the 'swapchain' member of 'VkImageSwapchainCreateInfoKHR' set to this swapchain's handle) 'must' use 'VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT'.
  * @member VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR
  * @member VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR
  */
export enum VkSwapchainCreateFlagBitsKHR {
  VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
  VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,
  VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR,
  
}

declare const VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: VkSwapchainCreateFlagBitsKHR;
declare const VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR: VkSwapchainCreateFlagBitsKHR;
declare const VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR: VkSwapchainCreateFlagBitsKHR;



/**
  * Bitmask specifying usage of a subpass
  * @member VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX specifies that shaders compiled for this subpass write the attributes for all views in a single invocation of each vertex processing stage. All pipelines compiled against a subpass that includes this bit 'must' write per-view attributes to the `
  * @member VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX specifies that shaders compiled for this subpass use per-view positions which only differ in value in the x component. Per-view viewport mask 'can' also be used.
  * @member VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM
  * @member VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM
  */
export enum VkSubpassDescriptionFlagBits {
  VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX,
  VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX,
  VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM,
  VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM,
  
}

declare const VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX: VkSubpassDescriptionFlagBits;
declare const VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX: VkSubpassDescriptionFlagBits;
declare const VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM: VkSubpassDescriptionFlagBits;
declare const VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM: VkSubpassDescriptionFlagBits;



/**
  * Bitmask specifying which severities of events cause a debug messenger callback
  * @member VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT specifies the most verbose output indicating all diagnostic messages from the Vulkan loader, layers, and drivers should be captured.
  * @member VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT specifies an informational message such as resource details that may be handy when debugging an application.
  * @member VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT specifies use of Vulkan that 'may' expose an app bug. Such cases may not be immediately harmful, such as a fragment shader outputting to a location with no attachment. Other cases 'may' point to behavior that is almost certainly bad when unintended such as using an image whose memory has not been filled. In general if you see a warning but you know that the behavior is intended/desired, then simply ignore the warning.
  * @member VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT specifies that the application has violated a valid usage condition of the specification.
  */
export enum VkDebugUtilsMessageSeverityFlagBitsEXT {
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT,
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
  
}

declare const VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT;
declare const VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT;
declare const VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT;
declare const VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT;



/**
  * Bitmask specifying which types of events cause a debug messenger callback
  * @member VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT specifies that some general event has occurred. This is typically a non-specification, non-performance event.
  * @member VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT specifies that something has occurred during validation against the Vulkan specification that may indicate invalid behavior.
  * @member VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT specifies a potentially non-optimal use of Vulkan, e.g. using 'vkCmdClearColorImage' when setting 'VkAttachmentDescription'::'loadOp' to 'VK_ATTACHMENT_LOAD_OP_CLEAR' would have worked.
  */
export enum VkDebugUtilsMessageTypeFlagBitsEXT {
  VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
  VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
  VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
  
}

declare const VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT: VkDebugUtilsMessageTypeFlagBitsEXT;
declare const VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT: VkDebugUtilsMessageTypeFlagBitsEXT;
declare const VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT: VkDebugUtilsMessageTypeFlagBitsEXT;



/**
  * Bitmask specifying descriptor set layout binding properties
  * @member VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT
  * @member VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT
  * @member VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT
  * @member VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT
  * @member VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM
  * @member VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
  * @member VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT
  * @member VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT
  * @member VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
  */
export enum VkDescriptorBindingFlagBits {
  VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
  VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
  VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
  VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
  VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM,
  VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT,
  VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT,
  VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT,
  VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT,
  
}

declare const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT: VkDescriptorBindingFlagBits;
declare const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT: VkDescriptorBindingFlagBits;
declare const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT: VkDescriptorBindingFlagBits;
declare const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT: VkDescriptorBindingFlagBits;
declare const VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM: VkDescriptorBindingFlagBits;
declare const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorBindingFlagBits;
declare const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT: VkDescriptorBindingFlagBits;
declare const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT: VkDescriptorBindingFlagBits;
declare const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT: VkDescriptorBindingFlagBits;



/**
  * Specify the behavior of conditional rendering
  * @member VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT specifies the condition used to determine whether to discard rendering commands or not. That is, if the 32-bit predicate read from 'buffer' memory at 'offset' is zero, the rendering commands are not discarded, and if non zero, then they are discarded.
  */
export enum VkConditionalRenderingFlagBitsEXT {
  VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT,
  
}

declare const VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT: VkConditionalRenderingFlagBitsEXT;



/**
  * Bitmask indicating supported depth and stencil resolve modes
  * @member VK_RESOLVE_MODE_NONE
  * @member VK_RESOLVE_MODE_SAMPLE_ZERO_BIT
  * @member VK_RESOLVE_MODE_AVERAGE_BIT
  * @member VK_RESOLVE_MODE_MIN_BIT
  * @member VK_RESOLVE_MODE_MAX_BIT
  * @member VK_RESOLVE_MODE_NONE_KHR
  * @member VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR
  * @member VK_RESOLVE_MODE_AVERAGE_BIT_KHR
  * @member VK_RESOLVE_MODE_MIN_BIT_KHR
  * @member VK_RESOLVE_MODE_MAX_BIT_KHR
  */
export enum VkResolveModeFlagBits {
  VK_RESOLVE_MODE_NONE,
  VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
  VK_RESOLVE_MODE_AVERAGE_BIT,
  VK_RESOLVE_MODE_MIN_BIT,
  VK_RESOLVE_MODE_MAX_BIT,
  VK_RESOLVE_MODE_NONE_KHR,
  VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR,
  VK_RESOLVE_MODE_AVERAGE_BIT_KHR,
  VK_RESOLVE_MODE_MIN_BIT_KHR,
  VK_RESOLVE_MODE_MAX_BIT_KHR,
  
}

declare const VK_RESOLVE_MODE_NONE: VkResolveModeFlagBits;
declare const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: VkResolveModeFlagBits;
declare const VK_RESOLVE_MODE_AVERAGE_BIT: VkResolveModeFlagBits;
declare const VK_RESOLVE_MODE_MIN_BIT: VkResolveModeFlagBits;
declare const VK_RESOLVE_MODE_MAX_BIT: VkResolveModeFlagBits;
declare const VK_RESOLVE_MODE_NONE_KHR: VkResolveModeFlagBits;
declare const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR: VkResolveModeFlagBits;
declare const VK_RESOLVE_MODE_AVERAGE_BIT_KHR: VkResolveModeFlagBits;
declare const VK_RESOLVE_MODE_MIN_BIT_KHR: VkResolveModeFlagBits;
declare const VK_RESOLVE_MODE_MAX_BIT_KHR: VkResolveModeFlagBits;



/**
  * Instance flag bits
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV
  * @member VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV
  * @member VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV
  */
export enum VkGeometryInstanceFlagBitsKHR {
  VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV,
  VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV,
  VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV,
  
}

declare const VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR: VkGeometryInstanceFlagBitsKHR;
declare const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR: VkGeometryInstanceFlagBitsKHR;
declare const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR: VkGeometryInstanceFlagBitsKHR;
declare const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR: VkGeometryInstanceFlagBitsKHR;
declare const VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV: VkGeometryInstanceFlagBitsKHR;
declare const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV: VkGeometryInstanceFlagBitsKHR;
declare const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsKHR;
declare const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsKHR;



/**
  * Bitmask specifying additional parameters for a geometry
  * @member VK_GEOMETRY_OPAQUE_BIT_KHR
  * @member VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR
  * @member VK_GEOMETRY_OPAQUE_BIT_NV
  * @member VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV
  */
export enum VkGeometryFlagBitsKHR {
  VK_GEOMETRY_OPAQUE_BIT_KHR,
  VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
  VK_GEOMETRY_OPAQUE_BIT_NV,
  VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV,
  
}

declare const VK_GEOMETRY_OPAQUE_BIT_KHR: VkGeometryFlagBitsKHR;
declare const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR: VkGeometryFlagBitsKHR;
declare const VK_GEOMETRY_OPAQUE_BIT_NV: VkGeometryFlagBitsKHR;
declare const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV: VkGeometryFlagBitsKHR;



/**
  * Bitmask specifying additional parameters for acceleration structure builds
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV
  */
export enum VkBuildAccelerationStructureFlagBitsKHR {
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV,
  
}

declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR: VkBuildAccelerationStructureFlagBitsKHR;
declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR: VkBuildAccelerationStructureFlagBitsKHR;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR: VkBuildAccelerationStructureFlagBitsKHR;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR: VkBuildAccelerationStructureFlagBitsKHR;
declare const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR: VkBuildAccelerationStructureFlagBitsKHR;
declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR;
declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR;
declare const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR;



/**
  * Bitmask specifying additional creation parameters for acceleration structure
  * @member VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
  */
export enum VkAccelerationStructureCreateFlagBitsKHR {
  VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
  
}

declare const VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkAccelerationStructureCreateFlagBitsKHR;



/**
  * Bitmask specifying framebuffer properties
  * @member VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT specifies that image views are not specified, and only attachment compatibility information will be provided via a 'VkFramebufferAttachmentImageInfo' structure.
  * @member VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR
  */
export enum VkFramebufferCreateFlagBits {
  VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
  VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR,
  
}

declare const VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT: VkFramebufferCreateFlagBits;
declare const VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR: VkFramebufferCreateFlagBits;



/**
  * Bitmask specifying diagnostics flags
  * @member VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV enables the generation of debug information for shaders.
  * @member VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV enables driver side tracking of resources (images, buffers, etc.) used to augment the device fault information.
  * @member VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV enables automatic insertion of <<device-diagnostic-checkreference, diagnostic checkreference>> for draw calls, dispatches, trace rays,
  */
export enum VkDeviceDiagnosticsConfigFlagBitsNV {
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV,
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV,
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV,
  
}

declare const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV: VkDeviceDiagnosticsConfigFlagBitsNV;
declare const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV: VkDeviceDiagnosticsConfigFlagBitsNV;
declare const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV: VkDeviceDiagnosticsConfigFlagBitsNV;



/**
  * Bitmask specifying pipeline or pipeline stage creation feedback
  * @member VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT indicates that the feedback information is valid.
  * @member VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT indicates that a readily usable pipeline or pipeline stage was found in the 'pipelineCache' specified by the application in the pipeline creation command.+An implementation 'should' set the'VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXTbit' if it was able to avoid the large majority of pipeline or pipeline stagecreation work by using the 'pipelineCache' parameter of'vkCreateGraphicsPipelines',ifdef::VK_KHR_ray_tracing_pipeline['vkCreateRayTracingPipelinesKHR',]ifdef::VK_NV_ray_tracing['vkCreateRayTracingPipelinesNV',]or 'vkCreateComputePipelines'.When an implementation sets this bit for the entire pipeline, it 'may' leaveit unset for any stage.+[NOTE].Note====Implementations are encouraged to provide a meaningful signal toapplications using this bit.The intention is to communicate to the application that the pipeline orpipeline stage was created "as fast as it gets" using the pipeline cacheprovided by the application.If an implementation uses an internal cache, it is discouraged from settingthis bit as the feedback would be unactionable.====
  * @member VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT
  */
export enum VkPipelineCreationFeedbackFlagBitsEXT {
  VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT,
  VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT,
  VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT,
  
}

declare const VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT: VkPipelineCreationFeedbackFlagBitsEXT;
declare const VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT: VkPipelineCreationFeedbackFlagBitsEXT;
declare const VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT: VkPipelineCreationFeedbackFlagBitsEXT;



/**
  * Bitmask specifying usage behavior for a counter
  * @member VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR specifies that recording the counter 'may' have a noticeable performance impact.
  * @member VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR
  * @member VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR specifies that concurrently recording the counter while other submitted command buffers are running 'may' impact the accuracy of the recording.
  * @member VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR
  */
export enum VkPerformanceCounterDescriptionFlagBitsKHR {
  VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR,
  VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR,
  VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR,
  VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR,
  
}

declare const VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR: VkPerformanceCounterDescriptionFlagBitsKHR;
declare const VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR: VkPerformanceCounterDescriptionFlagBitsKHR;
declare const VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR: VkPerformanceCounterDescriptionFlagBitsKHR;
declare const VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR: VkPerformanceCounterDescriptionFlagBitsKHR;



/**
  * Reserved for future use
  */
export enum VkAcquireProfilingLockFlagBitsKHR {
  
}




/**
  * Bitmask specifying shader core properties
  */
export enum VkShaderCorePropertiesFlagBitsAMD {
  
}




/**
  * 
  * @member VK_SHADER_MODULE_CREATE_RESERVED_0_BIT_NV
  */
export enum VkShaderModuleCreateFlagBits {
  VK_SHADER_MODULE_CREATE_RESERVED_0_BIT_NV,
  
}

declare const VK_SHADER_MODULE_CREATE_RESERVED_0_BIT_NV: VkShaderModuleCreateFlagBits;



/**
  * Enum specifying available compilation control flags
  */
export enum VkPipelineCompilerControlFlagBitsAMD {
  
}




/**
  * Bitmask specifying the purposes of an active tool
  * @member VK_TOOL_PURPOSE_VALIDATION_BIT_EXT specifies that the tool provides validation of API usage.
  * @member VK_TOOL_PURPOSE_PROFILING_BIT_EXT specifies that the tool provides profiling of API usage.
  * @member VK_TOOL_PURPOSE_TRACING_BIT_EXT specifies that the tool is capturing data about the application's API usage, including anything from simple logging to capturing data for later replay.
  * @member VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT specifies that the tool provides additional API features/extensions on top of the underlying implementation.
  * @member VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT specifies that the tool modifies the API features/limits/extensions presented to the application.
  * @member VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT specifies that the tool reports additional information to the application via callbacks specified byifdef::VK_EXT_debug_report[] 'vkCreateDebugReportCallbackEXT'
  * @member VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT
  */
export enum VkToolPurposeFlagBitsEXT {
  VK_TOOL_PURPOSE_VALIDATION_BIT_EXT,
  VK_TOOL_PURPOSE_PROFILING_BIT_EXT,
  VK_TOOL_PURPOSE_TRACING_BIT_EXT,
  VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT,
  VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT,
  VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT,
  VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT,
  
}

declare const VK_TOOL_PURPOSE_VALIDATION_BIT_EXT: VkToolPurposeFlagBitsEXT;
declare const VK_TOOL_PURPOSE_PROFILING_BIT_EXT: VkToolPurposeFlagBitsEXT;
declare const VK_TOOL_PURPOSE_TRACING_BIT_EXT: VkToolPurposeFlagBitsEXT;
declare const VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT: VkToolPurposeFlagBitsEXT;
declare const VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT: VkToolPurposeFlagBitsEXT;
declare const VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT: VkToolPurposeFlagBitsEXT;
declare const VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT: VkToolPurposeFlagBitsEXT;



/**
  * 
  * @member VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET
  * @member VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
  * @member VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR
  */
export enum VkDescriptorUpdateTemplateTypeKHR {
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR,
  
}

declare const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET: VkDescriptorUpdateTemplateTypeKHR;
declare const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR: VkDescriptorUpdateTemplateTypeKHR;
declare const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR: VkDescriptorUpdateTemplateTypeKHR;



/**
  * 
  * @member VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES
  * @member VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY
  * @member VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR
  * @member VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR
  */
export enum VkPointClippingBehaviorKHR {
  VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
  VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
  VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR,
  VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR,
  
}

declare const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES: VkPointClippingBehaviorKHR;
declare const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY: VkPointClippingBehaviorKHR;
declare const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR: VkPointClippingBehaviorKHR;
declare const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR: VkPointClippingBehaviorKHR;



/**
  * 
  * @member VK_RESOLVE_MODE_NONE
  * @member VK_RESOLVE_MODE_SAMPLE_ZERO_BIT
  * @member VK_RESOLVE_MODE_AVERAGE_BIT
  * @member VK_RESOLVE_MODE_MIN_BIT
  * @member VK_RESOLVE_MODE_MAX_BIT
  * @member VK_RESOLVE_MODE_NONE_KHR
  * @member VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR
  * @member VK_RESOLVE_MODE_AVERAGE_BIT_KHR
  * @member VK_RESOLVE_MODE_MIN_BIT_KHR
  * @member VK_RESOLVE_MODE_MAX_BIT_KHR
  */
export enum VkResolveModeFlagBitsKHR {
  VK_RESOLVE_MODE_NONE,
  VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
  VK_RESOLVE_MODE_AVERAGE_BIT,
  VK_RESOLVE_MODE_MIN_BIT,
  VK_RESOLVE_MODE_MAX_BIT,
  VK_RESOLVE_MODE_NONE_KHR,
  VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR,
  VK_RESOLVE_MODE_AVERAGE_BIT_KHR,
  VK_RESOLVE_MODE_MIN_BIT_KHR,
  VK_RESOLVE_MODE_MAX_BIT_KHR,
  
}

declare const VK_RESOLVE_MODE_NONE: VkResolveModeFlagBitsKHR;
declare const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: VkResolveModeFlagBitsKHR;
declare const VK_RESOLVE_MODE_AVERAGE_BIT: VkResolveModeFlagBitsKHR;
declare const VK_RESOLVE_MODE_MIN_BIT: VkResolveModeFlagBitsKHR;
declare const VK_RESOLVE_MODE_MAX_BIT: VkResolveModeFlagBitsKHR;
declare const VK_RESOLVE_MODE_NONE_KHR: VkResolveModeFlagBitsKHR;
declare const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR: VkResolveModeFlagBitsKHR;
declare const VK_RESOLVE_MODE_AVERAGE_BIT_KHR: VkResolveModeFlagBitsKHR;
declare const VK_RESOLVE_MODE_MIN_BIT_KHR: VkResolveModeFlagBitsKHR;
declare const VK_RESOLVE_MODE_MAX_BIT_KHR: VkResolveModeFlagBitsKHR;



/**
  * 
  * @member VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT
  * @member VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT
  * @member VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT
  * @member VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT
  * @member VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM
  * @member VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
  * @member VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT
  * @member VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT
  * @member VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
  */
export enum VkDescriptorBindingFlagBitsEXT {
  VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
  VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
  VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
  VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
  VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM,
  VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT,
  VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT,
  VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT,
  VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT,
  
}

declare const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT: VkDescriptorBindingFlagBitsEXT;
declare const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT: VkDescriptorBindingFlagBitsEXT;
declare const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT: VkDescriptorBindingFlagBitsEXT;
declare const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT: VkDescriptorBindingFlagBitsEXT;
declare const VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM: VkDescriptorBindingFlagBitsEXT;
declare const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorBindingFlagBitsEXT;
declare const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT: VkDescriptorBindingFlagBitsEXT;
declare const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT: VkDescriptorBindingFlagBitsEXT;
declare const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT: VkDescriptorBindingFlagBitsEXT;



/**
  * 
  * @member VK_SEMAPHORE_TYPE_BINARY
  * @member VK_SEMAPHORE_TYPE_TIMELINE
  * @member VK_SEMAPHORE_TYPE_BINARY_KHR
  * @member VK_SEMAPHORE_TYPE_TIMELINE_KHR
  */
export enum VkSemaphoreTypeKHR {
  VK_SEMAPHORE_TYPE_BINARY,
  VK_SEMAPHORE_TYPE_TIMELINE,
  VK_SEMAPHORE_TYPE_BINARY_KHR,
  VK_SEMAPHORE_TYPE_TIMELINE_KHR,
  
}

declare const VK_SEMAPHORE_TYPE_BINARY: VkSemaphoreTypeKHR;
declare const VK_SEMAPHORE_TYPE_TIMELINE: VkSemaphoreTypeKHR;
declare const VK_SEMAPHORE_TYPE_BINARY_KHR: VkSemaphoreTypeKHR;
declare const VK_SEMAPHORE_TYPE_TIMELINE_KHR: VkSemaphoreTypeKHR;



/**
  * 
  * @member VK_GEOMETRY_OPAQUE_BIT_KHR
  * @member VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR
  * @member VK_GEOMETRY_OPAQUE_BIT_NV
  * @member VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV
  */
export enum VkGeometryFlagBitsNV {
  VK_GEOMETRY_OPAQUE_BIT_KHR,
  VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
  VK_GEOMETRY_OPAQUE_BIT_NV,
  VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV,
  
}

declare const VK_GEOMETRY_OPAQUE_BIT_KHR: VkGeometryFlagBitsNV;
declare const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR: VkGeometryFlagBitsNV;
declare const VK_GEOMETRY_OPAQUE_BIT_NV: VkGeometryFlagBitsNV;
declare const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV: VkGeometryFlagBitsNV;



/**
  * 
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV
  * @member VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV
  * @member VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV
  */
export enum VkGeometryInstanceFlagBitsNV {
  VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV,
  VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV,
  VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV,
  
}

declare const VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR: VkGeometryInstanceFlagBitsNV;
declare const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR: VkGeometryInstanceFlagBitsNV;
declare const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR: VkGeometryInstanceFlagBitsNV;
declare const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR: VkGeometryInstanceFlagBitsNV;
declare const VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV: VkGeometryInstanceFlagBitsNV;
declare const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV: VkGeometryInstanceFlagBitsNV;
declare const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsNV;
declare const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsNV;



/**
  * 
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV
  */
export enum VkBuildAccelerationStructureFlagBitsNV {
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV,
  
}

declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR: VkBuildAccelerationStructureFlagBitsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR: VkBuildAccelerationStructureFlagBitsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR: VkBuildAccelerationStructureFlagBitsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR: VkBuildAccelerationStructureFlagBitsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR: VkBuildAccelerationStructureFlagBitsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV: VkBuildAccelerationStructureFlagBitsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV: VkBuildAccelerationStructureFlagBitsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV: VkBuildAccelerationStructureFlagBitsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV: VkBuildAccelerationStructureFlagBitsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV: VkBuildAccelerationStructureFlagBitsNV;



/**
  * 
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV
  * @member VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV
  */
export enum VkCopyAccelerationStructureModeNV {
  VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV,
  
}

declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR: VkCopyAccelerationStructureModeNV;
declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR: VkCopyAccelerationStructureModeNV;
declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR: VkCopyAccelerationStructureModeNV;
declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR: VkCopyAccelerationStructureModeNV;
declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV: VkCopyAccelerationStructureModeNV;
declare const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV: VkCopyAccelerationStructureModeNV;



/**
  * 
  * @member VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR
  * @member VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
  * @member VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR
  * @member VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV
  * @member VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV
  */
export enum VkAccelerationStructureTypeNV {
  VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
  VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
  VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
  VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV,
  VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV,
  
}

declare const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR: VkAccelerationStructureTypeNV;
declare const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR: VkAccelerationStructureTypeNV;
declare const VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR: VkAccelerationStructureTypeNV;
declare const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV: VkAccelerationStructureTypeNV;
declare const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV: VkAccelerationStructureTypeNV;



/**
  * 
  * @member VK_GEOMETRY_TYPE_TRIANGLES_KHR
  * @member VK_GEOMETRY_TYPE_AABBS_KHR
  * @member VK_GEOMETRY_TYPE_INSTANCES_KHR
  * @member VK_GEOMETRY_TYPE_TRIANGLES_NV
  * @member VK_GEOMETRY_TYPE_AABBS_NV
  */
export enum VkGeometryTypeNV {
  VK_GEOMETRY_TYPE_TRIANGLES_KHR,
  VK_GEOMETRY_TYPE_AABBS_KHR,
  VK_GEOMETRY_TYPE_INSTANCES_KHR,
  VK_GEOMETRY_TYPE_TRIANGLES_NV,
  VK_GEOMETRY_TYPE_AABBS_NV,
  
}

declare const VK_GEOMETRY_TYPE_TRIANGLES_KHR: VkGeometryTypeNV;
declare const VK_GEOMETRY_TYPE_AABBS_KHR: VkGeometryTypeNV;
declare const VK_GEOMETRY_TYPE_INSTANCES_KHR: VkGeometryTypeNV;
declare const VK_GEOMETRY_TYPE_TRIANGLES_NV: VkGeometryTypeNV;
declare const VK_GEOMETRY_TYPE_AABBS_NV: VkGeometryTypeNV;



/**
  * 
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV
  * @member VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV
  */
export enum VkRayTracingShaderGroupTypeNV {
  VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV,
  
}

declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR: VkRayTracingShaderGroupTypeNV;
declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR: VkRayTracingShaderGroupTypeNV;
declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR: VkRayTracingShaderGroupTypeNV;
declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV: VkRayTracingShaderGroupTypeNV;
declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV: VkRayTracingShaderGroupTypeNV;
declare const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV: VkRayTracingShaderGroupTypeNV;



/**
  * 
  * @member VK_SEMAPHORE_WAIT_ANY_BIT
  * @member VK_SEMAPHORE_WAIT_ANY_BIT_KHR
  */
export enum VkSemaphoreWaitFlagBitsKHR {
  VK_SEMAPHORE_WAIT_ANY_BIT,
  VK_SEMAPHORE_WAIT_ANY_BIT_KHR,
  
}

declare const VK_SEMAPHORE_WAIT_ANY_BIT: VkSemaphoreWaitFlagBitsKHR;
declare const VK_SEMAPHORE_WAIT_ANY_BIT_KHR: VkSemaphoreWaitFlagBitsKHR;



/**
  * 
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR
  */
export enum VkExternalMemoryHandleTypeFlagBitsKHR {
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR,
  
}

declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR: VkExternalMemoryHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR: VkExternalMemoryHandleTypeFlagBitsKHR;



/**
  * 
  * @member VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT
  * @member VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT
  * @member VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT
  * @member VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR
  */
export enum VkExternalMemoryFeatureFlagBitsKHR {
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR,
  
}

declare const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: VkExternalMemoryFeatureFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT: VkExternalMemoryFeatureFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT: VkExternalMemoryFeatureFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR: VkExternalMemoryFeatureFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBitsKHR;
declare const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBitsKHR;



/**
  * 
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR
  */
export enum VkExternalSemaphoreHandleTypeFlagBitsKHR {
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
  
}

declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalSemaphoreHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalSemaphoreHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalSemaphoreHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT: VkExternalSemaphoreHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBitsKHR;



/**
  * 
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR
  */
export enum VkExternalSemaphoreFeatureFlagBitsKHR {
  VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
  VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
  VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR,
  
}

declare const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: VkExternalSemaphoreFeatureFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: VkExternalSemaphoreFeatureFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBitsKHR;
declare const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBitsKHR;



/**
  * 
  * @member VK_SEMAPHORE_IMPORT_TEMPORARY_BIT
  * @member VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR
  */
export enum VkSemaphoreImportFlagBitsKHR {
  VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
  VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR,
  
}

declare const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: VkSemaphoreImportFlagBitsKHR;
declare const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR: VkSemaphoreImportFlagBitsKHR;



/**
  * 
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR
  */
export enum VkExternalFenceHandleTypeFlagBitsKHR {
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
  
}

declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalFenceHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalFenceHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalFenceHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT: VkExternalFenceHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalFenceHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalFenceHandleTypeFlagBitsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBitsKHR;



/**
  * 
  * @member VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT
  * @member VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT
  * @member VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR
  * @member VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR
  */
export enum VkExternalFenceFeatureFlagBitsKHR {
  VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
  VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
  VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR,
  VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR,
  
}

declare const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: VkExternalFenceFeatureFlagBitsKHR;
declare const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: VkExternalFenceFeatureFlagBitsKHR;
declare const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBitsKHR;
declare const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBitsKHR;



/**
  * 
  * @member VK_FENCE_IMPORT_TEMPORARY_BIT
  * @member VK_FENCE_IMPORT_TEMPORARY_BIT_KHR
  */
export enum VkFenceImportFlagBitsKHR {
  VK_FENCE_IMPORT_TEMPORARY_BIT,
  VK_FENCE_IMPORT_TEMPORARY_BIT_KHR,
  
}

declare const VK_FENCE_IMPORT_TEMPORARY_BIT: VkFenceImportFlagBitsKHR;
declare const VK_FENCE_IMPORT_TEMPORARY_BIT_KHR: VkFenceImportFlagBitsKHR;



/**
  * 
  * @member VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT
  * @member VK_PEER_MEMORY_FEATURE_COPY_DST_BIT
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT
  * @member VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR
  * @member VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR
  */
export enum VkPeerMemoryFeatureFlagBitsKHR {
  VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
  VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
  VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
  VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
  VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR,
  VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR,
  VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR,
  VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR,
  
}

declare const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT: VkPeerMemoryFeatureFlagBitsKHR;
declare const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT: VkPeerMemoryFeatureFlagBitsKHR;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: VkPeerMemoryFeatureFlagBitsKHR;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT: VkPeerMemoryFeatureFlagBitsKHR;
declare const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBitsKHR;
declare const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR: VkPeerMemoryFeatureFlagBitsKHR;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBitsKHR;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR: VkPeerMemoryFeatureFlagBitsKHR;



/**
  * 
  * @member VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
  * @member VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
  */
export enum VkMemoryAllocateFlagBitsKHR {
  VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
  VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
  
}

declare const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT: VkMemoryAllocateFlagBitsKHR;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT: VkMemoryAllocateFlagBitsKHR;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: VkMemoryAllocateFlagBitsKHR;
declare const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR: VkMemoryAllocateFlagBitsKHR;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR: VkMemoryAllocateFlagBitsKHR;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkMemoryAllocateFlagBitsKHR;



/**
  * 
  * @member VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT
  * @member VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT
  * @member VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR
  * @member VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR
  */
export enum VkTessellationDomainOriginKHR {
  VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
  VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
  VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR,
  VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR,
  
}

declare const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT: VkTessellationDomainOriginKHR;
declare const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT: VkTessellationDomainOriginKHR;
declare const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR: VkTessellationDomainOriginKHR;
declare const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR: VkTessellationDomainOriginKHR;



/**
  * 
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR
  * @member VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR
  */
export enum VkSamplerYcbcrModelConversionKHR {
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR,
  
}

declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY: VkSamplerYcbcrModelConversionKHR;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY: VkSamplerYcbcrModelConversionKHR;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709: VkSamplerYcbcrModelConversionKHR;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601: VkSamplerYcbcrModelConversionKHR;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020: VkSamplerYcbcrModelConversionKHR;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR: VkSamplerYcbcrModelConversionKHR;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR: VkSamplerYcbcrModelConversionKHR;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR: VkSamplerYcbcrModelConversionKHR;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR: VkSamplerYcbcrModelConversionKHR;
declare const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR: VkSamplerYcbcrModelConversionKHR;



/**
  * 
  * @member VK_SAMPLER_YCBCR_RANGE_ITU_FULL
  * @member VK_SAMPLER_YCBCR_RANGE_ITU_NARROW
  * @member VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR
  * @member VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR
  */
export enum VkSamplerYcbcrRangeKHR {
  VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
  VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
  VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR,
  VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR,
  
}

declare const VK_SAMPLER_YCBCR_RANGE_ITU_FULL: VkSamplerYcbcrRangeKHR;
declare const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW: VkSamplerYcbcrRangeKHR;
declare const VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR: VkSamplerYcbcrRangeKHR;
declare const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR: VkSamplerYcbcrRangeKHR;



/**
  * 
  * @member VK_CHROMA_LOCATION_COSITED_EVEN
  * @member VK_CHROMA_LOCATION_MIDPOINT
  * @member VK_CHROMA_LOCATION_COSITED_EVEN_KHR
  * @member VK_CHROMA_LOCATION_MIDPOINT_KHR
  */
export enum VkChromaLocationKHR {
  VK_CHROMA_LOCATION_COSITED_EVEN,
  VK_CHROMA_LOCATION_MIDPOINT,
  VK_CHROMA_LOCATION_COSITED_EVEN_KHR,
  VK_CHROMA_LOCATION_MIDPOINT_KHR,
  
}

declare const VK_CHROMA_LOCATION_COSITED_EVEN: VkChromaLocationKHR;
declare const VK_CHROMA_LOCATION_MIDPOINT: VkChromaLocationKHR;
declare const VK_CHROMA_LOCATION_COSITED_EVEN_KHR: VkChromaLocationKHR;
declare const VK_CHROMA_LOCATION_MIDPOINT_KHR: VkChromaLocationKHR;



/**
  * 
  * @member VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE
  * @member VK_SAMPLER_REDUCTION_MODE_MIN
  * @member VK_SAMPLER_REDUCTION_MODE_MAX
  * @member VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT
  * @member VK_SAMPLER_REDUCTION_MODE_MIN_EXT
  * @member VK_SAMPLER_REDUCTION_MODE_MAX_EXT
  */
export enum VkSamplerReductionModeEXT {
  VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
  VK_SAMPLER_REDUCTION_MODE_MIN,
  VK_SAMPLER_REDUCTION_MODE_MAX,
  VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT,
  VK_SAMPLER_REDUCTION_MODE_MIN_EXT,
  VK_SAMPLER_REDUCTION_MODE_MAX_EXT,
  
}

declare const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE: VkSamplerReductionModeEXT;
declare const VK_SAMPLER_REDUCTION_MODE_MIN: VkSamplerReductionModeEXT;
declare const VK_SAMPLER_REDUCTION_MODE_MAX: VkSamplerReductionModeEXT;
declare const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT: VkSamplerReductionModeEXT;
declare const VK_SAMPLER_REDUCTION_MODE_MIN_EXT: VkSamplerReductionModeEXT;
declare const VK_SAMPLER_REDUCTION_MODE_MAX_EXT: VkSamplerReductionModeEXT;



/**
  * 
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR
  * @member VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR
  */
export enum VkShaderFloatControlsIndependenceKHR {
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR,
  
}

declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY: VkShaderFloatControlsIndependenceKHR;
declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL: VkShaderFloatControlsIndependenceKHR;
declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE: VkShaderFloatControlsIndependenceKHR;
declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR: VkShaderFloatControlsIndependenceKHR;
declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR: VkShaderFloatControlsIndependenceKHR;
declare const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR: VkShaderFloatControlsIndependenceKHR;



/**
  * 
  * @member VK_DRIVER_ID_AMD_PROPRIETARY
  * @member VK_DRIVER_ID_AMD_OPEN_SOURCE
  * @member VK_DRIVER_ID_MESA_RADV
  * @member VK_DRIVER_ID_NVIDIA_PROPRIETARY
  * @member VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS
  * @member VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA
  * @member VK_DRIVER_ID_IMAGINATION_PROPRIETARY
  * @member VK_DRIVER_ID_QUALCOMM_PROPRIETARY
  * @member VK_DRIVER_ID_ARM_PROPRIETARY
  * @member VK_DRIVER_ID_GOOGLE_SWIFTSHADER
  * @member VK_DRIVER_ID_GGP_PROPRIETARY
  * @member VK_DRIVER_ID_BROADCOM_PROPRIETARY
  * @member VK_DRIVER_ID_MESA_LLVMPIPE
  * @member VK_DRIVER_ID_MOLTENVK
  * @member VK_DRIVER_ID_AMD_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR
  * @member VK_DRIVER_ID_MESA_RADV_KHR
  * @member VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR
  * @member VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR
  * @member VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_ARM_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR
  * @member VK_DRIVER_ID_GGP_PROPRIETARY_KHR
  * @member VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR
  */
export enum VkDriverIdKHR {
  VK_DRIVER_ID_AMD_PROPRIETARY,
  VK_DRIVER_ID_AMD_OPEN_SOURCE,
  VK_DRIVER_ID_MESA_RADV,
  VK_DRIVER_ID_NVIDIA_PROPRIETARY,
  VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
  VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
  VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
  VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
  VK_DRIVER_ID_ARM_PROPRIETARY,
  VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
  VK_DRIVER_ID_GGP_PROPRIETARY,
  VK_DRIVER_ID_BROADCOM_PROPRIETARY,
  VK_DRIVER_ID_MESA_LLVMPIPE,
  VK_DRIVER_ID_MOLTENVK,
  VK_DRIVER_ID_AMD_PROPRIETARY_KHR,
  VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR,
  VK_DRIVER_ID_MESA_RADV_KHR,
  VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR,
  VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR,
  VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR,
  VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR,
  VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR,
  VK_DRIVER_ID_ARM_PROPRIETARY_KHR,
  VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR,
  VK_DRIVER_ID_GGP_PROPRIETARY_KHR,
  VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR,
  
}

declare const VK_DRIVER_ID_AMD_PROPRIETARY: VkDriverIdKHR;
declare const VK_DRIVER_ID_AMD_OPEN_SOURCE: VkDriverIdKHR;
declare const VK_DRIVER_ID_MESA_RADV: VkDriverIdKHR;
declare const VK_DRIVER_ID_NVIDIA_PROPRIETARY: VkDriverIdKHR;
declare const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS: VkDriverIdKHR;
declare const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA: VkDriverIdKHR;
declare const VK_DRIVER_ID_IMAGINATION_PROPRIETARY: VkDriverIdKHR;
declare const VK_DRIVER_ID_QUALCOMM_PROPRIETARY: VkDriverIdKHR;
declare const VK_DRIVER_ID_ARM_PROPRIETARY: VkDriverIdKHR;
declare const VK_DRIVER_ID_GOOGLE_SWIFTSHADER: VkDriverIdKHR;
declare const VK_DRIVER_ID_GGP_PROPRIETARY: VkDriverIdKHR;
declare const VK_DRIVER_ID_BROADCOM_PROPRIETARY: VkDriverIdKHR;
declare const VK_DRIVER_ID_MESA_LLVMPIPE: VkDriverIdKHR;
declare const VK_DRIVER_ID_MOLTENVK: VkDriverIdKHR;
declare const VK_DRIVER_ID_AMD_PROPRIETARY_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_MESA_RADV_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_ARM_PROPRIETARY_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_GGP_PROPRIETARY_KHR: VkDriverIdKHR;
declare const VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR: VkDriverIdKHR;



/**
  * 
  * @member VK_GEOMETRY_OPAQUE_BIT_KHR
  * @member VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR
  * @member VK_GEOMETRY_OPAQUE_BIT_NV
  * @member VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV
  */
export enum VkGeometryFlagsNV {
  VK_GEOMETRY_OPAQUE_BIT_KHR,
  VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
  VK_GEOMETRY_OPAQUE_BIT_NV,
  VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV,
  
}

declare const VK_GEOMETRY_OPAQUE_BIT_KHR: VkGeometryFlagsNV;
declare const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR: VkGeometryFlagsNV;
declare const VK_GEOMETRY_OPAQUE_BIT_NV: VkGeometryFlagsNV;
declare const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV: VkGeometryFlagsNV;



/**
  * 
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV
  * @member VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV
  * @member VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV
  * @member VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV
  */
export enum VkGeometryInstanceFlagsNV {
  VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR,
  VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV,
  VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV,
  VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV,
  
}

declare const VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR: VkGeometryInstanceFlagsNV;
declare const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR: VkGeometryInstanceFlagsNV;
declare const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR: VkGeometryInstanceFlagsNV;
declare const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR: VkGeometryInstanceFlagsNV;
declare const VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV: VkGeometryInstanceFlagsNV;
declare const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV: VkGeometryInstanceFlagsNV;
declare const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV: VkGeometryInstanceFlagsNV;
declare const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV: VkGeometryInstanceFlagsNV;



/**
  * 
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV
  * @member VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV
  */
export enum VkBuildAccelerationStructureFlagsNV {
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV,
  VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV,
  
}

declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR: VkBuildAccelerationStructureFlagsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR: VkBuildAccelerationStructureFlagsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR: VkBuildAccelerationStructureFlagsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR: VkBuildAccelerationStructureFlagsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR: VkBuildAccelerationStructureFlagsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV: VkBuildAccelerationStructureFlagsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV: VkBuildAccelerationStructureFlagsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV: VkBuildAccelerationStructureFlagsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV: VkBuildAccelerationStructureFlagsNV;
declare const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV: VkBuildAccelerationStructureFlagsNV;



/**
  * 
  * @member VK_SEMAPHORE_WAIT_ANY_BIT
  * @member VK_SEMAPHORE_WAIT_ANY_BIT_KHR
  */
export enum VkSemaphoreWaitFlagsKHR {
  VK_SEMAPHORE_WAIT_ANY_BIT,
  VK_SEMAPHORE_WAIT_ANY_BIT_KHR,
  
}

declare const VK_SEMAPHORE_WAIT_ANY_BIT: VkSemaphoreWaitFlagsKHR;
declare const VK_SEMAPHORE_WAIT_ANY_BIT_KHR: VkSemaphoreWaitFlagsKHR;



/**
  * 
  * @member VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT
  * @member VK_PEER_MEMORY_FEATURE_COPY_DST_BIT
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT
  * @member VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR
  * @member VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR
  * @member VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR
  */
export enum VkPeerMemoryFeatureFlagsKHR {
  VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
  VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
  VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
  VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
  VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR,
  VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR,
  VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR,
  VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR,
  
}

declare const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT: VkPeerMemoryFeatureFlagsKHR;
declare const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT: VkPeerMemoryFeatureFlagsKHR;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: VkPeerMemoryFeatureFlagsKHR;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT: VkPeerMemoryFeatureFlagsKHR;
declare const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR: VkPeerMemoryFeatureFlagsKHR;
declare const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR: VkPeerMemoryFeatureFlagsKHR;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR: VkPeerMemoryFeatureFlagsKHR;
declare const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR: VkPeerMemoryFeatureFlagsKHR;



/**
  * 
  * @member VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
  * @member VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR
  * @member VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
  */
export enum VkMemoryAllocateFlagsKHR {
  VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
  VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
  
}

declare const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT: VkMemoryAllocateFlagsKHR;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT: VkMemoryAllocateFlagsKHR;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: VkMemoryAllocateFlagsKHR;
declare const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR: VkMemoryAllocateFlagsKHR;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR: VkMemoryAllocateFlagsKHR;
declare const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkMemoryAllocateFlagsKHR;



/**
  * 
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR
  */
export enum VkExternalMemoryHandleTypeFlagsKHR {
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR,
  
}

declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR: VkExternalMemoryHandleTypeFlagsKHR;
declare const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR: VkExternalMemoryHandleTypeFlagsKHR;



/**
  * 
  * @member VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT
  * @member VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT
  * @member VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT
  * @member VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR
  * @member VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR
  */
export enum VkExternalMemoryFeatureFlagsKHR {
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR,
  
}

declare const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: VkExternalMemoryFeatureFlagsKHR;
declare const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT: VkExternalMemoryFeatureFlagsKHR;
declare const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT: VkExternalMemoryFeatureFlagsKHR;
declare const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR: VkExternalMemoryFeatureFlagsKHR;
declare const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagsKHR;
declare const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagsKHR;



/**
  * 
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR
  */
export enum VkExternalSemaphoreHandleTypeFlagsKHR {
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
  
}

declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalSemaphoreHandleTypeFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalSemaphoreHandleTypeFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalSemaphoreHandleTypeFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT: VkExternalSemaphoreHandleTypeFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalSemaphoreHandleTypeFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalSemaphoreHandleTypeFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR: VkExternalSemaphoreHandleTypeFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagsKHR;



/**
  * 
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR
  * @member VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR
  */
export enum VkExternalSemaphoreFeatureFlagsKHR {
  VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
  VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
  VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR,
  VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR,
  
}

declare const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: VkExternalSemaphoreFeatureFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: VkExternalSemaphoreFeatureFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagsKHR;
declare const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagsKHR;



/**
  * 
  * @member VK_SEMAPHORE_IMPORT_TEMPORARY_BIT
  * @member VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR
  */
export enum VkSemaphoreImportFlagsKHR {
  VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
  VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR,
  
}

declare const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: VkSemaphoreImportFlagsKHR;
declare const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR: VkSemaphoreImportFlagsKHR;



/**
  * 
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
  * @member VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR
  */
export enum VkExternalFenceHandleTypeFlagsKHR {
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR,
  
}

declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalFenceHandleTypeFlagsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalFenceHandleTypeFlagsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalFenceHandleTypeFlagsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT: VkExternalFenceHandleTypeFlagsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalFenceHandleTypeFlagsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalFenceHandleTypeFlagsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR: VkExternalFenceHandleTypeFlagsKHR;
declare const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalFenceHandleTypeFlagsKHR;



/**
  * 
  * @member VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT
  * @member VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT
  * @member VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR
  * @member VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR
  */
export enum VkExternalFenceFeatureFlagsKHR {
  VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
  VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
  VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR,
  VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR,
  
}

declare const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: VkExternalFenceFeatureFlagsKHR;
declare const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: VkExternalFenceFeatureFlagsKHR;
declare const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagsKHR;
declare const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagsKHR;



/**
  * 
  * @member VK_FENCE_IMPORT_TEMPORARY_BIT
  * @member VK_FENCE_IMPORT_TEMPORARY_BIT_KHR
  */
export enum VkFenceImportFlagsKHR {
  VK_FENCE_IMPORT_TEMPORARY_BIT,
  VK_FENCE_IMPORT_TEMPORARY_BIT_KHR,
  
}

declare const VK_FENCE_IMPORT_TEMPORARY_BIT: VkFenceImportFlagsKHR;
declare const VK_FENCE_IMPORT_TEMPORARY_BIT_KHR: VkFenceImportFlagsKHR;



/**
  * 
  * @member VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT
  * @member VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT
  * @member VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT
  * @member VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT
  * @member VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM
  * @member VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
  * @member VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT
  * @member VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT
  * @member VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
  */
export enum VkDescriptorBindingFlagsEXT {
  VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
  VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
  VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
  VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
  VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM,
  VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT,
  VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT,
  VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT,
  VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT,
  
}

declare const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT: VkDescriptorBindingFlagsEXT;
declare const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT: VkDescriptorBindingFlagsEXT;
declare const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT: VkDescriptorBindingFlagsEXT;
declare const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT: VkDescriptorBindingFlagsEXT;
declare const VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM: VkDescriptorBindingFlagsEXT;
declare const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorBindingFlagsEXT;
declare const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT: VkDescriptorBindingFlagsEXT;
declare const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT: VkDescriptorBindingFlagsEXT;
declare const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT: VkDescriptorBindingFlagsEXT;



/**
  * 
  * @member VK_RESOLVE_MODE_NONE
  * @member VK_RESOLVE_MODE_SAMPLE_ZERO_BIT
  * @member VK_RESOLVE_MODE_AVERAGE_BIT
  * @member VK_RESOLVE_MODE_MIN_BIT
  * @member VK_RESOLVE_MODE_MAX_BIT
  * @member VK_RESOLVE_MODE_NONE_KHR
  * @member VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR
  * @member VK_RESOLVE_MODE_AVERAGE_BIT_KHR
  * @member VK_RESOLVE_MODE_MIN_BIT_KHR
  * @member VK_RESOLVE_MODE_MAX_BIT_KHR
  */
export enum VkResolveModeFlagsKHR {
  VK_RESOLVE_MODE_NONE,
  VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
  VK_RESOLVE_MODE_AVERAGE_BIT,
  VK_RESOLVE_MODE_MIN_BIT,
  VK_RESOLVE_MODE_MAX_BIT,
  VK_RESOLVE_MODE_NONE_KHR,
  VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR,
  VK_RESOLVE_MODE_AVERAGE_BIT_KHR,
  VK_RESOLVE_MODE_MIN_BIT_KHR,
  VK_RESOLVE_MODE_MAX_BIT_KHR,
  
}

declare const VK_RESOLVE_MODE_NONE: VkResolveModeFlagsKHR;
declare const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: VkResolveModeFlagsKHR;
declare const VK_RESOLVE_MODE_AVERAGE_BIT: VkResolveModeFlagsKHR;
declare const VK_RESOLVE_MODE_MIN_BIT: VkResolveModeFlagsKHR;
declare const VK_RESOLVE_MODE_MAX_BIT: VkResolveModeFlagsKHR;
declare const VK_RESOLVE_MODE_NONE_KHR: VkResolveModeFlagsKHR;
declare const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR: VkResolveModeFlagsKHR;
declare const VK_RESOLVE_MODE_AVERAGE_BIT_KHR: VkResolveModeFlagsKHR;
declare const VK_RESOLVE_MODE_MIN_BIT_KHR: VkResolveModeFlagsKHR;
declare const VK_RESOLVE_MODE_MAX_BIT_KHR: VkResolveModeFlagsKHR;





  /**
   * Opaque handle to a debug messenger object
   */
declare interface VkDebugUtilsMessengerEXT {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDebugUtilsMessengerEXTConstructor {
  readonly prototype: VkDebugUtilsMessengerEXT;
  new(): VkDebugUtilsMessengerEXT;

}

declare var VkDebugUtilsMessengerEXT: VkDebugUtilsMessengerEXTConstructor;


  /**
   * Opaque handle to a debug report callback object
   */
declare interface VkDebugReportCallbackEXT {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDebugReportCallbackEXTConstructor {
  readonly prototype: VkDebugReportCallbackEXT;
  new(): VkDebugReportCallbackEXT;

}

declare var VkDebugReportCallbackEXT: VkDebugReportCallbackEXTConstructor;


  /**
   * Opaque handle to a swapchain object
   */
declare interface VkSwapchainKHR {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkSwapchainKHRConstructor {
  readonly prototype: VkSwapchainKHR;
  new(): VkSwapchainKHR;

}

declare var VkSwapchainKHR: VkSwapchainKHRConstructor;


  /**
   * Opaque handle to a surface object
   */
declare interface VkSurfaceKHR {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkSurfaceKHRConstructor {
  readonly prototype: VkSurfaceKHR;
  new(): VkSurfaceKHR;

}

declare var VkSurfaceKHR: VkSurfaceKHRConstructor;


  /**
   * Opaque handle to a display mode object
   */
declare interface VkDisplayModeKHR {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDisplayModeKHRConstructor {
  readonly prototype: VkDisplayModeKHR;
  new(): VkDisplayModeKHR;

}

declare var VkDisplayModeKHR: VkDisplayModeKHRConstructor;


  /**
   * Opaque handle to a display object
   */
declare interface VkDisplayKHR {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDisplayKHRConstructor {
  readonly prototype: VkDisplayKHR;
  new(): VkDisplayKHR;

}

declare var VkDisplayKHR: VkDisplayKHRConstructor;


  /**
   * Opaque handle to a private data slot object
   */
declare interface VkPrivateDataSlotEXT {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkPrivateDataSlotEXTConstructor {
  readonly prototype: VkPrivateDataSlotEXT;
  new(): VkPrivateDataSlotEXT;

}

declare var VkPrivateDataSlotEXT: VkPrivateDataSlotEXTConstructor;


  /**
   * A deferred operation
   */
declare interface VkDeferredOperationKHR {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDeferredOperationKHRConstructor {
  readonly prototype: VkDeferredOperationKHR;
  new(): VkDeferredOperationKHR;

}

declare var VkDeferredOperationKHR: VkDeferredOperationKHRConstructor;


  /**
   * Device configuration for performance queries
   */
declare interface VkPerformanceConfigurationINTEL {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkPerformanceConfigurationINTELConstructor {
  readonly prototype: VkPerformanceConfigurationINTEL;
  new(): VkPerformanceConfigurationINTEL;

}

declare var VkPerformanceConfigurationINTEL: VkPerformanceConfigurationINTELConstructor;


  /**
   * Opaque handle to an acceleration structure object
   */
declare interface VkAccelerationStructureNV {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkAccelerationStructureNVConstructor {
  readonly prototype: VkAccelerationStructureNV;
  new(): VkAccelerationStructureNV;

}

declare var VkAccelerationStructureNV: VkAccelerationStructureNVConstructor;


  /**
   * Opaque handle to an acceleration structure object
   */
declare interface VkAccelerationStructureKHR {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkAccelerationStructureKHRConstructor {
  readonly prototype: VkAccelerationStructureKHR;
  new(): VkAccelerationStructureKHR;

}

declare var VkAccelerationStructureKHR: VkAccelerationStructureKHRConstructor;


  /**
   * Opaque handle to a validation cache object
   */
declare interface VkValidationCacheEXT {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkValidationCacheEXTConstructor {
  readonly prototype: VkValidationCacheEXT;
  new(): VkValidationCacheEXT;

}

declare var VkValidationCacheEXT: VkValidationCacheEXTConstructor;


  /**
   * 
   */
declare interface VkSamplerYcbcrConversion {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkSamplerYcbcrConversionConstructor {
  readonly prototype: VkSamplerYcbcrConversion;
  new(): VkSamplerYcbcrConversion;

}

declare var VkSamplerYcbcrConversion: VkSamplerYcbcrConversionConstructor;


  /**
   * Opaque handle to a descriptor update template
   */
declare interface VkDescriptorUpdateTemplate {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDescriptorUpdateTemplateConstructor {
  readonly prototype: VkDescriptorUpdateTemplate;
  new(): VkDescriptorUpdateTemplate;

}

declare var VkDescriptorUpdateTemplate: VkDescriptorUpdateTemplateConstructor;


  /**
   * Opaque handle to an indirect commands layout object
   */
declare interface VkIndirectCommandsLayoutNV {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkIndirectCommandsLayoutNVConstructor {
  readonly prototype: VkIndirectCommandsLayoutNV;
  new(): VkIndirectCommandsLayoutNV;

}

declare var VkIndirectCommandsLayoutNV: VkIndirectCommandsLayoutNVConstructor;


  /**
   * Opaque handle to a pipeline cache object
   */
declare interface VkPipelineCache {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkPipelineCacheConstructor {
  readonly prototype: VkPipelineCache;
  new(): VkPipelineCache;

}

declare var VkPipelineCache: VkPipelineCacheConstructor;


  /**
   * Opaque handle to a render pass object
   */
declare interface VkRenderPass {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkRenderPassConstructor {
  readonly prototype: VkRenderPass;
  new(): VkRenderPass;

}

declare var VkRenderPass: VkRenderPassConstructor;


  /**
   * Opaque handle to a framebuffer object
   */
declare interface VkFramebuffer {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkFramebufferConstructor {
  readonly prototype: VkFramebuffer;
  new(): VkFramebuffer;

}

declare var VkFramebuffer: VkFramebufferConstructor;


  /**
   * Opaque handle to a query pool object
   */
declare interface VkQueryPool {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkQueryPoolConstructor {
  readonly prototype: VkQueryPool;
  new(): VkQueryPool;

}

declare var VkQueryPool: VkQueryPoolConstructor;


  /**
   * Opaque handle to an event object
   */
declare interface VkEvent {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkEventConstructor {
  readonly prototype: VkEvent;
  new(): VkEvent;

}

declare var VkEvent: VkEventConstructor;


  /**
   * Opaque handle to a semaphore object
   */
declare interface VkSemaphore {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkSemaphoreConstructor {
  readonly prototype: VkSemaphore;
  new(): VkSemaphore;

}

declare var VkSemaphore: VkSemaphoreConstructor;


  /**
   * Opaque handle to a fence object
   */
declare interface VkFence {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkFenceConstructor {
  readonly prototype: VkFence;
  new(): VkFence;

}

declare var VkFence: VkFenceConstructor;


  /**
   * Opaque handle to a descriptor pool object
   */
declare interface VkDescriptorPool {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDescriptorPoolConstructor {
  readonly prototype: VkDescriptorPool;
  new(): VkDescriptorPool;

}

declare var VkDescriptorPool: VkDescriptorPoolConstructor;


  /**
   * Opaque handle to a descriptor set layout object
   */
declare interface VkDescriptorSetLayout {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDescriptorSetLayoutConstructor {
  readonly prototype: VkDescriptorSetLayout;
  new(): VkDescriptorSetLayout;

}

declare var VkDescriptorSetLayout: VkDescriptorSetLayoutConstructor;


  /**
   * Opaque handle to a descriptor set object
   */
declare interface VkDescriptorSet {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDescriptorSetConstructor {
  readonly prototype: VkDescriptorSet;
  new(): VkDescriptorSet;

}

declare var VkDescriptorSet: VkDescriptorSetConstructor;


  /**
   * Opaque handle to a sampler object
   */
declare interface VkSampler {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkSamplerConstructor {
  readonly prototype: VkSampler;
  new(): VkSampler;

}

declare var VkSampler: VkSamplerConstructor;


  /**
   * Opaque handle to a pipeline layout object
   */
declare interface VkPipelineLayout {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkPipelineLayoutConstructor {
  readonly prototype: VkPipelineLayout;
  new(): VkPipelineLayout;

}

declare var VkPipelineLayout: VkPipelineLayoutConstructor;


  /**
   * Opaque handle to a pipeline object
   */
declare interface VkPipeline {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkPipelineConstructor {
  readonly prototype: VkPipeline;
  new(): VkPipeline;

}

declare var VkPipeline: VkPipelineConstructor;


  /**
   * Opaque handle to a shader module object
   */
declare interface VkShaderModule {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkShaderModuleConstructor {
  readonly prototype: VkShaderModule;
  new(): VkShaderModule;

}

declare var VkShaderModule: VkShaderModuleConstructor;


  /**
   * Opaque handle to an image view object
   */
declare interface VkImageView {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkImageViewConstructor {
  readonly prototype: VkImageView;
  new(): VkImageView;

}

declare var VkImageView: VkImageViewConstructor;


  /**
   * Opaque handle to an image object
   */
declare interface VkImage {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkImageConstructor {
  readonly prototype: VkImage;
  new(): VkImage;

}

declare var VkImage: VkImageConstructor;


  /**
   * Opaque handle to a buffer view object
   */
declare interface VkBufferView {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkBufferViewConstructor {
  readonly prototype: VkBufferView;
  new(): VkBufferView;

}

declare var VkBufferView: VkBufferViewConstructor;


  /**
   * Opaque handle to a buffer object
   */
declare interface VkBuffer {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkBufferConstructor {
  readonly prototype: VkBuffer;
  new(): VkBuffer;

}

declare var VkBuffer: VkBufferConstructor;


  /**
   * Opaque handle to a command pool object
   */
declare interface VkCommandPool {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkCommandPoolConstructor {
  readonly prototype: VkCommandPool;
  new(): VkCommandPool;

}

declare var VkCommandPool: VkCommandPoolConstructor;


  /**
   * Opaque handle to a device memory object
   */
declare interface VkDeviceMemory {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDeviceMemoryConstructor {
  readonly prototype: VkDeviceMemory;
  new(): VkDeviceMemory;

}

declare var VkDeviceMemory: VkDeviceMemoryConstructor;


  /**
   * Opaque handle to a command buffer object
   */
declare interface VkCommandBuffer {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkCommandBufferConstructor {
  readonly prototype: VkCommandBuffer;
  new(): VkCommandBuffer;

}

declare var VkCommandBuffer: VkCommandBufferConstructor;


  /**
   * Opaque handle to a queue object
   */
declare interface VkQueue {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkQueueConstructor {
  readonly prototype: VkQueue;
  new(): VkQueue;

}

declare var VkQueue: VkQueueConstructor;


  /**
   * Opaque handle to a device object
   */
declare interface VkDevice {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkDeviceConstructor {
  readonly prototype: VkDevice;
  new(): VkDevice;

}

declare var VkDevice: VkDeviceConstructor;


  /**
   * Opaque handle to a physical device object
   */
declare interface VkPhysicalDevice {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkPhysicalDeviceConstructor {
  readonly prototype: VkPhysicalDevice;
  new(): VkPhysicalDevice;

}

declare var VkPhysicalDevice: VkPhysicalDeviceConstructor;


  /**
   * Opaque handle to an instance object
   */
declare interface VkInstance {

  /**
    * Memory reference to the original vulkan handle.
    */
  address: bigint;

}

declare interface VkInstanceConstructor {
  readonly prototype: VkInstance;
  new(): VkInstance;

}

declare var VkInstance: VkInstanceConstructor;













































  /**
   * Structure specifying build sizes for an acceleration structure
   */
interface VkAccelerationStructureBuildSizesInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the size in bytes required in a 'VkAccelerationStructureKHR' for a build or update operation.
     */
    accelerationStructureSize: bigint | number;

    /**
     * is the size in bytes required in a scratch buffer for an update operation.
     */
    updateScratchSize: bigint | number;

    /**
     * is the size in bytes required in a scratch buffer for a build operation.
     */
    buildScratchSize: bigint | number;

}

declare interface VkAccelerationStructureBuildSizesInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the size in bytes required in a 'VkAccelerationStructureKHR' for a build or update operation.
     */
    accelerationStructureSize?: bigint | number;

    /**
     * is the size in bytes required in a scratch buffer for an update operation.
     */
    updateScratchSize?: bigint | number;

    /**
     * is the size in bytes required in a scratch buffer for a build operation.
     */
    buildScratchSize?: bigint | number;
}

declare interface VkAccelerationStructureBuildSizesInfoKHRConstructor {
  readonly prototype: VkAccelerationStructureBuildSizesInfoKHR;
  new(param?: VkAccelerationStructureBuildSizesInfoKHRInitializer | null): VkAccelerationStructureBuildSizesInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureBuildSizesInfoKHR: VkAccelerationStructureBuildSizesInfoKHRConstructor;



  /**
   * Structure specifying parameters controlling the fragment shading rate using rate enums
   */
interface VkPipelineFragmentShadingRateEnumStateCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies a 'VkFragmentShadingRateTypeNV' value indicating whether fragment shading rates are specified using fragment sizes or 'VkFragmentShadingRateNV' enums.
     */
    shadingRateType: VkFragmentShadingRateTypeNV;

    /**
     * specifies a 'VkFragmentShadingRateNV' value indicating the pipeline fragment shading rate.
     */
    shadingRate: VkFragmentShadingRateNV;

    /**
     * specifies 'VkFragmentShadingRateCombinerOpKHR' values determining how the <<primsrast-fragment-shading-rate-pipeline,pipeline>>, <<primsrast-fragment-shading-rate-primitive,primitive>>, and <<primsrast-fragment-shading-rate-attachment,attachment shading rates>> are <<primsrast-fragment-shading-rate-combining,combined>> for fragments generated by drawing commands using the created pipeline.
     */
    combinerOps: number[] | null;

}

declare interface VkPipelineFragmentShadingRateEnumStateCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies a 'VkFragmentShadingRateTypeNV' value indicating whether fragment shading rates are specified using fragment sizes or 'VkFragmentShadingRateNV' enums.
     */
    shadingRateType?: VkFragmentShadingRateTypeNV;

    /**
     * specifies a 'VkFragmentShadingRateNV' value indicating the pipeline fragment shading rate.
     */
    shadingRate?: VkFragmentShadingRateNV;

    /**
     * specifies 'VkFragmentShadingRateCombinerOpKHR' values determining how the <<primsrast-fragment-shading-rate-pipeline,pipeline>>, <<primsrast-fragment-shading-rate-primitive,primitive>>, and <<primsrast-fragment-shading-rate-attachment,attachment shading rates>> are <<primsrast-fragment-shading-rate-combining,combined>> for fragments generated by drawing commands using the created pipeline.
     */
    combinerOps?: number[] | null;
}

declare interface VkPipelineFragmentShadingRateEnumStateCreateInfoNVConstructor {
  readonly prototype: VkPipelineFragmentShadingRateEnumStateCreateInfoNV;
  new(param?: VkPipelineFragmentShadingRateEnumStateCreateInfoNVInitializer | null): VkPipelineFragmentShadingRateEnumStateCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineFragmentShadingRateEnumStateCreateInfoNV: VkPipelineFragmentShadingRateEnumStateCreateInfoNVConstructor;



  /**
   * Structure describing fragment shading rate limits that can be supported by an implementation
   */
interface VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * indicates the maximum number of fragment shader invocations per fragment supported in pipeline, primitive, and attachment fragment shading rates.
     */
    maxFragmentShadingRateInvocationCount: VkSampleCountFlagBits;

}

declare interface VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * indicates the maximum number of fragment shader invocations per fragment supported in pipeline, primitive, and attachment fragment shading rates.
     */
    maxFragmentShadingRateInvocationCount?: VkSampleCountFlagBits;
}

declare interface VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVConstructor {
  readonly prototype: VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV;
  new(param?: VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVInitializer | null): VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV: VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNVConstructor;



  /**
   * Structure indicating support for fragment shading rate enums
   */
interface VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports specifying fragment shading rates using the 'VkFragmentShadingRateNV' enumerated type.
     */
    fragmentShadingRateEnums: boolean;

    /**
     * indicates that the implementation supports fragment shading rate enum values indicating more than one invocation per fragment.
     */
    supersampleFragmentShadingRates: boolean;

    /**
     * indicates that the implementation supports a fragment shading rate enum value indicating that no fragment shaders should be invoked when that shading rate is used.
     */
    noInvocationFragmentShadingRates: boolean;

}

declare interface VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports specifying fragment shading rates using the 'VkFragmentShadingRateNV' enumerated type.
     */
    fragmentShadingRateEnums?: boolean;

    /**
     * indicates that the implementation supports fragment shading rate enum values indicating more than one invocation per fragment.
     */
    supersampleFragmentShadingRates?: boolean;

    /**
     * indicates that the implementation supports a fragment shading rate enum value indicating that no fragment shaders should be invoked when that shading rate is used.
     */
    noInvocationFragmentShadingRates?: boolean;
}

declare interface VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
  new(param?: VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVInitializer | null): VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV: VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNVConstructor;



  /**
   * Structure describing support for the SPIR-V {#0#} extension
   */
interface VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * specifies whether the implementation supports SPIR-V modules that use the `SPV_KHR_terminate_invocation` extension.
     */
    shaderTerminateInvocation: boolean;

}

declare interface VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * specifies whether the implementation supports SPIR-V modules that use the `SPV_KHR_terminate_invocation` extension.
     */
    shaderTerminateInvocation?: boolean;
}

declare interface VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR;
  new(param?: VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRInitializer | null): VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR: VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRConstructor;



  /**
   * Structure returning information about sample count specific additional multisampling capabilities
   */
interface VkPhysicalDeviceFragmentShadingRateKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a bitmask of sample counts for which the shading rate described by 'fragmentSize' is supported.
     */
    readonly sampleCounts: VkSampleCountFlagBits;

    /**
     * is a 'VkExtent2D' describing the width and height of a supported shading rate.
     */
    readonly fragmentSize: VkExtent2D | null;

}

declare interface VkPhysicalDeviceFragmentShadingRateKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a bitmask of sample counts for which the shading rate described by 'fragmentSize' is supported.
     */
    readonly sampleCounts?: VkSampleCountFlagBits;

    /**
     * is a 'VkExtent2D' describing the width and height of a supported shading rate.
     */
    readonly fragmentSize?: VkExtent2D | null;
}

declare interface VkPhysicalDeviceFragmentShadingRateKHRConstructor {
  readonly prototype: VkPhysicalDeviceFragmentShadingRateKHR;
  new(param?: VkPhysicalDeviceFragmentShadingRateKHRInitializer | null): VkPhysicalDeviceFragmentShadingRateKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentShadingRateKHR: VkPhysicalDeviceFragmentShadingRateKHRConstructor;



  /**
   * Structure describing variable fragment shading rate limits that can be supported by an implementation
   */
interface VkPhysicalDeviceFragmentShadingRatePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * indicates minimum supported width and height of the portion of the framebuffer corresponding to each texel in a fragment shading rate attachment. Each value 'must' be less than or equal to the values in 'maxFragmentShadingRateAttachmentTexelSize'. Each value 'must' be a power-of-two. It 'must' be [eq]#(0,0)# if the <<features-attachmentFragmentShadingRate, 'attachmentFragmentShadingRate'>> feature is not supported.
     */
    readonly minFragmentShadingRateAttachmentTexelSize: VkExtent2D | null;

    /**
     * indicates maximum supported width and height of the portion of the framebuffer corresponding to each texel in a fragment shading rate attachment. Each value 'must' be greater than or equal to the values in 'minFragmentShadingRateAttachmentTexelSize'. Each value 'must' be a power-of-two. It 'must' be [eq]#(0,0)# if the <<features-attachmentFragmentShadingRate, 'attachmentFragmentShadingRate'>> feature is not supported.
     */
    readonly maxFragmentShadingRateAttachmentTexelSize: VkExtent2D | null;

    /**
     * indicates the maximum ratio between the width and height of the portion of the framebuffer corresponding to each texel in a fragment shading rate attachment. 'maxFragmentShadingRateAttachmentTexelSizeAspectRatio' 'must' be a power-of-two value, and 'must' be less than or equal to [eq]#max('maxFragmentShadingRateAttachmentTexelSize.width' / minFragmentShadingRateAttachmentTexelSize.height, 'maxFragmentShadingRateAttachmentTexelSize.height' / minFragmentShadingRateAttachmentTexelSize.width)#. It 'must' be 0 if the <<features-attachmentFragmentShadingRate, 'attachmentFragmentShadingRate'>> feature is not supported.
     */
    readonly maxFragmentShadingRateAttachmentTexelSizeAspectRatio: number;

    /**
     * specifies whether the <<primsrast-fragment-shading-rate-primitive,primitive fragment shading rate>> 'can' be used when multiple viewports are used. If this value is 'VK_FALSE', only a single viewport 'must' be used, and applications 'must' not write to the 'ViewportMaskNV' or
     */
    readonly primitiveFragmentShadingRateWithMultipleViewports: boolean;

    /**
     *
     */
    readonly layeredShadingRateAttachments: boolean;

    /**
     *
     */
    readonly fragmentShadingRateNonTrivialCombinerOps: boolean;

    /**
     *
     */
    readonly maxFragmentSize: VkExtent2D | null;

    /**
     *
     */
    readonly maxFragmentSizeAspectRatio: number;

    /**
     *
     */
    readonly maxFragmentShadingRateCoverageSamples: number;

    /**
     *
     */
    readonly maxFragmentShadingRateRasterizationSamples: VkSampleCountFlagBits;

    /**
     *
     */
    readonly fragmentShadingRateWithShaderDepthStencilWrites: boolean;

    /**
     *
     */
    readonly fragmentShadingRateWithSampleMask: boolean;

    /**
     *
     */
    readonly fragmentShadingRateWithShaderSampleMask: boolean;

    /**
     *
     */
    readonly fragmentShadingRateWithConservativeRasterization: boolean;

    /**
     *
     */
    readonly fragmentShadingRateWithFragmentShaderInterlock: boolean;

    /**
     *
     */
    readonly fragmentShadingRateWithCustomSampleLocations: boolean;

    /**
     *
     */
    readonly fragmentShadingRateStrictMultiplyCombiner: boolean;

}

declare interface VkPhysicalDeviceFragmentShadingRatePropertiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * indicates minimum supported width and height of the portion of the framebuffer corresponding to each texel in a fragment shading rate attachment. Each value 'must' be less than or equal to the values in 'maxFragmentShadingRateAttachmentTexelSize'. Each value 'must' be a power-of-two. It 'must' be [eq]#(0,0)# if the <<features-attachmentFragmentShadingRate, 'attachmentFragmentShadingRate'>> feature is not supported.
     */
    readonly minFragmentShadingRateAttachmentTexelSize?: VkExtent2D | null;

    /**
     * indicates maximum supported width and height of the portion of the framebuffer corresponding to each texel in a fragment shading rate attachment. Each value 'must' be greater than or equal to the values in 'minFragmentShadingRateAttachmentTexelSize'. Each value 'must' be a power-of-two. It 'must' be [eq]#(0,0)# if the <<features-attachmentFragmentShadingRate, 'attachmentFragmentShadingRate'>> feature is not supported.
     */
    readonly maxFragmentShadingRateAttachmentTexelSize?: VkExtent2D | null;

    /**
     * indicates the maximum ratio between the width and height of the portion of the framebuffer corresponding to each texel in a fragment shading rate attachment. 'maxFragmentShadingRateAttachmentTexelSizeAspectRatio' 'must' be a power-of-two value, and 'must' be less than or equal to [eq]#max('maxFragmentShadingRateAttachmentTexelSize.width' / minFragmentShadingRateAttachmentTexelSize.height, 'maxFragmentShadingRateAttachmentTexelSize.height' / minFragmentShadingRateAttachmentTexelSize.width)#. It 'must' be 0 if the <<features-attachmentFragmentShadingRate, 'attachmentFragmentShadingRate'>> feature is not supported.
     */
    readonly maxFragmentShadingRateAttachmentTexelSizeAspectRatio?: number;

    /**
     * specifies whether the <<primsrast-fragment-shading-rate-primitive,primitive fragment shading rate>> 'can' be used when multiple viewports are used. If this value is 'VK_FALSE', only a single viewport 'must' be used, and applications 'must' not write to the 'ViewportMaskNV' or
     */
    readonly primitiveFragmentShadingRateWithMultipleViewports?: boolean;

    /**
     *
     */
    readonly layeredShadingRateAttachments?: boolean;

    /**
     *
     */
    readonly fragmentShadingRateNonTrivialCombinerOps?: boolean;

    /**
     *
     */
    readonly maxFragmentSize?: VkExtent2D | null;

    /**
     *
     */
    readonly maxFragmentSizeAspectRatio?: number;

    /**
     *
     */
    readonly maxFragmentShadingRateCoverageSamples?: number;

    /**
     *
     */
    readonly maxFragmentShadingRateRasterizationSamples?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly fragmentShadingRateWithShaderDepthStencilWrites?: boolean;

    /**
     *
     */
    readonly fragmentShadingRateWithSampleMask?: boolean;

    /**
     *
     */
    readonly fragmentShadingRateWithShaderSampleMask?: boolean;

    /**
     *
     */
    readonly fragmentShadingRateWithConservativeRasterization?: boolean;

    /**
     *
     */
    readonly fragmentShadingRateWithFragmentShaderInterlock?: boolean;

    /**
     *
     */
    readonly fragmentShadingRateWithCustomSampleLocations?: boolean;

    /**
     *
     */
    readonly fragmentShadingRateStrictMultiplyCombiner?: boolean;
}

declare interface VkPhysicalDeviceFragmentShadingRatePropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceFragmentShadingRatePropertiesKHR;
  new(param?: VkPhysicalDeviceFragmentShadingRatePropertiesKHRInitializer | null): VkPhysicalDeviceFragmentShadingRatePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentShadingRatePropertiesKHR: VkPhysicalDeviceFragmentShadingRatePropertiesKHRConstructor;



  /**
   * Structure indicating support for variable rate fragment shading
   */
interface VkPhysicalDeviceFragmentShadingRateFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    pipelineFragmentShadingRate: boolean;

    /**
     *
     */
    primitiveFragmentShadingRate: boolean;

    /**
     *
     */
    attachmentFragmentShadingRate: boolean;

}

declare interface VkPhysicalDeviceFragmentShadingRateFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    pipelineFragmentShadingRate?: boolean;

    /**
     *
     */
    primitiveFragmentShadingRate?: boolean;

    /**
     *
     */
    attachmentFragmentShadingRate?: boolean;
}

declare interface VkPhysicalDeviceFragmentShadingRateFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceFragmentShadingRateFeaturesKHR;
  new(param?: VkPhysicalDeviceFragmentShadingRateFeaturesKHRInitializer | null): VkPhysicalDeviceFragmentShadingRateFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentShadingRateFeaturesKHR: VkPhysicalDeviceFragmentShadingRateFeaturesKHRConstructor;



  /**
   * Structure specifying parameters controlling the fragment shading rate
   */
interface VkPipelineFragmentShadingRateStateCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies a 'VkExtent2D' structure containing the fragment size used to define the pipeline fragment shading rate for draw commands using this pipeline.
     */
    fragmentSize: VkExtent2D | null;

    /**
     * specifies a 'VkFragmentShadingRateCombinerOpKHR' value determining how the <<primsrast-fragment-shading-rate-pipeline,pipeline>>, <<primsrast-fragment-shading-rate-primitive,primitive>>, and <<primsrast-fragment-shading-rate-attachment,attachment shading rates>> are <<primsrast-fragment-shading-rate-combining,combined>> for fragments generated by drawing commands using the created pipeline.
     */
    combinerOps: number[] | null;

}

declare interface VkPipelineFragmentShadingRateStateCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies a 'VkExtent2D' structure containing the fragment size used to define the pipeline fragment shading rate for draw commands using this pipeline.
     */
    fragmentSize?: VkExtent2D | null;

    /**
     * specifies a 'VkFragmentShadingRateCombinerOpKHR' value determining how the <<primsrast-fragment-shading-rate-pipeline,pipeline>>, <<primsrast-fragment-shading-rate-primitive,primitive>>, and <<primsrast-fragment-shading-rate-attachment,attachment shading rates>> are <<primsrast-fragment-shading-rate-combining,combined>> for fragments generated by drawing commands using the created pipeline.
     */
    combinerOps?: number[] | null;
}

declare interface VkPipelineFragmentShadingRateStateCreateInfoKHRConstructor {
  readonly prototype: VkPipelineFragmentShadingRateStateCreateInfoKHR;
  new(param?: VkPipelineFragmentShadingRateStateCreateInfoKHRInitializer | null): VkPipelineFragmentShadingRateStateCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineFragmentShadingRateStateCreateInfoKHR: VkPipelineFragmentShadingRateStateCreateInfoKHRConstructor;



  /**
   * Structure specifying a fragment shading rate attachment for a subpass
   */
interface VkFragmentShadingRateAttachmentInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is an optional 'VkAttachmentReference2KHR' structure defining the fragment shading rate attachment for this subpass.
     */
    pFragmentShadingRateAttachment: VkAttachmentReference2 | null;

    /**
     * specifies the size of the portion of the framebuffer corresponding to each texel in 'pFragmentShadingRateAttachment'.
     */
    shadingRateAttachmentTexelSize: VkExtent2D | null;

}

declare interface VkFragmentShadingRateAttachmentInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is an optional 'VkAttachmentReference2KHR' structure defining the fragment shading rate attachment for this subpass.
     */
    pFragmentShadingRateAttachment?: VkAttachmentReference2 | null;

    /**
     * specifies the size of the portion of the framebuffer corresponding to each texel in 'pFragmentShadingRateAttachment'.
     */
    shadingRateAttachmentTexelSize?: VkExtent2D | null;
}

declare interface VkFragmentShadingRateAttachmentInfoKHRConstructor {
  readonly prototype: VkFragmentShadingRateAttachmentInfoKHR;
  new(param?: VkFragmentShadingRateAttachmentInfoKHRInitializer | null): VkFragmentShadingRateAttachmentInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFragmentShadingRateAttachmentInfoKHR: VkFragmentShadingRateAttachmentInfoKHRConstructor;



  /**
   * Structure describing features supported by VK_EXT_shader_image_atomic_int64
   */
interface VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * indicates whether shaders 'can' support 64-bit unsigned and signed integer atomic operations on images.
     */
    shaderImageInt64Atomics: boolean;

    /**
     * indicates whether 64-bit integer atomics 'can' be used on sparse images.
     */
    sparseImageInt64Atomics: boolean;

}

declare interface VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * indicates whether shaders 'can' support 64-bit unsigned and signed integer atomic operations on images.
     */
    shaderImageInt64Atomics?: boolean;

    /**
     * indicates whether 64-bit integer atomics 'can' be used on sparse images.
     */
    sparseImageInt64Atomics?: boolean;
}

declare interface VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
  new(param?: VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTInitializer | null): VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT: VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTConstructor;



  /**
   * Structure specifying parameters of resolve image command
   */
interface VkResolveImageInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the source image.
     */
    srcImage: VkImage | null;

    /**
     * is the layout of the source image subresources for the resolve.
     */
    srcImageLayout: VkImageLayout;

    /**
     * is the destination image.
     */
    dstImage: VkImage | null;

    /**
     * is the layout of the destination image subresources for the resolve.
     */
    dstImageLayout: VkImageLayout;

    /**
     * is the number of regions to resolve.
     */
    regionCount: number;

    /**
     * is an array of 'VkImageResolve2KHR' structures specifying the regions to resolve.
     */
    pRegions: VkImageResolve2KHR[] | null;

}

declare interface VkResolveImageInfo2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the source image.
     */
    srcImage?: VkImage | null;

    /**
     * is the layout of the source image subresources for the resolve.
     */
    srcImageLayout?: VkImageLayout;

    /**
     * is the destination image.
     */
    dstImage?: VkImage | null;

    /**
     * is the layout of the destination image subresources for the resolve.
     */
    dstImageLayout?: VkImageLayout;

    /**
     * is the number of regions to resolve.
     */
    regionCount?: number;

    /**
     * is an array of 'VkImageResolve2KHR' structures specifying the regions to resolve.
     */
    pRegions?: VkImageResolve2KHR[] | null;
}

declare interface VkResolveImageInfo2KHRConstructor {
  readonly prototype: VkResolveImageInfo2KHR;
  new(param?: VkResolveImageInfo2KHRInitializer | null): VkResolveImageInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkResolveImageInfo2KHR: VkResolveImageInfo2KHRConstructor;



  /**
   * Structure specifying parameters of a image to buffer copy command
   */
interface VkCopyImageToBufferInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the source image.
     */
    srcImage: VkImage | null;

    /**
     * is the layout of the source image subresources for the copy.
     */
    srcImageLayout: VkImageLayout;

    /**
     * is the destination buffer.
     */
    dstBuffer: VkBuffer | null;

    /**
     * is the number of regions to copy.
     */
    regionCount: number;

    /**
     * is an array of 'VkBufferImageCopy2KHR' structures specifying the regions to copy.
     */
    pRegions: VkBufferImageCopy2KHR[] | null;

}

declare interface VkCopyImageToBufferInfo2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the source image.
     */
    srcImage?: VkImage | null;

    /**
     * is the layout of the source image subresources for the copy.
     */
    srcImageLayout?: VkImageLayout;

    /**
     * is the destination buffer.
     */
    dstBuffer?: VkBuffer | null;

    /**
     * is the number of regions to copy.
     */
    regionCount?: number;

    /**
     * is an array of 'VkBufferImageCopy2KHR' structures specifying the regions to copy.
     */
    pRegions?: VkBufferImageCopy2KHR[] | null;
}

declare interface VkCopyImageToBufferInfo2KHRConstructor {
  readonly prototype: VkCopyImageToBufferInfo2KHR;
  new(param?: VkCopyImageToBufferInfo2KHRInitializer | null): VkCopyImageToBufferInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCopyImageToBufferInfo2KHR: VkCopyImageToBufferInfo2KHRConstructor;



  /**
   * Structure specifying parameters of a buffer to image copy command
   */
interface VkCopyBufferToImageInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the source buffer.
     */
    srcBuffer: VkBuffer | null;

    /**
     * is the destination image.
     */
    dstImage: VkImage | null;

    /**
     * is the layout of the destination image subresources for the copy.
     */
    dstImageLayout: VkImageLayout;

    /**
     * is the number of regions to copy.
     */
    regionCount: number;

    /**
     * is an array of 'VkBufferImageCopy2KHR' structures specifying the regions to copy.
     */
    pRegions: VkBufferImageCopy2KHR[] | null;

}

declare interface VkCopyBufferToImageInfo2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the source buffer.
     */
    srcBuffer?: VkBuffer | null;

    /**
     * is the destination image.
     */
    dstImage?: VkImage | null;

    /**
     * is the layout of the destination image subresources for the copy.
     */
    dstImageLayout?: VkImageLayout;

    /**
     * is the number of regions to copy.
     */
    regionCount?: number;

    /**
     * is an array of 'VkBufferImageCopy2KHR' structures specifying the regions to copy.
     */
    pRegions?: VkBufferImageCopy2KHR[] | null;
}

declare interface VkCopyBufferToImageInfo2KHRConstructor {
  readonly prototype: VkCopyBufferToImageInfo2KHR;
  new(param?: VkCopyBufferToImageInfo2KHRInitializer | null): VkCopyBufferToImageInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCopyBufferToImageInfo2KHR: VkCopyBufferToImageInfo2KHRConstructor;



  /**
   * Structure specifying parameters of blit image command
   */
interface VkBlitImageInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the source image.
     */
    srcImage: VkImage | null;

    /**
     * is the layout of the source image subresources for the blit.
     */
    srcImageLayout: VkImageLayout;

    /**
     * is the destination image.
     */
    dstImage: VkImage | null;

    /**
     * is the layout of the destination image subresources for the blit.
     */
    dstImageLayout: VkImageLayout;

    /**
     * is the number of regions to blit.
     */
    regionCount: number;

    /**
     * is an array of 'VkImageBlit2KHR' structures specifying the regions to blit.
     */
    pRegions: VkImageBlit2KHR[] | null;

    /**
     * is a 'VkFilter' specifying the filter to apply if the blits require scaling.
     */
    filter: VkFilter;

}

declare interface VkBlitImageInfo2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the source image.
     */
    srcImage?: VkImage | null;

    /**
     * is the layout of the source image subresources for the blit.
     */
    srcImageLayout?: VkImageLayout;

    /**
     * is the destination image.
     */
    dstImage?: VkImage | null;

    /**
     * is the layout of the destination image subresources for the blit.
     */
    dstImageLayout?: VkImageLayout;

    /**
     * is the number of regions to blit.
     */
    regionCount?: number;

    /**
     * is an array of 'VkImageBlit2KHR' structures specifying the regions to blit.
     */
    pRegions?: VkImageBlit2KHR[] | null;

    /**
     * is a 'VkFilter' specifying the filter to apply if the blits require scaling.
     */
    filter?: VkFilter;
}

declare interface VkBlitImageInfo2KHRConstructor {
  readonly prototype: VkBlitImageInfo2KHR;
  new(param?: VkBlitImageInfo2KHRInitializer | null): VkBlitImageInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBlitImageInfo2KHR: VkBlitImageInfo2KHRConstructor;



  /**
   * Structure specifying parameters of an image copy command
   */
interface VkCopyImageInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the source image.
     */
    srcImage: VkImage | null;

    /**
     * is the current layout of the source image subresource.
     */
    srcImageLayout: VkImageLayout;

    /**
     * is the destination image.
     */
    dstImage: VkImage | null;

    /**
     * is the current layout of the destination image subresource.
     */
    dstImageLayout: VkImageLayout;

    /**
     * is the number of regions to copy.
     */
    regionCount: number;

    /**
     * is an array of 'VkImageCopy2KHR' structures specifying the regions to copy.
     */
    pRegions: VkImageCopy2KHR[] | null;

}

declare interface VkCopyImageInfo2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the source image.
     */
    srcImage?: VkImage | null;

    /**
     * is the current layout of the source image subresource.
     */
    srcImageLayout?: VkImageLayout;

    /**
     * is the destination image.
     */
    dstImage?: VkImage | null;

    /**
     * is the current layout of the destination image subresource.
     */
    dstImageLayout?: VkImageLayout;

    /**
     * is the number of regions to copy.
     */
    regionCount?: number;

    /**
     * is an array of 'VkImageCopy2KHR' structures specifying the regions to copy.
     */
    pRegions?: VkImageCopy2KHR[] | null;
}

declare interface VkCopyImageInfo2KHRConstructor {
  readonly prototype: VkCopyImageInfo2KHR;
  new(param?: VkCopyImageInfo2KHRInitializer | null): VkCopyImageInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCopyImageInfo2KHR: VkCopyImageInfo2KHRConstructor;



  /**
   * Structure specifying parameters of a buffer copy command
   */
interface VkCopyBufferInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the source buffer.
     */
    srcBuffer: VkBuffer | null;

    /**
     * is the destination buffer.
     */
    dstBuffer: VkBuffer | null;

    /**
     * is the number of regions to copy.
     */
    regionCount: number;

    /**
     * is an array of 'VkBufferCopy2KHR' structures specifying the regions to copy.
     */
    pRegions: VkBufferCopy2KHR[] | null;

}

declare interface VkCopyBufferInfo2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the source buffer.
     */
    srcBuffer?: VkBuffer | null;

    /**
     * is the destination buffer.
     */
    dstBuffer?: VkBuffer | null;

    /**
     * is the number of regions to copy.
     */
    regionCount?: number;

    /**
     * is an array of 'VkBufferCopy2KHR' structures specifying the regions to copy.
     */
    pRegions?: VkBufferCopy2KHR[] | null;
}

declare interface VkCopyBufferInfo2KHRConstructor {
  readonly prototype: VkCopyBufferInfo2KHR;
  new(param?: VkCopyBufferInfo2KHRInitializer | null): VkCopyBufferInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCopyBufferInfo2KHR: VkCopyBufferInfo2KHRConstructor;



  /**
   * Structure specifying an image resolve operation
   */
interface VkImageResolve2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     *
     */
    srcSubresource: VkImageSubresourceLayers | null;

    /**
     *
     */
    srcOffset: VkOffset3D | null;

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.
     */
    dstSubresource: VkImageSubresourceLayers | null;

    /**
     *
     */
    dstOffset: VkOffset3D | null;

    /**
     * is the size in texels of the source image to resolve in 'width', 'height' and 'depth'.
     */
    extent: VkExtent3D | null;

}

declare interface VkImageResolve2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     *
     */
    srcSubresource?: VkImageSubresourceLayers | null;

    /**
     *
     */
    srcOffset?: VkOffset3D | null;

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.
     */
    dstSubresource?: VkImageSubresourceLayers | null;

    /**
     *
     */
    dstOffset?: VkOffset3D | null;

    /**
     * is the size in texels of the source image to resolve in 'width', 'height' and 'depth'.
     */
    extent?: VkExtent3D | null;
}

declare interface VkImageResolve2KHRConstructor {
  readonly prototype: VkImageResolve2KHR;
  new(param?: VkImageResolve2KHRInitializer | null): VkImageResolve2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageResolve2KHR: VkImageResolve2KHRConstructor;



  /**
   * Structure specifying a buffer image copy operation
   */
interface VkBufferImageCopy2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the offset in bytes from the start of the buffer object where the image data is copied from or to.
     */
    bufferOffset: bigint | number;

    /**
     *
     */
    bufferRowLength: number;

    /**
     * specify in texels a subregion of a larger two- or three-dimensional image in buffer memory, and control the addressing calculations. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the 'imageExtent'.
     */
    bufferImageHeight: number;

    /**
     * is a 'VkImageSubresourceLayers' used to specify the specific image subresources of the image used for the source or destination image data.
     */
    imageSubresource: VkImageSubresourceLayers | null;

    /**
     *
     */
    imageOffset: VkOffset3D | null;

    /**
     * is the size in texels of the image to copy in 'width', 'height' and 'depth'.
     */
    imageExtent: VkExtent3D | null;

}

declare interface VkBufferImageCopy2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the offset in bytes from the start of the buffer object where the image data is copied from or to.
     */
    bufferOffset?: bigint | number;

    /**
     *
     */
    bufferRowLength?: number;

    /**
     * specify in texels a subregion of a larger two- or three-dimensional image in buffer memory, and control the addressing calculations. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the 'imageExtent'.
     */
    bufferImageHeight?: number;

    /**
     * is a 'VkImageSubresourceLayers' used to specify the specific image subresources of the image used for the source or destination image data.
     */
    imageSubresource?: VkImageSubresourceLayers | null;

    /**
     *
     */
    imageOffset?: VkOffset3D | null;

    /**
     * is the size in texels of the image to copy in 'width', 'height' and 'depth'.
     */
    imageExtent?: VkExtent3D | null;
}

declare interface VkBufferImageCopy2KHRConstructor {
  readonly prototype: VkBufferImageCopy2KHR;
  new(param?: VkBufferImageCopy2KHRInitializer | null): VkBufferImageCopy2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferImageCopy2KHR: VkBufferImageCopy2KHRConstructor;



  /**
   * Structure specifying an image blit operation
   */
interface VkImageBlit2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the subresource to blit from.
     */
    srcSubresource: VkImageSubresourceLayers | null;

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the source region within 'srcSubresource'.
     */
    srcOffsets: VkOffset3D[] | null;

    /**
     * is the subresource to blit into.
     */
    dstSubresource: VkImageSubresourceLayers | null;

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the destination region within 'dstSubresource'.
     */
    dstOffsets: VkOffset3D[] | null;

}

declare interface VkImageBlit2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the subresource to blit from.
     */
    srcSubresource?: VkImageSubresourceLayers | null;

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the source region within 'srcSubresource'.
     */
    srcOffsets?: VkOffset3D[] | null;

    /**
     * is the subresource to blit into.
     */
    dstSubresource?: VkImageSubresourceLayers | null;

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the destination region within 'dstSubresource'.
     */
    dstOffsets?: VkOffset3D[] | null;
}

declare interface VkImageBlit2KHRConstructor {
  readonly prototype: VkImageBlit2KHR;
  new(param?: VkImageBlit2KHRInitializer | null): VkImageBlit2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageBlit2KHR: VkImageBlit2KHRConstructor;



  /**
   * Structure specifying an image copy operation
   */
interface VkImageCopy2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     *
     */
    srcSubresource: VkImageSubresourceLayers | null;

    /**
     *
     */
    srcOffset: VkOffset3D | null;

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively.
     */
    dstSubresource: VkImageSubresourceLayers | null;

    /**
     *
     */
    dstOffset: VkOffset3D | null;

    /**
     *
     */
    extent: VkExtent3D | null;

}

declare interface VkImageCopy2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     *
     */
    srcSubresource?: VkImageSubresourceLayers | null;

    /**
     *
     */
    srcOffset?: VkOffset3D | null;

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively.
     */
    dstSubresource?: VkImageSubresourceLayers | null;

    /**
     *
     */
    dstOffset?: VkOffset3D | null;

    /**
     *
     */
    extent?: VkExtent3D | null;
}

declare interface VkImageCopy2KHRConstructor {
  readonly prototype: VkImageCopy2KHR;
  new(param?: VkImageCopy2KHRInitializer | null): VkImageCopy2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageCopy2KHR: VkImageCopy2KHRConstructor;



  /**
   * Structure specifying a buffer copy operation
   */
interface VkBufferCopy2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the starting offset in bytes from the start of 'srcBuffer'.
     */
    srcOffset: bigint | number;

    /**
     * is the starting offset in bytes from the start of 'dstBuffer'.
     */
    dstOffset: bigint | number;

    /**
     * is the number of bytes to copy.
     */
    size: bigint | number;

}

declare interface VkBufferCopy2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the starting offset in bytes from the start of 'srcBuffer'.
     */
    srcOffset?: bigint | number;

    /**
     * is the starting offset in bytes from the start of 'dstBuffer'.
     */
    dstOffset?: bigint | number;

    /**
     * is the number of bytes to copy.
     */
    size?: bigint | number;
}

declare interface VkBufferCopy2KHRConstructor {
  readonly prototype: VkBufferCopy2KHR;
  new(param?: VkBufferCopy2KHRInitializer | null): VkBufferCopy2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferCopy2KHR: VkBufferCopy2KHRConstructor;



  /**
   * Structure describing additional 4444 formats supported by an implementation
   */
interface VkPhysicalDevice4444FormatsFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation 'must' support using a 'VkFormat' of 'VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT' with at least the following 'VkFormatFeatureFlagBits':
     */
    formatA4R4G4B4: boolean;

    /**
     * indicates that the implementation 'must' support using a 'VkFormat' of 'VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT' with at least the following 'VkFormatFeatureFlagBits':
     */
    formatA4B4G4R4: boolean;

}

declare interface VkPhysicalDevice4444FormatsFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation 'must' support using a 'VkFormat' of 'VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT' with at least the following 'VkFormatFeatureFlagBits':
     */
    formatA4R4G4B4?: boolean;

    /**
     * indicates that the implementation 'must' support using a 'VkFormat' of 'VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT' with at least the following 'VkFormatFeatureFlagBits':
     */
    formatA4B4G4R4?: boolean;
}

declare interface VkPhysicalDevice4444FormatsFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDevice4444FormatsFeaturesEXT;
  new(param?: VkPhysicalDevice4444FormatsFeaturesEXTInitializer | null): VkPhysicalDevice4444FormatsFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevice4444FormatsFeaturesEXT: VkPhysicalDevice4444FormatsFeaturesEXTConstructor;



  /**
   * Structure describing the out-of-bounds behavior for an implementation
   */
interface VkPhysicalDeviceImageRobustnessFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether image accesses are tightly bounds-checked against the dimensions of the image view. <<textures-input-validation,Invalid texels>> resulting from out of bounds image loads will be replaced as described in <<textures-texel-replacement,Texel Replacement>>, with either [eq]#(0,0,1)# or [eq]#(0,0,0)# values inserted for missing G, B, or A components based on the format.
     */
    robustImageAccess: boolean;

}

declare interface VkPhysicalDeviceImageRobustnessFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether image accesses are tightly bounds-checked against the dimensions of the image view. <<textures-input-validation,Invalid texels>> resulting from out of bounds image loads will be replaced as described in <<textures-texel-replacement,Texel Replacement>>, with either [eq]#(0,0,1)# or [eq]#(0,0,0)# values inserted for missing G, B, or A components based on the format.
     */
    robustImageAccess?: boolean;
}

declare interface VkPhysicalDeviceImageRobustnessFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceImageRobustnessFeaturesEXT;
  new(param?: VkPhysicalDeviceImageRobustnessFeaturesEXTInitializer | null): VkPhysicalDeviceImageRobustnessFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceImageRobustnessFeaturesEXT: VkPhysicalDeviceImageRobustnessFeaturesEXTConstructor;



  /**
   * Structure describing robust buffer access properties supported by an implementation
   */
interface VkPhysicalDeviceRobustness2PropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the number of bytes that the range of a storage buffer descriptor is rounded up to when used for bounds-checking when <<features-robustBufferAccess2,'robustBufferAccess2'>> is enabled. This value is either 1 or 4.
     */
    readonly robustStorageBufferAccessSizeAlignment: bigint | number;

    /**
     * is the number of bytes that the range of a uniform buffer descriptor is rounded up to when used for bounds-checking when <<features-robustBufferAccess2,'robustBufferAccess2'>> is enabled. This value is a power of two in the range [1, 256].
     */
    readonly robustUniformBufferAccessSizeAlignment: bigint | number;

}

declare interface VkPhysicalDeviceRobustness2PropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the number of bytes that the range of a storage buffer descriptor is rounded up to when used for bounds-checking when <<features-robustBufferAccess2,'robustBufferAccess2'>> is enabled. This value is either 1 or 4.
     */
    readonly robustStorageBufferAccessSizeAlignment?: bigint | number;

    /**
     * is the number of bytes that the range of a uniform buffer descriptor is rounded up to when used for bounds-checking when <<features-robustBufferAccess2,'robustBufferAccess2'>> is enabled. This value is a power of two in the range [1, 256].
     */
    readonly robustUniformBufferAccessSizeAlignment?: bigint | number;
}

declare interface VkPhysicalDeviceRobustness2PropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceRobustness2PropertiesEXT;
  new(param?: VkPhysicalDeviceRobustness2PropertiesEXTInitializer | null): VkPhysicalDeviceRobustness2PropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceRobustness2PropertiesEXT: VkPhysicalDeviceRobustness2PropertiesEXTConstructor;



  /**
   * Structure describing the out-of-bounds behavior for an implementation
   */
interface VkPhysicalDeviceRobustness2FeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether buffer accesses are tightly bounds-checked against the range of the descriptor. Uniform buffers 'must' be bounds-checked to the range of the descriptor, where the range is rounded up to a multiple of <<limits-robustUniformBufferAccessSizeAlignment,robustUniformBufferAccessSizeAlignment>>. Storage buffers 'must' be bounds-checked to the range of the descriptor, where the range is rounded up to a multiple of <<limits-robustStorageBufferAccessSizeAlignment,robustStorageBufferAccessSizeAlignment>>. Out of bounds buffer loads will return zero values, and formatted loads will have [eq]#(0,0,1)# values inserted for missing G, B, or A components based on the format. 
     */
    robustBufferAccess2: boolean;

    /**
     * indicates whether image accesses are tightly bounds-checked against the dimensions of the image view. Out of bounds image loads will return zero values, with [eq]#(0,0,1)# values <<textures-conversion-to-rgba,inserted for missing G, B, or A components>> based on the format. 
     */
    robustImageAccess2: boolean;

    /**
     * indicates whether descriptors 'can' be written with a 'VK_NULL_HANDLE' resource or view, which are considered valid to access and act as if the descriptor were bound to nothing.
     */
    nullDescriptor: boolean;

}

declare interface VkPhysicalDeviceRobustness2FeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether buffer accesses are tightly bounds-checked against the range of the descriptor. Uniform buffers 'must' be bounds-checked to the range of the descriptor, where the range is rounded up to a multiple of <<limits-robustUniformBufferAccessSizeAlignment,robustUniformBufferAccessSizeAlignment>>. Storage buffers 'must' be bounds-checked to the range of the descriptor, where the range is rounded up to a multiple of <<limits-robustStorageBufferAccessSizeAlignment,robustStorageBufferAccessSizeAlignment>>. Out of bounds buffer loads will return zero values, and formatted loads will have [eq]#(0,0,1)# values inserted for missing G, B, or A components based on the format. 
     */
    robustBufferAccess2?: boolean;

    /**
     * indicates whether image accesses are tightly bounds-checked against the dimensions of the image view. Out of bounds image loads will return zero values, with [eq]#(0,0,1)# values <<textures-conversion-to-rgba,inserted for missing G, B, or A components>> based on the format. 
     */
    robustImageAccess2?: boolean;

    /**
     * indicates whether descriptors 'can' be written with a 'VK_NULL_HANDLE' resource or view, which are considered valid to access and act as if the descriptor were bound to nothing.
     */
    nullDescriptor?: boolean;
}

declare interface VkPhysicalDeviceRobustness2FeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceRobustness2FeaturesEXT;
  new(param?: VkPhysicalDeviceRobustness2FeaturesEXTInitializer | null): VkPhysicalDeviceRobustness2FeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceRobustness2FeaturesEXT: VkPhysicalDeviceRobustness2FeaturesEXTConstructor;



  /**
   * Specify diagnostics config for a Vulkan device
   */
interface VkDeviceDiagnosticsConfigCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkDeviceDiagnosticsConfigFlagBitsNV' specifying addtional parameters for configuring diagnostic tools.
     */
    flags: VkDeviceDiagnosticsConfigFlagBitsNV;

}

declare interface VkDeviceDiagnosticsConfigCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkDeviceDiagnosticsConfigFlagBitsNV' specifying addtional parameters for configuring diagnostic tools.
     */
    flags?: VkDeviceDiagnosticsConfigFlagBitsNV;
}

declare interface VkDeviceDiagnosticsConfigCreateInfoNVConstructor {
  readonly prototype: VkDeviceDiagnosticsConfigCreateInfoNV;
  new(param?: VkDeviceDiagnosticsConfigCreateInfoNVInitializer | null): VkDeviceDiagnosticsConfigCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceDiagnosticsConfigCreateInfoNV: VkDeviceDiagnosticsConfigCreateInfoNVConstructor;



  /**
   * Structure describing the device-generated diagnostic configuration features that can be supported by an implementation
   */
interface VkPhysicalDeviceDiagnosticsConfigFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports the ability to configure diagnostic tools.
     */
    diagnosticsConfig: boolean;

}

declare interface VkPhysicalDeviceDiagnosticsConfigFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports the ability to configure diagnostic tools.
     */
    diagnosticsConfig?: boolean;
}

declare interface VkPhysicalDeviceDiagnosticsConfigFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceDiagnosticsConfigFeaturesNV;
  new(param?: VkPhysicalDeviceDiagnosticsConfigFeaturesNVInitializer | null): VkPhysicalDeviceDiagnosticsConfigFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDiagnosticsConfigFeaturesNV: VkPhysicalDeviceDiagnosticsConfigFeaturesNVConstructor;



  /**
   * Structure describing transformed render pass parameters command buffer
   */
interface VkCommandBufferInheritanceRenderPassTransformInfoQCOM {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkSurfaceTransformFlagBitsKHR' value describing the transform to be applied to the render pass.
     */
    transform: VkSurfaceTransformFlagBitsKHR;

    /**
     * is the render area that is affected by the command buffer.
     */
    renderArea: VkRect2D | null;

}

declare interface VkCommandBufferInheritanceRenderPassTransformInfoQCOMInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkSurfaceTransformFlagBitsKHR' value describing the transform to be applied to the render pass.
     */
    transform?: VkSurfaceTransformFlagBitsKHR;

    /**
     * is the render area that is affected by the command buffer.
     */
    renderArea?: VkRect2D | null;
}

declare interface VkCommandBufferInheritanceRenderPassTransformInfoQCOMConstructor {
  readonly prototype: VkCommandBufferInheritanceRenderPassTransformInfoQCOM;
  new(param?: VkCommandBufferInheritanceRenderPassTransformInfoQCOMInitializer | null): VkCommandBufferInheritanceRenderPassTransformInfoQCOM;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCommandBufferInheritanceRenderPassTransformInfoQCOM: VkCommandBufferInheritanceRenderPassTransformInfoQCOMConstructor;



  /**
   * Structure describing transform parameters of rotated copy command
   */
interface VkCopyCommandTransformInfoQCOM {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext: null;

    /**
     * is a 'VkSurfaceTransformFlagBitsKHR' value describing the transform to be applied.
     */
    transform: VkSurfaceTransformFlagBitsKHR;

}

declare interface VkCopyCommandTransformInfoQCOMInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to an extension-specific structure.
     */
    pNext?: null;

    /**
     * is a 'VkSurfaceTransformFlagBitsKHR' value describing the transform to be applied.
     */
    transform?: VkSurfaceTransformFlagBitsKHR;
}

declare interface VkCopyCommandTransformInfoQCOMConstructor {
  readonly prototype: VkCopyCommandTransformInfoQCOM;
  new(param?: VkCopyCommandTransformInfoQCOMInitializer | null): VkCopyCommandTransformInfoQCOM;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCopyCommandTransformInfoQCOM: VkCopyCommandTransformInfoQCOMConstructor;



  /**
   * Structure describing transform parameters of a render pass instance
   */
interface VkRenderPassTransformBeginInfoQCOM {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkSurfaceTransformFlagBitsKHR' value describing the transform to be applied to rasterization.
     */
    transform: VkSurfaceTransformFlagBitsKHR;

}

declare interface VkRenderPassTransformBeginInfoQCOMInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkSurfaceTransformFlagBitsKHR' value describing the transform to be applied to rasterization.
     */
    transform?: VkSurfaceTransformFlagBitsKHR;
}

declare interface VkRenderPassTransformBeginInfoQCOMConstructor {
  readonly prototype: VkRenderPassTransformBeginInfoQCOM;
  new(param?: VkRenderPassTransformBeginInfoQCOMInitializer | null): VkRenderPassTransformBeginInfoQCOM;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassTransformBeginInfoQCOM: VkRenderPassTransformBeginInfoQCOMConstructor;



  /**
   * Structure describing what extended dynamic state can be used
   */
interface VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports the following dynamic states:
     */
    extendedDynamicState: boolean;

}

declare interface VkPhysicalDeviceExtendedDynamicStateFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports the following dynamic states:
     */
    extendedDynamicState?: boolean;
}

declare interface VkPhysicalDeviceExtendedDynamicStateFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceExtendedDynamicStateFeaturesEXT;
  new(param?: VkPhysicalDeviceExtendedDynamicStateFeaturesEXTInitializer | null): VkPhysicalDeviceExtendedDynamicStateFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExtendedDynamicStateFeaturesEXT: VkPhysicalDeviceExtendedDynamicStateFeaturesEXTConstructor;



  /**
   * Structure specifying pipeline libraries to use when creating a pipeline
   */
interface VkPipelineLibraryCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of pipeline libraries in 'pLibraries'.
     */
    libraryCount: number;

    /**
     * is an array of pipeline libraries to use when creating a pipeline.
     */
    pLibraries: VkPipeline[] | null;

}

declare interface VkPipelineLibraryCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of pipeline libraries in 'pLibraries'.
     */
    libraryCount?: number;

    /**
     * is an array of pipeline libraries to use when creating a pipeline.
     */
    pLibraries?: VkPipeline[] | null;
}

declare interface VkPipelineLibraryCreateInfoKHRConstructor {
  readonly prototype: VkPipelineLibraryCreateInfoKHR;
  new(param?: VkPipelineLibraryCreateInfoKHRInitializer | null): VkPipelineLibraryCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineLibraryCreateInfoKHR: VkPipelineLibraryCreateInfoKHRConstructor;



  /**
   * Structure specifying additional interface information when using libraries
   */
interface VkRayTracingPipelineInterfaceCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the maximum payload size in bytes used by any shader in the pipeline.
     */
    maxPipelineRayPayloadSize: number;

    /**
     * is the maximum attribute structure size in bytes used by any shader in the pipeline.
     */
    maxPipelineRayHitAttributeSize: number;

}

declare interface VkRayTracingPipelineInterfaceCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the maximum payload size in bytes used by any shader in the pipeline.
     */
    maxPipelineRayPayloadSize?: number;

    /**
     * is the maximum attribute structure size in bytes used by any shader in the pipeline.
     */
    maxPipelineRayHitAttributeSize?: number;
}

declare interface VkRayTracingPipelineInterfaceCreateInfoKHRConstructor {
  readonly prototype: VkRayTracingPipelineInterfaceCreateInfoKHR;
  new(param?: VkRayTracingPipelineInterfaceCreateInfoKHRInitializer | null): VkRayTracingPipelineInterfaceCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRayTracingPipelineInterfaceCreateInfoKHR: VkRayTracingPipelineInterfaceCreateInfoKHRConstructor;



  /**
   * Parameters for deserializing an acceleration structure
   */
interface VkCopyMemoryToAccelerationStructureInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the device or host address to memory containing the source data for the copy.
     */
    src: VkDeviceOrHostAddressConstKHR | null;

    /**
     * is the target acceleration structure for the copy.
     */
    dst: VkAccelerationStructureKHR | null;

    /**
     * is a 'VkCopyAccelerationStructureModeKHR' value that specifies additional operations to perform during the copy.
     */
    mode: VkCopyAccelerationStructureModeKHR;

}

declare interface VkCopyMemoryToAccelerationStructureInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the device or host address to memory containing the source data for the copy.
     */
    src?: VkDeviceOrHostAddressConstKHR | null;

    /**
     * is the target acceleration structure for the copy.
     */
    dst?: VkAccelerationStructureKHR | null;

    /**
     * is a 'VkCopyAccelerationStructureModeKHR' value that specifies additional operations to perform during the copy.
     */
    mode?: VkCopyAccelerationStructureModeKHR;
}

declare interface VkCopyMemoryToAccelerationStructureInfoKHRConstructor {
  readonly prototype: VkCopyMemoryToAccelerationStructureInfoKHR;
  new(param?: VkCopyMemoryToAccelerationStructureInfoKHRInitializer | null): VkCopyMemoryToAccelerationStructureInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCopyMemoryToAccelerationStructureInfoKHR: VkCopyMemoryToAccelerationStructureInfoKHRConstructor;



  /**
   * Parameters for serializing an acceleration structure
   */
interface VkCopyAccelerationStructureToMemoryInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the source acceleration structure for the copy
     */
    src: VkAccelerationStructureKHR | null;

    /**
     * is the device or host address to memory which is the target for the copy
     */
    dst: VkDeviceOrHostAddressKHR | null;

    /**
     * is a 'VkCopyAccelerationStructureModeKHR' value that specifies additional operations to perform during the copy.
     */
    mode: VkCopyAccelerationStructureModeKHR;

}

declare interface VkCopyAccelerationStructureToMemoryInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the source acceleration structure for the copy
     */
    src?: VkAccelerationStructureKHR | null;

    /**
     * is the device or host address to memory which is the target for the copy
     */
    dst?: VkDeviceOrHostAddressKHR | null;

    /**
     * is a 'VkCopyAccelerationStructureModeKHR' value that specifies additional operations to perform during the copy.
     */
    mode?: VkCopyAccelerationStructureModeKHR;
}

declare interface VkCopyAccelerationStructureToMemoryInfoKHRConstructor {
  readonly prototype: VkCopyAccelerationStructureToMemoryInfoKHR;
  new(param?: VkCopyAccelerationStructureToMemoryInfoKHRInitializer | null): VkCopyAccelerationStructureToMemoryInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCopyAccelerationStructureToMemoryInfoKHR: VkCopyAccelerationStructureToMemoryInfoKHRConstructor;



  /**
   * Parameters for copying an acceleration structure
   */
interface VkCopyAccelerationStructureInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the source acceleration structure for the copy.
     */
    src: VkAccelerationStructureKHR | null;

    /**
     * is the target acceleration structure for the copy.
     */
    dst: VkAccelerationStructureKHR | null;

    /**
     * is a 'VkCopyAccelerationStructureModeKHR' value that specifies additional operations to perform during the copy.
     */
    mode: VkCopyAccelerationStructureModeKHR;

}

declare interface VkCopyAccelerationStructureInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the source acceleration structure for the copy.
     */
    src?: VkAccelerationStructureKHR | null;

    /**
     * is the target acceleration structure for the copy.
     */
    dst?: VkAccelerationStructureKHR | null;

    /**
     * is a 'VkCopyAccelerationStructureModeKHR' value that specifies additional operations to perform during the copy.
     */
    mode?: VkCopyAccelerationStructureModeKHR;
}

declare interface VkCopyAccelerationStructureInfoKHRConstructor {
  readonly prototype: VkCopyAccelerationStructureInfoKHR;
  new(param?: VkCopyAccelerationStructureInfoKHRInitializer | null): VkCopyAccelerationStructureInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCopyAccelerationStructureInfoKHR: VkCopyAccelerationStructureInfoKHRConstructor;



  /**
   * Acceleration structure version information
   */
interface VkAccelerationStructureVersionInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a reference to the version header of an acceleration structure as defined in 'vkCmdCopyAccelerationStructureToMemoryKHR'
     */
    pVersionData: Uint8Array | null;

}

declare interface VkAccelerationStructureVersionInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a reference to the version header of an acceleration structure as defined in 'vkCmdCopyAccelerationStructureToMemoryKHR'
     */
    pVersionData?: Uint8Array | null;
}

declare interface VkAccelerationStructureVersionInfoKHRConstructor {
  readonly prototype: VkAccelerationStructureVersionInfoKHR;
  new(param?: VkAccelerationStructureVersionInfoKHRInitializer | null): VkAccelerationStructureVersionInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureVersionInfoKHR: VkAccelerationStructureVersionInfoKHRConstructor;



  /**
   * Structure specifying the acceleration structure to query an address for
   */
interface VkAccelerationStructureDeviceAddressInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies the acceleration structure whose address is being queried.
     */
    accelerationStructure: VkAccelerationStructureKHR | null;

}

declare interface VkAccelerationStructureDeviceAddressInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies the acceleration structure whose address is being queried.
     */
    accelerationStructure?: VkAccelerationStructureKHR | null;
}

declare interface VkAccelerationStructureDeviceAddressInfoKHRConstructor {
  readonly prototype: VkAccelerationStructureDeviceAddressInfoKHR;
  new(param?: VkAccelerationStructureDeviceAddressInfoKHRInitializer | null): VkAccelerationStructureDeviceAddressInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureDeviceAddressInfoKHR: VkAccelerationStructureDeviceAddressInfoKHRConstructor;



  /**
   * 
   */
interface VkAccelerationStructureInstanceNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    transform: VkTransformMatrixKHR | null;

    /**
     *
     */
    instanceCustomIndex: number;

    /**
     *
     */
    mask: number;

    /**
     *
     */
    instanceShaderBindingTableRecordOffset: number;

    /**
     *
     */
    flags: VkGeometryInstanceFlagBitsKHR;

    /**
     *
     */
    accelerationStructureReference: bigint | number;

}

declare interface VkAccelerationStructureInstanceNVInitializer {
  
    /**
     *
     */
    transform?: VkTransformMatrixKHR | null;

    /**
     *
     */
    instanceCustomIndex?: number;

    /**
     *
     */
    mask?: number;

    /**
     *
     */
    instanceShaderBindingTableRecordOffset?: number;

    /**
     *
     */
    flags?: VkGeometryInstanceFlagBitsKHR;

    /**
     *
     */
    accelerationStructureReference?: bigint | number;
}

declare interface VkAccelerationStructureInstanceNVConstructor {
  readonly prototype: VkAccelerationStructureInstanceNV;
  new(param?: VkAccelerationStructureInstanceNVInitializer | null): VkAccelerationStructureInstanceNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureInstanceNV: VkAccelerationStructureInstanceNVConstructor;



  /**
   * Structure specifying a single acceleration structure instance for building into an acceleration structure geometry
   */
interface VkAccelerationStructureInstanceKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    transform: VkTransformMatrixKHR | null;

    /**
     *
     */
    instanceCustomIndex: number;

    /**
     *
     */
    mask: number;

    /**
     *
     */
    instanceShaderBindingTableRecordOffset: number;

    /**
     *
     */
    flags: VkGeometryInstanceFlagBitsKHR;

    /**
     *
     */
    accelerationStructureReference: bigint | number;

}

declare interface VkAccelerationStructureInstanceKHRInitializer {
  
    /**
     *
     */
    transform?: VkTransformMatrixKHR | null;

    /**
     *
     */
    instanceCustomIndex?: number;

    /**
     *
     */
    mask?: number;

    /**
     *
     */
    instanceShaderBindingTableRecordOffset?: number;

    /**
     *
     */
    flags?: VkGeometryInstanceFlagBitsKHR;

    /**
     *
     */
    accelerationStructureReference?: bigint | number;
}

declare interface VkAccelerationStructureInstanceKHRConstructor {
  readonly prototype: VkAccelerationStructureInstanceKHR;
  new(param?: VkAccelerationStructureInstanceKHRInitializer | null): VkAccelerationStructureInstanceKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureInstanceKHR: VkAccelerationStructureInstanceKHRConstructor;



  /**
   * 
   */
interface VkTransformMatrixNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    matrix: number[] | null;

}

declare interface VkTransformMatrixNVInitializer {
  
    /**
     *
     */
    matrix?: number[] | null;
}

declare interface VkTransformMatrixNVConstructor {
  readonly prototype: VkTransformMatrixNV;
  new(param?: VkTransformMatrixNVInitializer | null): VkTransformMatrixNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkTransformMatrixNV: VkTransformMatrixNVConstructor;



  /**
   * Structure specifying a 3x4 affine transformation matrix
   */
interface VkTransformMatrixKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    matrix: number[] | null;

}

declare interface VkTransformMatrixKHRInitializer {
  
    /**
     *
     */
    matrix?: number[] | null;
}

declare interface VkTransformMatrixKHRConstructor {
  readonly prototype: VkTransformMatrixKHR;
  new(param?: VkTransformMatrixKHRInitializer | null): VkTransformMatrixKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkTransformMatrixKHR: VkTransformMatrixKHRConstructor;



  /**
   * 
   */
interface VkAabbPositionsNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    minX: number;

    /**
     *
     */
    minY: number;

    /**
     *
     */
    minZ: number;

    /**
     *
     */
    maxX: number;

    /**
     *
     */
    maxY: number;

    /**
     *
     */
    maxZ: number;

}

declare interface VkAabbPositionsNVInitializer {
  
    /**
     *
     */
    minX?: number;

    /**
     *
     */
    minY?: number;

    /**
     *
     */
    minZ?: number;

    /**
     *
     */
    maxX?: number;

    /**
     *
     */
    maxY?: number;

    /**
     *
     */
    maxZ?: number;
}

declare interface VkAabbPositionsNVConstructor {
  readonly prototype: VkAabbPositionsNV;
  new(param?: VkAabbPositionsNVInitializer | null): VkAabbPositionsNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAabbPositionsNV: VkAabbPositionsNVConstructor;



  /**
   * Structure specifying two opposing corners of an axis-aligned bounding box
   */
interface VkAabbPositionsKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    minX: number;

    /**
     *
     */
    minY: number;

    /**
     *
     */
    minZ: number;

    /**
     *
     */
    maxX: number;

    /**
     *
     */
    maxY: number;

    /**
     *
     */
    maxZ: number;

}

declare interface VkAabbPositionsKHRInitializer {
  
    /**
     *
     */
    minX?: number;

    /**
     *
     */
    minY?: number;

    /**
     *
     */
    minZ?: number;

    /**
     *
     */
    maxX?: number;

    /**
     *
     */
    maxY?: number;

    /**
     *
     */
    maxZ?: number;
}

declare interface VkAabbPositionsKHRConstructor {
  readonly prototype: VkAabbPositionsKHR;
  new(param?: VkAabbPositionsKHRInitializer | null): VkAabbPositionsKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAabbPositionsKHR: VkAabbPositionsKHRConstructor;



  /**
   * Structure specifying the parameters of a newly created acceleration structure object
   */
interface VkAccelerationStructureCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkAccelerationStructureCreateFlagBitsKHR' specifying additional creation parameters of the acceleration structure.
     */
    createFlags: VkAccelerationStructureCreateFlagBitsKHR;

    /**
     * is the buffer on which the acceleration structure will be stored.
     */
    buffer: VkBuffer | null;

    /**
     * is an offset in bytes from the base address of the buffer at which the acceleration structure will be stored, and 'must' be a multiple of `256`.
     */
    offset: bigint | number;

    /**
     * is the size required for the acceleration structure.
     */
    size: bigint | number;

    /**
     * is a 'VkAccelerationStructureTypeKHR' value specifying the type of acceleration structure that will be created.
     */
    type: VkAccelerationStructureTypeKHR;

    /**
     * is the device address requested for the acceleration structure if the <<features-accelerationStructureCaptureReplay, 'accelerationStructureCaptureReplay'>> feature is being used.
     */
    deviceAddress: bigint | number;

}

declare interface VkAccelerationStructureCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkAccelerationStructureCreateFlagBitsKHR' specifying additional creation parameters of the acceleration structure.
     */
    createFlags?: VkAccelerationStructureCreateFlagBitsKHR;

    /**
     * is the buffer on which the acceleration structure will be stored.
     */
    buffer?: VkBuffer | null;

    /**
     * is an offset in bytes from the base address of the buffer at which the acceleration structure will be stored, and 'must' be a multiple of `256`.
     */
    offset?: bigint | number;

    /**
     * is the size required for the acceleration structure.
     */
    size?: bigint | number;

    /**
     * is a 'VkAccelerationStructureTypeKHR' value specifying the type of acceleration structure that will be created.
     */
    type?: VkAccelerationStructureTypeKHR;

    /**
     * is the device address requested for the acceleration structure if the <<features-accelerationStructureCaptureReplay, 'accelerationStructureCaptureReplay'>> feature is being used.
     */
    deviceAddress?: bigint | number;
}

declare interface VkAccelerationStructureCreateInfoKHRConstructor {
  readonly prototype: VkAccelerationStructureCreateInfoKHR;
  new(param?: VkAccelerationStructureCreateInfoKHRInitializer | null): VkAccelerationStructureCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureCreateInfoKHR: VkAccelerationStructureCreateInfoKHRConstructor;



  /**
   * Structure specifying build offsets and counts for acceleration structure builds
   */
interface VkAccelerationStructureBuildRangeInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * defines the number of primitives for a corresponding acceleration structure geometry.
     */
    primitiveCount: number;

    /**
     * defines an offset in bytes into the memory where primitive data is defined.
     */
    primitiveOffset: number;

    /**
     * is the index of the first vertex to build from for triangle geometry.
     */
    firstVertex: number;

    /**
     * defines an offset in bytes into the memory where a transform matrix is defined.
     */
    transformOffset: number;

}

declare interface VkAccelerationStructureBuildRangeInfoKHRInitializer {
  
    /**
     * defines the number of primitives for a corresponding acceleration structure geometry.
     */
    primitiveCount?: number;

    /**
     * defines an offset in bytes into the memory where primitive data is defined.
     */
    primitiveOffset?: number;

    /**
     * is the index of the first vertex to build from for triangle geometry.
     */
    firstVertex?: number;

    /**
     * defines an offset in bytes into the memory where a transform matrix is defined.
     */
    transformOffset?: number;
}

declare interface VkAccelerationStructureBuildRangeInfoKHRConstructor {
  readonly prototype: VkAccelerationStructureBuildRangeInfoKHR;
  new(param?: VkAccelerationStructureBuildRangeInfoKHRInitializer | null): VkAccelerationStructureBuildRangeInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureBuildRangeInfoKHR: VkAccelerationStructureBuildRangeInfoKHRConstructor;



  /**
   * Structure specifying the geometry data used to build an acceleration structure
   */
interface VkAccelerationStructureBuildGeometryInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkAccelerationStructureTypeKHR' value specifying the type of acceleration structure being built.
     */
    type: VkAccelerationStructureTypeKHR;

    /**
     * is a bitmask of 'VkBuildAccelerationStructureFlagBitsKHR' specifying additional parameters of the acceleration structure.
     */
    flags: VkBuildAccelerationStructureFlagBitsKHR;

    /**
     * is a 'VkBuildAccelerationStructureModeKHR' value specifying the type of operation to perform.
     */
    mode: VkBuildAccelerationStructureModeKHR;

    /**
     * reference to an existing acceleration structure that is to be used to update the 'dst' acceleration structure when 'mode' is 'VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR'.
     */
    srcAccelerationStructure: VkAccelerationStructureKHR | null;

    /**
     * reference to the target acceleration structure for the build.
     */
    dstAccelerationStructure: VkAccelerationStructureKHR | null;

    /**
     * specifies the number of geometries that will be built into 'dstAccelerationStructure'.
     */
    geometryCount: number;

    /**
     * is an array of 'VkAccelerationStructureGeometryKHR' structures.
     */
    pGeometries: VkAccelerationStructureGeometryKHR[] | null;

    /**
     * is an array of references to 'VkAccelerationStructureGeometryKHR' structures.
     */
    ppGeometries: VkAccelerationStructureGeometryKHR[] | null;

    /**
     * is the device or host address to memory that will be used as scratch memory for the build.
     */
    scratchData: VkDeviceOrHostAddressKHR | null;

}

declare interface VkAccelerationStructureBuildGeometryInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkAccelerationStructureTypeKHR' value specifying the type of acceleration structure being built.
     */
    type?: VkAccelerationStructureTypeKHR;

    /**
     * is a bitmask of 'VkBuildAccelerationStructureFlagBitsKHR' specifying additional parameters of the acceleration structure.
     */
    flags?: VkBuildAccelerationStructureFlagBitsKHR;

    /**
     * is a 'VkBuildAccelerationStructureModeKHR' value specifying the type of operation to perform.
     */
    mode?: VkBuildAccelerationStructureModeKHR;

    /**
     * reference to an existing acceleration structure that is to be used to update the 'dst' acceleration structure when 'mode' is 'VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR'.
     */
    srcAccelerationStructure?: VkAccelerationStructureKHR | null;

    /**
     * reference to the target acceleration structure for the build.
     */
    dstAccelerationStructure?: VkAccelerationStructureKHR | null;

    /**
     * specifies the number of geometries that will be built into 'dstAccelerationStructure'.
     */
    geometryCount?: number;

    /**
     * is an array of 'VkAccelerationStructureGeometryKHR' structures.
     */
    pGeometries?: VkAccelerationStructureGeometryKHR[] | null;

    /**
     * is an array of references to 'VkAccelerationStructureGeometryKHR' structures.
     */
    ppGeometries?: VkAccelerationStructureGeometryKHR[] | null;

    /**
     * is the device or host address to memory that will be used as scratch memory for the build.
     */
    scratchData?: VkDeviceOrHostAddressKHR | null;
}

declare interface VkAccelerationStructureBuildGeometryInfoKHRConstructor {
  readonly prototype: VkAccelerationStructureBuildGeometryInfoKHR;
  new(param?: VkAccelerationStructureBuildGeometryInfoKHRInitializer | null): VkAccelerationStructureBuildGeometryInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureBuildGeometryInfoKHR: VkAccelerationStructureBuildGeometryInfoKHRConstructor;



  /**
   * Structure specifying geometries to be built into an acceleration structure
   */
interface VkAccelerationStructureGeometryKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * describes which type of geometry this 'VkAccelerationStructureGeometryKHR' refers to.
     */
    geometryType: VkGeometryTypeKHR;

    /**
     * is a 'VkAccelerationStructureGeometryDataKHR' union describing the geometry data for the relevant geometry type.
     */
    geometry: VkAccelerationStructureGeometryDataKHR | null;

    /**
     * is a bitmask of 'VkGeometryFlagBitsKHR' values describing additional properties of how the geometry should be built.
     */
    flags: VkGeometryFlagBitsKHR;

}

declare interface VkAccelerationStructureGeometryKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * describes which type of geometry this 'VkAccelerationStructureGeometryKHR' refers to.
     */
    geometryType?: VkGeometryTypeKHR;

    /**
     * is a 'VkAccelerationStructureGeometryDataKHR' union describing the geometry data for the relevant geometry type.
     */
    geometry?: VkAccelerationStructureGeometryDataKHR | null;

    /**
     * is a bitmask of 'VkGeometryFlagBitsKHR' values describing additional properties of how the geometry should be built.
     */
    flags?: VkGeometryFlagBitsKHR;
}

declare interface VkAccelerationStructureGeometryKHRConstructor {
  readonly prototype: VkAccelerationStructureGeometryKHR;
  new(param?: VkAccelerationStructureGeometryKHRInitializer | null): VkAccelerationStructureGeometryKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureGeometryKHR: VkAccelerationStructureGeometryKHRConstructor;



  /**
   * Structure specifying a geometry consisting of instances of other acceleration structures
   */
interface VkAccelerationStructureGeometryInstancesDataKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     *
     */
    arrayOfPointers: boolean;

    /**
     * is either the address of an array of device or host addresses referencing individual 'VkAccelerationStructureInstanceKHR' structures if 'arrayOfPointers' is 'VK_TRUE', or the address of an array of 'VkAccelerationStructureInstanceKHR' structures.
     */
    data: VkDeviceOrHostAddressConstKHR | null;

}

declare interface VkAccelerationStructureGeometryInstancesDataKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     *
     */
    arrayOfPointers?: boolean;

    /**
     * is either the address of an array of device or host addresses referencing individual 'VkAccelerationStructureInstanceKHR' structures if 'arrayOfPointers' is 'VK_TRUE', or the address of an array of 'VkAccelerationStructureInstanceKHR' structures.
     */
    data?: VkDeviceOrHostAddressConstKHR | null;
}

declare interface VkAccelerationStructureGeometryInstancesDataKHRConstructor {
  readonly prototype: VkAccelerationStructureGeometryInstancesDataKHR;
  new(param?: VkAccelerationStructureGeometryInstancesDataKHRInitializer | null): VkAccelerationStructureGeometryInstancesDataKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureGeometryInstancesDataKHR: VkAccelerationStructureGeometryInstancesDataKHRConstructor;



  /**
   * Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure
   */
interface VkAccelerationStructureGeometryAabbsDataKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a device or host address to memory containing 'VkAabbPositionsKHR' structures containing position data for each axis-aligned bounding box in the geometry.
     */
    data: VkDeviceOrHostAddressConstKHR | null;

    /**
     *
     */
    stride: bigint | number;

}

declare interface VkAccelerationStructureGeometryAabbsDataKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a device or host address to memory containing 'VkAabbPositionsKHR' structures containing position data for each axis-aligned bounding box in the geometry.
     */
    data?: VkDeviceOrHostAddressConstKHR | null;

    /**
     *
     */
    stride?: bigint | number;
}

declare interface VkAccelerationStructureGeometryAabbsDataKHRConstructor {
  readonly prototype: VkAccelerationStructureGeometryAabbsDataKHR;
  new(param?: VkAccelerationStructureGeometryAabbsDataKHRInitializer | null): VkAccelerationStructureGeometryAabbsDataKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureGeometryAabbsDataKHR: VkAccelerationStructureGeometryAabbsDataKHRConstructor;



  /**
   * Structure specifying a triangle geometry in a bottom-level acceleration structure
   */
interface VkAccelerationStructureGeometryTrianglesDataKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the 'VkFormat' of each vertex element.
     */
    vertexFormat: VkFormat;

    /**
     * is a device or host address to memory containing vertex data for this geometry.
     */
    vertexData: VkDeviceOrHostAddressConstKHR | null;

    /**
     * is the stride in bytes between each vertex.
     */
    vertexStride: bigint | number;

    /**
     * is the highest index of a vertex that will be addressed by a build command using this structure.
     */
    maxVertex: number;

    /**
     * is the 'VkIndexType' of each index element.
     */
    indexType: VkIndexType;

    /**
     * is a device or host address to memory containing index data for this geometry.
     */
    indexData: VkDeviceOrHostAddressConstKHR | null;

    /**
     * is a device or host address to memory containing an optional reference to a 'VkTransformMatrixKHR' structure defining a transformation that should be applied to vertices in this geometry.
     */
    transformData: VkDeviceOrHostAddressConstKHR | null;

}

declare interface VkAccelerationStructureGeometryTrianglesDataKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the 'VkFormat' of each vertex element.
     */
    vertexFormat?: VkFormat;

    /**
     * is a device or host address to memory containing vertex data for this geometry.
     */
    vertexData?: VkDeviceOrHostAddressConstKHR | null;

    /**
     * is the stride in bytes between each vertex.
     */
    vertexStride?: bigint | number;

    /**
     * is the highest index of a vertex that will be addressed by a build command using this structure.
     */
    maxVertex?: number;

    /**
     * is the 'VkIndexType' of each index element.
     */
    indexType?: VkIndexType;

    /**
     * is a device or host address to memory containing index data for this geometry.
     */
    indexData?: VkDeviceOrHostAddressConstKHR | null;

    /**
     * is a device or host address to memory containing an optional reference to a 'VkTransformMatrixKHR' structure defining a transformation that should be applied to vertices in this geometry.
     */
    transformData?: VkDeviceOrHostAddressConstKHR | null;
}

declare interface VkAccelerationStructureGeometryTrianglesDataKHRConstructor {
  readonly prototype: VkAccelerationStructureGeometryTrianglesDataKHR;
  new(param?: VkAccelerationStructureGeometryTrianglesDataKHRInitializer | null): VkAccelerationStructureGeometryTrianglesDataKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureGeometryTrianglesDataKHR: VkAccelerationStructureGeometryTrianglesDataKHRConstructor;



  /**
   * Structure describing whether custom border colors can be supported by an implementation
   */
interface VkPhysicalDeviceCustomBorderColorFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports providing a 'borderColor' value with one of the following values at sampler creation time:
     */
    customBorderColors: boolean;

    /**
     * indicates that explicit formats are not required for custom border colors and the value of the 'format' member of the 'VkSamplerCustomBorderColorCreateInfoEXT' structure 'may' be 'VK_FORMAT_UNDEFINED'. If this feature bit is not set, applications 'must' provide the 'VkFormat' of the image view(s) being sampled by this sampler in the 'format' member of the 'VkSamplerCustomBorderColorCreateInfoEXT' structure.
     */
    customBorderColorWithoutFormat: boolean;

}

declare interface VkPhysicalDeviceCustomBorderColorFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports providing a 'borderColor' value with one of the following values at sampler creation time:
     */
    customBorderColors?: boolean;

    /**
     * indicates that explicit formats are not required for custom border colors and the value of the 'format' member of the 'VkSamplerCustomBorderColorCreateInfoEXT' structure 'may' be 'VK_FORMAT_UNDEFINED'. If this feature bit is not set, applications 'must' provide the 'VkFormat' of the image view(s) being sampled by this sampler in the 'format' member of the 'VkSamplerCustomBorderColorCreateInfoEXT' structure.
     */
    customBorderColorWithoutFormat?: boolean;
}

declare interface VkPhysicalDeviceCustomBorderColorFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceCustomBorderColorFeaturesEXT;
  new(param?: VkPhysicalDeviceCustomBorderColorFeaturesEXTInitializer | null): VkPhysicalDeviceCustomBorderColorFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceCustomBorderColorFeaturesEXT: VkPhysicalDeviceCustomBorderColorFeaturesEXTConstructor;



  /**
   * Structure describing whether custom border colors can be supported by an implementation
   */
interface VkPhysicalDeviceCustomBorderColorPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxCustomBorderColorSamplers: number;

}

declare interface VkPhysicalDeviceCustomBorderColorPropertiesEXTInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxCustomBorderColorSamplers?: number;
}

declare interface VkPhysicalDeviceCustomBorderColorPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceCustomBorderColorPropertiesEXT;
  new(param?: VkPhysicalDeviceCustomBorderColorPropertiesEXTInitializer | null): VkPhysicalDeviceCustomBorderColorPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceCustomBorderColorPropertiesEXT: VkPhysicalDeviceCustomBorderColorPropertiesEXTConstructor;



  /**
   * Structure specifying custom border color
   */
interface VkSamplerCustomBorderColorCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkClearColorValue' representing the desired custom sampler border color.
     */
    customBorderColor: VkClearColorValue | null;

    /**
     * is a 'VkFormat' representing the format of the sampled image view(s). This field may be 'VK_FORMAT_UNDEFINED' if the <<features-customBorderColorWithoutFormat,customBorderColorWithoutFormat>> feature is enabled.
     */
    format: VkFormat;

}

declare interface VkSamplerCustomBorderColorCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkClearColorValue' representing the desired custom sampler border color.
     */
    customBorderColor?: VkClearColorValue | null;

    /**
     * is a 'VkFormat' representing the format of the sampled image view(s). This field may be 'VK_FORMAT_UNDEFINED' if the <<features-customBorderColorWithoutFormat,customBorderColorWithoutFormat>> feature is enabled.
     */
    format?: VkFormat;
}

declare interface VkSamplerCustomBorderColorCreateInfoEXTConstructor {
  readonly prototype: VkSamplerCustomBorderColorCreateInfoEXT;
  new(param?: VkSamplerCustomBorderColorCreateInfoEXTInitializer | null): VkSamplerCustomBorderColorCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSamplerCustomBorderColorCreateInfoEXT: VkSamplerCustomBorderColorCreateInfoEXTConstructor;



  /**
   * Structure providing information about an active tool
   */
interface VkPhysicalDeviceToolPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a string containing the name of the tool.
     */
    readonly name: string | null;

    /**
     * is a string containing the version of the tool.
     */
    readonly version: string | null;

    /**
     * is a bitmask of 'VkToolPurposeFlagBitsEXT' which is populated with purposes supported by the tool.
     */
    readonly purposes: VkToolPurposeFlagBitsEXT;

    /**
     * is a string containing a description of the tool.
     */
    readonly description: string | null;

    /**
     * is a string that contains the name of the layer implementing the tool, if the tool is implemented in a layer - otherwise it 'may' be an empty string.
     */
    readonly layer: string | null;

}

declare interface VkPhysicalDeviceToolPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a string containing the name of the tool.
     */
    readonly name?: string | null;

    /**
     * is a string containing the version of the tool.
     */
    readonly version?: string | null;

    /**
     * is a bitmask of 'VkToolPurposeFlagBitsEXT' which is populated with purposes supported by the tool.
     */
    readonly purposes?: VkToolPurposeFlagBitsEXT;

    /**
     * is a string containing a description of the tool.
     */
    readonly description?: string | null;

    /**
     * is a string that contains the name of the layer implementing the tool, if the tool is implemented in a layer - otherwise it 'may' be an empty string.
     */
    readonly layer?: string | null;
}

declare interface VkPhysicalDeviceToolPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceToolPropertiesEXT;
  new(param?: VkPhysicalDeviceToolPropertiesEXTInitializer | null): VkPhysicalDeviceToolPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceToolPropertiesEXT: VkPhysicalDeviceToolPropertiesEXTConstructor;



  /**
   * Structure describing whether device coherent memory can be supported by an implementation
   */
interface VkPhysicalDeviceCoherentMemoryFeaturesAMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports <<VkMemoryPropertyFlagBits,device coherent memory>>.
     */
    deviceCoherentMemory: boolean;

}

declare interface VkPhysicalDeviceCoherentMemoryFeaturesAMDInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports <<VkMemoryPropertyFlagBits,device coherent memory>>.
     */
    deviceCoherentMemory?: boolean;
}

declare interface VkPhysicalDeviceCoherentMemoryFeaturesAMDConstructor {
  readonly prototype: VkPhysicalDeviceCoherentMemoryFeaturesAMD;
  new(param?: VkPhysicalDeviceCoherentMemoryFeaturesAMDInitializer | null): VkPhysicalDeviceCoherentMemoryFeaturesAMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceCoherentMemoryFeaturesAMD: VkPhysicalDeviceCoherentMemoryFeaturesAMDConstructor;



  /**
   * Structure used to pass compilation control flags to a pipeline
   */
interface VkPipelineCompilerControlCreateInfoAMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkPipelineCompilerControlFlagBitsAMD' affecting how the pipeline will be compiled.
     */
    compilerControlFlags: VkPipelineCompilerControlFlagBitsAMD;

}

declare interface VkPipelineCompilerControlCreateInfoAMDInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkPipelineCompilerControlFlagBitsAMD' affecting how the pipeline will be compiled.
     */
    compilerControlFlags?: VkPipelineCompilerControlFlagBitsAMD;
}

declare interface VkPipelineCompilerControlCreateInfoAMDConstructor {
  readonly prototype: VkPipelineCompilerControlCreateInfoAMD;
  new(param?: VkPipelineCompilerControlCreateInfoAMDInitializer | null): VkPipelineCompilerControlCreateInfoAMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineCompilerControlCreateInfoAMD: VkPipelineCompilerControlCreateInfoAMDConstructor;



  /**
   * Structure specifying physical device properties for functionality promoted to Vulkan 1.2
   */
interface VkPhysicalDeviceVulkan12Properties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly driverID: VkDriverId;

    /**
     *
     */
    readonly driverName: string | null;

    /**
     *
     */
    readonly driverInfo: string | null;

    /**
     *
     */
    readonly conformanceVersion: VkConformanceVersion | null;

    /**
     *
     */
    readonly denormBehaviorIndependence: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly roundingModeIndependence: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat16: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat32: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat64: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat16: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat32: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat64: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat16: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat32: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat64: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat16: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat32: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat64: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat16: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat32: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat64: boolean;

    /**
     *
     */
    readonly maxUpdateAfterBindDescriptorsInAllPools: number;

    /**
     *
     */
    readonly shaderUniformBufferArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderSampledImageArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderStorageBufferArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderStorageImageArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderInputAttachmentArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly robustBufferAccessUpdateAfterBind: boolean;

    /**
     *
     */
    readonly quadDivergentImplicitLod: boolean;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSamplers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindUniformBuffers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageBuffers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSampledImages: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageImages: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindInputAttachments: number;

    /**
     *
     */
    readonly maxPerStageUpdateAfterBindResources: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSamplers: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffers: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffers: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSampledImages: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageImages: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindInputAttachments: number;

    /**
     *
     */
    readonly supportedDepthResolveModes: VkResolveModeFlagBits;

    /**
     *
     */
    readonly supportedStencilResolveModes: VkResolveModeFlagBits;

    /**
     *
     */
    readonly independentResolveNone: boolean;

    /**
     *
     */
    readonly independentResolve: boolean;

    /**
     *
     */
    readonly filterMinmaxSingleComponentFormats: boolean;

    /**
     *
     */
    readonly filterMinmaxImageComponentMapping: boolean;

    /**
     *
     */
    readonly maxTimelineSemaphoreValueDifference: bigint | number;

    /**
     *
     */
    readonly framebufferIntegerColorSampleCounts: VkSampleCountFlagBits;

}

declare interface VkPhysicalDeviceVulkan12PropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly driverID?: VkDriverId;

    /**
     *
     */
    readonly driverName?: string | null;

    /**
     *
     */
    readonly driverInfo?: string | null;

    /**
     *
     */
    readonly conformanceVersion?: VkConformanceVersion | null;

    /**
     *
     */
    readonly denormBehaviorIndependence?: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly roundingModeIndependence?: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat16?: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat32?: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat64?: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat16?: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat32?: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat64?: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat16?: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat32?: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat64?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat16?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat32?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat64?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat16?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat32?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat64?: boolean;

    /**
     *
     */
    readonly maxUpdateAfterBindDescriptorsInAllPools?: number;

    /**
     *
     */
    readonly shaderUniformBufferArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderSampledImageArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderStorageBufferArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderStorageImageArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderInputAttachmentArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly robustBufferAccessUpdateAfterBind?: boolean;

    /**
     *
     */
    readonly quadDivergentImplicitLod?: boolean;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSamplers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindUniformBuffers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageBuffers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSampledImages?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageImages?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindInputAttachments?: number;

    /**
     *
     */
    readonly maxPerStageUpdateAfterBindResources?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSamplers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffersDynamic?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffersDynamic?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSampledImages?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageImages?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindInputAttachments?: number;

    /**
     *
     */
    readonly supportedDepthResolveModes?: VkResolveModeFlagBits;

    /**
     *
     */
    readonly supportedStencilResolveModes?: VkResolveModeFlagBits;

    /**
     *
     */
    readonly independentResolveNone?: boolean;

    /**
     *
     */
    readonly independentResolve?: boolean;

    /**
     *
     */
    readonly filterMinmaxSingleComponentFormats?: boolean;

    /**
     *
     */
    readonly filterMinmaxImageComponentMapping?: boolean;

    /**
     *
     */
    readonly maxTimelineSemaphoreValueDifference?: bigint | number;

    /**
     *
     */
    readonly framebufferIntegerColorSampleCounts?: VkSampleCountFlagBits;
}

declare interface VkPhysicalDeviceVulkan12PropertiesConstructor {
  readonly prototype: VkPhysicalDeviceVulkan12Properties;
  new(param?: VkPhysicalDeviceVulkan12PropertiesInitializer | null): VkPhysicalDeviceVulkan12Properties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVulkan12Properties: VkPhysicalDeviceVulkan12PropertiesConstructor;



  /**
   * Structure describing the Vulkan 1.2 features that can be supported by an implementation
   */
interface VkPhysicalDeviceVulkan12Features {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    samplerMirrorClampToEdge: boolean;

    /**
     *
     */
    drawIndirectCount: boolean;

    /**
     *
     */
    storageBuffer8BitAccess: boolean;

    /**
     *
     */
    uniformAndStorageBuffer8BitAccess: boolean;

    /**
     *
     */
    storagePushConstant8: boolean;

    /**
     *
     */
    shaderBufferInt64Atomics: boolean;

    /**
     *
     */
    shaderSharedInt64Atomics: boolean;

    /**
     *
     */
    shaderFloat16: boolean;

    /**
     *
     */
    shaderInt8: boolean;

    /**
     *
     */
    descriptorIndexing: boolean;

    /**
     *
     */
    shaderInputAttachmentArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderUniformBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderSampledImageArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderStorageBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderStorageImageArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderInputAttachmentArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    descriptorBindingUniformBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingSampledImageUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingStorageImageUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingStorageBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingUniformTexelBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingStorageTexelBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingUpdateUnusedWhilePending: boolean;

    /**
     *
     */
    descriptorBindingPartiallyBound: boolean;

    /**
     *
     */
    descriptorBindingVariableDescriptorCount: boolean;

    /**
     *
     */
    runtimeDescriptorArray: boolean;

    /**
     *
     */
    samplerFilterMinmax: boolean;

    /**
     *
     */
    scalarBlockLayout: boolean;

    /**
     *
     */
    imagelessFramebuffer: boolean;

    /**
     *
     */
    uniformBufferStandardLayout: boolean;

    /**
     *
     */
    shaderSubgroupExtendedTypes: boolean;

    /**
     *
     */
    separateDepthStencilLayouts: boolean;

    /**
     *
     */
    hostQueryReset: boolean;

    /**
     *
     */
    timelineSemaphore: boolean;

    /**
     *
     */
    bufferDeviceAddress: boolean;

    /**
     *
     */
    bufferDeviceAddressCaptureReplay: boolean;

    /**
     *
     */
    bufferDeviceAddressMultiDevice: boolean;

    /**
     *
     */
    vulkanMemoryModel: boolean;

    /**
     *
     */
    vulkanMemoryModelDeviceScope: boolean;

    /**
     *
     */
    vulkanMemoryModelAvailabilityVisibilityChains: boolean;

    /**
     * indicates whether the implementation supports the 'ShaderViewportIndex' SPIR-V capability enabling variables decorated with the 'ViewportIndex' built-in to be exported from vertex or tessellation evaluation shaders. If this feature is not enabled, the 'ViewportIndex' built-in decoration 'must' not be used on outputs in vertex or tessellation evaluation shaders.
     */
    shaderOutputViewportIndex: boolean;

    /**
     * indicates whether the implementation supports the 'ShaderLayer' SPIR-V capability enabling variables decorated with the 'Layer' built-in to be exported from vertex or tessellation evaluation shaders. If this feature is not enabled, the 'Layer' built-in decoration 'must' not be used on outputs in vertex or tessellation evaluation shaders.
     */
    shaderOutputLayer: boolean;

    /**
     *
     */
    subgroupBroadcastDynamicId: boolean;

}

declare interface VkPhysicalDeviceVulkan12FeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    samplerMirrorClampToEdge?: boolean;

    /**
     *
     */
    drawIndirectCount?: boolean;

    /**
     *
     */
    storageBuffer8BitAccess?: boolean;

    /**
     *
     */
    uniformAndStorageBuffer8BitAccess?: boolean;

    /**
     *
     */
    storagePushConstant8?: boolean;

    /**
     *
     */
    shaderBufferInt64Atomics?: boolean;

    /**
     *
     */
    shaderSharedInt64Atomics?: boolean;

    /**
     *
     */
    shaderFloat16?: boolean;

    /**
     *
     */
    shaderInt8?: boolean;

    /**
     *
     */
    descriptorIndexing?: boolean;

    /**
     *
     */
    shaderInputAttachmentArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderUniformBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderSampledImageArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderStorageBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderStorageImageArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderInputAttachmentArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    descriptorBindingUniformBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingSampledImageUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingStorageImageUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingStorageBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingUniformTexelBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingStorageTexelBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingUpdateUnusedWhilePending?: boolean;

    /**
     *
     */
    descriptorBindingPartiallyBound?: boolean;

    /**
     *
     */
    descriptorBindingVariableDescriptorCount?: boolean;

    /**
     *
     */
    runtimeDescriptorArray?: boolean;

    /**
     *
     */
    samplerFilterMinmax?: boolean;

    /**
     *
     */
    scalarBlockLayout?: boolean;

    /**
     *
     */
    imagelessFramebuffer?: boolean;

    /**
     *
     */
    uniformBufferStandardLayout?: boolean;

    /**
     *
     */
    shaderSubgroupExtendedTypes?: boolean;

    /**
     *
     */
    separateDepthStencilLayouts?: boolean;

    /**
     *
     */
    hostQueryReset?: boolean;

    /**
     *
     */
    timelineSemaphore?: boolean;

    /**
     *
     */
    bufferDeviceAddress?: boolean;

    /**
     *
     */
    bufferDeviceAddressCaptureReplay?: boolean;

    /**
     *
     */
    bufferDeviceAddressMultiDevice?: boolean;

    /**
     *
     */
    vulkanMemoryModel?: boolean;

    /**
     *
     */
    vulkanMemoryModelDeviceScope?: boolean;

    /**
     *
     */
    vulkanMemoryModelAvailabilityVisibilityChains?: boolean;

    /**
     * indicates whether the implementation supports the 'ShaderViewportIndex' SPIR-V capability enabling variables decorated with the 'ViewportIndex' built-in to be exported from vertex or tessellation evaluation shaders. If this feature is not enabled, the 'ViewportIndex' built-in decoration 'must' not be used on outputs in vertex or tessellation evaluation shaders.
     */
    shaderOutputViewportIndex?: boolean;

    /**
     * indicates whether the implementation supports the 'ShaderLayer' SPIR-V capability enabling variables decorated with the 'Layer' built-in to be exported from vertex or tessellation evaluation shaders. If this feature is not enabled, the 'Layer' built-in decoration 'must' not be used on outputs in vertex or tessellation evaluation shaders.
     */
    shaderOutputLayer?: boolean;

    /**
     *
     */
    subgroupBroadcastDynamicId?: boolean;
}

declare interface VkPhysicalDeviceVulkan12FeaturesConstructor {
  readonly prototype: VkPhysicalDeviceVulkan12Features;
  new(param?: VkPhysicalDeviceVulkan12FeaturesInitializer | null): VkPhysicalDeviceVulkan12Features;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVulkan12Features: VkPhysicalDeviceVulkan12FeaturesConstructor;



  /**
   * Structure specifying physical device properties for functionality promoted to Vulkan 1.1
   */
interface VkPhysicalDeviceVulkan11Properties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly deviceUUID: number[] | null;

    /**
     *
     */
    readonly driverUUID: number[] | null;

    /**
     *
     */
    readonly deviceLUID: number[] | null;

    /**
     *
     */
    readonly deviceNodeMask: number;

    /**
     *
     */
    readonly deviceLUIDValid: boolean;

    /**
     *
     */
    readonly subgroupSize: number;

    /**
     *
     */
    readonly subgroupSupportedStages: VkShaderStageFlagBits;

    /**
     *
     */
    readonly subgroupSupportedOperations: VkSubgroupFeatureFlagBits;

    /**
     *
     */
    readonly subgroupQuadOperationsInAllStages: boolean;

    /**
     *
     */
    readonly pointClippingBehavior: VkPointClippingBehavior;

    /**
     *
     */
    readonly maxMultiviewViewCount: number;

    /**
     *
     */
    readonly maxMultiviewInstanceIndex: number;

    /**
     *
     */
    readonly protectedNoFault: boolean;

    /**
     *
     */
    readonly maxPerSetDescriptors: number;

    /**
     *
     */
    readonly maxMemoryAllocationSize: bigint | number;

}

declare interface VkPhysicalDeviceVulkan11PropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly deviceUUID?: number[] | null;

    /**
     *
     */
    readonly driverUUID?: number[] | null;

    /**
     *
     */
    readonly deviceLUID?: number[] | null;

    /**
     *
     */
    readonly deviceNodeMask?: number;

    /**
     *
     */
    readonly deviceLUIDValid?: boolean;

    /**
     *
     */
    readonly subgroupSize?: number;

    /**
     *
     */
    readonly subgroupSupportedStages?: VkShaderStageFlagBits;

    /**
     *
     */
    readonly subgroupSupportedOperations?: VkSubgroupFeatureFlagBits;

    /**
     *
     */
    readonly subgroupQuadOperationsInAllStages?: boolean;

    /**
     *
     */
    readonly pointClippingBehavior?: VkPointClippingBehavior;

    /**
     *
     */
    readonly maxMultiviewViewCount?: number;

    /**
     *
     */
    readonly maxMultiviewInstanceIndex?: number;

    /**
     *
     */
    readonly protectedNoFault?: boolean;

    /**
     *
     */
    readonly maxPerSetDescriptors?: number;

    /**
     *
     */
    readonly maxMemoryAllocationSize?: bigint | number;
}

declare interface VkPhysicalDeviceVulkan11PropertiesConstructor {
  readonly prototype: VkPhysicalDeviceVulkan11Properties;
  new(param?: VkPhysicalDeviceVulkan11PropertiesInitializer | null): VkPhysicalDeviceVulkan11Properties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVulkan11Properties: VkPhysicalDeviceVulkan11PropertiesConstructor;



  /**
   * Structure describing the Vulkan 1.1 features that can be supported by an implementation
   */
interface VkPhysicalDeviceVulkan11Features {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    storageBuffer16BitAccess: boolean;

    /**
     *
     */
    uniformAndStorageBuffer16BitAccess: boolean;

    /**
     *
     */
    storagePushConstant16: boolean;

    /**
     *
     */
    storageInputOutput16: boolean;

    /**
     *
     */
    multiview: boolean;

    /**
     *
     */
    multiviewGeometryShader: boolean;

    /**
     *
     */
    multiviewTessellationShader: boolean;

    /**
     *
     */
    variablePointersStorageBuffer: boolean;

    /**
     *
     */
    variablePointers: boolean;

    /**
     *
     */
    protectedMemory: boolean;

    /**
     *
     */
    samplerYcbcrConversion: boolean;

    /**
     *
     */
    shaderDrawParameters: boolean;

}

declare interface VkPhysicalDeviceVulkan11FeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    storageBuffer16BitAccess?: boolean;

    /**
     *
     */
    uniformAndStorageBuffer16BitAccess?: boolean;

    /**
     *
     */
    storagePushConstant16?: boolean;

    /**
     *
     */
    storageInputOutput16?: boolean;

    /**
     *
     */
    multiview?: boolean;

    /**
     *
     */
    multiviewGeometryShader?: boolean;

    /**
     *
     */
    multiviewTessellationShader?: boolean;

    /**
     *
     */
    variablePointersStorageBuffer?: boolean;

    /**
     *
     */
    variablePointers?: boolean;

    /**
     *
     */
    protectedMemory?: boolean;

    /**
     *
     */
    samplerYcbcrConversion?: boolean;

    /**
     *
     */
    shaderDrawParameters?: boolean;
}

declare interface VkPhysicalDeviceVulkan11FeaturesConstructor {
  readonly prototype: VkPhysicalDeviceVulkan11Features;
  new(param?: VkPhysicalDeviceVulkan11FeaturesInitializer | null): VkPhysicalDeviceVulkan11Features;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVulkan11Features: VkPhysicalDeviceVulkan11FeaturesConstructor;



  /**
   * Structure describing whether pipeline cache control can be supported by an implementation
   */
interface VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    pipelineCreationCacheControl: boolean;

}

declare interface VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    pipelineCreationCacheControl?: boolean;
}

declare interface VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT;
  new(param?: VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTInitializer | null): VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT: VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline line rasterization state
   */
interface VkPipelineRasterizationLineStateCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkLineRasterizationModeEXT' value selecting the style of line rasterization.
     */
    lineRasterizationMode: VkLineRasterizationModeEXT;

    /**
     * enables <<primsrast-lines-stipple, stippled line rasterization>>.
     */
    stippledLineEnable: boolean;

    /**
     * is the repeat factor used in stippled line rasterization.
     */
    lineStippleFactor: number;

    /**
     * is the bit pattern used in stippled line rasterization.
     */
    lineStipplePattern: number;

}

declare interface VkPipelineRasterizationLineStateCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkLineRasterizationModeEXT' value selecting the style of line rasterization.
     */
    lineRasterizationMode?: VkLineRasterizationModeEXT;

    /**
     * enables <<primsrast-lines-stipple, stippled line rasterization>>.
     */
    stippledLineEnable?: boolean;

    /**
     * is the repeat factor used in stippled line rasterization.
     */
    lineStippleFactor?: number;

    /**
     * is the bit pattern used in stippled line rasterization.
     */
    lineStipplePattern?: number;
}

declare interface VkPipelineRasterizationLineStateCreateInfoEXTConstructor {
  readonly prototype: VkPipelineRasterizationLineStateCreateInfoEXT;
  new(param?: VkPipelineRasterizationLineStateCreateInfoEXTInitializer | null): VkPipelineRasterizationLineStateCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineRasterizationLineStateCreateInfoEXT: VkPipelineRasterizationLineStateCreateInfoEXTConstructor;



  /**
   * Structure describing line rasterization properties supported by an implementation
   */
interface VkPhysicalDeviceLineRasterizationPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the number of bits of subpixel precision in framebuffer coordinates [eq]#x~f~# and [eq]#y~f~# when rasterizing <<primsrast-lines,line segments>>.
     */
    readonly lineSubPixelPrecisionBits: number;

}

declare interface VkPhysicalDeviceLineRasterizationPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the number of bits of subpixel precision in framebuffer coordinates [eq]#x~f~# and [eq]#y~f~# when rasterizing <<primsrast-lines,line segments>>.
     */
    readonly lineSubPixelPrecisionBits?: number;
}

declare interface VkPhysicalDeviceLineRasterizationPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceLineRasterizationPropertiesEXT;
  new(param?: VkPhysicalDeviceLineRasterizationPropertiesEXTInitializer | null): VkPhysicalDeviceLineRasterizationPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceLineRasterizationPropertiesEXT: VkPhysicalDeviceLineRasterizationPropertiesEXTConstructor;



  /**
   * Structure describing the line rasterization features that can be supported by an implementation
   */
interface VkPhysicalDeviceLineRasterizationFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports <<primsrast-lines,rectangular line rasterization>>.
     */
    rectangularLines: boolean;

    /**
     * indicates whether the implementation supports <<primsrast-lines-bresenham,Bresenham-style line rasterization>>.
     */
    bresenhamLines: boolean;

    /**
     * indicates whether the implementation supports <<primsrast-lines-smooth,smooth line rasterization>>.
     */
    smoothLines: boolean;

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT' lines, or with 'VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT' lines if 'VkPhysicalDeviceLimits'::'strictLines' is 'VK_TRUE'.
     */
    stippledRectangularLines: boolean;

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT' lines.
     */
    stippledBresenhamLines: boolean;

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT' lines.
     */
    stippledSmoothLines: boolean;

}

declare interface VkPhysicalDeviceLineRasterizationFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports <<primsrast-lines,rectangular line rasterization>>.
     */
    rectangularLines?: boolean;

    /**
     * indicates whether the implementation supports <<primsrast-lines-bresenham,Bresenham-style line rasterization>>.
     */
    bresenhamLines?: boolean;

    /**
     * indicates whether the implementation supports <<primsrast-lines-smooth,smooth line rasterization>>.
     */
    smoothLines?: boolean;

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT' lines, or with 'VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT' lines if 'VkPhysicalDeviceLimits'::'strictLines' is 'VK_TRUE'.
     */
    stippledRectangularLines?: boolean;

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT' lines.
     */
    stippledBresenhamLines?: boolean;

    /**
     * indicates whether the implementation supports <<primsrast-lines-stipple,stippled line rasterization>> with 'VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT' lines.
     */
    stippledSmoothLines?: boolean;
}

declare interface VkPhysicalDeviceLineRasterizationFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceLineRasterizationFeaturesEXT;
  new(param?: VkPhysicalDeviceLineRasterizationFeaturesEXTInitializer | null): VkPhysicalDeviceLineRasterizationFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceLineRasterizationFeaturesEXT: VkPhysicalDeviceLineRasterizationFeaturesEXTConstructor;



  /**
   * 
   */
interface VkDeviceMemoryOpaqueCaptureAddressInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    memory: VkDeviceMemory | null;

}

declare interface VkDeviceMemoryOpaqueCaptureAddressInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    memory?: VkDeviceMemory | null;
}

declare interface VkDeviceMemoryOpaqueCaptureAddressInfoKHRConstructor {
  readonly prototype: VkDeviceMemoryOpaqueCaptureAddressInfoKHR;
  new(param?: VkDeviceMemoryOpaqueCaptureAddressInfoKHRInitializer | null): VkDeviceMemoryOpaqueCaptureAddressInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceMemoryOpaqueCaptureAddressInfoKHR: VkDeviceMemoryOpaqueCaptureAddressInfoKHRConstructor;



  /**
   * Structure specifying the memory object to query an address for
   */
interface VkDeviceMemoryOpaqueCaptureAddressInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    memory: VkDeviceMemory | null;

}

declare interface VkDeviceMemoryOpaqueCaptureAddressInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    memory?: VkDeviceMemory | null;
}

declare interface VkDeviceMemoryOpaqueCaptureAddressInfoConstructor {
  readonly prototype: VkDeviceMemoryOpaqueCaptureAddressInfo;
  new(param?: VkDeviceMemoryOpaqueCaptureAddressInfoInitializer | null): VkDeviceMemoryOpaqueCaptureAddressInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceMemoryOpaqueCaptureAddressInfo: VkDeviceMemoryOpaqueCaptureAddressInfoConstructor;



  /**
   * 
   */
interface VkMemoryOpaqueCaptureAddressAllocateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    opaqueCaptureAddress: bigint | number;

}

declare interface VkMemoryOpaqueCaptureAddressAllocateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    opaqueCaptureAddress?: bigint | number;
}

declare interface VkMemoryOpaqueCaptureAddressAllocateInfoKHRConstructor {
  readonly prototype: VkMemoryOpaqueCaptureAddressAllocateInfoKHR;
  new(param?: VkMemoryOpaqueCaptureAddressAllocateInfoKHRInitializer | null): VkMemoryOpaqueCaptureAddressAllocateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryOpaqueCaptureAddressAllocateInfoKHR: VkMemoryOpaqueCaptureAddressAllocateInfoKHRConstructor;



  /**
   * Request a specific address for a memory allocation
   */
interface VkMemoryOpaqueCaptureAddressAllocateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    opaqueCaptureAddress: bigint | number;

}

declare interface VkMemoryOpaqueCaptureAddressAllocateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    opaqueCaptureAddress?: bigint | number;
}

declare interface VkMemoryOpaqueCaptureAddressAllocateInfoConstructor {
  readonly prototype: VkMemoryOpaqueCaptureAddressAllocateInfo;
  new(param?: VkMemoryOpaqueCaptureAddressAllocateInfoInitializer | null): VkMemoryOpaqueCaptureAddressAllocateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryOpaqueCaptureAddressAllocateInfo: VkMemoryOpaqueCaptureAddressAllocateInfoConstructor;



  /**
   * Structure specifying the required subgroup size of a newly created pipeline shader stage
   */
interface VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a number value that specifies the required subgroup size for the newly created pipeline shader stage.
     */
    readonly requiredSubgroupSize: number;

}

declare interface VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a number value that specifies the required subgroup size for the newly created pipeline shader stage.
     */
    readonly requiredSubgroupSize?: number;
}

declare interface VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTConstructor {
  readonly prototype: VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;
  new(param?: VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTInitializer | null): VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT: VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTConstructor;



  /**
   * Structure describing the control subgroup size properties of an implementation
   */
interface VkPhysicalDeviceSubgroupSizeControlPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the minimum subgroup size supported by this device. 'minSubgroupSize' is at least one if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'. 'minSubgroupSize' is a power-of-two. 'minSubgroupSize' is less than or equal to 'maxSubgroupSize'. 'minSubgroupSize' is less than or equal to <<limits-subgroup-size,subgroupSize>>.
     */
    readonly minSubgroupSize: number;

    /**
     * is the maximum subgroup size supported by this device. 'maxSubgroupSize' is at least one if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'. 'maxSubgroupSize' is a power-of-two. 'maxSubgroupSize' is greater than or equal to 'minSubgroupSize'. 'maxSubgroupSize' is greater than or equal to <<limits-subgroup-size,subgroupSize>>.
     */
    readonly maxSubgroupSize: number;

    /**
     * is the maximum number of subgroups supported by the implementation within a workgroup.
     */
    readonly maxComputeWorkgroupSubgroups: number;

    /**
     * is a bitfield of what shader stages support having a required subgroup size specified.
     */
    readonly requiredSubgroupSizeStages: VkShaderStageFlagBits;

}

declare interface VkPhysicalDeviceSubgroupSizeControlPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the minimum subgroup size supported by this device. 'minSubgroupSize' is at least one if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'. 'minSubgroupSize' is a power-of-two. 'minSubgroupSize' is less than or equal to 'maxSubgroupSize'. 'minSubgroupSize' is less than or equal to <<limits-subgroup-size,subgroupSize>>.
     */
    readonly minSubgroupSize?: number;

    /**
     * is the maximum subgroup size supported by this device. 'maxSubgroupSize' is at least one if any of the physical device's queues support 'VK_QUEUE_GRAPHICS_BIT' or 'VK_QUEUE_COMPUTE_BIT'. 'maxSubgroupSize' is a power-of-two. 'maxSubgroupSize' is greater than or equal to 'minSubgroupSize'. 'maxSubgroupSize' is greater than or equal to <<limits-subgroup-size,subgroupSize>>.
     */
    readonly maxSubgroupSize?: number;

    /**
     * is the maximum number of subgroups supported by the implementation within a workgroup.
     */
    readonly maxComputeWorkgroupSubgroups?: number;

    /**
     * is a bitfield of what shader stages support having a required subgroup size specified.
     */
    readonly requiredSubgroupSizeStages?: VkShaderStageFlagBits;
}

declare interface VkPhysicalDeviceSubgroupSizeControlPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceSubgroupSizeControlPropertiesEXT;
  new(param?: VkPhysicalDeviceSubgroupSizeControlPropertiesEXTInitializer | null): VkPhysicalDeviceSubgroupSizeControlPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSubgroupSizeControlPropertiesEXT: VkPhysicalDeviceSubgroupSizeControlPropertiesEXTConstructor;



  /**
   * Structure describing the subgroup size control features that can be supported by an implementation
   */
interface VkPhysicalDeviceSubgroupSizeControlFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports controlling shader subgroup sizes via the 'VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT' flag and the 'VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT' structure.
     */
    subgroupSizeControl: boolean;

    /**
     * indicates whether the implementation supports requiring full subgroups in compute shaders via the 'VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT' flag.
     */
    computeFullSubgroups: boolean;

}

declare interface VkPhysicalDeviceSubgroupSizeControlFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports controlling shader subgroup sizes via the 'VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT' flag and the 'VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT' structure.
     */
    subgroupSizeControl?: boolean;

    /**
     * indicates whether the implementation supports requiring full subgroups in compute shaders via the 'VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT' flag.
     */
    computeFullSubgroups?: boolean;
}

declare interface VkPhysicalDeviceSubgroupSizeControlFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceSubgroupSizeControlFeaturesEXT;
  new(param?: VkPhysicalDeviceSubgroupSizeControlFeaturesEXTInitializer | null): VkPhysicalDeviceSubgroupSizeControlFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSubgroupSizeControlFeaturesEXT: VkPhysicalDeviceSubgroupSizeControlFeaturesEXTConstructor;



  /**
   * Structure describing the texel buffer alignment requirements supported by an implementation
   */
interface VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a byte alignment that is sufficient for a storage texel buffer of any format.
     */
    readonly storageTexelBufferOffsetAlignmentBytes: bigint | number;

    /**
     * indicates whether single texel alignment is sufficient for a storage texel buffer of any format.
     */
    readonly storageTexelBufferOffsetSingleTexelAlignment: boolean;

    /**
     * is a byte alignment that is sufficient for a uniform texel buffer of any format.
     */
    readonly uniformTexelBufferOffsetAlignmentBytes: bigint | number;

    /**
     * indicates whether single texel alignment is sufficient for a uniform texel buffer of any format.
     */
    readonly uniformTexelBufferOffsetSingleTexelAlignment: boolean;

}

declare interface VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a byte alignment that is sufficient for a storage texel buffer of any format.
     */
    readonly storageTexelBufferOffsetAlignmentBytes?: bigint | number;

    /**
     * indicates whether single texel alignment is sufficient for a storage texel buffer of any format.
     */
    readonly storageTexelBufferOffsetSingleTexelAlignment?: boolean;

    /**
     * is a byte alignment that is sufficient for a uniform texel buffer of any format.
     */
    readonly uniformTexelBufferOffsetAlignmentBytes?: bigint | number;

    /**
     * indicates whether single texel alignment is sufficient for a uniform texel buffer of any format.
     */
    readonly uniformTexelBufferOffsetSingleTexelAlignment?: boolean;
}

declare interface VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT;
  new(param?: VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTInitializer | null): VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT: VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTConstructor;



  /**
   * Structure describing the texel buffer alignment features that can be supported by an implementation
   */
interface VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation uses more specific alignment requirements advertised in 'VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT' rather than 'VkPhysicalDeviceLimits'::'minTexelBufferOffsetAlignment'.
     */
    texelBufferAlignment: boolean;

}

declare interface VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation uses more specific alignment requirements advertised in 'VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT' rather than 'VkPhysicalDeviceLimits'::'minTexelBufferOffsetAlignment'.
     */
    texelBufferAlignment?: boolean;
}

declare interface VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT;
  new(param?: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTInitializer | null): VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTConstructor;



  /**
   * Structure describing the shader demote to helper invocations features that can be supported by an implementation
   */
interface VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderDemoteToHelperInvocation: boolean;

}

declare interface VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderDemoteToHelperInvocation?: boolean;
}

declare interface VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;
  new(param?: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTInitializer | null): VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTConstructor;



  /**
   * Structure describing the textual form of a pipeline executable internal representation
   */
interface VkPipelineExecutableInternalRepresentationKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     *
     */
    readonly name: string | null;

    /**
     *
     */
    readonly description: string | null;

    /**
     * specifies whether the returned data is text or opaque data. If 'isText' is 'VK_TRUE' then the data returned in 'pData' is text and is guaranteed to be a string.
     */
    readonly isText: boolean;

    /**
     * is a number related to the size, in bytes, of the internal representation data, as described below.
     */
    readonly dataSize: bigint | number;

    /**
     * is either <i>null</i> or a reference to an block of data into which the implementation will write the textual form of the internal representation.
     */
    readonly pData: ArrayBuffer | null;

}

declare interface VkPipelineExecutableInternalRepresentationKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly name?: string | null;

    /**
     *
     */
    readonly description?: string | null;

    /**
     * specifies whether the returned data is text or opaque data. If 'isText' is 'VK_TRUE' then the data returned in 'pData' is text and is guaranteed to be a string.
     */
    readonly isText?: boolean;

    /**
     * is a number related to the size, in bytes, of the internal representation data, as described below.
     */
    readonly dataSize?: bigint | number;

    /**
     * is either <i>null</i> or a reference to an block of data into which the implementation will write the textual form of the internal representation.
     */
    readonly pData?: ArrayBuffer | null;
}

declare interface VkPipelineExecutableInternalRepresentationKHRConstructor {
  readonly prototype: VkPipelineExecutableInternalRepresentationKHR;
  new(param?: VkPipelineExecutableInternalRepresentationKHRInitializer | null): VkPipelineExecutableInternalRepresentationKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineExecutableInternalRepresentationKHR: VkPipelineExecutableInternalRepresentationKHRConstructor;



  /**
   * Structure describing a compile-time pipeline executable statistic
   */
interface VkPipelineExecutableStatisticKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     *
     */
    readonly name: string | null;

    /**
     *
     */
    readonly description: string | null;

    /**
     * is a 'VkPipelineExecutableStatisticFormatKHR' value specifying the format of the data found in 'value'.
     */
    readonly format: VkPipelineExecutableStatisticFormatKHR;

    /**
     * is the value of this statistic.
     */
    readonly value: VkPipelineExecutableStatisticValueKHR | null;

}

declare interface VkPipelineExecutableStatisticKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly name?: string | null;

    /**
     *
     */
    readonly description?: string | null;

    /**
     * is a 'VkPipelineExecutableStatisticFormatKHR' value specifying the format of the data found in 'value'.
     */
    readonly format?: VkPipelineExecutableStatisticFormatKHR;

    /**
     * is the value of this statistic.
     */
    readonly value?: VkPipelineExecutableStatisticValueKHR | null;
}

declare interface VkPipelineExecutableStatisticKHRConstructor {
  readonly prototype: VkPipelineExecutableStatisticKHR;
  new(param?: VkPipelineExecutableStatisticKHRInitializer | null): VkPipelineExecutableStatisticKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineExecutableStatisticKHR: VkPipelineExecutableStatisticKHRConstructor;



  /**
   * Structure describing a pipeline executable to query for associated statistics or internal representations
   */
interface VkPipelineExecutableInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the pipeline to query.
     */
    pipeline: VkPipeline | null;

    /**
     * is the index of the executable to query in the array of executable properties returned by 'vkGetPipelineExecutablePropertiesKHR'.
     */
    executableIndex: number;

}

declare interface VkPipelineExecutableInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the pipeline to query.
     */
    pipeline?: VkPipeline | null;

    /**
     * is the index of the executable to query in the array of executable properties returned by 'vkGetPipelineExecutablePropertiesKHR'.
     */
    executableIndex?: number;
}

declare interface VkPipelineExecutableInfoKHRConstructor {
  readonly prototype: VkPipelineExecutableInfoKHR;
  new(param?: VkPipelineExecutableInfoKHRInitializer | null): VkPipelineExecutableInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineExecutableInfoKHR: VkPipelineExecutableInfoKHRConstructor;



  /**
   * Structure describing a pipeline executable
   */
interface VkPipelineExecutablePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a bitmask of 'VkShaderStageFlagBits' indicating which shader stages (if any) were principally used as inputs to compile this pipeline executable.
     */
    readonly stages: VkShaderStageFlagBits;

    /**
     *
     */
    readonly name: string | null;

    /**
     *
     */
    readonly description: string | null;

    /**
     * is the subgroup size with which this executable is dispatched.
     */
    readonly subgroupSize: number;

}

declare interface VkPipelineExecutablePropertiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a bitmask of 'VkShaderStageFlagBits' indicating which shader stages (if any) were principally used as inputs to compile this pipeline executable.
     */
    readonly stages?: VkShaderStageFlagBits;

    /**
     *
     */
    readonly name?: string | null;

    /**
     *
     */
    readonly description?: string | null;

    /**
     * is the subgroup size with which this executable is dispatched.
     */
    readonly subgroupSize?: number;
}

declare interface VkPipelineExecutablePropertiesKHRConstructor {
  readonly prototype: VkPipelineExecutablePropertiesKHR;
  new(param?: VkPipelineExecutablePropertiesKHRInitializer | null): VkPipelineExecutablePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineExecutablePropertiesKHR: VkPipelineExecutablePropertiesKHRConstructor;



  /**
   * Structure describing a pipeline
   */
interface VkPipelineInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkPipeline' handle.
     */
    pipeline: VkPipeline | null;

}

declare interface VkPipelineInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkPipeline' handle.
     */
    pipeline?: VkPipeline | null;
}

declare interface VkPipelineInfoKHRConstructor {
  readonly prototype: VkPipelineInfoKHR;
  new(param?: VkPipelineInfoKHRInitializer | null): VkPipelineInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineInfoKHR: VkPipelineInfoKHRConstructor;



  /**
   * Structure describing whether pipeline executable properties are available
   */
interface VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports reporting properties and statistics about the executables associated with a compiled pipeline.
     */
    pipelineExecutableInfo: boolean;

}

declare interface VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports reporting properties and statistics about the executables associated with a compiled pipeline.
     */
    pipelineExecutableInfo?: boolean;
}

declare interface VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
  new(param?: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRInitializer | null): VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHRConstructor;



  /**
   * 
   */
interface VkAttachmentDescriptionStencilLayoutKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    stencilInitialLayout: VkImageLayout;

    /**
     *
     */
    stencilFinalLayout: VkImageLayout;

}

declare interface VkAttachmentDescriptionStencilLayoutKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    stencilInitialLayout?: VkImageLayout;

    /**
     *
     */
    stencilFinalLayout?: VkImageLayout;
}

declare interface VkAttachmentDescriptionStencilLayoutKHRConstructor {
  readonly prototype: VkAttachmentDescriptionStencilLayoutKHR;
  new(param?: VkAttachmentDescriptionStencilLayoutKHRInitializer | null): VkAttachmentDescriptionStencilLayoutKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentDescriptionStencilLayoutKHR: VkAttachmentDescriptionStencilLayoutKHRConstructor;



  /**
   * Structure specifying an attachment description
   */
interface VkAttachmentDescriptionStencilLayout {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    stencilInitialLayout: VkImageLayout;

    /**
     *
     */
    stencilFinalLayout: VkImageLayout;

}

declare interface VkAttachmentDescriptionStencilLayoutInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    stencilInitialLayout?: VkImageLayout;

    /**
     *
     */
    stencilFinalLayout?: VkImageLayout;
}

declare interface VkAttachmentDescriptionStencilLayoutConstructor {
  readonly prototype: VkAttachmentDescriptionStencilLayout;
  new(param?: VkAttachmentDescriptionStencilLayoutInitializer | null): VkAttachmentDescriptionStencilLayout;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentDescriptionStencilLayout: VkAttachmentDescriptionStencilLayoutConstructor;



  /**
   * 
   */
interface VkAttachmentReferenceStencilLayoutKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    stencilLayout: VkImageLayout;

}

declare interface VkAttachmentReferenceStencilLayoutKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    stencilLayout?: VkImageLayout;
}

declare interface VkAttachmentReferenceStencilLayoutKHRConstructor {
  readonly prototype: VkAttachmentReferenceStencilLayoutKHR;
  new(param?: VkAttachmentReferenceStencilLayoutKHRInitializer | null): VkAttachmentReferenceStencilLayoutKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentReferenceStencilLayoutKHR: VkAttachmentReferenceStencilLayoutKHRConstructor;



  /**
   * Structure specifying an attachment description
   */
interface VkAttachmentReferenceStencilLayout {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    stencilLayout: VkImageLayout;

}

declare interface VkAttachmentReferenceStencilLayoutInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    stencilLayout?: VkImageLayout;
}

declare interface VkAttachmentReferenceStencilLayoutConstructor {
  readonly prototype: VkAttachmentReferenceStencilLayout;
  new(param?: VkAttachmentReferenceStencilLayoutInitializer | null): VkAttachmentReferenceStencilLayout;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentReferenceStencilLayout: VkAttachmentReferenceStencilLayoutConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    separateDepthStencilLayouts: boolean;

}

declare interface VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    separateDepthStencilLayouts?: boolean;
}

declare interface VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR;
  new(param?: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHRInitializer | null): VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHRConstructor;



  /**
   * Structure describing whether the implementation can do depth and stencil image barriers separately
   */
interface VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    separateDepthStencilLayouts: boolean;

}

declare interface VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    separateDepthStencilLayouts?: boolean;
}

declare interface VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
  new(param?: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesInitializer | null): VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesConstructor;



  /**
   * Structure describing fragment shader interlock features that can be supported by an implementation
   */
interface VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    fragmentShaderSampleInterlock: boolean;

    /**
     *
     */
    fragmentShaderPixelInterlock: boolean;

    /**
     *
     */
    fragmentShaderShadingRateInterlock: boolean;

}

declare interface VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    fragmentShaderSampleInterlock?: boolean;

    /**
     *
     */
    fragmentShaderPixelInterlock?: boolean;

    /**
     *
     */
    fragmentShaderShadingRateInterlock?: boolean;
}

declare interface VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT;
  new(param?: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTInitializer | null): VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTConstructor;



  /**
   * Structure describing the shader SM Builtins features that can be supported by an implementation
   */
interface VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports the SPIR-V 'ShaderSMBuiltinsNV' capability.
     */
    shaderSMBuiltins: boolean;

}

declare interface VkPhysicalDeviceShaderSMBuiltinsFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports the SPIR-V 'ShaderSMBuiltinsNV' capability.
     */
    shaderSMBuiltins?: boolean;
}

declare interface VkPhysicalDeviceShaderSMBuiltinsFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceShaderSMBuiltinsFeaturesNV;
  new(param?: VkPhysicalDeviceShaderSMBuiltinsFeaturesNVInitializer | null): VkPhysicalDeviceShaderSMBuiltinsFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderSMBuiltinsFeaturesNV: VkPhysicalDeviceShaderSMBuiltinsFeaturesNVConstructor;



  /**
   * Structure describing shader SM Builtins properties supported by an implementation
   */
interface VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the number of SMs on the device.
     */
    readonly shaderSMCount: number;

    /**
     * is the maximum number of simultaneously executing warps on an SM.
     */
    readonly shaderWarpsPerSM: number;

}

declare interface VkPhysicalDeviceShaderSMBuiltinsPropertiesNVInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the number of SMs on the device.
     */
    readonly shaderSMCount?: number;

    /**
     * is the maximum number of simultaneously executing warps on an SM.
     */
    readonly shaderWarpsPerSM?: number;
}

declare interface VkPhysicalDeviceShaderSMBuiltinsPropertiesNVConstructor {
  readonly prototype: VkPhysicalDeviceShaderSMBuiltinsPropertiesNV;
  new(param?: VkPhysicalDeviceShaderSMBuiltinsPropertiesNVInitializer | null): VkPhysicalDeviceShaderSMBuiltinsPropertiesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderSMBuiltinsPropertiesNV: VkPhysicalDeviceShaderSMBuiltinsPropertiesNVConstructor;



  /**
   * Structure describing whether uint8 index type can be used
   */
interface VkPhysicalDeviceIndexTypeUint8FeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that 'VK_INDEX_TYPE_UINT8_EXT' can be used with 'vkCmdBindIndexBuffer'.
     */
    indexTypeUint8: boolean;

}

declare interface VkPhysicalDeviceIndexTypeUint8FeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that 'VK_INDEX_TYPE_UINT8_EXT' can be used with 'vkCmdBindIndexBuffer'.
     */
    indexTypeUint8?: boolean;
}

declare interface VkPhysicalDeviceIndexTypeUint8FeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceIndexTypeUint8FeaturesEXT;
  new(param?: VkPhysicalDeviceIndexTypeUint8FeaturesEXTInitializer | null): VkPhysicalDeviceIndexTypeUint8FeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceIndexTypeUint8FeaturesEXT: VkPhysicalDeviceIndexTypeUint8FeaturesEXTConstructor;



  /**
   * Structure describing features supported by VK_KHR_shader_clock
   */
interface VkPhysicalDeviceShaderClockFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * indicates whether shaders 'can' perform 'Subgroup' scoped clock reads.
     */
    shaderSubgroupClock: boolean;

    /**
     * indicates whether shaders 'can' perform 'Device' scoped clock reads.
     */
    shaderDeviceClock: boolean;

}

declare interface VkPhysicalDeviceShaderClockFeaturesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * indicates whether shaders 'can' perform 'Subgroup' scoped clock reads.
     */
    shaderSubgroupClock?: boolean;

    /**
     * indicates whether shaders 'can' perform 'Device' scoped clock reads.
     */
    shaderDeviceClock?: boolean;
}

declare interface VkPhysicalDeviceShaderClockFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceShaderClockFeaturesKHR;
  new(param?: VkPhysicalDeviceShaderClockFeaturesKHRInitializer | null): VkPhysicalDeviceShaderClockFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderClockFeaturesKHR: VkPhysicalDeviceShaderClockFeaturesKHRConstructor;



  /**
   * Acquire a configuration to capture performance data
   */
interface VkPerformanceConfigurationAcquireInfoINTEL {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is one of the 'VkPerformanceConfigurationTypeINTEL' type of performance configuration that will be acquired.
     */
    type: VkPerformanceConfigurationTypeINTEL;

}

declare interface VkPerformanceConfigurationAcquireInfoINTELInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is one of the 'VkPerformanceConfigurationTypeINTEL' type of performance configuration that will be acquired.
     */
    type?: VkPerformanceConfigurationTypeINTEL;
}

declare interface VkPerformanceConfigurationAcquireInfoINTELConstructor {
  readonly prototype: VkPerformanceConfigurationAcquireInfoINTEL;
  new(param?: VkPerformanceConfigurationAcquireInfoINTELInitializer | null): VkPerformanceConfigurationAcquireInfoINTEL;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPerformanceConfigurationAcquireInfoINTEL: VkPerformanceConfigurationAcquireInfoINTELConstructor;



  /**
   * Performance override info
   */
interface VkPerformanceOverrideInfoINTEL {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * is the particular 'VkPerformanceOverrideTypeINTEL' to set.
     */
    type: VkPerformanceOverrideTypeINTEL;

    /**
     * defines whether the override is enabled.
     */
    enable: boolean;

    /**
     * is a potential required parameter for the override.
     */
    parameter: bigint | number;

}

declare interface VkPerformanceOverrideInfoINTELInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * is the particular 'VkPerformanceOverrideTypeINTEL' to set.
     */
    type?: VkPerformanceOverrideTypeINTEL;

    /**
     * defines whether the override is enabled.
     */
    enable?: boolean;

    /**
     * is a potential required parameter for the override.
     */
    parameter?: bigint | number;
}

declare interface VkPerformanceOverrideInfoINTELConstructor {
  readonly prototype: VkPerformanceOverrideInfoINTEL;
  new(param?: VkPerformanceOverrideInfoINTELInitializer | null): VkPerformanceOverrideInfoINTEL;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPerformanceOverrideInfoINTEL: VkPerformanceOverrideInfoINTELConstructor;



  /**
   * Structure specifying stream performance markers
   */
interface VkPerformanceStreamMarkerInfoINTEL {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the marker value that will be recorded into the reports consumed by an external application.
     */
    marker: number;

}

declare interface VkPerformanceStreamMarkerInfoINTELInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the marker value that will be recorded into the reports consumed by an external application.
     */
    marker?: number;
}

declare interface VkPerformanceStreamMarkerInfoINTELConstructor {
  readonly prototype: VkPerformanceStreamMarkerInfoINTEL;
  new(param?: VkPerformanceStreamMarkerInfoINTELInitializer | null): VkPerformanceStreamMarkerInfoINTEL;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPerformanceStreamMarkerInfoINTEL: VkPerformanceStreamMarkerInfoINTELConstructor;



  /**
   * Structure specifying performance markers
   */
interface VkPerformanceMarkerInfoINTEL {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the marker value that will be recorded into the opaque query results.
     */
    marker: bigint | number;

}

declare interface VkPerformanceMarkerInfoINTELInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the marker value that will be recorded into the opaque query results.
     */
    marker?: bigint | number;
}

declare interface VkPerformanceMarkerInfoINTELConstructor {
  readonly prototype: VkPerformanceMarkerInfoINTEL;
  new(param?: VkPerformanceMarkerInfoINTELInitializer | null): VkPerformanceMarkerInfoINTEL;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPerformanceMarkerInfoINTEL: VkPerformanceMarkerInfoINTELConstructor;



  /**
   * 
   */
interface VkQueryPoolCreateInfoINTEL {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    performanceCountersSampling: VkQueryPoolSamplingModeINTEL;

}

declare interface VkQueryPoolCreateInfoINTELInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    performanceCountersSampling?: VkQueryPoolSamplingModeINTEL;
}

declare interface VkQueryPoolCreateInfoINTELConstructor {
  readonly prototype: VkQueryPoolCreateInfoINTEL;
  new(param?: VkQueryPoolCreateInfoINTELInitializer | null): VkQueryPoolCreateInfoINTEL;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkQueryPoolCreateInfoINTEL: VkQueryPoolCreateInfoINTELConstructor;



  /**
   * Structure specifying parameters to create a pool of performance queries
   */
interface VkQueryPoolPerformanceQueryCreateInfoINTEL {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    performanceCountersSampling: VkQueryPoolSamplingModeINTEL;

}

declare interface VkQueryPoolPerformanceQueryCreateInfoINTELInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    performanceCountersSampling?: VkQueryPoolSamplingModeINTEL;
}

declare interface VkQueryPoolPerformanceQueryCreateInfoINTELConstructor {
  readonly prototype: VkQueryPoolPerformanceQueryCreateInfoINTEL;
  new(param?: VkQueryPoolPerformanceQueryCreateInfoINTELInitializer | null): VkQueryPoolPerformanceQueryCreateInfoINTEL;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkQueryPoolPerformanceQueryCreateInfoINTEL: VkQueryPoolPerformanceQueryCreateInfoINTELConstructor;



  /**
   * Structure specifying parameters of initialize of the device
   */
interface VkInitializePerformanceApiInfoINTEL {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a reference for application data.
     */
    pUserData: ArrayBuffer | null;

}

declare interface VkInitializePerformanceApiInfoINTELInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a reference for application data.
     */
    pUserData?: ArrayBuffer | null;
}

declare interface VkInitializePerformanceApiInfoINTELConstructor {
  readonly prototype: VkInitializePerformanceApiInfoINTEL;
  new(param?: VkInitializePerformanceApiInfoINTELInitializer | null): VkInitializePerformanceApiInfoINTEL;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkInitializePerformanceApiInfoINTEL: VkInitializePerformanceApiInfoINTELConstructor;



  /**
   * Container for value and types of parameters that can be queried
   */
interface VkPerformanceValueINTEL {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a 'VkPerformanceValueTypeINTEL' value specifying the type of the returned data.
     */
    type: VkPerformanceValueTypeINTEL;

    /**
     * is a 'VkPerformanceValueDataINTEL' union specifying the value of the returned data.
     */
    data: VkPerformanceValueDataINTEL | null;

}

declare interface VkPerformanceValueINTELInitializer {
  
    /**
     * is a 'VkPerformanceValueTypeINTEL' value specifying the type of the returned data.
     */
    type?: VkPerformanceValueTypeINTEL;

    /**
     * is a 'VkPerformanceValueDataINTEL' union specifying the value of the returned data.
     */
    data?: VkPerformanceValueDataINTEL | null;
}

declare interface VkPerformanceValueINTELConstructor {
  readonly prototype: VkPerformanceValueINTEL;
  new(param?: VkPerformanceValueINTELInitializer | null): VkPerformanceValueINTEL;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPerformanceValueINTEL: VkPerformanceValueINTELConstructor;



  /**
   * Structure describing shader integer functions that can be supported by an implementation
   */
interface VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports the 'IntegerFunctions2INTEL' SPIR-V capability.
     */
    shaderIntegerFunctions2: boolean;

}

declare interface VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports the 'IntegerFunctions2INTEL' SPIR-V capability.
     */
    shaderIntegerFunctions2?: boolean;
}

declare interface VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELConstructor {
  readonly prototype: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
  new(param?: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELInitializer | null): VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELConstructor;



  /**
   * Structure specifying a supported sample count combination
   */
interface VkFramebufferMixedSamplesCombinationNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a 'VkCoverageReductionModeNV' value specifying the coverage reduction mode.
     */
    readonly coverageReductionMode: VkCoverageReductionModeNV;

    /**
     * specifies the number of rasterization samples in the supported combination.
     */
    readonly rasterizationSamples: VkSampleCountFlagBits;

    /**
     * specifies the number of samples in the depth stencil attachment in the supported combination. A value of 0 indicates the combination does not have a depth stencil attachment.
     */
    readonly depthStencilSamples: VkSampleCountFlagBits;

    /**
     * specifies the number of color samples in a color attachment in the supported combination. A value of 0 indicates the combination does not have a color attachment.
     */
    readonly colorSamples: VkSampleCountFlagBits;

}

declare interface VkFramebufferMixedSamplesCombinationNVInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a 'VkCoverageReductionModeNV' value specifying the coverage reduction mode.
     */
    readonly coverageReductionMode?: VkCoverageReductionModeNV;

    /**
     * specifies the number of rasterization samples in the supported combination.
     */
    readonly rasterizationSamples?: VkSampleCountFlagBits;

    /**
     * specifies the number of samples in the depth stencil attachment in the supported combination. A value of 0 indicates the combination does not have a depth stencil attachment.
     */
    readonly depthStencilSamples?: VkSampleCountFlagBits;

    /**
     * specifies the number of color samples in a color attachment in the supported combination. A value of 0 indicates the combination does not have a color attachment.
     */
    readonly colorSamples?: VkSampleCountFlagBits;
}

declare interface VkFramebufferMixedSamplesCombinationNVConstructor {
  readonly prototype: VkFramebufferMixedSamplesCombinationNV;
  new(param?: VkFramebufferMixedSamplesCombinationNVInitializer | null): VkFramebufferMixedSamplesCombinationNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFramebufferMixedSamplesCombinationNV: VkFramebufferMixedSamplesCombinationNVConstructor;



  /**
   * Structure specifying parameters controlling coverage reduction
   */
interface VkPipelineCoverageReductionStateCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is a 'VkCoverageReductionModeNV' value controlling how color sample coverage is generated from pixel coverage.
     */
    coverageReductionMode: VkCoverageReductionModeNV;

}

declare interface VkPipelineCoverageReductionStateCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is a 'VkCoverageReductionModeNV' value controlling how color sample coverage is generated from pixel coverage.
     */
    coverageReductionMode?: VkCoverageReductionModeNV;
}

declare interface VkPipelineCoverageReductionStateCreateInfoNVConstructor {
  readonly prototype: VkPipelineCoverageReductionStateCreateInfoNV;
  new(param?: VkPipelineCoverageReductionStateCreateInfoNVInitializer | null): VkPipelineCoverageReductionStateCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineCoverageReductionStateCreateInfoNV: VkPipelineCoverageReductionStateCreateInfoNVConstructor;



  /**
   * Structure describing the coverage reduction mode features that can be supported by an implementation
   */
interface VkPhysicalDeviceCoverageReductionModeFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports coverage reduction modes. See <<fragops-coverage-reduction, Coverage Reduction>>.
     */
    coverageReductionMode: boolean;

}

declare interface VkPhysicalDeviceCoverageReductionModeFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports coverage reduction modes. See <<fragops-coverage-reduction, Coverage Reduction>>.
     */
    coverageReductionMode?: boolean;
}

declare interface VkPhysicalDeviceCoverageReductionModeFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceCoverageReductionModeFeaturesNV;
  new(param?: VkPhysicalDeviceCoverageReductionModeFeaturesNVInitializer | null): VkPhysicalDeviceCoverageReductionModeFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceCoverageReductionModeFeaturesNV: VkPhysicalDeviceCoverageReductionModeFeaturesNVConstructor;



  /**
   * Structure specifying parameters of a newly created headless surface object
   */
interface VkHeadlessSurfaceCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

}

declare interface VkHeadlessSurfaceCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;
}

declare interface VkHeadlessSurfaceCreateInfoEXTConstructor {
  readonly prototype: VkHeadlessSurfaceCreateInfoEXT;
  new(param?: VkHeadlessSurfaceCreateInfoEXTInitializer | null): VkHeadlessSurfaceCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkHeadlessSurfaceCreateInfoEXT: VkHeadlessSurfaceCreateInfoEXTConstructor;



  /**
   * Structure indicating which counter pass index is active for performance queries
   */
interface VkPerformanceQuerySubmitInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies which counter pass index is active.
     */
    counterPassIndex: number;

}

declare interface VkPerformanceQuerySubmitInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies which counter pass index is active.
     */
    counterPassIndex?: number;
}

declare interface VkPerformanceQuerySubmitInfoKHRConstructor {
  readonly prototype: VkPerformanceQuerySubmitInfoKHR;
  new(param?: VkPerformanceQuerySubmitInfoKHRInitializer | null): VkPerformanceQuerySubmitInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPerformanceQuerySubmitInfoKHR: VkPerformanceQuerySubmitInfoKHRConstructor;



  /**
   * Structure specifying parameters to acquire the profiling lock
   */
interface VkAcquireProfilingLockInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: VkAcquireProfilingLockFlagBitsKHR;

    /**
     * indicates how long the function waits, in nanoseconds, if the profiling lock is not available.
     */
    timeout: bigint | number;

}

declare interface VkAcquireProfilingLockInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: VkAcquireProfilingLockFlagBitsKHR;

    /**
     * indicates how long the function waits, in nanoseconds, if the profiling lock is not available.
     */
    timeout?: bigint | number;
}

declare interface VkAcquireProfilingLockInfoKHRConstructor {
  readonly prototype: VkAcquireProfilingLockInfoKHR;
  new(param?: VkAcquireProfilingLockInfoKHRInitializer | null): VkAcquireProfilingLockInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAcquireProfilingLockInfoKHR: VkAcquireProfilingLockInfoKHRConstructor;



  /**
   * Structure specifying parameters of a newly created performance query pool
   */
interface VkQueryPoolPerformanceCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the queue family index to create this performance query pool for.
     */
    queueFamilyIndex: number;

    /**
     *
     */
    counterIndexCount: number;

    /**
     * is the array of indices into the 'vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR'::'pCounters' to enable in this performance query pool.
     */
    pCounterIndices: Uint32Array | null;

}

declare interface VkQueryPoolPerformanceCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the queue family index to create this performance query pool for.
     */
    queueFamilyIndex?: number;

    /**
     *
     */
    counterIndexCount?: number;

    /**
     * is the array of indices into the 'vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR'::'pCounters' to enable in this performance query pool.
     */
    pCounterIndices?: Uint32Array | null;
}

declare interface VkQueryPoolPerformanceCreateInfoKHRConstructor {
  readonly prototype: VkQueryPoolPerformanceCreateInfoKHR;
  new(param?: VkQueryPoolPerformanceCreateInfoKHRInitializer | null): VkQueryPoolPerformanceCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkQueryPoolPerformanceCreateInfoKHR: VkQueryPoolPerformanceCreateInfoKHRConstructor;



  /**
   * Structure providing more detailed information about a counter
   */
interface VkPerformanceCounterDescriptionKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a bitmask of 'VkPerformanceCounterDescriptionFlagBitsKHR' indicating the usage behavior for the counter.
     */
    readonly flags: VkPerformanceCounterDescriptionFlagBitsKHR;

    /**
     *
     */
    readonly name: string | null;

    /**
     *
     */
    readonly category: string | null;

    /**
     *
     */
    readonly description: string | null;

}

declare interface VkPerformanceCounterDescriptionKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a bitmask of 'VkPerformanceCounterDescriptionFlagBitsKHR' indicating the usage behavior for the counter.
     */
    readonly flags?: VkPerformanceCounterDescriptionFlagBitsKHR;

    /**
     *
     */
    readonly name?: string | null;

    /**
     *
     */
    readonly category?: string | null;

    /**
     *
     */
    readonly description?: string | null;
}

declare interface VkPerformanceCounterDescriptionKHRConstructor {
  readonly prototype: VkPerformanceCounterDescriptionKHR;
  new(param?: VkPerformanceCounterDescriptionKHRInitializer | null): VkPerformanceCounterDescriptionKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPerformanceCounterDescriptionKHR: VkPerformanceCounterDescriptionKHRConstructor;



  /**
   * Structure providing information about a counter
   */
interface VkPerformanceCounterKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a 'VkPerformanceCounterUnitKHR' specifying the unit that the counter data will record.
     */
    readonly unit: VkPerformanceCounterUnitKHR;

    /**
     * is a 'VkPerformanceCounterScopeKHR' specifying the scope that the counter belongs to.
     */
    readonly scope: VkPerformanceCounterScopeKHR;

    /**
     * is a 'VkPerformanceCounterStorageKHR' specifying the storage type that the counter's data uses.
     */
    readonly storage: VkPerformanceCounterStorageKHR;

    /**
     *
     */
    readonly uuid: number[] | null;

}

declare interface VkPerformanceCounterKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a 'VkPerformanceCounterUnitKHR' specifying the unit that the counter data will record.
     */
    readonly unit?: VkPerformanceCounterUnitKHR;

    /**
     * is a 'VkPerformanceCounterScopeKHR' specifying the scope that the counter belongs to.
     */
    readonly scope?: VkPerformanceCounterScopeKHR;

    /**
     * is a 'VkPerformanceCounterStorageKHR' specifying the storage type that the counter's data uses.
     */
    readonly storage?: VkPerformanceCounterStorageKHR;

    /**
     *
     */
    readonly uuid?: number[] | null;
}

declare interface VkPerformanceCounterKHRConstructor {
  readonly prototype: VkPerformanceCounterKHR;
  new(param?: VkPerformanceCounterKHRInitializer | null): VkPerformanceCounterKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPerformanceCounterKHR: VkPerformanceCounterKHRConstructor;



  /**
   * Structure describing performance query properties for an implementation
   */
interface VkPhysicalDevicePerformanceQueryPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     *
     */
    readonly allowCommandBufferQueryCopies: boolean;

}

declare interface VkPhysicalDevicePerformanceQueryPropertiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly allowCommandBufferQueryCopies?: boolean;
}

declare interface VkPhysicalDevicePerformanceQueryPropertiesKHRConstructor {
  readonly prototype: VkPhysicalDevicePerformanceQueryPropertiesKHR;
  new(param?: VkPhysicalDevicePerformanceQueryPropertiesKHRInitializer | null): VkPhysicalDevicePerformanceQueryPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevicePerformanceQueryPropertiesKHR: VkPhysicalDevicePerformanceQueryPropertiesKHRConstructor;



  /**
   * Structure describing performance query support for an implementation
   */
interface VkPhysicalDevicePerformanceQueryFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.// tag::VK_KHR_performance_query-features[]
     */
    pNext: null;

    /**
     * indicates whether the implementation supports performance counter query pools.
     */
    performanceCounterQueryPools: boolean;

    /**
     * indicates whether the implementation supports using multiple performance query pools in a primary command buffer and secondary command buffers executed within it.// end::VK_KHR_performance_query-features[]
     */
    performanceCounterMultipleQueryPools: boolean;

}

declare interface VkPhysicalDevicePerformanceQueryFeaturesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.// tag::VK_KHR_performance_query-features[]
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports performance counter query pools.
     */
    performanceCounterQueryPools?: boolean;

    /**
     * indicates whether the implementation supports using multiple performance query pools in a primary command buffer and secondary command buffers executed within it.// end::VK_KHR_performance_query-features[]
     */
    performanceCounterMultipleQueryPools?: boolean;
}

declare interface VkPhysicalDevicePerformanceQueryFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDevicePerformanceQueryFeaturesKHR;
  new(param?: VkPhysicalDevicePerformanceQueryFeaturesKHRInitializer | null): VkPhysicalDevicePerformanceQueryFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevicePerformanceQueryFeaturesKHR: VkPhysicalDevicePerformanceQueryFeaturesKHRConstructor;



  /**
   * Structure describing full screen exclusive capabilities of a surface
   */
interface VkSurfaceCapabilitiesFullScreenExclusiveEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     *
     */
    fullScreenExclusiveSupported: boolean;

}

declare interface VkSurfaceCapabilitiesFullScreenExclusiveEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     *
     */
    fullScreenExclusiveSupported?: boolean;
}

declare interface VkSurfaceCapabilitiesFullScreenExclusiveEXTConstructor {
  readonly prototype: VkSurfaceCapabilitiesFullScreenExclusiveEXT;
  new(param?: VkSurfaceCapabilitiesFullScreenExclusiveEXTInitializer | null): VkSurfaceCapabilitiesFullScreenExclusiveEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSurfaceCapabilitiesFullScreenExclusiveEXT: VkSurfaceCapabilitiesFullScreenExclusiveEXTConstructor;



  /**
   * Structure specifying additional creation parameters specific to Win32 fullscreen exclusive mode
   */
interface VkSurfaceFullScreenExclusiveWin32InfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the Win32 'HMONITOR' handle identifying the display to create the surface with.
     */
    hmonitor: null;

}

declare interface VkSurfaceFullScreenExclusiveWin32InfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the Win32 'HMONITOR' handle identifying the display to create the surface with.
     */
    hmonitor?: null;
}

declare interface VkSurfaceFullScreenExclusiveWin32InfoEXTConstructor {
  readonly prototype: VkSurfaceFullScreenExclusiveWin32InfoEXT;
  new(param?: VkSurfaceFullScreenExclusiveWin32InfoEXTInitializer | null): VkSurfaceFullScreenExclusiveWin32InfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSurfaceFullScreenExclusiveWin32InfoEXT: VkSurfaceFullScreenExclusiveWin32InfoEXTConstructor;



  /**
   * Structure specifying the preferred full-screen transition behavior
   */
interface VkSurfaceFullScreenExclusiveInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkFullScreenExclusiveEXT' value specifying the preferred full-screen transition behavior.
     */
    fullScreenExclusive: VkFullScreenExclusiveEXT;

}

declare interface VkSurfaceFullScreenExclusiveInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkFullScreenExclusiveEXT' value specifying the preferred full-screen transition behavior.
     */
    fullScreenExclusive?: VkFullScreenExclusiveEXT;
}

declare interface VkSurfaceFullScreenExclusiveInfoEXTConstructor {
  readonly prototype: VkSurfaceFullScreenExclusiveInfoEXT;
  new(param?: VkSurfaceFullScreenExclusiveInfoEXTInitializer | null): VkSurfaceFullScreenExclusiveInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSurfaceFullScreenExclusiveInfoEXT: VkSurfaceFullScreenExclusiveInfoEXTConstructor;



  /**
   * Request for feedback about the creation of a pipeline
   */
interface VkPipelineCreationFeedbackCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a reference to a 'VkPipelineCreationFeedbackEXT' structure.
     */
    pPipelineCreationFeedback: VkPipelineCreationFeedbackEXT | null;

    /**
     * is the number of elements in 'pPipelineStageCreationFeedbacks'.
     */
    pipelineStageCreationFeedbackCount: number;

    /**
     * is an array of 'pipelineStageCreationFeedbackCount' 'VkPipelineCreationFeedbackEXT' structures.
     */
    pPipelineStageCreationFeedbacks: VkPipelineCreationFeedbackEXT[] | null;

}

declare interface VkPipelineCreationFeedbackCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a reference to a 'VkPipelineCreationFeedbackEXT' structure.
     */
    pPipelineCreationFeedback?: VkPipelineCreationFeedbackEXT | null;

    /**
     * is the number of elements in 'pPipelineStageCreationFeedbacks'.
     */
    pipelineStageCreationFeedbackCount?: number;

    /**
     * is an array of 'pipelineStageCreationFeedbackCount' 'VkPipelineCreationFeedbackEXT' structures.
     */
    pPipelineStageCreationFeedbacks?: VkPipelineCreationFeedbackEXT[] | null;
}

declare interface VkPipelineCreationFeedbackCreateInfoEXTConstructor {
  readonly prototype: VkPipelineCreationFeedbackCreateInfoEXT;
  new(param?: VkPipelineCreationFeedbackCreateInfoEXTInitializer | null): VkPipelineCreationFeedbackCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineCreationFeedbackCreateInfoEXT: VkPipelineCreationFeedbackCreateInfoEXTConstructor;



  /**
   * Feedback about the creation of a pipeline or pipeline stage
   */
interface VkPipelineCreationFeedbackEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a bitmask of 'VkPipelineCreationFeedbackFlagBitsEXT' providing feedback about the creation of a pipeline or of a pipeline stage.
     */
    readonly flags: VkPipelineCreationFeedbackFlagBitsEXT;

    /**
     * is the duration spent creating a pipeline or pipeline stage in nanoseconds.
     */
    readonly duration: bigint | number;

}

declare interface VkPipelineCreationFeedbackEXTInitializer {
  
    /**
     * is a bitmask of 'VkPipelineCreationFeedbackFlagBitsEXT' providing feedback about the creation of a pipeline or of a pipeline stage.
     */
    readonly flags?: VkPipelineCreationFeedbackFlagBitsEXT;

    /**
     * is the duration spent creating a pipeline or pipeline stage in nanoseconds.
     */
    readonly duration?: bigint | number;
}

declare interface VkPipelineCreationFeedbackEXTConstructor {
  readonly prototype: VkPipelineCreationFeedbackEXT;
  new(param?: VkPipelineCreationFeedbackEXTInitializer | null): VkPipelineCreationFeedbackEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineCreationFeedbackEXT: VkPipelineCreationFeedbackEXTConstructor;



  /**
   * Structure specifying the image view for handle queries
   */
interface VkImageViewAddressPropertiesNVX {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the device address of the image view.
     */
    readonly deviceAddress: bigint | number;

    /**
     * is the size in bytes of the image view device memory.
     */
    readonly size: bigint | number;

}

declare interface VkImageViewAddressPropertiesNVXInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the device address of the image view.
     */
    readonly deviceAddress?: bigint | number;

    /**
     * is the size in bytes of the image view device memory.
     */
    readonly size?: bigint | number;
}

declare interface VkImageViewAddressPropertiesNVXConstructor {
  readonly prototype: VkImageViewAddressPropertiesNVX;
  new(param?: VkImageViewAddressPropertiesNVXInitializer | null): VkImageViewAddressPropertiesNVX;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageViewAddressPropertiesNVX: VkImageViewAddressPropertiesNVXConstructor;



  /**
   * Structure specifying the image view for handle queries
   */
interface VkImageViewHandleInfoNVX {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the image view to query.
     */
    imageView: VkImageView | null;

    /**
     * is the type of descriptor for which to query a handle.
     */
    descriptorType: VkDescriptorType;

    /**
     * is the sampler to combine with the image view when generating the handle.
     */
    sampler: VkSampler | null;

}

declare interface VkImageViewHandleInfoNVXInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the image view to query.
     */
    imageView?: VkImageView | null;

    /**
     * is the type of descriptor for which to query a handle.
     */
    descriptorType?: VkDescriptorType;

    /**
     * is the sampler to combine with the image view when generating the handle.
     */
    sampler?: VkSampler | null;
}

declare interface VkImageViewHandleInfoNVXConstructor {
  readonly prototype: VkImageViewHandleInfoNVX;
  new(param?: VkImageViewHandleInfoNVXInitializer | null): VkImageViewHandleInfoNVX;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageViewHandleInfoNVX: VkImageViewHandleInfoNVXConstructor;



  /**
   * Structure describing extended Y\
   */
interface VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    ycbcrImageArrays: boolean;

}

declare interface VkPhysicalDeviceYcbcrImageArraysFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    ycbcrImageArrays?: boolean;
}

declare interface VkPhysicalDeviceYcbcrImageArraysFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceYcbcrImageArraysFeaturesEXT;
  new(param?: VkPhysicalDeviceYcbcrImageArraysFeaturesEXTInitializer | null): VkPhysicalDeviceYcbcrImageArraysFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceYcbcrImageArraysFeaturesEXT: VkPhysicalDeviceYcbcrImageArraysFeaturesEXTConstructor;



  /**
   * Structure specifying cooperative matrix properties
   */
interface VkCooperativeMatrixPropertiesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    MSize: number;

    /**
     *
     */
    NSize: number;

    /**
     *
     */
    KSize: number;

    /**
     *
     */
    AType: VkComponentTypeNV;

    /**
     *
     */
    BType: VkComponentTypeNV;

    /**
     *
     */
    CType: VkComponentTypeNV;

    /**
     *
     */
    DType: VkComponentTypeNV;

    /**
     *
     */
    scope: VkScopeNV;

}

declare interface VkCooperativeMatrixPropertiesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    MSize?: number;

    /**
     *
     */
    NSize?: number;

    /**
     *
     */
    KSize?: number;

    /**
     *
     */
    AType?: VkComponentTypeNV;

    /**
     *
     */
    BType?: VkComponentTypeNV;

    /**
     *
     */
    CType?: VkComponentTypeNV;

    /**
     *
     */
    DType?: VkComponentTypeNV;

    /**
     *
     */
    scope?: VkScopeNV;
}

declare interface VkCooperativeMatrixPropertiesNVConstructor {
  readonly prototype: VkCooperativeMatrixPropertiesNV;
  new(param?: VkCooperativeMatrixPropertiesNVInitializer | null): VkCooperativeMatrixPropertiesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCooperativeMatrixPropertiesNV: VkCooperativeMatrixPropertiesNVConstructor;



  /**
   * Structure describing cooperative matrix properties supported by an implementation
   */
interface VkPhysicalDeviceCooperativeMatrixPropertiesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a bitfield of 'VkShaderStageFlagBits' describing the shader stages that cooperative matrix instructions are supported in. 'cooperativeMatrixSupportedStages' will have the 'VK_SHADER_STAGE_COMPUTE_BIT' bit set if any of the physical device's queues support 'VK_QUEUE_COMPUTE_BIT'.
     */
    readonly cooperativeMatrixSupportedStages: VkShaderStageFlagBits;

}

declare interface VkPhysicalDeviceCooperativeMatrixPropertiesNVInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a bitfield of 'VkShaderStageFlagBits' describing the shader stages that cooperative matrix instructions are supported in. 'cooperativeMatrixSupportedStages' will have the 'VK_SHADER_STAGE_COMPUTE_BIT' bit set if any of the physical device's queues support 'VK_QUEUE_COMPUTE_BIT'.
     */
    readonly cooperativeMatrixSupportedStages?: VkShaderStageFlagBits;
}

declare interface VkPhysicalDeviceCooperativeMatrixPropertiesNVConstructor {
  readonly prototype: VkPhysicalDeviceCooperativeMatrixPropertiesNV;
  new(param?: VkPhysicalDeviceCooperativeMatrixPropertiesNVInitializer | null): VkPhysicalDeviceCooperativeMatrixPropertiesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceCooperativeMatrixPropertiesNV: VkPhysicalDeviceCooperativeMatrixPropertiesNVConstructor;



  /**
   * Structure describing cooperative matrix features that can be supported by an implementation
   */
interface VkPhysicalDeviceCooperativeMatrixFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports the 'CooperativeMatrixNV' SPIR-V capability.
     */
    cooperativeMatrix: boolean;

    /**
     * indicates that the implementation supports robust buffer access for SPIR-V 'OpCooperativeMatrixLoadNV' and 'OpCooperativeMatrixStoreNV' instructions.
     */
    cooperativeMatrixRobustBufferAccess: boolean;

}

declare interface VkPhysicalDeviceCooperativeMatrixFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports the 'CooperativeMatrixNV' SPIR-V capability.
     */
    cooperativeMatrix?: boolean;

    /**
     * indicates that the implementation supports robust buffer access for SPIR-V 'OpCooperativeMatrixLoadNV' and 'OpCooperativeMatrixStoreNV' instructions.
     */
    cooperativeMatrixRobustBufferAccess?: boolean;
}

declare interface VkPhysicalDeviceCooperativeMatrixFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceCooperativeMatrixFeaturesNV;
  new(param?: VkPhysicalDeviceCooperativeMatrixFeaturesNVInitializer | null): VkPhysicalDeviceCooperativeMatrixFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceCooperativeMatrixFeaturesNV: VkPhysicalDeviceCooperativeMatrixFeaturesNVConstructor;



  /**
   * Structure describing ASTC HDR features that can be supported by an implementation
   */
interface VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether all of the ASTC HDR compressed texture formats are supported. If this feature is enabled, then the 'VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT', 'VK_FORMAT_FEATURE_BLIT_SRC_BIT' and 'VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT' features 'must' be supported in 'optimalTilingFeatures' for the following formats:+
     */
    textureCompressionASTC_HDR: boolean;

}

declare interface VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether all of the ASTC HDR compressed texture formats are supported. If this feature is enabled, then the 'VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT', 'VK_FORMAT_FEATURE_BLIT_SRC_BIT' and 'VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT' features 'must' be supported in 'optimalTilingFeatures' for the following formats:+
     */
    textureCompressionASTC_HDR?: boolean;
}

declare interface VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT;
  new(param?: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTInitializer | null): VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTConstructor;



  /**
   * 
   */
interface VkRenderPassAttachmentBeginInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    attachmentCount: number;

    /**
     *
     */
    pAttachments: VkImageView[] | null;

}

declare interface VkRenderPassAttachmentBeginInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    attachmentCount?: number;

    /**
     *
     */
    pAttachments?: VkImageView[] | null;
}

declare interface VkRenderPassAttachmentBeginInfoKHRConstructor {
  readonly prototype: VkRenderPassAttachmentBeginInfoKHR;
  new(param?: VkRenderPassAttachmentBeginInfoKHRInitializer | null): VkRenderPassAttachmentBeginInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassAttachmentBeginInfoKHR: VkRenderPassAttachmentBeginInfoKHRConstructor;



  /**
   * Structure specifying images to be used as framebuffer attachments
   */
interface VkRenderPassAttachmentBeginInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    attachmentCount: number;

    /**
     *
     */
    pAttachments: VkImageView[] | null;

}

declare interface VkRenderPassAttachmentBeginInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    attachmentCount?: number;

    /**
     *
     */
    pAttachments?: VkImageView[] | null;
}

declare interface VkRenderPassAttachmentBeginInfoConstructor {
  readonly prototype: VkRenderPassAttachmentBeginInfo;
  new(param?: VkRenderPassAttachmentBeginInfoInitializer | null): VkRenderPassAttachmentBeginInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassAttachmentBeginInfo: VkRenderPassAttachmentBeginInfoConstructor;



  /**
   * 
   */
interface VkFramebufferAttachmentImageInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkImageCreateFlagBits;

    /**
     *
     */
    usage: VkImageUsageFlagBits;

    /**
     *
     */
    width: number;

    /**
     *
     */
    height: number;

    /**
     *
     */
    layerCount: number;

    /**
     *
     */
    viewFormatCount: number;

    /**
     *
     */
    pViewFormats: Int32Array | null;

}

declare interface VkFramebufferAttachmentImageInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkImageCreateFlagBits;

    /**
     *
     */
    usage?: VkImageUsageFlagBits;

    /**
     *
     */
    width?: number;

    /**
     *
     */
    height?: number;

    /**
     *
     */
    layerCount?: number;

    /**
     *
     */
    viewFormatCount?: number;

    /**
     *
     */
    pViewFormats?: Int32Array | null;
}

declare interface VkFramebufferAttachmentImageInfoKHRConstructor {
  readonly prototype: VkFramebufferAttachmentImageInfoKHR;
  new(param?: VkFramebufferAttachmentImageInfoKHRInitializer | null): VkFramebufferAttachmentImageInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFramebufferAttachmentImageInfoKHR: VkFramebufferAttachmentImageInfoKHRConstructor;



  /**
   * Structure specifying parameters of an image that will be used with a framebuffer
   */
interface VkFramebufferAttachmentImageInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkImageCreateFlagBits;

    /**
     *
     */
    usage: VkImageUsageFlagBits;

    /**
     *
     */
    width: number;

    /**
     *
     */
    height: number;

    /**
     *
     */
    layerCount: number;

    /**
     *
     */
    viewFormatCount: number;

    /**
     *
     */
    pViewFormats: Int32Array | null;

}

declare interface VkFramebufferAttachmentImageInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkImageCreateFlagBits;

    /**
     *
     */
    usage?: VkImageUsageFlagBits;

    /**
     *
     */
    width?: number;

    /**
     *
     */
    height?: number;

    /**
     *
     */
    layerCount?: number;

    /**
     *
     */
    viewFormatCount?: number;

    /**
     *
     */
    pViewFormats?: Int32Array | null;
}

declare interface VkFramebufferAttachmentImageInfoConstructor {
  readonly prototype: VkFramebufferAttachmentImageInfo;
  new(param?: VkFramebufferAttachmentImageInfoInitializer | null): VkFramebufferAttachmentImageInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFramebufferAttachmentImageInfo: VkFramebufferAttachmentImageInfoConstructor;



  /**
   * 
   */
interface VkFramebufferAttachmentsCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    attachmentImageInfoCount: number;

    /**
     *
     */
    pAttachmentImageInfos: VkFramebufferAttachmentImageInfo[] | null;

}

declare interface VkFramebufferAttachmentsCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    attachmentImageInfoCount?: number;

    /**
     *
     */
    pAttachmentImageInfos?: VkFramebufferAttachmentImageInfo[] | null;
}

declare interface VkFramebufferAttachmentsCreateInfoKHRConstructor {
  readonly prototype: VkFramebufferAttachmentsCreateInfoKHR;
  new(param?: VkFramebufferAttachmentsCreateInfoKHRInitializer | null): VkFramebufferAttachmentsCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFramebufferAttachmentsCreateInfoKHR: VkFramebufferAttachmentsCreateInfoKHRConstructor;



  /**
   * Structure specifying parameters of images that will be used with a framebuffer
   */
interface VkFramebufferAttachmentsCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    attachmentImageInfoCount: number;

    /**
     *
     */
    pAttachmentImageInfos: VkFramebufferAttachmentImageInfo[] | null;

}

declare interface VkFramebufferAttachmentsCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    attachmentImageInfoCount?: number;

    /**
     *
     */
    pAttachmentImageInfos?: VkFramebufferAttachmentImageInfo[] | null;
}

declare interface VkFramebufferAttachmentsCreateInfoConstructor {
  readonly prototype: VkFramebufferAttachmentsCreateInfo;
  new(param?: VkFramebufferAttachmentsCreateInfoInitializer | null): VkFramebufferAttachmentsCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFramebufferAttachmentsCreateInfo: VkFramebufferAttachmentsCreateInfoConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceImagelessFramebufferFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    imagelessFramebuffer: boolean;

}

declare interface VkPhysicalDeviceImagelessFramebufferFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    imagelessFramebuffer?: boolean;
}

declare interface VkPhysicalDeviceImagelessFramebufferFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceImagelessFramebufferFeaturesKHR;
  new(param?: VkPhysicalDeviceImagelessFramebufferFeaturesKHRInitializer | null): VkPhysicalDeviceImagelessFramebufferFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceImagelessFramebufferFeaturesKHR: VkPhysicalDeviceImagelessFramebufferFeaturesKHRConstructor;



  /**
   * Structure indicating support for imageless framebuffers
   */
interface VkPhysicalDeviceImagelessFramebufferFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    imagelessFramebuffer: boolean;

}

declare interface VkPhysicalDeviceImagelessFramebufferFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    imagelessFramebuffer?: boolean;
}

declare interface VkPhysicalDeviceImagelessFramebufferFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceImagelessFramebufferFeatures;
  new(param?: VkPhysicalDeviceImagelessFramebufferFeaturesInitializer | null): VkPhysicalDeviceImagelessFramebufferFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceImagelessFramebufferFeatures: VkPhysicalDeviceImagelessFramebufferFeaturesConstructor;



  /**
   * Structure for querying cubic filtering capabilities of an image view type
   */
interface VkFilterCubicImageViewImageFormatPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * tells if image format, image type and image view type 'can' be used with cubic filtering. This field is set by the implementation. User-specified value is ignored.
     */
    readonly filterCubic: boolean;

    /**
     * tells if image format, image type and image view type 'can' be used with cubic filtering and minmax filtering. This field is set by the implementation. User-specified value is ignored.
     */
    readonly filterCubicMinmax: boolean;

}

declare interface VkFilterCubicImageViewImageFormatPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * tells if image format, image type and image view type 'can' be used with cubic filtering. This field is set by the implementation. User-specified value is ignored.
     */
    readonly filterCubic?: boolean;

    /**
     * tells if image format, image type and image view type 'can' be used with cubic filtering and minmax filtering. This field is set by the implementation. User-specified value is ignored.
     */
    readonly filterCubicMinmax?: boolean;
}

declare interface VkFilterCubicImageViewImageFormatPropertiesEXTConstructor {
  readonly prototype: VkFilterCubicImageViewImageFormatPropertiesEXT;
  new(param?: VkFilterCubicImageViewImageFormatPropertiesEXTInitializer | null): VkFilterCubicImageViewImageFormatPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFilterCubicImageViewImageFormatPropertiesEXT: VkFilterCubicImageViewImageFormatPropertiesEXTConstructor;



  /**
   * Structure for providing image view type
   */
interface VkPhysicalDeviceImageViewImageFormatInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkImageViewType' value specifying the type of the image view.
     */
    imageViewType: VkImageViewType;

}

declare interface VkPhysicalDeviceImageViewImageFormatInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkImageViewType' value specifying the type of the image view.
     */
    imageViewType?: VkImageViewType;
}

declare interface VkPhysicalDeviceImageViewImageFormatInfoEXTConstructor {
  readonly prototype: VkPhysicalDeviceImageViewImageFormatInfoEXT;
  new(param?: VkPhysicalDeviceImageViewImageFormatInfoEXTInitializer | null): VkPhysicalDeviceImageViewImageFormatInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceImageViewImageFormatInfoEXT: VkPhysicalDeviceImageViewImageFormatInfoEXTConstructor;



  /**
   * Request a specific address for a buffer
   */
interface VkBufferDeviceAddressCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the device address requested for the buffer.
     */
    deviceAddress: bigint | number;

}

declare interface VkBufferDeviceAddressCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the device address requested for the buffer.
     */
    deviceAddress?: bigint | number;
}

declare interface VkBufferDeviceAddressCreateInfoEXTConstructor {
  readonly prototype: VkBufferDeviceAddressCreateInfoEXT;
  new(param?: VkBufferDeviceAddressCreateInfoEXTInitializer | null): VkBufferDeviceAddressCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferDeviceAddressCreateInfoEXT: VkBufferDeviceAddressCreateInfoEXTConstructor;



  /**
   * 
   */
interface VkBufferOpaqueCaptureAddressCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    opaqueCaptureAddress: bigint | number;

}

declare interface VkBufferOpaqueCaptureAddressCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    opaqueCaptureAddress?: bigint | number;
}

declare interface VkBufferOpaqueCaptureAddressCreateInfoKHRConstructor {
  readonly prototype: VkBufferOpaqueCaptureAddressCreateInfoKHR;
  new(param?: VkBufferOpaqueCaptureAddressCreateInfoKHRInitializer | null): VkBufferOpaqueCaptureAddressCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferOpaqueCaptureAddressCreateInfoKHR: VkBufferOpaqueCaptureAddressCreateInfoKHRConstructor;



  /**
   * Request a specific address for a buffer
   */
interface VkBufferOpaqueCaptureAddressCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    opaqueCaptureAddress: bigint | number;

}

declare interface VkBufferOpaqueCaptureAddressCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    opaqueCaptureAddress?: bigint | number;
}

declare interface VkBufferOpaqueCaptureAddressCreateInfoConstructor {
  readonly prototype: VkBufferOpaqueCaptureAddressCreateInfo;
  new(param?: VkBufferOpaqueCaptureAddressCreateInfoInitializer | null): VkBufferOpaqueCaptureAddressCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferOpaqueCaptureAddressCreateInfo: VkBufferOpaqueCaptureAddressCreateInfoConstructor;



  /**
   * 
   */
interface VkBufferDeviceAddressInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    buffer: VkBuffer | null;

}

declare interface VkBufferDeviceAddressInfoEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    buffer?: VkBuffer | null;
}

declare interface VkBufferDeviceAddressInfoEXTConstructor {
  readonly prototype: VkBufferDeviceAddressInfoEXT;
  new(param?: VkBufferDeviceAddressInfoEXTInitializer | null): VkBufferDeviceAddressInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferDeviceAddressInfoEXT: VkBufferDeviceAddressInfoEXTConstructor;



  /**
   * 
   */
interface VkBufferDeviceAddressInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    buffer: VkBuffer | null;

}

declare interface VkBufferDeviceAddressInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    buffer?: VkBuffer | null;
}

declare interface VkBufferDeviceAddressInfoKHRConstructor {
  readonly prototype: VkBufferDeviceAddressInfoKHR;
  new(param?: VkBufferDeviceAddressInfoKHRInitializer | null): VkBufferDeviceAddressInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferDeviceAddressInfoKHR: VkBufferDeviceAddressInfoKHRConstructor;



  /**
   * Structure specifying the buffer to query an address for
   */
interface VkBufferDeviceAddressInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    buffer: VkBuffer | null;

}

declare interface VkBufferDeviceAddressInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    buffer?: VkBuffer | null;
}

declare interface VkBufferDeviceAddressInfoConstructor {
  readonly prototype: VkBufferDeviceAddressInfo;
  new(param?: VkBufferDeviceAddressInfoInitializer | null): VkBufferDeviceAddressInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferDeviceAddressInfo: VkBufferDeviceAddressInfoConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceBufferAddressFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    bufferDeviceAddress: boolean;

    /**
     *
     */
    bufferDeviceAddressCaptureReplay: boolean;

    /**
     *
     */
    bufferDeviceAddressMultiDevice: boolean;

}

declare interface VkPhysicalDeviceBufferAddressFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    bufferDeviceAddress?: boolean;

    /**
     *
     */
    bufferDeviceAddressCaptureReplay?: boolean;

    /**
     *
     */
    bufferDeviceAddressMultiDevice?: boolean;
}

declare interface VkPhysicalDeviceBufferAddressFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceBufferAddressFeaturesEXT;
  new(param?: VkPhysicalDeviceBufferAddressFeaturesEXTInitializer | null): VkPhysicalDeviceBufferAddressFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceBufferAddressFeaturesEXT: VkPhysicalDeviceBufferAddressFeaturesEXTConstructor;



  /**
   * Structure describing buffer address features that can be supported by an implementation
   */
interface VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    bufferDeviceAddress: boolean;

    /**
     *
     */
    bufferDeviceAddressCaptureReplay: boolean;

    /**
     *
     */
    bufferDeviceAddressMultiDevice: boolean;

}

declare interface VkPhysicalDeviceBufferDeviceAddressFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    bufferDeviceAddress?: boolean;

    /**
     *
     */
    bufferDeviceAddressCaptureReplay?: boolean;

    /**
     *
     */
    bufferDeviceAddressMultiDevice?: boolean;
}

declare interface VkPhysicalDeviceBufferDeviceAddressFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
  new(param?: VkPhysicalDeviceBufferDeviceAddressFeaturesEXTInitializer | null): VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceBufferDeviceAddressFeaturesEXT: VkPhysicalDeviceBufferDeviceAddressFeaturesEXTConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceBufferDeviceAddressFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    bufferDeviceAddress: boolean;

    /**
     *
     */
    bufferDeviceAddressCaptureReplay: boolean;

    /**
     *
     */
    bufferDeviceAddressMultiDevice: boolean;

}

declare interface VkPhysicalDeviceBufferDeviceAddressFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    bufferDeviceAddress?: boolean;

    /**
     *
     */
    bufferDeviceAddressCaptureReplay?: boolean;

    /**
     *
     */
    bufferDeviceAddressMultiDevice?: boolean;
}

declare interface VkPhysicalDeviceBufferDeviceAddressFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceBufferDeviceAddressFeaturesKHR;
  new(param?: VkPhysicalDeviceBufferDeviceAddressFeaturesKHRInitializer | null): VkPhysicalDeviceBufferDeviceAddressFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceBufferDeviceAddressFeaturesKHR: VkPhysicalDeviceBufferDeviceAddressFeaturesKHRConstructor;



  /**
   * Structure describing buffer address features that can be supported by an implementation
   */
interface VkPhysicalDeviceBufferDeviceAddressFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    bufferDeviceAddress: boolean;

    /**
     *
     */
    bufferDeviceAddressCaptureReplay: boolean;

    /**
     *
     */
    bufferDeviceAddressMultiDevice: boolean;

}

declare interface VkPhysicalDeviceBufferDeviceAddressFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    bufferDeviceAddress?: boolean;

    /**
     *
     */
    bufferDeviceAddressCaptureReplay?: boolean;

    /**
     *
     */
    bufferDeviceAddressMultiDevice?: boolean;
}

declare interface VkPhysicalDeviceBufferDeviceAddressFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceBufferDeviceAddressFeatures;
  new(param?: VkPhysicalDeviceBufferDeviceAddressFeaturesInitializer | null): VkPhysicalDeviceBufferDeviceAddressFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceBufferDeviceAddressFeatures: VkPhysicalDeviceBufferDeviceAddressFeaturesConstructor;



  /**
   * Specify a memory allocation priority
   */
interface VkMemoryPriorityAllocateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a floating-point value between `0` and `1`, indicating the priority of the allocation relative to other memory allocations. Larger values are higher priority. The granularity of the priorities is implementation-dependent.
     */
    priority: number;

}

declare interface VkMemoryPriorityAllocateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a floating-point value between `0` and `1`, indicating the priority of the allocation relative to other memory allocations. Larger values are higher priority. The granularity of the priorities is implementation-dependent.
     */
    priority?: number;
}

declare interface VkMemoryPriorityAllocateInfoEXTConstructor {
  readonly prototype: VkMemoryPriorityAllocateInfoEXT;
  new(param?: VkMemoryPriorityAllocateInfoEXTInitializer | null): VkMemoryPriorityAllocateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryPriorityAllocateInfoEXT: VkMemoryPriorityAllocateInfoEXTConstructor;



  /**
   * Structure describing memory priority features that can be supported by an implementation
   */
interface VkPhysicalDeviceMemoryPriorityFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports memory priorities specified at memory allocation time via 'VkMemoryPriorityAllocateInfoEXT'.
     */
    memoryPriority: boolean;

}

declare interface VkPhysicalDeviceMemoryPriorityFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports memory priorities specified at memory allocation time via 'VkMemoryPriorityAllocateInfoEXT'.
     */
    memoryPriority?: boolean;
}

declare interface VkPhysicalDeviceMemoryPriorityFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceMemoryPriorityFeaturesEXT;
  new(param?: VkPhysicalDeviceMemoryPriorityFeaturesEXTInitializer | null): VkPhysicalDeviceMemoryPriorityFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMemoryPriorityFeaturesEXT: VkPhysicalDeviceMemoryPriorityFeaturesEXTConstructor;



  /**
   * Structure specifying physical device memory budget and usage
   */
interface VkPhysicalDeviceMemoryBudgetPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     *
     */
    readonly heapBudget: number[] | null;

    /**
     *
     */
    readonly heapUsage: number[] | null;

}

declare interface VkPhysicalDeviceMemoryBudgetPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly heapBudget?: number[] | null;

    /**
     *
     */
    readonly heapUsage?: number[] | null;
}

declare interface VkPhysicalDeviceMemoryBudgetPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceMemoryBudgetPropertiesEXT;
  new(param?: VkPhysicalDeviceMemoryBudgetPropertiesEXTInitializer | null): VkPhysicalDeviceMemoryBudgetPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMemoryBudgetPropertiesEXT: VkPhysicalDeviceMemoryBudgetPropertiesEXTConstructor;



  /**
   * Structure specifying depth clipping state
   */
interface VkPipelineRasterizationDepthClipStateCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * controls whether depth clipping is enabled as described in <<vertexpostproc-clipping, Primitive Clipping>>.
     */
    depthClipEnable: boolean;

}

declare interface VkPipelineRasterizationDepthClipStateCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * controls whether depth clipping is enabled as described in <<vertexpostproc-clipping, Primitive Clipping>>.
     */
    depthClipEnable?: boolean;
}

declare interface VkPipelineRasterizationDepthClipStateCreateInfoEXTConstructor {
  readonly prototype: VkPipelineRasterizationDepthClipStateCreateInfoEXT;
  new(param?: VkPipelineRasterizationDepthClipStateCreateInfoEXTInitializer | null): VkPipelineRasterizationDepthClipStateCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineRasterizationDepthClipStateCreateInfoEXT: VkPipelineRasterizationDepthClipStateCreateInfoEXTConstructor;



  /**
   * Structure indicating support for explicit enable of depth clip
   */
interface VkPhysicalDeviceDepthClipEnableFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports setting the depth clipping operation explicitly via the 'VkPipelineRasterizationDepthClipStateCreateInfoEXT' pipeline state. Otherwise depth clipping is only enabled when 'VkPipelineRasterizationStateCreateInfo'::'depthClampEnable' is set to 'VK_FALSE'.
     */
    depthClipEnable: boolean;

}

declare interface VkPhysicalDeviceDepthClipEnableFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports setting the depth clipping operation explicitly via the 'VkPipelineRasterizationDepthClipStateCreateInfoEXT' pipeline state. Otherwise depth clipping is only enabled when 'VkPipelineRasterizationStateCreateInfo'::'depthClampEnable' is set to 'VK_FALSE'.
     */
    depthClipEnable?: boolean;
}

declare interface VkPhysicalDeviceDepthClipEnableFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceDepthClipEnableFeaturesEXT;
  new(param?: VkPhysicalDeviceDepthClipEnableFeaturesEXTInitializer | null): VkPhysicalDeviceDepthClipEnableFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDepthClipEnableFeaturesEXT: VkPhysicalDeviceDepthClipEnableFeaturesEXTConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    uniformBufferStandardLayout: boolean;

}

declare interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    uniformBufferStandardLayout?: boolean;
}

declare interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR;
  new(param?: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRInitializer | null): VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRConstructor;



  /**
   * Structure indicating support for std430-like packing in uniform buffers
   */
interface VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    uniformBufferStandardLayout: boolean;

}

declare interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    uniformBufferStandardLayout?: boolean;
}

declare interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceUniformBufferStandardLayoutFeatures;
  new(param?: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesInitializer | null): VkPhysicalDeviceUniformBufferStandardLayoutFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceUniformBufferStandardLayoutFeatures: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesConstructor;



  /**
   * Structure describing capability of a surface to be protected
   */
interface VkSurfaceProtectedCapabilitiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies whether a protected swapchain created from 'VkPhysicalDeviceSurfaceInfo2KHR'::'surface' for a particular windowing system 'can' be displayed on screen or not. If 'supportsProtected' is 'VK_TRUE', then creation of swapchains with the 'VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR' flag set 'must' be supported for 'surface'.
     */
    supportsProtected: boolean;

}

declare interface VkSurfaceProtectedCapabilitiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies whether a protected swapchain created from 'VkPhysicalDeviceSurfaceInfo2KHR'::'surface' for a particular windowing system 'can' be displayed on screen or not. If 'supportsProtected' is 'VK_TRUE', then creation of swapchains with the 'VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR' flag set 'must' be supported for 'surface'.
     */
    supportsProtected?: boolean;
}

declare interface VkSurfaceProtectedCapabilitiesKHRConstructor {
  readonly prototype: VkSurfaceProtectedCapabilitiesKHR;
  new(param?: VkSurfaceProtectedCapabilitiesKHRInitializer | null): VkSurfaceProtectedCapabilitiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSurfaceProtectedCapabilitiesKHR: VkSurfaceProtectedCapabilitiesKHRConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceScalarBlockLayoutFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    scalarBlockLayout: boolean;

}

declare interface VkPhysicalDeviceScalarBlockLayoutFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    scalarBlockLayout?: boolean;
}

declare interface VkPhysicalDeviceScalarBlockLayoutFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceScalarBlockLayoutFeaturesEXT;
  new(param?: VkPhysicalDeviceScalarBlockLayoutFeaturesEXTInitializer | null): VkPhysicalDeviceScalarBlockLayoutFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceScalarBlockLayoutFeaturesEXT: VkPhysicalDeviceScalarBlockLayoutFeaturesEXTConstructor;



  /**
   * Structure indicating support for scalar block layouts
   */
interface VkPhysicalDeviceScalarBlockLayoutFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    scalarBlockLayout: boolean;

}

declare interface VkPhysicalDeviceScalarBlockLayoutFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    scalarBlockLayout?: boolean;
}

declare interface VkPhysicalDeviceScalarBlockLayoutFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceScalarBlockLayoutFeatures;
  new(param?: VkPhysicalDeviceScalarBlockLayoutFeaturesInitializer | null): VkPhysicalDeviceScalarBlockLayoutFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceScalarBlockLayoutFeatures: VkPhysicalDeviceScalarBlockLayoutFeaturesConstructor;



  /**
   * Structure containing fragment density map attachment for render pass
   */
interface VkRenderPassFragmentDensityMapCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the fragment density map to use for the render pass.
     */
    fragmentDensityMapAttachment: VkAttachmentReference | null;

}

declare interface VkRenderPassFragmentDensityMapCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the fragment density map to use for the render pass.
     */
    fragmentDensityMapAttachment?: VkAttachmentReference | null;
}

declare interface VkRenderPassFragmentDensityMapCreateInfoEXTConstructor {
  readonly prototype: VkRenderPassFragmentDensityMapCreateInfoEXT;
  new(param?: VkRenderPassFragmentDensityMapCreateInfoEXTInitializer | null): VkRenderPassFragmentDensityMapCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassFragmentDensityMapCreateInfoEXT: VkRenderPassFragmentDensityMapCreateInfoEXTConstructor;



  /**
   * Structure describing additional fragment density map properties that can be supported by an implementation
   */
interface VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     * specifies if performing image data read with load operations on subsampled attachments will be resampled to the fragment density of the render pass
     */
    readonly subsampledLoads: boolean;

    /**
     *
     */
    readonly subsampledCoarseReconstructionEarlyAccess: boolean;

    /**
     *
     */
    readonly maxSubsampledArrayLayers: number;

    /**
     *
     */
    readonly maxDescriptorSetSubsampledSamplers: number;

}

declare interface VkPhysicalDeviceFragmentDensityMap2PropertiesEXTInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     * specifies if performing image data read with load operations on subsampled attachments will be resampled to the fragment density of the render pass
     */
    readonly subsampledLoads?: boolean;

    /**
     *
     */
    readonly subsampledCoarseReconstructionEarlyAccess?: boolean;

    /**
     *
     */
    readonly maxSubsampledArrayLayers?: number;

    /**
     *
     */
    readonly maxDescriptorSetSubsampledSamplers?: number;
}

declare interface VkPhysicalDeviceFragmentDensityMap2PropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceFragmentDensityMap2PropertiesEXT;
  new(param?: VkPhysicalDeviceFragmentDensityMap2PropertiesEXTInitializer | null): VkPhysicalDeviceFragmentDensityMap2PropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentDensityMap2PropertiesEXT: VkPhysicalDeviceFragmentDensityMap2PropertiesEXTConstructor;



  /**
   * Structure describing fragment density map properties that can be supported by an implementation
   */
interface VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     * is the minimum <<glossary-fragment-density-texel-size,fragment density texel size>>.
     */
    readonly minFragmentDensityTexelSize: VkExtent2D | null;

    /**
     *
     */
    readonly maxFragmentDensityTexelSize: VkExtent2D | null;

    /**
     *
     */
    readonly fragmentDensityInvocations: boolean;

}

declare interface VkPhysicalDeviceFragmentDensityMapPropertiesEXTInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     * is the minimum <<glossary-fragment-density-texel-size,fragment density texel size>>.
     */
    readonly minFragmentDensityTexelSize?: VkExtent2D | null;

    /**
     *
     */
    readonly maxFragmentDensityTexelSize?: VkExtent2D | null;

    /**
     *
     */
    readonly fragmentDensityInvocations?: boolean;
}

declare interface VkPhysicalDeviceFragmentDensityMapPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceFragmentDensityMapPropertiesEXT;
  new(param?: VkPhysicalDeviceFragmentDensityMapPropertiesEXTInitializer | null): VkPhysicalDeviceFragmentDensityMapPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentDensityMapPropertiesEXT: VkPhysicalDeviceFragmentDensityMapPropertiesEXTConstructor;



  /**
   * Structure describing additional fragment density map features that can be supported by an implementation
   */
interface VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * specifies whether the implementation supports deferred reads of fragment density map image views. If this feature is not enabled, 'VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT' 'must' not be included in 'VkImageViewCreateInfo'::'flags'.
     */
    fragmentDensityMapDeferred: boolean;

}

declare interface VkPhysicalDeviceFragmentDensityMap2FeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * specifies whether the implementation supports deferred reads of fragment density map image views. If this feature is not enabled, 'VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT' 'must' not be included in 'VkImageViewCreateInfo'::'flags'.
     */
    fragmentDensityMapDeferred?: boolean;
}

declare interface VkPhysicalDeviceFragmentDensityMap2FeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceFragmentDensityMap2FeaturesEXT;
  new(param?: VkPhysicalDeviceFragmentDensityMap2FeaturesEXTInitializer | null): VkPhysicalDeviceFragmentDensityMap2FeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentDensityMap2FeaturesEXT: VkPhysicalDeviceFragmentDensityMap2FeaturesEXTConstructor;



  /**
   * Structure describing fragment density map features that can be supported by an implementation
   */
interface VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * specifies whether the implementation supports render passes with a fragment density map attachment. If this feature is not enabled and the 'pNext' chain of 'VkRenderPassCreateInfo' includes a 'VkRenderPassFragmentDensityMapCreateInfoEXT' structure, 'fragmentDensityMapAttachment' 'must' be 'VK_ATTACHMENT_UNUSED'.
     */
    fragmentDensityMap: boolean;

    /**
     * specifies whether the implementation supports dynamic fragment density map image views. If this feature is not enabled, 'VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT' 'must' not be included in 'VkImageViewCreateInfo'::'flags'.
     */
    fragmentDensityMapDynamic: boolean;

    /**
     * specifies whether the implementation supports regular non-subsampled image attachments with fragment density map render passes. If this feature is not enabled, render passes with a <<renderpass-fragmentdensitymapattachment,fragment density map attachment>> 'must' only have <<samplers-subsamplesampler,subsampled attachments>> bound.
     */
    fragmentDensityMapNonSubsampledImages: boolean;

}

declare interface VkPhysicalDeviceFragmentDensityMapFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * specifies whether the implementation supports render passes with a fragment density map attachment. If this feature is not enabled and the 'pNext' chain of 'VkRenderPassCreateInfo' includes a 'VkRenderPassFragmentDensityMapCreateInfoEXT' structure, 'fragmentDensityMapAttachment' 'must' be 'VK_ATTACHMENT_UNUSED'.
     */
    fragmentDensityMap?: boolean;

    /**
     * specifies whether the implementation supports dynamic fragment density map image views. If this feature is not enabled, 'VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT' 'must' not be included in 'VkImageViewCreateInfo'::'flags'.
     */
    fragmentDensityMapDynamic?: boolean;

    /**
     * specifies whether the implementation supports regular non-subsampled image attachments with fragment density map render passes. If this feature is not enabled, render passes with a <<renderpass-fragmentdensitymapattachment,fragment density map attachment>> 'must' only have <<samplers-subsamplesampler,subsampled attachments>> bound.
     */
    fragmentDensityMapNonSubsampledImages?: boolean;
}

declare interface VkPhysicalDeviceFragmentDensityMapFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceFragmentDensityMapFeaturesEXT;
  new(param?: VkPhysicalDeviceFragmentDensityMapFeaturesEXTInitializer | null): VkPhysicalDeviceFragmentDensityMapFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentDensityMapFeaturesEXT: VkPhysicalDeviceFragmentDensityMapFeaturesEXTConstructor;



  /**
   * Specify memory overallocation behavior for a Vulkan device
   */
interface VkDeviceMemoryOverallocationCreateInfoAMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the desired overallocation behavior.
     */
    overallocationBehavior: VkMemoryOverallocationBehaviorAMD;

}

declare interface VkDeviceMemoryOverallocationCreateInfoAMDInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the desired overallocation behavior.
     */
    overallocationBehavior?: VkMemoryOverallocationBehaviorAMD;
}

declare interface VkDeviceMemoryOverallocationCreateInfoAMDConstructor {
  readonly prototype: VkDeviceMemoryOverallocationCreateInfoAMD;
  new(param?: VkDeviceMemoryOverallocationCreateInfoAMDInitializer | null): VkDeviceMemoryOverallocationCreateInfoAMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceMemoryOverallocationCreateInfoAMD: VkDeviceMemoryOverallocationCreateInfoAMDConstructor;



  /**
   * 
   */
interface VkImageStencilUsageCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    stencilUsage: VkImageUsageFlagBits;

}

declare interface VkImageStencilUsageCreateInfoEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    stencilUsage?: VkImageUsageFlagBits;
}

declare interface VkImageStencilUsageCreateInfoEXTConstructor {
  readonly prototype: VkImageStencilUsageCreateInfoEXT;
  new(param?: VkImageStencilUsageCreateInfoEXTInitializer | null): VkImageStencilUsageCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageStencilUsageCreateInfoEXT: VkImageStencilUsageCreateInfoEXTConstructor;



  /**
   * Specify separate usage flags for the stencil aspect of a depth-stencil image
   */
interface VkImageStencilUsageCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    stencilUsage: VkImageUsageFlagBits;

}

declare interface VkImageStencilUsageCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    stencilUsage?: VkImageUsageFlagBits;
}

declare interface VkImageStencilUsageCreateInfoConstructor {
  readonly prototype: VkImageStencilUsageCreateInfo;
  new(param?: VkImageStencilUsageCreateInfoInitializer | null): VkImageStencilUsageCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageStencilUsageCreateInfo: VkImageStencilUsageCreateInfoConstructor;



  /**
   * Properties of an image\
   */
interface VkImageDrmFormatModifierPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * returns the image's <<glossary-drm-format-modifier,Linux DRM format modifier>>.
     */
    readonly drmFormatModifier: bigint | number;

}

declare interface VkImageDrmFormatModifierPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * returns the image's <<glossary-drm-format-modifier,Linux DRM format modifier>>.
     */
    readonly drmFormatModifier?: bigint | number;
}

declare interface VkImageDrmFormatModifierPropertiesEXTConstructor {
  readonly prototype: VkImageDrmFormatModifierPropertiesEXT;
  new(param?: VkImageDrmFormatModifierPropertiesEXTInitializer | null): VkImageDrmFormatModifierPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageDrmFormatModifierPropertiesEXT: VkImageDrmFormatModifierPropertiesEXTConstructor;



  /**
   * Specify that an image be created with the provided DRM format modifier and explicit memory layout
   */
interface VkImageDrmFormatModifierExplicitCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the _Linux DRM format modifier_ with which the image will be created.
     */
    drmFormatModifier: bigint | number;

    /**
     * is the number of _memory planes_ in the image (as reported by 'VkDrmFormatModifierPropertiesEXT') as well as the length of the 'pPlaneLayouts' array.
     */
    drmFormatModifierPlaneCount: number;

    /**
     * is an array of 'VkSubresourceLayout' structures describing the image's _memory planes_.
     */
    pPlaneLayouts: VkSubresourceLayout[] | null;

}

declare interface VkImageDrmFormatModifierExplicitCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the _Linux DRM format modifier_ with which the image will be created.
     */
    drmFormatModifier?: bigint | number;

    /**
     * is the number of _memory planes_ in the image (as reported by 'VkDrmFormatModifierPropertiesEXT') as well as the length of the 'pPlaneLayouts' array.
     */
    drmFormatModifierPlaneCount?: number;

    /**
     * is an array of 'VkSubresourceLayout' structures describing the image's _memory planes_.
     */
    pPlaneLayouts?: VkSubresourceLayout[] | null;
}

declare interface VkImageDrmFormatModifierExplicitCreateInfoEXTConstructor {
  readonly prototype: VkImageDrmFormatModifierExplicitCreateInfoEXT;
  new(param?: VkImageDrmFormatModifierExplicitCreateInfoEXTInitializer | null): VkImageDrmFormatModifierExplicitCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageDrmFormatModifierExplicitCreateInfoEXT: VkImageDrmFormatModifierExplicitCreateInfoEXTConstructor;



  /**
   * Specify that an image must be created with a DRM format modifier from the provided list
   */
interface VkImageDrmFormatModifierListCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the length of the 'pDrmFormatModifiers' array.
     */
    drmFormatModifierCount: number;

    /**
     * is an array of _Linux DRM format modifiers_.
     */
    pDrmFormatModifiers: BigUint64Array | null;

}

declare interface VkImageDrmFormatModifierListCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the length of the 'pDrmFormatModifiers' array.
     */
    drmFormatModifierCount?: number;

    /**
     * is an array of _Linux DRM format modifiers_.
     */
    pDrmFormatModifiers?: BigUint64Array | null;
}

declare interface VkImageDrmFormatModifierListCreateInfoEXTConstructor {
  readonly prototype: VkImageDrmFormatModifierListCreateInfoEXT;
  new(param?: VkImageDrmFormatModifierListCreateInfoEXTInitializer | null): VkImageDrmFormatModifierListCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageDrmFormatModifierListCreateInfoEXT: VkImageDrmFormatModifierListCreateInfoEXTConstructor;



  /**
   * Structure specifying a DRM format modifier as image creation parameter
   */
interface VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the image's _Linux DRM format modifier_, corresponding to 'VkImageDrmFormatModifierExplicitCreateInfoEXT'::'modifier' or to 'VkImageDrmFormatModifierListCreateInfoEXT'::'pModifiers'.
     */
    drmFormatModifier: bigint | number;

    /**
     * specifies how the image will be accessed by multiple queue families.
     */
    sharingMode: VkSharingMode;

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount: number;

    /**
     * is a list of queue families that will access the image (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices: Uint32Array | null;

}

declare interface VkPhysicalDeviceImageDrmFormatModifierInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the image's _Linux DRM format modifier_, corresponding to 'VkImageDrmFormatModifierExplicitCreateInfoEXT'::'modifier' or to 'VkImageDrmFormatModifierListCreateInfoEXT'::'pModifiers'.
     */
    drmFormatModifier?: bigint | number;

    /**
     * specifies how the image will be accessed by multiple queue families.
     */
    sharingMode?: VkSharingMode;

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount?: number;

    /**
     * is a list of queue families that will access the image (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices?: Uint32Array | null;
}

declare interface VkPhysicalDeviceImageDrmFormatModifierInfoEXTConstructor {
  readonly prototype: VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
  new(param?: VkPhysicalDeviceImageDrmFormatModifierInfoEXTInitializer | null): VkPhysicalDeviceImageDrmFormatModifierInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceImageDrmFormatModifierInfoEXT: VkPhysicalDeviceImageDrmFormatModifierInfoEXTConstructor;



  /**
   * Structure specifying properties of a format when combined with a DRM format modifier
   */
interface VkDrmFormatModifierPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a _Linux DRM format modifier_.
     */
    readonly drmFormatModifier: bigint | number;

    /**
     * is the number of _memory planes_ in any image created with 'format' and 'drmFormatModifier'. An image's _memory planecount_ is distinct from its _format planecount_, as explained below.
     */
    readonly drmFormatModifierPlaneCount: number;

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' that are supported by any image created with 'format' and 'drmFormatModifier'.
     */
    readonly drmFormatModifierTilingFeatures: VkFormatFeatureFlagBits;

}

declare interface VkDrmFormatModifierPropertiesEXTInitializer {
  
    /**
     * is a _Linux DRM format modifier_.
     */
    readonly drmFormatModifier?: bigint | number;

    /**
     * is the number of _memory planes_ in any image created with 'format' and 'drmFormatModifier'. An image's _memory planecount_ is distinct from its _format planecount_, as explained below.
     */
    readonly drmFormatModifierPlaneCount?: number;

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' that are supported by any image created with 'format' and 'drmFormatModifier'.
     */
    readonly drmFormatModifierTilingFeatures?: VkFormatFeatureFlagBits;
}

declare interface VkDrmFormatModifierPropertiesEXTConstructor {
  readonly prototype: VkDrmFormatModifierPropertiesEXT;
  new(param?: VkDrmFormatModifierPropertiesEXTInitializer | null): VkDrmFormatModifierPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDrmFormatModifierPropertiesEXT: VkDrmFormatModifierPropertiesEXTConstructor;



  /**
   * Structure specifying the list of DRM format modifiers supported for a format
   */
interface VkDrmFormatModifierPropertiesListEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is an inout parameter related to the number of modifiers compatible with the 'format', as described below.
     */
    readonly drmFormatModifierCount: number;

    /**
     * is either <i>null</i> or an array of 'VkDrmFormatModifierPropertiesEXT' structures.
     */
    readonly pDrmFormatModifierProperties: VkDrmFormatModifierPropertiesEXT[] | null;

}

declare interface VkDrmFormatModifierPropertiesListEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is an inout parameter related to the number of modifiers compatible with the 'format', as described below.
     */
    readonly drmFormatModifierCount?: number;

    /**
     * is either <i>null</i> or an array of 'VkDrmFormatModifierPropertiesEXT' structures.
     */
    readonly pDrmFormatModifierProperties?: VkDrmFormatModifierPropertiesEXT[] | null;
}

declare interface VkDrmFormatModifierPropertiesListEXTConstructor {
  readonly prototype: VkDrmFormatModifierPropertiesListEXT;
  new(param?: VkDrmFormatModifierPropertiesListEXTInitializer | null): VkDrmFormatModifierPropertiesListEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDrmFormatModifierPropertiesListEXT: VkDrmFormatModifierPropertiesListEXTConstructor;



  /**
   * Structure specifying the parameters of an indirect trace ray command
   */
interface VkTraceRaysIndirectCommandKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the width of the ray trace query dimensions.
     */
    width: number;

    /**
     * is height of the ray trace query dimensions.
     */
    height: number;

    /**
     * is depth of the ray trace query dimensions.
     */
    depth: number;

}

declare interface VkTraceRaysIndirectCommandKHRInitializer {
  
    /**
     * is the width of the ray trace query dimensions.
     */
    width?: number;

    /**
     * is height of the ray trace query dimensions.
     */
    height?: number;

    /**
     * is depth of the ray trace query dimensions.
     */
    depth?: number;
}

declare interface VkTraceRaysIndirectCommandKHRConstructor {
  readonly prototype: VkTraceRaysIndirectCommandKHR;
  new(param?: VkTraceRaysIndirectCommandKHRInitializer | null): VkTraceRaysIndirectCommandKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkTraceRaysIndirectCommandKHR: VkTraceRaysIndirectCommandKHRConstructor;



  /**
   * Structure specifying a region of device addresses with a stride
   */
interface VkStridedDeviceAddressRegionKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the device address (as returned by the 'vkGetBufferDeviceAddress' command) at which the region starts.
     */
    deviceAddress: bigint | number;

    /**
     * is the byte stride between consecutive elements.
     */
    stride: bigint | number;

    /**
     * is the size in bytes of the region starting at 'deviceAddress'.
     */
    size: bigint | number;

}

declare interface VkStridedDeviceAddressRegionKHRInitializer {
  
    /**
     * is the device address (as returned by the 'vkGetBufferDeviceAddress' command) at which the region starts.
     */
    deviceAddress?: bigint | number;

    /**
     * is the byte stride between consecutive elements.
     */
    stride?: bigint | number;

    /**
     * is the size in bytes of the region starting at 'deviceAddress'.
     */
    size?: bigint | number;
}

declare interface VkStridedDeviceAddressRegionKHRConstructor {
  readonly prototype: VkStridedDeviceAddressRegionKHR;
  new(param?: VkStridedDeviceAddressRegionKHRInitializer | null): VkStridedDeviceAddressRegionKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkStridedDeviceAddressRegionKHR: VkStridedDeviceAddressRegionKHRConstructor;



  /**
   * Properties of the physical device for ray tracing
   */
interface VkPhysicalDeviceRayTracingPropertiesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * size in bytes of the shader header.
     */
    readonly shaderGroupHandleSize: number;

    /**
     * is the maximum number of levels of recursion allowed in a trace command.
     */
    readonly maxRecursionDepth: number;

    /**
     * is the maximum stride in bytes allowed between shader groups in the shader binding table.
     */
    readonly maxShaderGroupStride: number;

    /**
     * is the 'required' alignment in bytes for the base of the shader binding table.
     */
    readonly shaderGroupBaseAlignment: number;

    /**
     * is the maximum number of geometries in the bottom level acceleration structure.
     */
    readonly maxGeometryCount: bigint | number;

    /**
     * is the maximum number of instances in the top level acceleration structure.
     */
    readonly maxInstanceCount: bigint | number;

    /**
     * is the maximum number of triangles in all geometries in the bottom level acceleration structure.
     */
    readonly maxTriangleCount: bigint | number;

    /**
     * is the maximum number of acceleration structure descriptors that are allowed in a descriptor set.
     */
    readonly maxDescriptorSetAccelerationStructures: number;

}

declare interface VkPhysicalDeviceRayTracingPropertiesNVInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * size in bytes of the shader header.
     */
    readonly shaderGroupHandleSize?: number;

    /**
     * is the maximum number of levels of recursion allowed in a trace command.
     */
    readonly maxRecursionDepth?: number;

    /**
     * is the maximum stride in bytes allowed between shader groups in the shader binding table.
     */
    readonly maxShaderGroupStride?: number;

    /**
     * is the 'required' alignment in bytes for the base of the shader binding table.
     */
    readonly shaderGroupBaseAlignment?: number;

    /**
     * is the maximum number of geometries in the bottom level acceleration structure.
     */
    readonly maxGeometryCount?: bigint | number;

    /**
     * is the maximum number of instances in the top level acceleration structure.
     */
    readonly maxInstanceCount?: bigint | number;

    /**
     * is the maximum number of triangles in all geometries in the bottom level acceleration structure.
     */
    readonly maxTriangleCount?: bigint | number;

    /**
     * is the maximum number of acceleration structure descriptors that are allowed in a descriptor set.
     */
    readonly maxDescriptorSetAccelerationStructures?: number;
}

declare interface VkPhysicalDeviceRayTracingPropertiesNVConstructor {
  readonly prototype: VkPhysicalDeviceRayTracingPropertiesNV;
  new(param?: VkPhysicalDeviceRayTracingPropertiesNVInitializer | null): VkPhysicalDeviceRayTracingPropertiesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceRayTracingPropertiesNV: VkPhysicalDeviceRayTracingPropertiesNVConstructor;



  /**
   * Properties of the physical device for ray tracing
   */
interface VkPhysicalDeviceRayTracingPipelinePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * size in bytes of the shader header.
     */
    readonly shaderGroupHandleSize: number;

    /**
     * is the maximum number of levels of ray recursion allowed in a trace command.
     */
    readonly maxRayRecursionDepth: number;

    /**
     * is the maximum stride in bytes allowed between shader groups in the shader binding table.
     */
    readonly maxShaderGroupStride: number;

    /**
     * is the 'required' alignment in bytes for the base of the shader binding table.
     */
    readonly shaderGroupBaseAlignment: number;

    /**
     * is the number of bytes for the information required to do capture and replay for shader group handles.
     */
    readonly shaderGroupHandleCaptureReplaySize: number;

    /**
     * is the maximum number of ray generation shader invocations which 'may' be produced by a single 'vkCmdTraceRaysIndirectKHR' or 'vkCmdTraceRaysKHR' command.
     */
    readonly maxRayDispatchInvocationCount: number;

    /**
     * is the 'required' alignment in bytes for each shader binding table entry.
     */
    readonly shaderGroupHandleAlignment: number;

    /**
     * is the maximum size in bytes for a ray attribute structure
     */
    readonly maxRayHitAttributeSize: number;

}

declare interface VkPhysicalDeviceRayTracingPipelinePropertiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * size in bytes of the shader header.
     */
    readonly shaderGroupHandleSize?: number;

    /**
     * is the maximum number of levels of ray recursion allowed in a trace command.
     */
    readonly maxRayRecursionDepth?: number;

    /**
     * is the maximum stride in bytes allowed between shader groups in the shader binding table.
     */
    readonly maxShaderGroupStride?: number;

    /**
     * is the 'required' alignment in bytes for the base of the shader binding table.
     */
    readonly shaderGroupBaseAlignment?: number;

    /**
     * is the number of bytes for the information required to do capture and replay for shader group handles.
     */
    readonly shaderGroupHandleCaptureReplaySize?: number;

    /**
     * is the maximum number of ray generation shader invocations which 'may' be produced by a single 'vkCmdTraceRaysIndirectKHR' or 'vkCmdTraceRaysKHR' command.
     */
    readonly maxRayDispatchInvocationCount?: number;

    /**
     * is the 'required' alignment in bytes for each shader binding table entry.
     */
    readonly shaderGroupHandleAlignment?: number;

    /**
     * is the maximum size in bytes for a ray attribute structure
     */
    readonly maxRayHitAttributeSize?: number;
}

declare interface VkPhysicalDeviceRayTracingPipelinePropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceRayTracingPipelinePropertiesKHR;
  new(param?: VkPhysicalDeviceRayTracingPipelinePropertiesKHRInitializer | null): VkPhysicalDeviceRayTracingPipelinePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceRayTracingPipelinePropertiesKHR: VkPhysicalDeviceRayTracingPipelinePropertiesKHRConstructor;



  /**
   * Properties of the physical device for acceleration structure
   */
interface VkPhysicalDeviceAccelerationStructurePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the maximum number of geometries in the bottom level acceleration structure.
     */
    readonly maxGeometryCount: bigint | number;

    /**
     * is the maximum number of instances in the top level acceleration structure.
     */
    readonly maxInstanceCount: bigint | number;

    /**
     * is the maximum number of triangles or AABBs in all geometries in the bottom level acceleration structure.
     */
    readonly maxPrimitiveCount: bigint | number;

    /**
     * is the maximum number of acceleration structure bindings that 'can' be accessible to a single shader stage in a pipeline layout. Descriptor bindings with a descriptor type of 'VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR' count against this limit. Only descriptor bindings in descriptor set layouts created without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT' bit set count against this limit.
     */
    readonly maxPerStageDescriptorAccelerationStructures: number;

    /**
     * is similar to 'maxPerStageDescriptorAccelerationStructures' but counts descriptor bindings from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindAccelerationStructures: number;

    /**
     * is the maximum number of acceleration structure descriptors that 'can' be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptor bindings with a descriptor type of 'VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR' count against this limit. Only descriptor bindings in descriptor set layouts created without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT' bit set count against this limit.
     */
    readonly maxDescriptorSetAccelerationStructures: number;

    /**
     * is similar to 'maxDescriptorSetAccelerationStructures' but counts descriptor bindings from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindAccelerationStructures: number;

    /**
     * is the minimum 'required' alignment, in bytes, for scratch data passed in to an acceleration structure build command.
     */
    readonly minAccelerationStructureScratchOffsetAlignment: number;

}

declare interface VkPhysicalDeviceAccelerationStructurePropertiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the maximum number of geometries in the bottom level acceleration structure.
     */
    readonly maxGeometryCount?: bigint | number;

    /**
     * is the maximum number of instances in the top level acceleration structure.
     */
    readonly maxInstanceCount?: bigint | number;

    /**
     * is the maximum number of triangles or AABBs in all geometries in the bottom level acceleration structure.
     */
    readonly maxPrimitiveCount?: bigint | number;

    /**
     * is the maximum number of acceleration structure bindings that 'can' be accessible to a single shader stage in a pipeline layout. Descriptor bindings with a descriptor type of 'VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR' count against this limit. Only descriptor bindings in descriptor set layouts created without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT' bit set count against this limit.
     */
    readonly maxPerStageDescriptorAccelerationStructures?: number;

    /**
     * is similar to 'maxPerStageDescriptorAccelerationStructures' but counts descriptor bindings from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT' bit set.
     */
    readonly maxPerStageDescriptorUpdateAfterBindAccelerationStructures?: number;

    /**
     * is the maximum number of acceleration structure descriptors that 'can' be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptor bindings with a descriptor type of 'VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR' count against this limit. Only descriptor bindings in descriptor set layouts created without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT' bit set count against this limit.
     */
    readonly maxDescriptorSetAccelerationStructures?: number;

    /**
     * is similar to 'maxDescriptorSetAccelerationStructures' but counts descriptor bindings from descriptor sets created with or without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT' bit set.
     */
    readonly maxDescriptorSetUpdateAfterBindAccelerationStructures?: number;

    /**
     * is the minimum 'required' alignment, in bytes, for scratch data passed in to an acceleration structure build command.
     */
    readonly minAccelerationStructureScratchOffsetAlignment?: number;
}

declare interface VkPhysicalDeviceAccelerationStructurePropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceAccelerationStructurePropertiesKHR;
  new(param?: VkPhysicalDeviceAccelerationStructurePropertiesKHRInitializer | null): VkPhysicalDeviceAccelerationStructurePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceAccelerationStructurePropertiesKHR: VkPhysicalDeviceAccelerationStructurePropertiesKHRConstructor;



  /**
   * Structure describing the ray query features that can be supported by an implementation
   */
interface VkPhysicalDeviceRayQueryFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports ray query ('OpRayQueryProceedKHR') functionality.
     */
    rayQuery: boolean;

}

declare interface VkPhysicalDeviceRayQueryFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports ray query ('OpRayQueryProceedKHR') functionality.
     */
    rayQuery?: boolean;
}

declare interface VkPhysicalDeviceRayQueryFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceRayQueryFeaturesKHR;
  new(param?: VkPhysicalDeviceRayQueryFeaturesKHRInitializer | null): VkPhysicalDeviceRayQueryFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceRayQueryFeaturesKHR: VkPhysicalDeviceRayQueryFeaturesKHRConstructor;



  /**
   * Structure describing the ray tracing features that can be supported by an implementation
   */
interface VkPhysicalDeviceRayTracingPipelineFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports the ray tracing pipeline functionality. See <<ray-tracing,Ray Tracing>>.
     */
    rayTracingPipeline: boolean;

    /**
     * indicates whether the implementation supports saving and reusing shader group handles, e.g. for trace capture and replay.
     */
    rayTracingPipelineShaderGroupHandleCaptureReplay: boolean;

    /**
     * indicates whether the implementation supports reuse of shader group handles being arbitrarily mixed with creation of non-reused shader group handles. If this is 'VK_FALSE', all reused shader group handles 'must' be specified before any non-reused handles 'may' be created.
     */
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed: boolean;

    /**
     * indicates whether the implementation supports indirect trace ray commands, e.g. 'vkCmdTraceRaysIndirectKHR'.
     */
    rayTracingPipelineTraceRaysIndirect: boolean;

    /**
     * indicates whether the implementation supports <<ray-traversal-culling-primitive, primitive culling during ray traversal>>.
     */
    rayTraversalPrimitiveCulling: boolean;

}

declare interface VkPhysicalDeviceRayTracingPipelineFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports the ray tracing pipeline functionality. See <<ray-tracing,Ray Tracing>>.
     */
    rayTracingPipeline?: boolean;

    /**
     * indicates whether the implementation supports saving and reusing shader group handles, e.g. for trace capture and replay.
     */
    rayTracingPipelineShaderGroupHandleCaptureReplay?: boolean;

    /**
     * indicates whether the implementation supports reuse of shader group handles being arbitrarily mixed with creation of non-reused shader group handles. If this is 'VK_FALSE', all reused shader group handles 'must' be specified before any non-reused handles 'may' be created.
     */
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed?: boolean;

    /**
     * indicates whether the implementation supports indirect trace ray commands, e.g. 'vkCmdTraceRaysIndirectKHR'.
     */
    rayTracingPipelineTraceRaysIndirect?: boolean;

    /**
     * indicates whether the implementation supports <<ray-traversal-culling-primitive, primitive culling during ray traversal>>.
     */
    rayTraversalPrimitiveCulling?: boolean;
}

declare interface VkPhysicalDeviceRayTracingPipelineFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceRayTracingPipelineFeaturesKHR;
  new(param?: VkPhysicalDeviceRayTracingPipelineFeaturesKHRInitializer | null): VkPhysicalDeviceRayTracingPipelineFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceRayTracingPipelineFeaturesKHR: VkPhysicalDeviceRayTracingPipelineFeaturesKHRConstructor;



  /**
   * Structure describing the acceleration structure features that can be supported by an implementation
   */
interface VkPhysicalDeviceAccelerationStructureFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports the acceleration structure functionality. See <<acceleration-structure,Acceleration Structures>>.
     */
    accelerationStructure: boolean;

    /**
     * indicates whether the implementation supports saving and reusing acceleration structure device addresses, e.g. for trace capture and replay.
     */
    accelerationStructureCaptureReplay: boolean;

    /**
     * indicates whether the implementation supports indirect acceleration structure build commands, e.g. 'vkCmdBuildAccelerationStructuresIndirectKHR'.
     */
    accelerationStructureIndirectBuild: boolean;

    /**
     * indicates whether the implementation supports host side acceleration structure commands, e.g. 'vkBuildAccelerationStructuresKHR', 'vkCopyAccelerationStructureKHR', 'vkCopyAccelerationStructureToMemoryKHR', 'vkCopyMemoryToAccelerationStructureKHR', 'vkWriteAccelerationStructuresPropertiesKHR'.
     */
    accelerationStructureHostCommands: boolean;

    /**
     * indicates whether the implementation supports updating acceleration structure descriptors after a set is bound. If this feature is not enabled, 'VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT' 'must' not be used with 'VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR'.
     */
    descriptorBindingAccelerationStructureUpdateAfterBind: boolean;

}

declare interface VkPhysicalDeviceAccelerationStructureFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports the acceleration structure functionality. See <<acceleration-structure,Acceleration Structures>>.
     */
    accelerationStructure?: boolean;

    /**
     * indicates whether the implementation supports saving and reusing acceleration structure device addresses, e.g. for trace capture and replay.
     */
    accelerationStructureCaptureReplay?: boolean;

    /**
     * indicates whether the implementation supports indirect acceleration structure build commands, e.g. 'vkCmdBuildAccelerationStructuresIndirectKHR'.
     */
    accelerationStructureIndirectBuild?: boolean;

    /**
     * indicates whether the implementation supports host side acceleration structure commands, e.g. 'vkBuildAccelerationStructuresKHR', 'vkCopyAccelerationStructureKHR', 'vkCopyAccelerationStructureToMemoryKHR', 'vkCopyMemoryToAccelerationStructureKHR', 'vkWriteAccelerationStructuresPropertiesKHR'.
     */
    accelerationStructureHostCommands?: boolean;

    /**
     * indicates whether the implementation supports updating acceleration structure descriptors after a set is bound. If this feature is not enabled, 'VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT' 'must' not be used with 'VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR'.
     */
    descriptorBindingAccelerationStructureUpdateAfterBind?: boolean;
}

declare interface VkPhysicalDeviceAccelerationStructureFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceAccelerationStructureFeaturesKHR;
  new(param?: VkPhysicalDeviceAccelerationStructureFeaturesKHRInitializer | null): VkPhysicalDeviceAccelerationStructureFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceAccelerationStructureFeaturesKHR: VkPhysicalDeviceAccelerationStructureFeaturesKHRConstructor;



  /**
   * Structure specifying acceleration to query for memory requirements
   */
interface VkAccelerationStructureMemoryRequirementsInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * selects the type of memory requirement being queried. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV' returns the memory requirements for the object itself. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV' returns the memory requirements for the scratch memory when doing a build. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV' returns the memory requirements for the scratch memory when doing an update.
     */
    type: VkAccelerationStructureMemoryRequirementsTypeNV;

    /**
     * is the acceleration structure to be queried for memory requirements.
     */
    accelerationStructure: VkAccelerationStructureNV | null;

}

declare interface VkAccelerationStructureMemoryRequirementsInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * selects the type of memory requirement being queried. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV' returns the memory requirements for the object itself. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV' returns the memory requirements for the scratch memory when doing a build. 'VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV' returns the memory requirements for the scratch memory when doing an update.
     */
    type?: VkAccelerationStructureMemoryRequirementsTypeNV;

    /**
     * is the acceleration structure to be queried for memory requirements.
     */
    accelerationStructure?: VkAccelerationStructureNV | null;
}

declare interface VkAccelerationStructureMemoryRequirementsInfoNVConstructor {
  readonly prototype: VkAccelerationStructureMemoryRequirementsInfoNV;
  new(param?: VkAccelerationStructureMemoryRequirementsInfoNVInitializer | null): VkAccelerationStructureMemoryRequirementsInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureMemoryRequirementsInfoNV: VkAccelerationStructureMemoryRequirementsInfoNVConstructor;



  /**
   * Structure specifying acceleration structure descriptor info
   */
interface VkWriteDescriptorSetAccelerationStructureNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of elements in 'pAccelerationStructures'.
     */
    accelerationStructureCount: number;

    /**
     * are the acceleration structures to update.
     */
    pAccelerationStructures: VkAccelerationStructureNV[] | null;

}

declare interface VkWriteDescriptorSetAccelerationStructureNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of elements in 'pAccelerationStructures'.
     */
    accelerationStructureCount?: number;

    /**
     * are the acceleration structures to update.
     */
    pAccelerationStructures?: VkAccelerationStructureNV[] | null;
}

declare interface VkWriteDescriptorSetAccelerationStructureNVConstructor {
  readonly prototype: VkWriteDescriptorSetAccelerationStructureNV;
  new(param?: VkWriteDescriptorSetAccelerationStructureNVInitializer | null): VkWriteDescriptorSetAccelerationStructureNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkWriteDescriptorSetAccelerationStructureNV: VkWriteDescriptorSetAccelerationStructureNVConstructor;



  /**
   * Structure specifying acceleration structure descriptor info
   */
interface VkWriteDescriptorSetAccelerationStructureKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of elements in 'pAccelerationStructures'.
     */
    accelerationStructureCount: number;

    /**
     * are the acceleration structures to update.
     */
    pAccelerationStructures: VkAccelerationStructureKHR[] | null;

}

declare interface VkWriteDescriptorSetAccelerationStructureKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of elements in 'pAccelerationStructures'.
     */
    accelerationStructureCount?: number;

    /**
     * are the acceleration structures to update.
     */
    pAccelerationStructures?: VkAccelerationStructureKHR[] | null;
}

declare interface VkWriteDescriptorSetAccelerationStructureKHRConstructor {
  readonly prototype: VkWriteDescriptorSetAccelerationStructureKHR;
  new(param?: VkWriteDescriptorSetAccelerationStructureKHRInitializer | null): VkWriteDescriptorSetAccelerationStructureKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkWriteDescriptorSetAccelerationStructureKHR: VkWriteDescriptorSetAccelerationStructureKHRConstructor;



  /**
   * Structure specifying acceleration structure memory binding
   */
interface VkBindAccelerationStructureMemoryInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the acceleration structure to be attached to memory.
     */
    accelerationStructure: VkAccelerationStructureNV | null;

    /**
     * is a 'VkDeviceMemory' object describing the device memory to attach.
     */
    memory: VkDeviceMemory | null;

    /**
     * is the start offset of the region of memory that is to be bound to the acceleration structure. The number of bytes returned in the 'VkMemoryRequirements'::'size' member in 'memory', starting from 'memoryOffset' bytes, will be bound to the specified acceleration structure.
     */
    memoryOffset: bigint | number;

    /**
     * is the number of elements in 'pDeviceIndices'.
     */
    deviceIndexCount: number;

    /**
     * is an array of device indices.
     */
    pDeviceIndices: Uint32Array | null;

}

declare interface VkBindAccelerationStructureMemoryInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the acceleration structure to be attached to memory.
     */
    accelerationStructure?: VkAccelerationStructureNV | null;

    /**
     * is a 'VkDeviceMemory' object describing the device memory to attach.
     */
    memory?: VkDeviceMemory | null;

    /**
     * is the start offset of the region of memory that is to be bound to the acceleration structure. The number of bytes returned in the 'VkMemoryRequirements'::'size' member in 'memory', starting from 'memoryOffset' bytes, will be bound to the specified acceleration structure.
     */
    memoryOffset?: bigint | number;

    /**
     * is the number of elements in 'pDeviceIndices'.
     */
    deviceIndexCount?: number;

    /**
     * is an array of device indices.
     */
    pDeviceIndices?: Uint32Array | null;
}

declare interface VkBindAccelerationStructureMemoryInfoNVConstructor {
  readonly prototype: VkBindAccelerationStructureMemoryInfoNV;
  new(param?: VkBindAccelerationStructureMemoryInfoNVInitializer | null): VkBindAccelerationStructureMemoryInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindAccelerationStructureMemoryInfoNV: VkBindAccelerationStructureMemoryInfoNVConstructor;



  /**
   * Structure specifying the parameters of a newly created acceleration structure object
   */
interface VkAccelerationStructureCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the size from the result of 'vkCmdWriteAccelerationStructuresPropertiesNV' if this acceleration structure is going to be the target of a compacting copy.
     */
    compactedSize: bigint | number;

    /**
     * is the 'VkAccelerationStructureInfoNV' structure specifying further parameters of the created acceleration structure.
     */
    info: VkAccelerationStructureInfoNV | null;

}

declare interface VkAccelerationStructureCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the size from the result of 'vkCmdWriteAccelerationStructuresPropertiesNV' if this acceleration structure is going to be the target of a compacting copy.
     */
    compactedSize?: bigint | number;

    /**
     * is the 'VkAccelerationStructureInfoNV' structure specifying further parameters of the created acceleration structure.
     */
    info?: VkAccelerationStructureInfoNV | null;
}

declare interface VkAccelerationStructureCreateInfoNVConstructor {
  readonly prototype: VkAccelerationStructureCreateInfoNV;
  new(param?: VkAccelerationStructureCreateInfoNVInitializer | null): VkAccelerationStructureCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureCreateInfoNV: VkAccelerationStructureCreateInfoNVConstructor;



  /**
   * Structure specifying the parameters of acceleration structure object
   */
interface VkAccelerationStructureInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkAccelerationStructureTypeNV' value specifying the type of acceleration structure that will be created.
     */
    type: VkAccelerationStructureTypeNV;

    /**
     * is a bitmask of 'VkBuildAccelerationStructureFlagBitsNV' specifying additional parameters of the acceleration structure.
     */
    flags: VkBuildAccelerationStructureFlagsNV;

    /**
     * specifies the number of instances that will be in the new acceleration structure.
     */
    instanceCount: number;

    /**
     * 'VkGeometryNV' structures containing the scene data being passed into the acceleration structure.
     */
    geometryCount: number;

    /**
     *
     */
    pGeometries: VkGeometryNV[] | null;

}

declare interface VkAccelerationStructureInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkAccelerationStructureTypeNV' value specifying the type of acceleration structure that will be created.
     */
    type?: VkAccelerationStructureTypeNV;

    /**
     * is a bitmask of 'VkBuildAccelerationStructureFlagBitsNV' specifying additional parameters of the acceleration structure.
     */
    flags?: VkBuildAccelerationStructureFlagsNV;

    /**
     * specifies the number of instances that will be in the new acceleration structure.
     */
    instanceCount?: number;

    /**
     * 'VkGeometryNV' structures containing the scene data being passed into the acceleration structure.
     */
    geometryCount?: number;

    /**
     *
     */
    pGeometries?: VkGeometryNV[] | null;
}

declare interface VkAccelerationStructureInfoNVConstructor {
  readonly prototype: VkAccelerationStructureInfoNV;
  new(param?: VkAccelerationStructureInfoNVInitializer | null): VkAccelerationStructureInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureInfoNV: VkAccelerationStructureInfoNVConstructor;



  /**
   * Structure specifying a geometry in a bottom-level acceleration structure
   */
interface VkGeometryNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies the 'VkGeometryTypeKHR' which this geometry refers to.
     */
    geometryType: VkGeometryTypeKHR;

    /**
     * contains the geometry data as described in 'VkGeometryDataNV'.
     */
    geometry: VkGeometryDataNV | null;

    /**
     * has 'VkGeometryFlagBitsKHR' describing options for this geometry.
     */
    flags: VkGeometryFlagBitsKHR;

}

declare interface VkGeometryNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies the 'VkGeometryTypeKHR' which this geometry refers to.
     */
    geometryType?: VkGeometryTypeKHR;

    /**
     * contains the geometry data as described in 'VkGeometryDataNV'.
     */
    geometry?: VkGeometryDataNV | null;

    /**
     * has 'VkGeometryFlagBitsKHR' describing options for this geometry.
     */
    flags?: VkGeometryFlagBitsKHR;
}

declare interface VkGeometryNVConstructor {
  readonly prototype: VkGeometryNV;
  new(param?: VkGeometryNVInitializer | null): VkGeometryNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkGeometryNV: VkGeometryNVConstructor;



  /**
   * Structure specifying geometry in a bottom-level acceleration structure
   */
interface VkGeometryDataNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * contains triangle data if 'VkGeometryNV'::'geometryType' is 'VK_GEOMETRY_TYPE_TRIANGLES_NV'.
     */
    triangles: VkGeometryTrianglesNV | null;

    /**
     * contains axis-aligned bounding box data if 'VkGeometryNV'::'geometryType' is 'VK_GEOMETRY_TYPE_AABBS_NV'.
     */
    aabbs: VkGeometryAABBNV | null;

}

declare interface VkGeometryDataNVInitializer {
  
    /**
     * contains triangle data if 'VkGeometryNV'::'geometryType' is 'VK_GEOMETRY_TYPE_TRIANGLES_NV'.
     */
    triangles?: VkGeometryTrianglesNV | null;

    /**
     * contains axis-aligned bounding box data if 'VkGeometryNV'::'geometryType' is 'VK_GEOMETRY_TYPE_AABBS_NV'.
     */
    aabbs?: VkGeometryAABBNV | null;
}

declare interface VkGeometryDataNVConstructor {
  readonly prototype: VkGeometryDataNV;
  new(param?: VkGeometryDataNVInitializer | null): VkGeometryDataNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkGeometryDataNV: VkGeometryDataNVConstructor;



  /**
   * Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure
   */
interface VkGeometryAABBNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the buffer containing axis-aligned bounding box data.
     */
    aabbData: VkBuffer | null;

    /**
     * is the number of AABBs in this geometry.
     */
    numAABBs: number;

    /**
     *
     */
    stride: number;

    /**
     *
     */
    offset: bigint | number;

}

declare interface VkGeometryAABBNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the buffer containing axis-aligned bounding box data.
     */
    aabbData?: VkBuffer | null;

    /**
     * is the number of AABBs in this geometry.
     */
    numAABBs?: number;

    /**
     *
     */
    stride?: number;

    /**
     *
     */
    offset?: bigint | number;
}

declare interface VkGeometryAABBNVConstructor {
  readonly prototype: VkGeometryAABBNV;
  new(param?: VkGeometryAABBNVInitializer | null): VkGeometryAABBNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkGeometryAABBNV: VkGeometryAABBNVConstructor;



  /**
   * Structure specifying a triangle geometry in a bottom-level acceleration structure
   */
interface VkGeometryTrianglesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * containing vertex data for this geometry.
     */
    vertexData: VkBuffer | null;

    /**
     *
     */
    vertexOffset: bigint | number;

    /**
     * is the number of valid vertices.
     */
    vertexCount: number;

    /**
     * is the stride in bytes between each vertex.
     */
    vertexStride: bigint | number;

    /**
     * is a 'VkFormat' describing the format of each vertex element.
     */
    vertexFormat: VkFormat;

    /**
     * containing index data for this geometry.
     */
    indexData: VkBuffer | null;

    /**
     *
     */
    indexOffset: bigint | number;

    /**
     * is the number of indices to include in this geometry.
     */
    indexCount: number;

    /**
     * is a 'VkIndexType' describing the format of each index.
     */
    indexType: VkIndexType;

    /**
     * of the transform information described above.
     */
    transformData: VkBuffer | null;

    /**
     *
     */
    transformOffset: bigint | number;

}

declare interface VkGeometryTrianglesNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * containing vertex data for this geometry.
     */
    vertexData?: VkBuffer | null;

    /**
     *
     */
    vertexOffset?: bigint | number;

    /**
     * is the number of valid vertices.
     */
    vertexCount?: number;

    /**
     * is the stride in bytes between each vertex.
     */
    vertexStride?: bigint | number;

    /**
     * is a 'VkFormat' describing the format of each vertex element.
     */
    vertexFormat?: VkFormat;

    /**
     * containing index data for this geometry.
     */
    indexData?: VkBuffer | null;

    /**
     *
     */
    indexOffset?: bigint | number;

    /**
     * is the number of indices to include in this geometry.
     */
    indexCount?: number;

    /**
     * is a 'VkIndexType' describing the format of each index.
     */
    indexType?: VkIndexType;

    /**
     * of the transform information described above.
     */
    transformData?: VkBuffer | null;

    /**
     *
     */
    transformOffset?: bigint | number;
}

declare interface VkGeometryTrianglesNVConstructor {
  readonly prototype: VkGeometryTrianglesNV;
  new(param?: VkGeometryTrianglesNVInitializer | null): VkGeometryTrianglesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkGeometryTrianglesNV: VkGeometryTrianglesNVConstructor;



  /**
   * Structure specifying parameters of a newly created ray tracing pipeline
   */
interface VkRayTracingPipelineCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags: VkPipelineCreateFlagBits;

    /**
     * 'VkPipelineShaderStageCreateInfo' structures describing the set of the shader stages to be included in the ray tracing pipeline.
     */
    stageCount: number;

    /**
     * array.
     */
    pStages: VkPipelineShaderStageCreateInfo[] | null;

    /**
     * 'VkRayTracingShaderGroupCreateInfoKHR' structures describing the set of the shader stages to be included in each shader group in the ray tracing pipeline.
     */
    groupCount: number;

    /**
     * array.
     */
    pGroups: VkRayTracingShaderGroupCreateInfoKHR[] | null;

    /**
     * is the <<ray-tracing-recursion-depth, maximum recursion depth>> of shaders executed by this pipeline.
     */
    maxPipelineRayRecursionDepth: number;

    /**
     * is a reference to a 'VkPipelineLibraryCreateInfoKHR' structure defining pipeline libraries to include.
     */
    pLibraryInfo: VkPipelineLibraryCreateInfoKHR | null;

    /**
     * is a reference to a 'VkRayTracingPipelineInterfaceCreateInfoKHR' structure defining additional information when using pipeline libraries.
     */
    pLibraryInterface: VkRayTracingPipelineInterfaceCreateInfoKHR | null;

    /**
     * is a reference to a 'VkPipelineDynamicStateCreateInfo' structure, and is used to indicate which properties of the pipeline state object are dynamic and 'can' be changed independently of the pipeline state. This 'can' be <i>null</i>, which means no state in the pipeline is considered dynamic.
     */
    pDynamicState: VkPipelineDynamicStateCreateInfo | null;

    /**
     * is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
     */
    layout: VkPipelineLayout | null;

    /**
     * is a pipeline to derive from.
     */
    basePipelineHandle: VkPipeline | null;

    /**
     *
     */
    basePipelineIndex: number;

}

declare interface VkRayTracingPipelineCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags?: VkPipelineCreateFlagBits;

    /**
     * 'VkPipelineShaderStageCreateInfo' structures describing the set of the shader stages to be included in the ray tracing pipeline.
     */
    stageCount?: number;

    /**
     * array.
     */
    pStages?: VkPipelineShaderStageCreateInfo[] | null;

    /**
     * 'VkRayTracingShaderGroupCreateInfoKHR' structures describing the set of the shader stages to be included in each shader group in the ray tracing pipeline.
     */
    groupCount?: number;

    /**
     * array.
     */
    pGroups?: VkRayTracingShaderGroupCreateInfoKHR[] | null;

    /**
     * is the <<ray-tracing-recursion-depth, maximum recursion depth>> of shaders executed by this pipeline.
     */
    maxPipelineRayRecursionDepth?: number;

    /**
     * is a reference to a 'VkPipelineLibraryCreateInfoKHR' structure defining pipeline libraries to include.
     */
    pLibraryInfo?: VkPipelineLibraryCreateInfoKHR | null;

    /**
     * is a reference to a 'VkRayTracingPipelineInterfaceCreateInfoKHR' structure defining additional information when using pipeline libraries.
     */
    pLibraryInterface?: VkRayTracingPipelineInterfaceCreateInfoKHR | null;

    /**
     * is a reference to a 'VkPipelineDynamicStateCreateInfo' structure, and is used to indicate which properties of the pipeline state object are dynamic and 'can' be changed independently of the pipeline state. This 'can' be <i>null</i>, which means no state in the pipeline is considered dynamic.
     */
    pDynamicState?: VkPipelineDynamicStateCreateInfo | null;

    /**
     * is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
     */
    layout?: VkPipelineLayout | null;

    /**
     * is a pipeline to derive from.
     */
    basePipelineHandle?: VkPipeline | null;

    /**
     *
     */
    basePipelineIndex?: number;
}

declare interface VkRayTracingPipelineCreateInfoKHRConstructor {
  readonly prototype: VkRayTracingPipelineCreateInfoKHR;
  new(param?: VkRayTracingPipelineCreateInfoKHRInitializer | null): VkRayTracingPipelineCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRayTracingPipelineCreateInfoKHR: VkRayTracingPipelineCreateInfoKHRConstructor;



  /**
   * Structure specifying parameters of a newly created ray tracing pipeline
   */
interface VkRayTracingPipelineCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags: VkPipelineCreateFlagBits;

    /**
     * structures of type 'VkPipelineShaderStageCreateInfo' describing the set of the shader stages to be included in the ray tracing pipeline.
     */
    stageCount: number;

    /**
     * array.
     */
    pStages: VkPipelineShaderStageCreateInfo[] | null;

    /**
     * structures of type 'VkRayTracingShaderGroupCreateInfoNV' describing the set of the shader stages to be included in each shader group in the ray tracing pipeline.
     */
    groupCount: number;

    /**
     * array.
     */
    pGroups: VkRayTracingShaderGroupCreateInfoNV[] | null;

    /**
     * is the <<ray-tracing-recursion-depth, maximum recursion depth>> of shaders executed by this pipeline.
     */
    maxRecursionDepth: number;

    /**
     * is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
     */
    layout: VkPipelineLayout | null;

    /**
     * is a pipeline to derive from.
     */
    basePipelineHandle: VkPipeline | null;

    /**
     *
     */
    basePipelineIndex: number;

}

declare interface VkRayTracingPipelineCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags?: VkPipelineCreateFlagBits;

    /**
     * structures of type 'VkPipelineShaderStageCreateInfo' describing the set of the shader stages to be included in the ray tracing pipeline.
     */
    stageCount?: number;

    /**
     * array.
     */
    pStages?: VkPipelineShaderStageCreateInfo[] | null;

    /**
     * structures of type 'VkRayTracingShaderGroupCreateInfoNV' describing the set of the shader stages to be included in each shader group in the ray tracing pipeline.
     */
    groupCount?: number;

    /**
     * array.
     */
    pGroups?: VkRayTracingShaderGroupCreateInfoNV[] | null;

    /**
     * is the <<ray-tracing-recursion-depth, maximum recursion depth>> of shaders executed by this pipeline.
     */
    maxRecursionDepth?: number;

    /**
     * is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
     */
    layout?: VkPipelineLayout | null;

    /**
     * is a pipeline to derive from.
     */
    basePipelineHandle?: VkPipeline | null;

    /**
     *
     */
    basePipelineIndex?: number;
}

declare interface VkRayTracingPipelineCreateInfoNVConstructor {
  readonly prototype: VkRayTracingPipelineCreateInfoNV;
  new(param?: VkRayTracingPipelineCreateInfoNVInitializer | null): VkRayTracingPipelineCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRayTracingPipelineCreateInfoNV: VkRayTracingPipelineCreateInfoNVConstructor;



  /**
   * Structure specifying shaders in a shader group
   */
interface VkRayTracingShaderGroupCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the type of hit group specified in this structure.
     */
    type: VkRayTracingShaderGroupTypeKHR;

    /**
     * is the index of the ray generation, miss, or callable shader from 'VkRayTracingPipelineCreateInfoKHR'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR', and 'VK_SHADER_UNUSED_KHR' otherwise.
     */
    generalShader: number;

    /**
     * is the optional index of the closest hit shader from 'VkRayTracingPipelineCreateInfoKHR'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR', and 'VK_SHADER_UNUSED_KHR' otherwise.
     */
    closestHitShader: number;

    /**
     * is the optional index of the any-hit shader from 'VkRayTracingPipelineCreateInfoKHR'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR', and 'VK_SHADER_UNUSED_KHR' otherwise.
     */
    anyHitShader: number;

    /**
     * is the index of the intersection shader from 'VkRayTracingPipelineCreateInfoKHR'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR', and 'VK_SHADER_UNUSED_KHR' otherwise.
     */
    intersectionShader: number;

    /**
     * is an optional reference to replay information for this shader group. Ignored if 'VkPhysicalDeviceRayTracingPipelineFeaturesKHR'::'rayTracingPipelineShaderGroupHandleCaptureReplay' is 'VK_FALSE'.
     */
    pShaderGroupCaptureReplayHandle: ArrayBuffer | null;

}

declare interface VkRayTracingShaderGroupCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the type of hit group specified in this structure.
     */
    type?: VkRayTracingShaderGroupTypeKHR;

    /**
     * is the index of the ray generation, miss, or callable shader from 'VkRayTracingPipelineCreateInfoKHR'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR', and 'VK_SHADER_UNUSED_KHR' otherwise.
     */
    generalShader?: number;

    /**
     * is the optional index of the closest hit shader from 'VkRayTracingPipelineCreateInfoKHR'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR', and 'VK_SHADER_UNUSED_KHR' otherwise.
     */
    closestHitShader?: number;

    /**
     * is the optional index of the any-hit shader from 'VkRayTracingPipelineCreateInfoKHR'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR', and 'VK_SHADER_UNUSED_KHR' otherwise.
     */
    anyHitShader?: number;

    /**
     * is the index of the intersection shader from 'VkRayTracingPipelineCreateInfoKHR'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR', and 'VK_SHADER_UNUSED_KHR' otherwise.
     */
    intersectionShader?: number;

    /**
     * is an optional reference to replay information for this shader group. Ignored if 'VkPhysicalDeviceRayTracingPipelineFeaturesKHR'::'rayTracingPipelineShaderGroupHandleCaptureReplay' is 'VK_FALSE'.
     */
    pShaderGroupCaptureReplayHandle?: ArrayBuffer | null;
}

declare interface VkRayTracingShaderGroupCreateInfoKHRConstructor {
  readonly prototype: VkRayTracingShaderGroupCreateInfoKHR;
  new(param?: VkRayTracingShaderGroupCreateInfoKHRInitializer | null): VkRayTracingShaderGroupCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRayTracingShaderGroupCreateInfoKHR: VkRayTracingShaderGroupCreateInfoKHRConstructor;



  /**
   * Structure specifying shaders in a shader group
   */
interface VkRayTracingShaderGroupCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the type of hit group specified in this structure.
     */
    type: VkRayTracingShaderGroupTypeKHR;

    /**
     * is the index of the ray generation, miss, or callable shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV', and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    generalShader: number;

    /**
     * is the optional index of the closest hit shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV', and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    closestHitShader: number;

    /**
     * is the optional index of the any-hit shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV', and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    anyHitShader: number;

    /**
     * is the index of the intersection shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV', and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    intersectionShader: number;

}

declare interface VkRayTracingShaderGroupCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the type of hit group specified in this structure.
     */
    type?: VkRayTracingShaderGroupTypeKHR;

    /**
     * is the index of the ray generation, miss, or callable shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV', and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    generalShader?: number;

    /**
     * is the optional index of the closest hit shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV', and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    closestHitShader?: number;

    /**
     * is the optional index of the any-hit shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV' or 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV', and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    anyHitShader?: number;

    /**
     * is the index of the intersection shader from 'VkRayTracingPipelineCreateInfoNV'::'pStages' in the group if the shader group has 'type' of 'VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV', and 'VK_SHADER_UNUSED_NV' otherwise.
     */
    intersectionShader?: number;
}

declare interface VkRayTracingShaderGroupCreateInfoNVConstructor {
  readonly prototype: VkRayTracingShaderGroupCreateInfoNV;
  new(param?: VkRayTracingShaderGroupCreateInfoNVInitializer | null): VkRayTracingShaderGroupCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRayTracingShaderGroupCreateInfoNV: VkRayTracingShaderGroupCreateInfoNVConstructor;



  /**
   * Structure specifying a mesh tasks draw indirect command
   */
interface VkDrawMeshTasksIndirectCommandNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the number of local workgroups to dispatch in the X dimension. Y and Z dimension are implicitly set to one.
     */
    taskCount: number;

    /**
     * is the X component of the first workgroup ID.
     */
    firstTask: number;

}

declare interface VkDrawMeshTasksIndirectCommandNVInitializer {
  
    /**
     * is the number of local workgroups to dispatch in the X dimension. Y and Z dimension are implicitly set to one.
     */
    taskCount?: number;

    /**
     * is the X component of the first workgroup ID.
     */
    firstTask?: number;
}

declare interface VkDrawMeshTasksIndirectCommandNVConstructor {
  readonly prototype: VkDrawMeshTasksIndirectCommandNV;
  new(param?: VkDrawMeshTasksIndirectCommandNVInitializer | null): VkDrawMeshTasksIndirectCommandNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDrawMeshTasksIndirectCommandNV: VkDrawMeshTasksIndirectCommandNVConstructor;



  /**
   * Structure describing mesh shading properties
   */
interface VkPhysicalDeviceMeshShaderPropertiesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the maximum number of local workgroups that 'can' be launched by a single draw mesh tasks command. See <<drawing-mesh-shading>>.
     */
    readonly maxDrawMeshTasksCount: number;

    /**
     * is the maximum total number of task shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the 'LocalSize' execution mode in shader modules or by the object decorated by the 'WorkgroupSize' decoration, 'must' be less than or equal to this limit.
     */
    readonly maxTaskWorkGroupInvocations: number;

    /**
     *
     */
    readonly maxTaskWorkGroupSize: number[] | null;

    /**
     * is the maximum number of bytes that the task shader can use in total for shared and output memory combined.
     */
    readonly maxTaskTotalMemorySize: number;

    /**
     * is the maximum number of output tasks a single task shader workgroup can emit.
     */
    readonly maxTaskOutputCount: number;

    /**
     * is the maximum total number of mesh shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the 'LocalSize' execution mode in shader modules or by the object decorated by the 'WorkgroupSize' decoration, 'must' be less than or equal to this limit.
     */
    readonly maxMeshWorkGroupInvocations: number;

    /**
     *
     */
    readonly maxMeshWorkGroupSize: number[] | null;

    /**
     * is the maximum number of bytes that the mesh shader can use in total for shared and output memory combined.
     */
    readonly maxMeshTotalMemorySize: number;

    /**
     * is the maximum number of vertices a mesh shader output can store.
     */
    readonly maxMeshOutputVertices: number;

    /**
     * is the maximum number of primitives a mesh shader output can store.
     */
    readonly maxMeshOutputPrimitives: number;

    /**
     * is the maximum number of multi-view views a mesh shader can use.
     */
    readonly maxMeshMultiviewViewCount: number;

    /**
     * is the granularity with which mesh vertex outputs are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to 'maxMeshTotalMemorySize'.
     */
    readonly meshOutputPerVertexGranularity: number;

    /**
     * is the granularity with which mesh outputs qualified as per-primitive are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to 'maxMeshTotalMemorySize'.
     */
    readonly meshOutputPerPrimitiveGranularity: number;

}

declare interface VkPhysicalDeviceMeshShaderPropertiesNVInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the maximum number of local workgroups that 'can' be launched by a single draw mesh tasks command. See <<drawing-mesh-shading>>.
     */
    readonly maxDrawMeshTasksCount?: number;

    /**
     * is the maximum total number of task shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the 'LocalSize' execution mode in shader modules or by the object decorated by the 'WorkgroupSize' decoration, 'must' be less than or equal to this limit.
     */
    readonly maxTaskWorkGroupInvocations?: number;

    /**
     *
     */
    readonly maxTaskWorkGroupSize?: number[] | null;

    /**
     * is the maximum number of bytes that the task shader can use in total for shared and output memory combined.
     */
    readonly maxTaskTotalMemorySize?: number;

    /**
     * is the maximum number of output tasks a single task shader workgroup can emit.
     */
    readonly maxTaskOutputCount?: number;

    /**
     * is the maximum total number of mesh shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the 'LocalSize' execution mode in shader modules or by the object decorated by the 'WorkgroupSize' decoration, 'must' be less than or equal to this limit.
     */
    readonly maxMeshWorkGroupInvocations?: number;

    /**
     *
     */
    readonly maxMeshWorkGroupSize?: number[] | null;

    /**
     * is the maximum number of bytes that the mesh shader can use in total for shared and output memory combined.
     */
    readonly maxMeshTotalMemorySize?: number;

    /**
     * is the maximum number of vertices a mesh shader output can store.
     */
    readonly maxMeshOutputVertices?: number;

    /**
     * is the maximum number of primitives a mesh shader output can store.
     */
    readonly maxMeshOutputPrimitives?: number;

    /**
     * is the maximum number of multi-view views a mesh shader can use.
     */
    readonly maxMeshMultiviewViewCount?: number;

    /**
     * is the granularity with which mesh vertex outputs are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to 'maxMeshTotalMemorySize'.
     */
    readonly meshOutputPerVertexGranularity?: number;

    /**
     * is the granularity with which mesh outputs qualified as per-primitive are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to 'maxMeshTotalMemorySize'.
     */
    readonly meshOutputPerPrimitiveGranularity?: number;
}

declare interface VkPhysicalDeviceMeshShaderPropertiesNVConstructor {
  readonly prototype: VkPhysicalDeviceMeshShaderPropertiesNV;
  new(param?: VkPhysicalDeviceMeshShaderPropertiesNVInitializer | null): VkPhysicalDeviceMeshShaderPropertiesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMeshShaderPropertiesNV: VkPhysicalDeviceMeshShaderPropertiesNVConstructor;



  /**
   * Structure describing mesh shading features that can be supported by an implementation
   */
interface VkPhysicalDeviceMeshShaderFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the task shader stage is supported.
     */
    taskShader: boolean;

    /**
     * indicates whether the mesh shader stage is supported.
     */
    meshShader: boolean;

}

declare interface VkPhysicalDeviceMeshShaderFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the task shader stage is supported.
     */
    taskShader?: boolean;

    /**
     * indicates whether the mesh shader stage is supported.
     */
    meshShader?: boolean;
}

declare interface VkPhysicalDeviceMeshShaderFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceMeshShaderFeaturesNV;
  new(param?: VkPhysicalDeviceMeshShaderFeaturesNVInitializer | null): VkPhysicalDeviceMeshShaderFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMeshShaderFeaturesNV: VkPhysicalDeviceMeshShaderFeaturesNVConstructor;



  /**
   * Structure specifying parameters controlling sample order in coarse fragments
   */
interface VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies the mechanism used to order coverage samples in fragments larger than one pixel.
     */
    sampleOrderType: VkCoarseSampleOrderTypeNV;

    /**
     * specifies the number of custom sample orderings to use when ordering coverage samples.
     */
    customSampleOrderCount: number;

    /**
     * is an array of 'customSampleOrderCount' 'VkCoarseSampleOrderCustomNV' structures, each of which specifies the coverage sample order for a single combination of fragment area and coverage sample count.
     */
    pCustomSampleOrders: VkCoarseSampleOrderCustomNV[] | null;

}

declare interface VkPipelineViewportCoarseSampleOrderStateCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies the mechanism used to order coverage samples in fragments larger than one pixel.
     */
    sampleOrderType?: VkCoarseSampleOrderTypeNV;

    /**
     * specifies the number of custom sample orderings to use when ordering coverage samples.
     */
    customSampleOrderCount?: number;

    /**
     * is an array of 'customSampleOrderCount' 'VkCoarseSampleOrderCustomNV' structures, each of which specifies the coverage sample order for a single combination of fragment area and coverage sample count.
     */
    pCustomSampleOrders?: VkCoarseSampleOrderCustomNV[] | null;
}

declare interface VkPipelineViewportCoarseSampleOrderStateCreateInfoNVConstructor {
  readonly prototype: VkPipelineViewportCoarseSampleOrderStateCreateInfoNV;
  new(param?: VkPipelineViewportCoarseSampleOrderStateCreateInfoNVInitializer | null): VkPipelineViewportCoarseSampleOrderStateCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineViewportCoarseSampleOrderStateCreateInfoNV: VkPipelineViewportCoarseSampleOrderStateCreateInfoNVConstructor;



  /**
   * Structure specifying parameters controlling shading rate image usage
   */
interface VkCoarseSampleOrderCustomNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a shading rate palette entry that identifies the fragment width and height for the combination of fragment area and per-pixel coverage sample count to control.
     */
    shadingRate: VkShadingRatePaletteEntryNV;

    /**
     * identifies the per-pixel coverage sample count for the combination of fragment area and coverage sample count to control.
     */
    sampleCount: number;

    /**
     * specifies the number of sample locations in the custom ordering.
     */
    sampleLocationCount: number;

    /**
     * is an array of 'VkCoarseSampleOrderCustomNV' structures specifying the location of each sample in the custom ordering.
     */
    pSampleLocations: VkCoarseSampleLocationNV[] | null;

}

declare interface VkCoarseSampleOrderCustomNVInitializer {
  
    /**
     * is a shading rate palette entry that identifies the fragment width and height for the combination of fragment area and per-pixel coverage sample count to control.
     */
    shadingRate?: VkShadingRatePaletteEntryNV;

    /**
     * identifies the per-pixel coverage sample count for the combination of fragment area and coverage sample count to control.
     */
    sampleCount?: number;

    /**
     * specifies the number of sample locations in the custom ordering.
     */
    sampleLocationCount?: number;

    /**
     * is an array of 'VkCoarseSampleOrderCustomNV' structures specifying the location of each sample in the custom ordering.
     */
    pSampleLocations?: VkCoarseSampleLocationNV[] | null;
}

declare interface VkCoarseSampleOrderCustomNVConstructor {
  readonly prototype: VkCoarseSampleOrderCustomNV;
  new(param?: VkCoarseSampleOrderCustomNVInitializer | null): VkCoarseSampleOrderCustomNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCoarseSampleOrderCustomNV: VkCoarseSampleOrderCustomNVConstructor;



  /**
   * Structure specifying parameters controlling shading rate image usage
   */
interface VkCoarseSampleLocationNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is added to the x coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.
     */
    pixelX: number;

    /**
     * is added to the y coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.
     */
    pixelY: number;

    /**
     * is the number of the coverage sample in the pixel identified by 'pixelX' and 'pixelY'.
     */
    sample: number;

}

declare interface VkCoarseSampleLocationNVInitializer {
  
    /**
     * is added to the x coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.
     */
    pixelX?: number;

    /**
     * is added to the y coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.
     */
    pixelY?: number;

    /**
     * is the number of the coverage sample in the pixel identified by 'pixelX' and 'pixelY'.
     */
    sample?: number;
}

declare interface VkCoarseSampleLocationNVConstructor {
  readonly prototype: VkCoarseSampleLocationNV;
  new(param?: VkCoarseSampleLocationNVInitializer | null): VkCoarseSampleLocationNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCoarseSampleLocationNV: VkCoarseSampleLocationNVConstructor;



  /**
   * Structure describing shading rate image limits that can be supported by an implementation
   */
interface VkPhysicalDeviceShadingRateImagePropertiesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * indicates the width and height of the portion of the framebuffer corresponding to each texel in the shading rate image.
     */
    readonly shadingRateTexelSize: VkExtent2D | null;

    /**
     *
     */
    readonly shadingRatePaletteSize: number;

    /**
     *
     */
    readonly shadingRateMaxCoarseSamples: number;

}

declare interface VkPhysicalDeviceShadingRateImagePropertiesNVInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * indicates the width and height of the portion of the framebuffer corresponding to each texel in the shading rate image.
     */
    readonly shadingRateTexelSize?: VkExtent2D | null;

    /**
     *
     */
    readonly shadingRatePaletteSize?: number;

    /**
     *
     */
    readonly shadingRateMaxCoarseSamples?: number;
}

declare interface VkPhysicalDeviceShadingRateImagePropertiesNVConstructor {
  readonly prototype: VkPhysicalDeviceShadingRateImagePropertiesNV;
  new(param?: VkPhysicalDeviceShadingRateImagePropertiesNVInitializer | null): VkPhysicalDeviceShadingRateImagePropertiesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShadingRateImagePropertiesNV: VkPhysicalDeviceShadingRateImagePropertiesNVConstructor;



  /**
   * Structure describing shading rate image features that can be supported by an implementation
   */
interface VkPhysicalDeviceShadingRateImageFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports the use of a shading rate image to derive an effective shading rate for fragment processing. It also indicates that the implementation supports the 'ShadingRateNV' SPIR-V execution mode.
     */
    shadingRateImage: boolean;

    /**
     * indicates that the implementation supports a user-configurable ordering of coverage samples in fragments larger than one pixel.
     */
    shadingRateCoarseSampleOrder: boolean;

}

declare interface VkPhysicalDeviceShadingRateImageFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports the use of a shading rate image to derive an effective shading rate for fragment processing. It also indicates that the implementation supports the 'ShadingRateNV' SPIR-V execution mode.
     */
    shadingRateImage?: boolean;

    /**
     * indicates that the implementation supports a user-configurable ordering of coverage samples in fragments larger than one pixel.
     */
    shadingRateCoarseSampleOrder?: boolean;
}

declare interface VkPhysicalDeviceShadingRateImageFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceShadingRateImageFeaturesNV;
  new(param?: VkPhysicalDeviceShadingRateImageFeaturesNVInitializer | null): VkPhysicalDeviceShadingRateImageFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShadingRateImageFeaturesNV: VkPhysicalDeviceShadingRateImageFeaturesNVConstructor;



  /**
   * Structure specifying parameters controlling shading rate image usage
   */
interface VkPipelineViewportShadingRateImageStateCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies whether shading rate image and palettes are used during rasterization.
     */
    shadingRateImageEnable: boolean;

    /**
     * specifies the number of per-viewport palettes used to translate values stored in shading rate images.
     */
    viewportCount: number;

    /**
     * is an array of 'VkShadingRatePaletteNV' structures defining the palette for each viewport. If the shading rate palette state is dynamic, this member is ignored.
     */
    pShadingRatePalettes: VkShadingRatePaletteNV[] | null;

}

declare interface VkPipelineViewportShadingRateImageStateCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies whether shading rate image and palettes are used during rasterization.
     */
    shadingRateImageEnable?: boolean;

    /**
     * specifies the number of per-viewport palettes used to translate values stored in shading rate images.
     */
    viewportCount?: number;

    /**
     * is an array of 'VkShadingRatePaletteNV' structures defining the palette for each viewport. If the shading rate palette state is dynamic, this member is ignored.
     */
    pShadingRatePalettes?: VkShadingRatePaletteNV[] | null;
}

declare interface VkPipelineViewportShadingRateImageStateCreateInfoNVConstructor {
  readonly prototype: VkPipelineViewportShadingRateImageStateCreateInfoNV;
  new(param?: VkPipelineViewportShadingRateImageStateCreateInfoNVInitializer | null): VkPipelineViewportShadingRateImageStateCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineViewportShadingRateImageStateCreateInfoNV: VkPipelineViewportShadingRateImageStateCreateInfoNVConstructor;



  /**
   * Structure specifying a single shading rate palette
   */
interface VkShadingRatePaletteNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * specifies the number of entries in the shading rate image palette.
     */
    shadingRatePaletteEntryCount: number;

    /**
     * is an array of 'VkShadingRatePaletteEntryNV' enums defining the shading rate for each palette entry.
     */
    pShadingRatePaletteEntries: Int32Array | null;

}

declare interface VkShadingRatePaletteNVInitializer {
  
    /**
     * specifies the number of entries in the shading rate image palette.
     */
    shadingRatePaletteEntryCount?: number;

    /**
     * is an array of 'VkShadingRatePaletteEntryNV' enums defining the shading rate for each palette entry.
     */
    pShadingRatePaletteEntries?: Int32Array | null;
}

declare interface VkShadingRatePaletteNVConstructor {
  readonly prototype: VkShadingRatePaletteNV;
  new(param?: VkShadingRatePaletteNVInitializer | null): VkShadingRatePaletteNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkShadingRatePaletteNV: VkShadingRatePaletteNVConstructor;



  /**
   * Structure describing dedicated allocation image aliasing features that can be supported by an implementation
   */
interface VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    dedicatedAllocationImageAliasing: boolean;

}

declare interface VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    dedicatedAllocationImageAliasing?: boolean;
}

declare interface VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
  new(param?: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVInitializer | null): VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVConstructor;



  /**
   * Structure describing shader image footprint features that can be supported by an implementation
   */
interface VkPhysicalDeviceShaderImageFootprintFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * specifies whether the implementation supports the 'ImageFootprintNV' SPIR-V capability.
     */
    imageFootprint: boolean;

}

declare interface VkPhysicalDeviceShaderImageFootprintFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * specifies whether the implementation supports the 'ImageFootprintNV' SPIR-V capability.
     */
    imageFootprint?: boolean;
}

declare interface VkPhysicalDeviceShaderImageFootprintFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceShaderImageFootprintFeaturesNV;
  new(param?: VkPhysicalDeviceShaderImageFootprintFeaturesNVInitializer | null): VkPhysicalDeviceShaderImageFootprintFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderImageFootprintFeaturesNV: VkPhysicalDeviceShaderImageFootprintFeaturesNVConstructor;



  /**
   * Structure describing barycentric support in fragment shaders that can be supported by an implementation
   */
interface VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports the 'BaryCoordNV' and 'BaryCoordNoPerspNV' SPIR-V fragment shader built-ins and supports the 'PerVertexNV' SPIR-V decoration on fragment shader input variables.
     */
    fragmentShaderBarycentric: boolean;

}

declare interface VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports the 'BaryCoordNV' and 'BaryCoordNoPerspNV' SPIR-V fragment shader built-ins and supports the 'PerVertexNV' SPIR-V decoration on fragment shader input variables.
     */
    fragmentShaderBarycentric?: boolean;
}

declare interface VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV;
  new(param?: VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVInitializer | null): VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV: VkPhysicalDeviceFragmentShaderBarycentricFeaturesNVConstructor;



  /**
   * Structure describing compute shader derivative features that can be supported by an implementation
   */
interface VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    computeDerivativeGroupQuads: boolean;

    /**
     *
     */
    computeDerivativeGroupLinear: boolean;

}

declare interface VkPhysicalDeviceComputeShaderDerivativesFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    computeDerivativeGroupQuads?: boolean;

    /**
     *
     */
    computeDerivativeGroupLinear?: boolean;
}

declare interface VkPhysicalDeviceComputeShaderDerivativesFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceComputeShaderDerivativesFeaturesNV;
  new(param?: VkPhysicalDeviceComputeShaderDerivativesFeaturesNVInitializer | null): VkPhysicalDeviceComputeShaderDerivativesFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceComputeShaderDerivativesFeaturesNV: VkPhysicalDeviceComputeShaderDerivativesFeaturesNVConstructor;



  /**
   * Structure describing corner sampled image features that can be supported by an implementation
   */
interface VkPhysicalDeviceCornerSampledImageFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * specifies whether images can be created with a 'VkImageCreateInfo'::'flags' containing 'VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV'. See <<resources-images-corner-sampled,Corner-Sampled Images>>.
     */
    cornerSampledImage: boolean;

}

declare interface VkPhysicalDeviceCornerSampledImageFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * specifies whether images can be created with a 'VkImageCreateInfo'::'flags' containing 'VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV'. See <<resources-images-corner-sampled,Corner-Sampled Images>>.
     */
    cornerSampledImage?: boolean;
}

declare interface VkPhysicalDeviceCornerSampledImageFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceCornerSampledImageFeaturesNV;
  new(param?: VkPhysicalDeviceCornerSampledImageFeaturesNVInitializer | null): VkPhysicalDeviceCornerSampledImageFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceCornerSampledImageFeaturesNV: VkPhysicalDeviceCornerSampledImageFeaturesNVConstructor;



  /**
   * Structure specifying parameters controlling exclusive scissor testing
   */
interface VkPipelineViewportExclusiveScissorStateCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of exclusive scissor rectangles.
     */
    exclusiveScissorCount: number;

    /**
     * is an array of 'VkRect2D' structures defining exclusive scissor rectangles.
     */
    pExclusiveScissors: VkRect2D[] | null;

}

declare interface VkPipelineViewportExclusiveScissorStateCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of exclusive scissor rectangles.
     */
    exclusiveScissorCount?: number;

    /**
     * is an array of 'VkRect2D' structures defining exclusive scissor rectangles.
     */
    pExclusiveScissors?: VkRect2D[] | null;
}

declare interface VkPipelineViewportExclusiveScissorStateCreateInfoNVConstructor {
  readonly prototype: VkPipelineViewportExclusiveScissorStateCreateInfoNV;
  new(param?: VkPipelineViewportExclusiveScissorStateCreateInfoNVInitializer | null): VkPipelineViewportExclusiveScissorStateCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineViewportExclusiveScissorStateCreateInfoNV: VkPipelineViewportExclusiveScissorStateCreateInfoNVConstructor;



  /**
   * Structure describing exclusive scissor features that can be supported by an implementation
   */
interface VkPhysicalDeviceExclusiveScissorFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates that the implementation supports the exclusive scissor test.
     */
    exclusiveScissor: boolean;

}

declare interface VkPhysicalDeviceExclusiveScissorFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates that the implementation supports the exclusive scissor test.
     */
    exclusiveScissor?: boolean;
}

declare interface VkPhysicalDeviceExclusiveScissorFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceExclusiveScissorFeaturesNV;
  new(param?: VkPhysicalDeviceExclusiveScissorFeaturesNVInitializer | null): VkPhysicalDeviceExclusiveScissorFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExclusiveScissorFeaturesNV: VkPhysicalDeviceExclusiveScissorFeaturesNVConstructor;



  /**
   * Structure specifying representative fragment test
   */
interface VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * controls whether the representative fragment test is enabled.
     */
    representativeFragmentTestEnable: boolean;

}

declare interface VkPipelineRepresentativeFragmentTestStateCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * controls whether the representative fragment test is enabled.
     */
    representativeFragmentTestEnable?: boolean;
}

declare interface VkPipelineRepresentativeFragmentTestStateCreateInfoNVConstructor {
  readonly prototype: VkPipelineRepresentativeFragmentTestStateCreateInfoNV;
  new(param?: VkPipelineRepresentativeFragmentTestStateCreateInfoNVInitializer | null): VkPipelineRepresentativeFragmentTestStateCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineRepresentativeFragmentTestStateCreateInfoNV: VkPipelineRepresentativeFragmentTestStateCreateInfoNVConstructor;



  /**
   * Structure describing the representative fragment test features that can be supported by an implementation
   */
interface VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports the representative fragment test. See <<fragops-rep-frag-test, Representative Fragment Test>>.
     */
    representativeFragmentTest: boolean;

}

declare interface VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports the representative fragment test. See <<fragops-rep-frag-test, Representative Fragment Test>>.
     */
    representativeFragmentTest?: boolean;
}

declare interface VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV;
  new(param?: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVInitializer | null): VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNVConstructor;



  /**
   * Structure defining the geometry stream used for rasterization
   */
interface VkPipelineRasterizationStateStreamCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is the vertex stream selected for rasterization.
     */
    rasterizationStream: number;

}

declare interface VkPipelineRasterizationStateStreamCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is the vertex stream selected for rasterization.
     */
    rasterizationStream?: number;
}

declare interface VkPipelineRasterizationStateStreamCreateInfoEXTConstructor {
  readonly prototype: VkPipelineRasterizationStateStreamCreateInfoEXT;
  new(param?: VkPipelineRasterizationStateStreamCreateInfoEXTInitializer | null): VkPipelineRasterizationStateStreamCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineRasterizationStateStreamCreateInfoEXT: VkPipelineRasterizationStateStreamCreateInfoEXTConstructor;



  /**
   * Structure describing transform feedback properties that can be supported by an implementation
   */
interface VkPhysicalDeviceTransformFeedbackPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the maximum number of vertex streams that can be output from geometry shaders declared with the 'GeometryStreams' capability. If the implementation does not support 'VkPhysicalDeviceTransformFeedbackFeaturesEXT'::'geometryStreams' then 'maxTransformFeedbackStreams' 'must' be set to `1`.
     */
    readonly maxTransformFeedbackStreams: number;

    /**
     *
     */
    readonly maxTransformFeedbackBuffers: number;

    /**
     *
     */
    readonly maxTransformFeedbackBufferSize: bigint | number;

    /**
     *
     */
    readonly maxTransformFeedbackStreamDataSize: number;

    /**
     *
     */
    readonly maxTransformFeedbackBufferDataSize: number;

    /**
     *
     */
    readonly maxTransformFeedbackBufferDataStride: number;

    /**
     *
     */
    readonly transformFeedbackQueries: boolean;

    /**
     *
     */
    readonly transformFeedbackStreamsLinesTriangles: boolean;

    /**
     *
     */
    readonly transformFeedbackRasterizationStreamSelect: boolean;

    /**
     *
     */
    readonly transformFeedbackDraw: boolean;

}

declare interface VkPhysicalDeviceTransformFeedbackPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the maximum number of vertex streams that can be output from geometry shaders declared with the 'GeometryStreams' capability. If the implementation does not support 'VkPhysicalDeviceTransformFeedbackFeaturesEXT'::'geometryStreams' then 'maxTransformFeedbackStreams' 'must' be set to `1`.
     */
    readonly maxTransformFeedbackStreams?: number;

    /**
     *
     */
    readonly maxTransformFeedbackBuffers?: number;

    /**
     *
     */
    readonly maxTransformFeedbackBufferSize?: bigint | number;

    /**
     *
     */
    readonly maxTransformFeedbackStreamDataSize?: number;

    /**
     *
     */
    readonly maxTransformFeedbackBufferDataSize?: number;

    /**
     *
     */
    readonly maxTransformFeedbackBufferDataStride?: number;

    /**
     *
     */
    readonly transformFeedbackQueries?: boolean;

    /**
     *
     */
    readonly transformFeedbackStreamsLinesTriangles?: boolean;

    /**
     *
     */
    readonly transformFeedbackRasterizationStreamSelect?: boolean;

    /**
     *
     */
    readonly transformFeedbackDraw?: boolean;
}

declare interface VkPhysicalDeviceTransformFeedbackPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceTransformFeedbackPropertiesEXT;
  new(param?: VkPhysicalDeviceTransformFeedbackPropertiesEXTInitializer | null): VkPhysicalDeviceTransformFeedbackPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceTransformFeedbackPropertiesEXT: VkPhysicalDeviceTransformFeedbackPropertiesEXTConstructor;



  /**
   * Structure describing transform feedback features that can be supported by an implementation
   */
interface VkPhysicalDeviceTransformFeedbackFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports transform feedback and shader modules 'can' declare the 'TransformFeedback' capability.
     */
    transformFeedback: boolean;

    /**
     *
     */
    geometryStreams: boolean;

}

declare interface VkPhysicalDeviceTransformFeedbackFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports transform feedback and shader modules 'can' declare the 'TransformFeedback' capability.
     */
    transformFeedback?: boolean;

    /**
     *
     */
    geometryStreams?: boolean;
}

declare interface VkPhysicalDeviceTransformFeedbackFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceTransformFeedbackFeaturesEXT;
  new(param?: VkPhysicalDeviceTransformFeedbackFeaturesEXTInitializer | null): VkPhysicalDeviceTransformFeedbackFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceTransformFeedbackFeaturesEXT: VkPhysicalDeviceTransformFeedbackFeaturesEXTConstructor;



  /**
   * Structure describing ASTC decode mode features
   */
interface VkPhysicalDeviceASTCDecodeFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    decodeModeSharedExponent: boolean;

}

declare interface VkPhysicalDeviceASTCDecodeFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    decodeModeSharedExponent?: boolean;
}

declare interface VkPhysicalDeviceASTCDecodeFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceASTCDecodeFeaturesEXT;
  new(param?: VkPhysicalDeviceASTCDecodeFeaturesEXTInitializer | null): VkPhysicalDeviceASTCDecodeFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceASTCDecodeFeaturesEXT: VkPhysicalDeviceASTCDecodeFeaturesEXTConstructor;



  /**
   * Structure describing the ASTC decode mode for an image view
   */
interface VkImageViewASTCDecodeModeEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the intermediate format used to decode ASTC compressed formats.
     */
    decodeMode: VkFormat;

}

declare interface VkImageViewASTCDecodeModeEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the intermediate format used to decode ASTC compressed formats.
     */
    decodeMode?: VkFormat;
}

declare interface VkImageViewASTCDecodeModeEXTConstructor {
  readonly prototype: VkImageViewASTCDecodeModeEXT;
  new(param?: VkImageViewASTCDecodeModeEXTInitializer | null): VkImageViewASTCDecodeModeEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageViewASTCDecodeModeEXT: VkImageViewASTCDecodeModeEXTConstructor;



  /**
   * 
   */
interface VkSubpassDescriptionDepthStencilResolveKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    depthResolveMode: VkResolveModeFlagBits;

    /**
     *
     */
    stencilResolveMode: VkResolveModeFlagBits;

    /**
     *
     */
    pDepthStencilResolveAttachment: VkAttachmentReference2 | null;

}

declare interface VkSubpassDescriptionDepthStencilResolveKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    depthResolveMode?: VkResolveModeFlagBits;

    /**
     *
     */
    stencilResolveMode?: VkResolveModeFlagBits;

    /**
     *
     */
    pDepthStencilResolveAttachment?: VkAttachmentReference2 | null;
}

declare interface VkSubpassDescriptionDepthStencilResolveKHRConstructor {
  readonly prototype: VkSubpassDescriptionDepthStencilResolveKHR;
  new(param?: VkSubpassDescriptionDepthStencilResolveKHRInitializer | null): VkSubpassDescriptionDepthStencilResolveKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassDescriptionDepthStencilResolveKHR: VkSubpassDescriptionDepthStencilResolveKHRConstructor;



  /**
   * Structure specifying depth/stencil resolve operations for a subpass
   */
interface VkSubpassDescriptionDepthStencilResolve {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    depthResolveMode: VkResolveModeFlagBits;

    /**
     *
     */
    stencilResolveMode: VkResolveModeFlagBits;

    /**
     *
     */
    pDepthStencilResolveAttachment: VkAttachmentReference2 | null;

}

declare interface VkSubpassDescriptionDepthStencilResolveInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    depthResolveMode?: VkResolveModeFlagBits;

    /**
     *
     */
    stencilResolveMode?: VkResolveModeFlagBits;

    /**
     *
     */
    pDepthStencilResolveAttachment?: VkAttachmentReference2 | null;
}

declare interface VkSubpassDescriptionDepthStencilResolveConstructor {
  readonly prototype: VkSubpassDescriptionDepthStencilResolve;
  new(param?: VkSubpassDescriptionDepthStencilResolveInitializer | null): VkSubpassDescriptionDepthStencilResolve;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassDescriptionDepthStencilResolve: VkSubpassDescriptionDepthStencilResolveConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceDepthStencilResolvePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly supportedDepthResolveModes: VkResolveModeFlagBits;

    /**
     *
     */
    readonly supportedStencilResolveModes: VkResolveModeFlagBits;

    /**
     *
     */
    readonly independentResolveNone: boolean;

    /**
     *
     */
    readonly independentResolve: boolean;

}

declare interface VkPhysicalDeviceDepthStencilResolvePropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly supportedDepthResolveModes?: VkResolveModeFlagBits;

    /**
     *
     */
    readonly supportedStencilResolveModes?: VkResolveModeFlagBits;

    /**
     *
     */
    readonly independentResolveNone?: boolean;

    /**
     *
     */
    readonly independentResolve?: boolean;
}

declare interface VkPhysicalDeviceDepthStencilResolvePropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceDepthStencilResolvePropertiesKHR;
  new(param?: VkPhysicalDeviceDepthStencilResolvePropertiesKHRInitializer | null): VkPhysicalDeviceDepthStencilResolvePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDepthStencilResolvePropertiesKHR: VkPhysicalDeviceDepthStencilResolvePropertiesKHRConstructor;



  /**
   * Structure describing depth/stencil resolve properties that can be supported by an implementation
   */
interface VkPhysicalDeviceDepthStencilResolveProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly supportedDepthResolveModes: VkResolveModeFlagBits;

    /**
     *
     */
    readonly supportedStencilResolveModes: VkResolveModeFlagBits;

    /**
     *
     */
    readonly independentResolveNone: boolean;

    /**
     *
     */
    readonly independentResolve: boolean;

}

declare interface VkPhysicalDeviceDepthStencilResolvePropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly supportedDepthResolveModes?: VkResolveModeFlagBits;

    /**
     *
     */
    readonly supportedStencilResolveModes?: VkResolveModeFlagBits;

    /**
     *
     */
    readonly independentResolveNone?: boolean;

    /**
     *
     */
    readonly independentResolve?: boolean;
}

declare interface VkPhysicalDeviceDepthStencilResolvePropertiesConstructor {
  readonly prototype: VkPhysicalDeviceDepthStencilResolveProperties;
  new(param?: VkPhysicalDeviceDepthStencilResolvePropertiesInitializer | null): VkPhysicalDeviceDepthStencilResolveProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDepthStencilResolveProperties: VkPhysicalDeviceDepthStencilResolvePropertiesConstructor;



  /**
   * return structure for command buffer checkpoint data
   */
interface VkCheckpointDataNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * indicates which pipeline stage the checkpoint marker data refers to.
     */
    readonly stage: VkPipelineStageFlagBits;

    /**
     * contains the value of the last checkpoint marker executed in the stage that 'stage' refers to.
     */
    readonly pCheckpointMarker: ArrayBuffer | null;

}

declare interface VkCheckpointDataNVInitializer {
  
    /**
     * is the type of this structure
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * indicates which pipeline stage the checkpoint marker data refers to.
     */
    readonly stage?: VkPipelineStageFlagBits;

    /**
     * contains the value of the last checkpoint marker executed in the stage that 'stage' refers to.
     */
    readonly pCheckpointMarker?: ArrayBuffer | null;
}

declare interface VkCheckpointDataNVConstructor {
  readonly prototype: VkCheckpointDataNV;
  new(param?: VkCheckpointDataNVInitializer | null): VkCheckpointDataNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCheckpointDataNV: VkCheckpointDataNVConstructor;



  /**
   * return structure for queue family checkpoint info query
   */
interface VkQueueFamilyCheckpointPropertiesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a mask indicating which pipeline stages the implementation can execute checkpoint markers in.
     */
    readonly checkpointExecutionStageMask: VkPipelineStageFlagBits;

}

declare interface VkQueueFamilyCheckpointPropertiesNVInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a mask indicating which pipeline stages the implementation can execute checkpoint markers in.
     */
    readonly checkpointExecutionStageMask?: VkPipelineStageFlagBits;
}

declare interface VkQueueFamilyCheckpointPropertiesNVConstructor {
  readonly prototype: VkQueueFamilyCheckpointPropertiesNV;
  new(param?: VkQueueFamilyCheckpointPropertiesNVInitializer | null): VkQueueFamilyCheckpointPropertiesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkQueueFamilyCheckpointPropertiesNV: VkQueueFamilyCheckpointPropertiesNVConstructor;



  /**
   * Structure describing if fetching of vertex attribute may be repeated for instanced rendering
   */
interface VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies whether vertex attribute fetching may be repeated in case of instanced rendering.
     */
    vertexAttributeInstanceRateDivisor: boolean;

    /**
     * specifies whether a zero value for 'VkVertexInputBindingDivisorDescriptionEXT'::'divisor' is supported.
     */
    vertexAttributeInstanceRateZeroDivisor: boolean;

}

declare interface VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies whether vertex attribute fetching may be repeated in case of instanced rendering.
     */
    vertexAttributeInstanceRateDivisor?: boolean;

    /**
     * specifies whether a zero value for 'VkVertexInputBindingDivisorDescriptionEXT'::'divisor' is supported.
     */
    vertexAttributeInstanceRateZeroDivisor?: boolean;
}

declare interface VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;
  new(param?: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTInitializer | null): VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTConstructor;



  /**
   * Structure describing features supported by VK_EXT_shader_atomic_float
   */
interface VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     *
     */
    shaderBufferFloat32Atomics: boolean;

    /**
     *
     */
    shaderBufferFloat32AtomicAdd: boolean;

    /**
     *
     */
    shaderBufferFloat64Atomics: boolean;

    /**
     *
     */
    shaderBufferFloat64AtomicAdd: boolean;

    /**
     *
     */
    shaderSharedFloat32Atomics: boolean;

    /**
     *
     */
    shaderSharedFloat32AtomicAdd: boolean;

    /**
     *
     */
    shaderSharedFloat64Atomics: boolean;

    /**
     *
     */
    shaderSharedFloat64AtomicAdd: boolean;

    /**
     *
     */
    shaderImageFloat32Atomics: boolean;

    /**
     *
     */
    shaderImageFloat32AtomicAdd: boolean;

    /**
     *
     */
    sparseImageFloat32Atomics: boolean;

    /**
     *
     */
    sparseImageFloat32AtomicAdd: boolean;

}

declare interface VkPhysicalDeviceShaderAtomicFloatFeaturesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     *
     */
    shaderBufferFloat32Atomics?: boolean;

    /**
     *
     */
    shaderBufferFloat32AtomicAdd?: boolean;

    /**
     *
     */
    shaderBufferFloat64Atomics?: boolean;

    /**
     *
     */
    shaderBufferFloat64AtomicAdd?: boolean;

    /**
     *
     */
    shaderSharedFloat32Atomics?: boolean;

    /**
     *
     */
    shaderSharedFloat32AtomicAdd?: boolean;

    /**
     *
     */
    shaderSharedFloat64Atomics?: boolean;

    /**
     *
     */
    shaderSharedFloat64AtomicAdd?: boolean;

    /**
     *
     */
    shaderImageFloat32Atomics?: boolean;

    /**
     *
     */
    shaderImageFloat32AtomicAdd?: boolean;

    /**
     *
     */
    sparseImageFloat32Atomics?: boolean;

    /**
     *
     */
    sparseImageFloat32AtomicAdd?: boolean;
}

declare interface VkPhysicalDeviceShaderAtomicFloatFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT;
  new(param?: VkPhysicalDeviceShaderAtomicFloatFeaturesEXTInitializer | null): VkPhysicalDeviceShaderAtomicFloatFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderAtomicFloatFeaturesEXT: VkPhysicalDeviceShaderAtomicFloatFeaturesEXTConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceShaderAtomicInt64FeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderBufferInt64Atomics: boolean;

    /**
     *
     */
    shaderSharedInt64Atomics: boolean;

}

declare interface VkPhysicalDeviceShaderAtomicInt64FeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderBufferInt64Atomics?: boolean;

    /**
     *
     */
    shaderSharedInt64Atomics?: boolean;
}

declare interface VkPhysicalDeviceShaderAtomicInt64FeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceShaderAtomicInt64FeaturesKHR;
  new(param?: VkPhysicalDeviceShaderAtomicInt64FeaturesKHRInitializer | null): VkPhysicalDeviceShaderAtomicInt64FeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderAtomicInt64FeaturesKHR: VkPhysicalDeviceShaderAtomicInt64FeaturesKHRConstructor;



  /**
   * Structure describing features supported by VK_KHR_shader_atomic_int64
   */
interface VkPhysicalDeviceShaderAtomicInt64Features {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderBufferInt64Atomics: boolean;

    /**
     *
     */
    shaderSharedInt64Atomics: boolean;

}

declare interface VkPhysicalDeviceShaderAtomicInt64FeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderBufferInt64Atomics?: boolean;

    /**
     *
     */
    shaderSharedInt64Atomics?: boolean;
}

declare interface VkPhysicalDeviceShaderAtomicInt64FeaturesConstructor {
  readonly prototype: VkPhysicalDeviceShaderAtomicInt64Features;
  new(param?: VkPhysicalDeviceShaderAtomicInt64FeaturesInitializer | null): VkPhysicalDeviceShaderAtomicInt64Features;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderAtomicInt64Features: VkPhysicalDeviceShaderAtomicInt64FeaturesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceVulkanMemoryModelFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    vulkanMemoryModel: boolean;

    /**
     *
     */
    vulkanMemoryModelDeviceScope: boolean;

    /**
     *
     */
    vulkanMemoryModelAvailabilityVisibilityChains: boolean;

}

declare interface VkPhysicalDeviceVulkanMemoryModelFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    vulkanMemoryModel?: boolean;

    /**
     *
     */
    vulkanMemoryModelDeviceScope?: boolean;

    /**
     *
     */
    vulkanMemoryModelAvailabilityVisibilityChains?: boolean;
}

declare interface VkPhysicalDeviceVulkanMemoryModelFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceVulkanMemoryModelFeaturesKHR;
  new(param?: VkPhysicalDeviceVulkanMemoryModelFeaturesKHRInitializer | null): VkPhysicalDeviceVulkanMemoryModelFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVulkanMemoryModelFeaturesKHR: VkPhysicalDeviceVulkanMemoryModelFeaturesKHRConstructor;



  /**
   * Structure describing features supported by the memory model
   */
interface VkPhysicalDeviceVulkanMemoryModelFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    vulkanMemoryModel: boolean;

    /**
     *
     */
    vulkanMemoryModelDeviceScope: boolean;

    /**
     *
     */
    vulkanMemoryModelAvailabilityVisibilityChains: boolean;

}

declare interface VkPhysicalDeviceVulkanMemoryModelFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    vulkanMemoryModel?: boolean;

    /**
     *
     */
    vulkanMemoryModelDeviceScope?: boolean;

    /**
     *
     */
    vulkanMemoryModelAvailabilityVisibilityChains?: boolean;
}

declare interface VkPhysicalDeviceVulkanMemoryModelFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceVulkanMemoryModelFeatures;
  new(param?: VkPhysicalDeviceVulkanMemoryModelFeaturesInitializer | null): VkPhysicalDeviceVulkanMemoryModelFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVulkanMemoryModelFeatures: VkPhysicalDeviceVulkanMemoryModelFeaturesConstructor;



  /**
   * Structure describing if a secondary command buffer can be executed if conditional rendering is active in the primary command buffer
   */
interface VkPhysicalDeviceConditionalRenderingFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies whether conditional rendering is supported.
     */
    conditionalRendering: boolean;

    /**
     * specifies whether a secondary command buffer 'can' be executed while conditional rendering is active in the primary command buffer.
     */
    inheritedConditionalRendering: boolean;

}

declare interface VkPhysicalDeviceConditionalRenderingFeaturesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies whether conditional rendering is supported.
     */
    conditionalRendering?: boolean;

    /**
     * specifies whether a secondary command buffer 'can' be executed while conditional rendering is active in the primary command buffer.
     */
    inheritedConditionalRendering?: boolean;
}

declare interface VkPhysicalDeviceConditionalRenderingFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceConditionalRenderingFeaturesEXT;
  new(param?: VkPhysicalDeviceConditionalRenderingFeaturesEXTInitializer | null): VkPhysicalDeviceConditionalRenderingFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceConditionalRenderingFeaturesEXT: VkPhysicalDeviceConditionalRenderingFeaturesEXTConstructor;



  /**
   * 
   */
interface VkPhysicalDevice8BitStorageFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    storageBuffer8BitAccess: boolean;

    /**
     *
     */
    uniformAndStorageBuffer8BitAccess: boolean;

    /**
     *
     */
    storagePushConstant8: boolean;

}

declare interface VkPhysicalDevice8BitStorageFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    storageBuffer8BitAccess?: boolean;

    /**
     *
     */
    uniformAndStorageBuffer8BitAccess?: boolean;

    /**
     *
     */
    storagePushConstant8?: boolean;
}

declare interface VkPhysicalDevice8BitStorageFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDevice8BitStorageFeaturesKHR;
  new(param?: VkPhysicalDevice8BitStorageFeaturesKHRInitializer | null): VkPhysicalDevice8BitStorageFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevice8BitStorageFeaturesKHR: VkPhysicalDevice8BitStorageFeaturesKHRConstructor;



  /**
   * Structure describing features supported by VK_KHR_8bit_storage
   */
interface VkPhysicalDevice8BitStorageFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    storageBuffer8BitAccess: boolean;

    /**
     *
     */
    uniformAndStorageBuffer8BitAccess: boolean;

    /**
     *
     */
    storagePushConstant8: boolean;

}

declare interface VkPhysicalDevice8BitStorageFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    storageBuffer8BitAccess?: boolean;

    /**
     *
     */
    uniformAndStorageBuffer8BitAccess?: boolean;

    /**
     *
     */
    storagePushConstant8?: boolean;
}

declare interface VkPhysicalDevice8BitStorageFeaturesConstructor {
  readonly prototype: VkPhysicalDevice8BitStorageFeatures;
  new(param?: VkPhysicalDevice8BitStorageFeaturesInitializer | null): VkPhysicalDevice8BitStorageFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevice8BitStorageFeatures: VkPhysicalDevice8BitStorageFeaturesConstructor;



  /**
   * Structure specifying command buffer inheritance info
   */
interface VkCommandBufferInheritanceConditionalRenderingInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure
     */
    pNext: null;

    /**
     * specifies whether the command buffer 'can' be executed while conditional rendering is active in the primary command buffer. If this is 'VK_TRUE', then this command buffer 'can' be executed whether the primary command buffer has active conditional rendering or not. If this is 'VK_FALSE', then the primary command buffer 'must' not have conditional rendering active.
     */
    conditionalRenderingEnable: boolean;

}

declare interface VkCommandBufferInheritanceConditionalRenderingInfoEXTInitializer {
  
    /**
     * is the type of this structure
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure
     */
    pNext?: null;

    /**
     * specifies whether the command buffer 'can' be executed while conditional rendering is active in the primary command buffer. If this is 'VK_TRUE', then this command buffer 'can' be executed whether the primary command buffer has active conditional rendering or not. If this is 'VK_FALSE', then the primary command buffer 'must' not have conditional rendering active.
     */
    conditionalRenderingEnable?: boolean;
}

declare interface VkCommandBufferInheritanceConditionalRenderingInfoEXTConstructor {
  readonly prototype: VkCommandBufferInheritanceConditionalRenderingInfoEXT;
  new(param?: VkCommandBufferInheritanceConditionalRenderingInfoEXTInitializer | null): VkCommandBufferInheritanceConditionalRenderingInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCommandBufferInheritanceConditionalRenderingInfoEXT: VkCommandBufferInheritanceConditionalRenderingInfoEXTConstructor;



  /**
   * Structure containing PCI bus information of a physical device
   */
interface VkPhysicalDevicePCIBusInfoPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the PCI bus domain.
     */
    readonly pciDomain: number;

    /**
     * is the PCI bus identifier.
     */
    readonly pciBus: number;

    /**
     * is the PCI device identifier.
     */
    readonly pciDevice: number;

    /**
     * is the PCI device function identifier.
     */
    readonly pciFunction: number;

}

declare interface VkPhysicalDevicePCIBusInfoPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the PCI bus domain.
     */
    readonly pciDomain?: number;

    /**
     * is the PCI bus identifier.
     */
    readonly pciBus?: number;

    /**
     * is the PCI device identifier.
     */
    readonly pciDevice?: number;

    /**
     * is the PCI device function identifier.
     */
    readonly pciFunction?: number;
}

declare interface VkPhysicalDevicePCIBusInfoPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDevicePCIBusInfoPropertiesEXT;
  new(param?: VkPhysicalDevicePCIBusInfoPropertiesEXTInitializer | null): VkPhysicalDevicePCIBusInfoPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevicePCIBusInfoPropertiesEXT: VkPhysicalDevicePCIBusInfoPropertiesEXTConstructor;



  /**
   * Structure describing max value of vertex attribute divisor that can be supported by an implementation
   */
interface VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the maximum value of the number of instances that will repeat the value of vertex attribute data when instanced rendering is enabled.
     */
    readonly maxVertexAttribDivisor: number;

}

declare interface VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the maximum value of the number of instances that will repeat the value of vertex attribute data when instanced rendering is enabled.
     */
    readonly maxVertexAttribDivisor?: number;
}

declare interface VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;
  new(param?: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTInitializer | null): VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTConstructor;



  /**
   * Structure specifying vertex attributes assignment during instanced rendering
   */
interface VkPipelineVertexInputDivisorStateCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure
     */
    pNext: null;

    /**
     * is the number of elements in the 'pVertexBindingDivisors' array.
     */
    vertexBindingDivisorCount: number;

    /**
     * is an array of 'VkVertexInputBindingDivisorDescriptionEXT' structures, which specifies the divisor value for each binding.
     */
    pVertexBindingDivisors: VkVertexInputBindingDivisorDescriptionEXT[] | null;

}

declare interface VkPipelineVertexInputDivisorStateCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure
     */
    pNext?: null;

    /**
     * is the number of elements in the 'pVertexBindingDivisors' array.
     */
    vertexBindingDivisorCount?: number;

    /**
     * is an array of 'VkVertexInputBindingDivisorDescriptionEXT' structures, which specifies the divisor value for each binding.
     */
    pVertexBindingDivisors?: VkVertexInputBindingDivisorDescriptionEXT[] | null;
}

declare interface VkPipelineVertexInputDivisorStateCreateInfoEXTConstructor {
  readonly prototype: VkPipelineVertexInputDivisorStateCreateInfoEXT;
  new(param?: VkPipelineVertexInputDivisorStateCreateInfoEXTInitializer | null): VkPipelineVertexInputDivisorStateCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineVertexInputDivisorStateCreateInfoEXT: VkPipelineVertexInputDivisorStateCreateInfoEXTConstructor;



  /**
   * Structure specifying a divisor used in instanced rendering
   */
interface VkVertexInputBindingDivisorDescriptionEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the binding number for which the divisor is specified.
     */
    binding: number;

    /**
     * is the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. For example, if the divisor is N, the same vertex attribute will be applied to N successive instances before moving on to the next vertex attribute. The maximum value of divisor is implementation dependent and can be queried using 'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT'::'maxVertexAttribDivisor'. A value of `0` 'can' be used for the divisor if the <<features-vertexAttributeInstanceRateZeroDivisor,'vertexAttributeInstanceRateZeroDivisor'>> feature is enabled. In this case, the same vertex attribute will be applied to all instances.
     */
    divisor: number;

}

declare interface VkVertexInputBindingDivisorDescriptionEXTInitializer {
  
    /**
     * is the binding number for which the divisor is specified.
     */
    binding?: number;

    /**
     * is the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. For example, if the divisor is N, the same vertex attribute will be applied to N successive instances before moving on to the next vertex attribute. The maximum value of divisor is implementation dependent and can be queried using 'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT'::'maxVertexAttribDivisor'. A value of `0` 'can' be used for the divisor if the <<features-vertexAttributeInstanceRateZeroDivisor,'vertexAttributeInstanceRateZeroDivisor'>> feature is enabled. In this case, the same vertex attribute will be applied to all instances.
     */
    divisor?: number;
}

declare interface VkVertexInputBindingDivisorDescriptionEXTConstructor {
  readonly prototype: VkVertexInputBindingDivisorDescriptionEXT;
  new(param?: VkVertexInputBindingDivisorDescriptionEXTInitializer | null): VkVertexInputBindingDivisorDescriptionEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkVertexInputBindingDivisorDescriptionEXT: VkVertexInputBindingDivisorDescriptionEXTConstructor;



  /**
   * 
   */
interface VkSemaphoreSignalInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    semaphore: VkSemaphore | null;

    /**
     *
     */
    value: bigint | number;

}

declare interface VkSemaphoreSignalInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    semaphore?: VkSemaphore | null;

    /**
     *
     */
    value?: bigint | number;
}

declare interface VkSemaphoreSignalInfoKHRConstructor {
  readonly prototype: VkSemaphoreSignalInfoKHR;
  new(param?: VkSemaphoreSignalInfoKHRInitializer | null): VkSemaphoreSignalInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSemaphoreSignalInfoKHR: VkSemaphoreSignalInfoKHRConstructor;



  /**
   * Structure containing information about a semaphore signal operation
   */
interface VkSemaphoreSignalInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    semaphore: VkSemaphore | null;

    /**
     *
     */
    value: bigint | number;

}

declare interface VkSemaphoreSignalInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    semaphore?: VkSemaphore | null;

    /**
     *
     */
    value?: bigint | number;
}

declare interface VkSemaphoreSignalInfoConstructor {
  readonly prototype: VkSemaphoreSignalInfo;
  new(param?: VkSemaphoreSignalInfoInitializer | null): VkSemaphoreSignalInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSemaphoreSignalInfo: VkSemaphoreSignalInfoConstructor;



  /**
   * 
   */
interface VkSemaphoreWaitInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkSemaphoreWaitFlagBits;

    /**
     *
     */
    semaphoreCount: number;

    /**
     *
     */
    pSemaphores: VkSemaphore[] | null;

    /**
     *
     */
    pValues: BigUint64Array | null;

}

declare interface VkSemaphoreWaitInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkSemaphoreWaitFlagBits;

    /**
     *
     */
    semaphoreCount?: number;

    /**
     *
     */
    pSemaphores?: VkSemaphore[] | null;

    /**
     *
     */
    pValues?: BigUint64Array | null;
}

declare interface VkSemaphoreWaitInfoKHRConstructor {
  readonly prototype: VkSemaphoreWaitInfoKHR;
  new(param?: VkSemaphoreWaitInfoKHRInitializer | null): VkSemaphoreWaitInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSemaphoreWaitInfoKHR: VkSemaphoreWaitInfoKHRConstructor;



  /**
   * Structure containing information about the semaphore wait condition
   */
interface VkSemaphoreWaitInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkSemaphoreWaitFlagBits;

    /**
     *
     */
    semaphoreCount: number;

    /**
     *
     */
    pSemaphores: VkSemaphore[] | null;

    /**
     *
     */
    pValues: BigUint64Array | null;

}

declare interface VkSemaphoreWaitInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkSemaphoreWaitFlagBits;

    /**
     *
     */
    semaphoreCount?: number;

    /**
     *
     */
    pSemaphores?: VkSemaphore[] | null;

    /**
     *
     */
    pValues?: BigUint64Array | null;
}

declare interface VkSemaphoreWaitInfoConstructor {
  readonly prototype: VkSemaphoreWaitInfo;
  new(param?: VkSemaphoreWaitInfoInitializer | null): VkSemaphoreWaitInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSemaphoreWaitInfo: VkSemaphoreWaitInfoConstructor;



  /**
   * 
   */
interface VkTimelineSemaphoreSubmitInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    waitSemaphoreValueCount: number;

    /**
     *
     */
    pWaitSemaphoreValues: BigUint64Array | null;

    /**
     *
     */
    signalSemaphoreValueCount: number;

    /**
     *
     */
    pSignalSemaphoreValues: BigUint64Array | null;

}

declare interface VkTimelineSemaphoreSubmitInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    waitSemaphoreValueCount?: number;

    /**
     *
     */
    pWaitSemaphoreValues?: BigUint64Array | null;

    /**
     *
     */
    signalSemaphoreValueCount?: number;

    /**
     *
     */
    pSignalSemaphoreValues?: BigUint64Array | null;
}

declare interface VkTimelineSemaphoreSubmitInfoKHRConstructor {
  readonly prototype: VkTimelineSemaphoreSubmitInfoKHR;
  new(param?: VkTimelineSemaphoreSubmitInfoKHRInitializer | null): VkTimelineSemaphoreSubmitInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkTimelineSemaphoreSubmitInfoKHR: VkTimelineSemaphoreSubmitInfoKHRConstructor;



  /**
   * Structure specifying signal and wait values for timeline semaphores
   */
interface VkTimelineSemaphoreSubmitInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    waitSemaphoreValueCount: number;

    /**
     *
     */
    pWaitSemaphoreValues: BigUint64Array | null;

    /**
     *
     */
    signalSemaphoreValueCount: number;

    /**
     *
     */
    pSignalSemaphoreValues: BigUint64Array | null;

}

declare interface VkTimelineSemaphoreSubmitInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    waitSemaphoreValueCount?: number;

    /**
     *
     */
    pWaitSemaphoreValues?: BigUint64Array | null;

    /**
     *
     */
    signalSemaphoreValueCount?: number;

    /**
     *
     */
    pSignalSemaphoreValues?: BigUint64Array | null;
}

declare interface VkTimelineSemaphoreSubmitInfoConstructor {
  readonly prototype: VkTimelineSemaphoreSubmitInfo;
  new(param?: VkTimelineSemaphoreSubmitInfoInitializer | null): VkTimelineSemaphoreSubmitInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkTimelineSemaphoreSubmitInfo: VkTimelineSemaphoreSubmitInfoConstructor;



  /**
   * 
   */
interface VkSemaphoreTypeCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    semaphoreType: VkSemaphoreType;

    /**
     *
     */
    initialValue: bigint | number;

}

declare interface VkSemaphoreTypeCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    semaphoreType?: VkSemaphoreType;

    /**
     *
     */
    initialValue?: bigint | number;
}

declare interface VkSemaphoreTypeCreateInfoKHRConstructor {
  readonly prototype: VkSemaphoreTypeCreateInfoKHR;
  new(param?: VkSemaphoreTypeCreateInfoKHRInitializer | null): VkSemaphoreTypeCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSemaphoreTypeCreateInfoKHR: VkSemaphoreTypeCreateInfoKHRConstructor;



  /**
   * Structure specifying the type of a newly created semaphore
   */
interface VkSemaphoreTypeCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    semaphoreType: VkSemaphoreType;

    /**
     *
     */
    initialValue: bigint | number;

}

declare interface VkSemaphoreTypeCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    semaphoreType?: VkSemaphoreType;

    /**
     *
     */
    initialValue?: bigint | number;
}

declare interface VkSemaphoreTypeCreateInfoConstructor {
  readonly prototype: VkSemaphoreTypeCreateInfo;
  new(param?: VkSemaphoreTypeCreateInfoInitializer | null): VkSemaphoreTypeCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSemaphoreTypeCreateInfo: VkSemaphoreTypeCreateInfoConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceTimelineSemaphorePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxTimelineSemaphoreValueDifference: bigint | number;

}

declare interface VkPhysicalDeviceTimelineSemaphorePropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxTimelineSemaphoreValueDifference?: bigint | number;
}

declare interface VkPhysicalDeviceTimelineSemaphorePropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceTimelineSemaphorePropertiesKHR;
  new(param?: VkPhysicalDeviceTimelineSemaphorePropertiesKHRInitializer | null): VkPhysicalDeviceTimelineSemaphorePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceTimelineSemaphorePropertiesKHR: VkPhysicalDeviceTimelineSemaphorePropertiesKHRConstructor;



  /**
   * Structure describing timeline semaphore properties that can be supported by an implementation
   */
interface VkPhysicalDeviceTimelineSemaphoreProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxTimelineSemaphoreValueDifference: bigint | number;

}

declare interface VkPhysicalDeviceTimelineSemaphorePropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxTimelineSemaphoreValueDifference?: bigint | number;
}

declare interface VkPhysicalDeviceTimelineSemaphorePropertiesConstructor {
  readonly prototype: VkPhysicalDeviceTimelineSemaphoreProperties;
  new(param?: VkPhysicalDeviceTimelineSemaphorePropertiesInitializer | null): VkPhysicalDeviceTimelineSemaphoreProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceTimelineSemaphoreProperties: VkPhysicalDeviceTimelineSemaphorePropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceTimelineSemaphoreFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    timelineSemaphore: boolean;

}

declare interface VkPhysicalDeviceTimelineSemaphoreFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    timelineSemaphore?: boolean;
}

declare interface VkPhysicalDeviceTimelineSemaphoreFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceTimelineSemaphoreFeaturesKHR;
  new(param?: VkPhysicalDeviceTimelineSemaphoreFeaturesKHRInitializer | null): VkPhysicalDeviceTimelineSemaphoreFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceTimelineSemaphoreFeaturesKHR: VkPhysicalDeviceTimelineSemaphoreFeaturesKHRConstructor;



  /**
   * Structure describing timeline semaphore features that can be supported by an implementation
   */
interface VkPhysicalDeviceTimelineSemaphoreFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    timelineSemaphore: boolean;

}

declare interface VkPhysicalDeviceTimelineSemaphoreFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    timelineSemaphore?: boolean;
}

declare interface VkPhysicalDeviceTimelineSemaphoreFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceTimelineSemaphoreFeatures;
  new(param?: VkPhysicalDeviceTimelineSemaphoreFeaturesInitializer | null): VkPhysicalDeviceTimelineSemaphoreFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceTimelineSemaphoreFeatures: VkPhysicalDeviceTimelineSemaphoreFeaturesConstructor;



  /**
   * 
   */
interface VkSubpassEndInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

}

declare interface VkSubpassEndInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;
}

declare interface VkSubpassEndInfoKHRConstructor {
  readonly prototype: VkSubpassEndInfoKHR;
  new(param?: VkSubpassEndInfoKHRInitializer | null): VkSubpassEndInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassEndInfoKHR: VkSubpassEndInfoKHRConstructor;



  /**
   * Structure specifying subpass end info
   */
interface VkSubpassEndInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

}

declare interface VkSubpassEndInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;
}

declare interface VkSubpassEndInfoConstructor {
  readonly prototype: VkSubpassEndInfo;
  new(param?: VkSubpassEndInfoInitializer | null): VkSubpassEndInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassEndInfo: VkSubpassEndInfoConstructor;



  /**
   * 
   */
interface VkSubpassBeginInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    contents: VkSubpassContents;

}

declare interface VkSubpassBeginInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    contents?: VkSubpassContents;
}

declare interface VkSubpassBeginInfoKHRConstructor {
  readonly prototype: VkSubpassBeginInfoKHR;
  new(param?: VkSubpassBeginInfoKHRInitializer | null): VkSubpassBeginInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassBeginInfoKHR: VkSubpassBeginInfoKHRConstructor;



  /**
   * Structure specifying subpass begin info
   */
interface VkSubpassBeginInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    contents: VkSubpassContents;

}

declare interface VkSubpassBeginInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    contents?: VkSubpassContents;
}

declare interface VkSubpassBeginInfoConstructor {
  readonly prototype: VkSubpassBeginInfo;
  new(param?: VkSubpassBeginInfoInitializer | null): VkSubpassBeginInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassBeginInfo: VkSubpassBeginInfoConstructor;



  /**
   * 
   */
interface VkRenderPassCreateInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkRenderPassCreateFlagBits;

    /**
     *
     */
    attachmentCount: number;

    /**
     *
     */
    pAttachments: VkAttachmentDescription2[] | null;

    /**
     *
     */
    subpassCount: number;

    /**
     *
     */
    pSubpasses: VkSubpassDescription2[] | null;

    /**
     *
     */
    dependencyCount: number;

    /**
     *
     */
    pDependencies: VkSubpassDependency2[] | null;

    /**
     *
     */
    correlatedViewMaskCount: number;

    /**
     *
     */
    pCorrelatedViewMasks: Uint32Array | null;

}

declare interface VkRenderPassCreateInfo2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkRenderPassCreateFlagBits;

    /**
     *
     */
    attachmentCount?: number;

    /**
     *
     */
    pAttachments?: VkAttachmentDescription2[] | null;

    /**
     *
     */
    subpassCount?: number;

    /**
     *
     */
    pSubpasses?: VkSubpassDescription2[] | null;

    /**
     *
     */
    dependencyCount?: number;

    /**
     *
     */
    pDependencies?: VkSubpassDependency2[] | null;

    /**
     *
     */
    correlatedViewMaskCount?: number;

    /**
     *
     */
    pCorrelatedViewMasks?: Uint32Array | null;
}

declare interface VkRenderPassCreateInfo2KHRConstructor {
  readonly prototype: VkRenderPassCreateInfo2KHR;
  new(param?: VkRenderPassCreateInfo2KHRInitializer | null): VkRenderPassCreateInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassCreateInfo2KHR: VkRenderPassCreateInfo2KHRConstructor;



  /**
   * Structure specifying parameters of a newly created render pass
   */
interface VkRenderPassCreateInfo2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkRenderPassCreateFlagBits;

    /**
     *
     */
    attachmentCount: number;

    /**
     *
     */
    pAttachments: VkAttachmentDescription2[] | null;

    /**
     *
     */
    subpassCount: number;

    /**
     *
     */
    pSubpasses: VkSubpassDescription2[] | null;

    /**
     *
     */
    dependencyCount: number;

    /**
     *
     */
    pDependencies: VkSubpassDependency2[] | null;

    /**
     *
     */
    correlatedViewMaskCount: number;

    /**
     *
     */
    pCorrelatedViewMasks: Uint32Array | null;

}

declare interface VkRenderPassCreateInfo2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkRenderPassCreateFlagBits;

    /**
     *
     */
    attachmentCount?: number;

    /**
     *
     */
    pAttachments?: VkAttachmentDescription2[] | null;

    /**
     *
     */
    subpassCount?: number;

    /**
     *
     */
    pSubpasses?: VkSubpassDescription2[] | null;

    /**
     *
     */
    dependencyCount?: number;

    /**
     *
     */
    pDependencies?: VkSubpassDependency2[] | null;

    /**
     *
     */
    correlatedViewMaskCount?: number;

    /**
     *
     */
    pCorrelatedViewMasks?: Uint32Array | null;
}

declare interface VkRenderPassCreateInfo2Constructor {
  readonly prototype: VkRenderPassCreateInfo2;
  new(param?: VkRenderPassCreateInfo2Initializer | null): VkRenderPassCreateInfo2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassCreateInfo2: VkRenderPassCreateInfo2Constructor;



  /**
   * 
   */
interface VkSubpassDependency2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    srcSubpass: number;

    /**
     *
     */
    dstSubpass: number;

    /**
     *
     */
    srcStageMask: VkPipelineStageFlagBits;

    /**
     *
     */
    dstStageMask: VkPipelineStageFlagBits;

    /**
     *
     */
    srcAccessMask: VkAccessFlagBits;

    /**
     *
     */
    dstAccessMask: VkAccessFlagBits;

    /**
     *
     */
    dependencyFlags: VkDependencyFlagBits;

    /**
     *
     */
    viewOffset: number;

}

declare interface VkSubpassDependency2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    srcSubpass?: number;

    /**
     *
     */
    dstSubpass?: number;

    /**
     *
     */
    srcStageMask?: VkPipelineStageFlagBits;

    /**
     *
     */
    dstStageMask?: VkPipelineStageFlagBits;

    /**
     *
     */
    srcAccessMask?: VkAccessFlagBits;

    /**
     *
     */
    dstAccessMask?: VkAccessFlagBits;

    /**
     *
     */
    dependencyFlags?: VkDependencyFlagBits;

    /**
     *
     */
    viewOffset?: number;
}

declare interface VkSubpassDependency2KHRConstructor {
  readonly prototype: VkSubpassDependency2KHR;
  new(param?: VkSubpassDependency2KHRInitializer | null): VkSubpassDependency2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassDependency2KHR: VkSubpassDependency2KHRConstructor;



  /**
   * Structure specifying a subpass dependency
   */
interface VkSubpassDependency2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    srcSubpass: number;

    /**
     *
     */
    dstSubpass: number;

    /**
     *
     */
    srcStageMask: VkPipelineStageFlagBits;

    /**
     *
     */
    dstStageMask: VkPipelineStageFlagBits;

    /**
     *
     */
    srcAccessMask: VkAccessFlagBits;

    /**
     *
     */
    dstAccessMask: VkAccessFlagBits;

    /**
     *
     */
    dependencyFlags: VkDependencyFlagBits;

    /**
     *
     */
    viewOffset: number;

}

declare interface VkSubpassDependency2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    srcSubpass?: number;

    /**
     *
     */
    dstSubpass?: number;

    /**
     *
     */
    srcStageMask?: VkPipelineStageFlagBits;

    /**
     *
     */
    dstStageMask?: VkPipelineStageFlagBits;

    /**
     *
     */
    srcAccessMask?: VkAccessFlagBits;

    /**
     *
     */
    dstAccessMask?: VkAccessFlagBits;

    /**
     *
     */
    dependencyFlags?: VkDependencyFlagBits;

    /**
     *
     */
    viewOffset?: number;
}

declare interface VkSubpassDependency2Constructor {
  readonly prototype: VkSubpassDependency2;
  new(param?: VkSubpassDependency2Initializer | null): VkSubpassDependency2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassDependency2: VkSubpassDependency2Constructor;



  /**
   * 
   */
interface VkSubpassDescription2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkSubpassDescriptionFlagBits;

    /**
     *
     */
    pipelineBindPoint: VkPipelineBindPoint;

    /**
     *
     */
    viewMask: number;

    /**
     *
     */
    inputAttachmentCount: number;

    /**
     *
     */
    pInputAttachments: VkAttachmentReference2[] | null;

    /**
     *
     */
    colorAttachmentCount: number;

    /**
     *
     */
    pColorAttachments: VkAttachmentReference2[] | null;

    /**
     *
     */
    pResolveAttachments: VkAttachmentReference2[] | null;

    /**
     *
     */
    pDepthStencilAttachment: VkAttachmentReference2 | null;

    /**
     *
     */
    preserveAttachmentCount: number;

    /**
     *
     */
    pPreserveAttachments: Uint32Array | null;

}

declare interface VkSubpassDescription2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkSubpassDescriptionFlagBits;

    /**
     *
     */
    pipelineBindPoint?: VkPipelineBindPoint;

    /**
     *
     */
    viewMask?: number;

    /**
     *
     */
    inputAttachmentCount?: number;

    /**
     *
     */
    pInputAttachments?: VkAttachmentReference2[] | null;

    /**
     *
     */
    colorAttachmentCount?: number;

    /**
     *
     */
    pColorAttachments?: VkAttachmentReference2[] | null;

    /**
     *
     */
    pResolveAttachments?: VkAttachmentReference2[] | null;

    /**
     *
     */
    pDepthStencilAttachment?: VkAttachmentReference2 | null;

    /**
     *
     */
    preserveAttachmentCount?: number;

    /**
     *
     */
    pPreserveAttachments?: Uint32Array | null;
}

declare interface VkSubpassDescription2KHRConstructor {
  readonly prototype: VkSubpassDescription2KHR;
  new(param?: VkSubpassDescription2KHRInitializer | null): VkSubpassDescription2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassDescription2KHR: VkSubpassDescription2KHRConstructor;



  /**
   * Structure specifying a subpass description
   */
interface VkSubpassDescription2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkSubpassDescriptionFlagBits;

    /**
     *
     */
    pipelineBindPoint: VkPipelineBindPoint;

    /**
     *
     */
    viewMask: number;

    /**
     *
     */
    inputAttachmentCount: number;

    /**
     *
     */
    pInputAttachments: VkAttachmentReference2[] | null;

    /**
     *
     */
    colorAttachmentCount: number;

    /**
     *
     */
    pColorAttachments: VkAttachmentReference2[] | null;

    /**
     *
     */
    pResolveAttachments: VkAttachmentReference2[] | null;

    /**
     *
     */
    pDepthStencilAttachment: VkAttachmentReference2 | null;

    /**
     *
     */
    preserveAttachmentCount: number;

    /**
     *
     */
    pPreserveAttachments: Uint32Array | null;

}

declare interface VkSubpassDescription2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkSubpassDescriptionFlagBits;

    /**
     *
     */
    pipelineBindPoint?: VkPipelineBindPoint;

    /**
     *
     */
    viewMask?: number;

    /**
     *
     */
    inputAttachmentCount?: number;

    /**
     *
     */
    pInputAttachments?: VkAttachmentReference2[] | null;

    /**
     *
     */
    colorAttachmentCount?: number;

    /**
     *
     */
    pColorAttachments?: VkAttachmentReference2[] | null;

    /**
     *
     */
    pResolveAttachments?: VkAttachmentReference2[] | null;

    /**
     *
     */
    pDepthStencilAttachment?: VkAttachmentReference2 | null;

    /**
     *
     */
    preserveAttachmentCount?: number;

    /**
     *
     */
    pPreserveAttachments?: Uint32Array | null;
}

declare interface VkSubpassDescription2Constructor {
  readonly prototype: VkSubpassDescription2;
  new(param?: VkSubpassDescription2Initializer | null): VkSubpassDescription2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassDescription2: VkSubpassDescription2Constructor;



  /**
   * 
   */
interface VkAttachmentReference2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    attachment: number;

    /**
     *
     */
    layout: VkImageLayout;

    /**
     *
     */
    aspectMask: VkImageAspectFlagBits;

}

declare interface VkAttachmentReference2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    attachment?: number;

    /**
     *
     */
    layout?: VkImageLayout;

    /**
     *
     */
    aspectMask?: VkImageAspectFlagBits;
}

declare interface VkAttachmentReference2KHRConstructor {
  readonly prototype: VkAttachmentReference2KHR;
  new(param?: VkAttachmentReference2KHRInitializer | null): VkAttachmentReference2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentReference2KHR: VkAttachmentReference2KHRConstructor;



  /**
   * Structure specifying an attachment reference
   */
interface VkAttachmentReference2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    attachment: number;

    /**
     *
     */
    layout: VkImageLayout;

    /**
     *
     */
    aspectMask: VkImageAspectFlagBits;

}

declare interface VkAttachmentReference2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    attachment?: number;

    /**
     *
     */
    layout?: VkImageLayout;

    /**
     *
     */
    aspectMask?: VkImageAspectFlagBits;
}

declare interface VkAttachmentReference2Constructor {
  readonly prototype: VkAttachmentReference2;
  new(param?: VkAttachmentReference2Initializer | null): VkAttachmentReference2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentReference2: VkAttachmentReference2Constructor;



  /**
   * 
   */
interface VkAttachmentDescription2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkAttachmentDescriptionFlagBits;

    /**
     *
     */
    format: VkFormat;

    /**
     *
     */
    samples: VkSampleCountFlagBits;

    /**
     *
     */
    loadOp: VkAttachmentLoadOp;

    /**
     *
     */
    storeOp: VkAttachmentStoreOp;

    /**
     *
     */
    stencilLoadOp: VkAttachmentLoadOp;

    /**
     *
     */
    stencilStoreOp: VkAttachmentStoreOp;

    /**
     *
     */
    initialLayout: VkImageLayout;

    /**
     *
     */
    finalLayout: VkImageLayout;

}

declare interface VkAttachmentDescription2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkAttachmentDescriptionFlagBits;

    /**
     *
     */
    format?: VkFormat;

    /**
     *
     */
    samples?: VkSampleCountFlagBits;

    /**
     *
     */
    loadOp?: VkAttachmentLoadOp;

    /**
     *
     */
    storeOp?: VkAttachmentStoreOp;

    /**
     *
     */
    stencilLoadOp?: VkAttachmentLoadOp;

    /**
     *
     */
    stencilStoreOp?: VkAttachmentStoreOp;

    /**
     *
     */
    initialLayout?: VkImageLayout;

    /**
     *
     */
    finalLayout?: VkImageLayout;
}

declare interface VkAttachmentDescription2KHRConstructor {
  readonly prototype: VkAttachmentDescription2KHR;
  new(param?: VkAttachmentDescription2KHRInitializer | null): VkAttachmentDescription2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentDescription2KHR: VkAttachmentDescription2KHRConstructor;



  /**
   * Structure specifying an attachment description
   */
interface VkAttachmentDescription2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkAttachmentDescriptionFlagBits;

    /**
     *
     */
    format: VkFormat;

    /**
     *
     */
    samples: VkSampleCountFlagBits;

    /**
     *
     */
    loadOp: VkAttachmentLoadOp;

    /**
     *
     */
    storeOp: VkAttachmentStoreOp;

    /**
     *
     */
    stencilLoadOp: VkAttachmentLoadOp;

    /**
     *
     */
    stencilStoreOp: VkAttachmentStoreOp;

    /**
     *
     */
    initialLayout: VkImageLayout;

    /**
     *
     */
    finalLayout: VkImageLayout;

}

declare interface VkAttachmentDescription2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkAttachmentDescriptionFlagBits;

    /**
     *
     */
    format?: VkFormat;

    /**
     *
     */
    samples?: VkSampleCountFlagBits;

    /**
     *
     */
    loadOp?: VkAttachmentLoadOp;

    /**
     *
     */
    storeOp?: VkAttachmentStoreOp;

    /**
     *
     */
    stencilLoadOp?: VkAttachmentLoadOp;

    /**
     *
     */
    stencilStoreOp?: VkAttachmentStoreOp;

    /**
     *
     */
    initialLayout?: VkImageLayout;

    /**
     *
     */
    finalLayout?: VkImageLayout;
}

declare interface VkAttachmentDescription2Constructor {
  readonly prototype: VkAttachmentDescription2;
  new(param?: VkAttachmentDescription2Initializer | null): VkAttachmentDescription2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentDescription2: VkAttachmentDescription2Constructor;



  /**
   * 
   */
interface VkDescriptorSetVariableDescriptorCountLayoutSupportEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxVariableDescriptorCount: number;

}

declare interface VkDescriptorSetVariableDescriptorCountLayoutSupportEXTInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxVariableDescriptorCount?: number;
}

declare interface VkDescriptorSetVariableDescriptorCountLayoutSupportEXTConstructor {
  readonly prototype: VkDescriptorSetVariableDescriptorCountLayoutSupportEXT;
  new(param?: VkDescriptorSetVariableDescriptorCountLayoutSupportEXTInitializer | null): VkDescriptorSetVariableDescriptorCountLayoutSupportEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetVariableDescriptorCountLayoutSupportEXT: VkDescriptorSetVariableDescriptorCountLayoutSupportEXTConstructor;



  /**
   * Structure returning information about whether a descriptor set layout can be supported
   */
interface VkDescriptorSetVariableDescriptorCountLayoutSupport {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxVariableDescriptorCount: number;

}

declare interface VkDescriptorSetVariableDescriptorCountLayoutSupportInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxVariableDescriptorCount?: number;
}

declare interface VkDescriptorSetVariableDescriptorCountLayoutSupportConstructor {
  readonly prototype: VkDescriptorSetVariableDescriptorCountLayoutSupport;
  new(param?: VkDescriptorSetVariableDescriptorCountLayoutSupportInitializer | null): VkDescriptorSetVariableDescriptorCountLayoutSupport;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetVariableDescriptorCountLayoutSupport: VkDescriptorSetVariableDescriptorCountLayoutSupportConstructor;



  /**
   * 
   */
interface VkDescriptorSetVariableDescriptorCountAllocateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    descriptorSetCount: number;

    /**
     *
     */
    pDescriptorCounts: Uint32Array | null;

}

declare interface VkDescriptorSetVariableDescriptorCountAllocateInfoEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    descriptorSetCount?: number;

    /**
     *
     */
    pDescriptorCounts?: Uint32Array | null;
}

declare interface VkDescriptorSetVariableDescriptorCountAllocateInfoEXTConstructor {
  readonly prototype: VkDescriptorSetVariableDescriptorCountAllocateInfoEXT;
  new(param?: VkDescriptorSetVariableDescriptorCountAllocateInfoEXTInitializer | null): VkDescriptorSetVariableDescriptorCountAllocateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetVariableDescriptorCountAllocateInfoEXT: VkDescriptorSetVariableDescriptorCountAllocateInfoEXTConstructor;



  /**
   * Structure specifying additional allocation parameters for descriptor sets
   */
interface VkDescriptorSetVariableDescriptorCountAllocateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    descriptorSetCount: number;

    /**
     *
     */
    pDescriptorCounts: Uint32Array | null;

}

declare interface VkDescriptorSetVariableDescriptorCountAllocateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    descriptorSetCount?: number;

    /**
     *
     */
    pDescriptorCounts?: Uint32Array | null;
}

declare interface VkDescriptorSetVariableDescriptorCountAllocateInfoConstructor {
  readonly prototype: VkDescriptorSetVariableDescriptorCountAllocateInfo;
  new(param?: VkDescriptorSetVariableDescriptorCountAllocateInfoInitializer | null): VkDescriptorSetVariableDescriptorCountAllocateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetVariableDescriptorCountAllocateInfo: VkDescriptorSetVariableDescriptorCountAllocateInfoConstructor;



  /**
   * 
   */
interface VkDescriptorSetLayoutBindingFlagsCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    bindingCount: number;

    /**
     *
     */
    pBindingFlags: Int32Array | null;

}

declare interface VkDescriptorSetLayoutBindingFlagsCreateInfoEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    bindingCount?: number;

    /**
     *
     */
    pBindingFlags?: Int32Array | null;
}

declare interface VkDescriptorSetLayoutBindingFlagsCreateInfoEXTConstructor {
  readonly prototype: VkDescriptorSetLayoutBindingFlagsCreateInfoEXT;
  new(param?: VkDescriptorSetLayoutBindingFlagsCreateInfoEXTInitializer | null): VkDescriptorSetLayoutBindingFlagsCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetLayoutBindingFlagsCreateInfoEXT: VkDescriptorSetLayoutBindingFlagsCreateInfoEXTConstructor;



  /**
   * Structure specifying creation flags for descriptor set layout bindings
   */
interface VkDescriptorSetLayoutBindingFlagsCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    bindingCount: number;

    /**
     *
     */
    pBindingFlags: Int32Array | null;

}

declare interface VkDescriptorSetLayoutBindingFlagsCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    bindingCount?: number;

    /**
     *
     */
    pBindingFlags?: Int32Array | null;
}

declare interface VkDescriptorSetLayoutBindingFlagsCreateInfoConstructor {
  readonly prototype: VkDescriptorSetLayoutBindingFlagsCreateInfo;
  new(param?: VkDescriptorSetLayoutBindingFlagsCreateInfoInitializer | null): VkDescriptorSetLayoutBindingFlagsCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetLayoutBindingFlagsCreateInfo: VkDescriptorSetLayoutBindingFlagsCreateInfoConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceDescriptorIndexingPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxUpdateAfterBindDescriptorsInAllPools: number;

    /**
     *
     */
    readonly shaderUniformBufferArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderSampledImageArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderStorageBufferArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderStorageImageArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderInputAttachmentArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly robustBufferAccessUpdateAfterBind: boolean;

    /**
     *
     */
    readonly quadDivergentImplicitLod: boolean;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSamplers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindUniformBuffers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageBuffers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSampledImages: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageImages: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindInputAttachments: number;

    /**
     *
     */
    readonly maxPerStageUpdateAfterBindResources: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSamplers: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffers: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffers: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSampledImages: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageImages: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindInputAttachments: number;

}

declare interface VkPhysicalDeviceDescriptorIndexingPropertiesEXTInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxUpdateAfterBindDescriptorsInAllPools?: number;

    /**
     *
     */
    readonly shaderUniformBufferArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderSampledImageArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderStorageBufferArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderStorageImageArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderInputAttachmentArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly robustBufferAccessUpdateAfterBind?: boolean;

    /**
     *
     */
    readonly quadDivergentImplicitLod?: boolean;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSamplers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindUniformBuffers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageBuffers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSampledImages?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageImages?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindInputAttachments?: number;

    /**
     *
     */
    readonly maxPerStageUpdateAfterBindResources?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSamplers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffersDynamic?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffersDynamic?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSampledImages?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageImages?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindInputAttachments?: number;
}

declare interface VkPhysicalDeviceDescriptorIndexingPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceDescriptorIndexingPropertiesEXT;
  new(param?: VkPhysicalDeviceDescriptorIndexingPropertiesEXTInitializer | null): VkPhysicalDeviceDescriptorIndexingPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDescriptorIndexingPropertiesEXT: VkPhysicalDeviceDescriptorIndexingPropertiesEXTConstructor;



  /**
   * Structure describing descriptor indexing properties that can be supported by an implementation
   */
interface VkPhysicalDeviceDescriptorIndexingProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxUpdateAfterBindDescriptorsInAllPools: number;

    /**
     *
     */
    readonly shaderUniformBufferArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderSampledImageArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderStorageBufferArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderStorageImageArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly shaderInputAttachmentArrayNonUniformIndexingNative: boolean;

    /**
     *
     */
    readonly robustBufferAccessUpdateAfterBind: boolean;

    /**
     *
     */
    readonly quadDivergentImplicitLod: boolean;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSamplers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindUniformBuffers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageBuffers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSampledImages: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageImages: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindInputAttachments: number;

    /**
     *
     */
    readonly maxPerStageUpdateAfterBindResources: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSamplers: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffers: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffers: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSampledImages: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageImages: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindInputAttachments: number;

}

declare interface VkPhysicalDeviceDescriptorIndexingPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxUpdateAfterBindDescriptorsInAllPools?: number;

    /**
     *
     */
    readonly shaderUniformBufferArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderSampledImageArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderStorageBufferArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderStorageImageArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly shaderInputAttachmentArrayNonUniformIndexingNative?: boolean;

    /**
     *
     */
    readonly robustBufferAccessUpdateAfterBind?: boolean;

    /**
     *
     */
    readonly quadDivergentImplicitLod?: boolean;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSamplers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindUniformBuffers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageBuffers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindSampledImages?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindStorageImages?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindInputAttachments?: number;

    /**
     *
     */
    readonly maxPerStageUpdateAfterBindResources?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSamplers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindUniformBuffersDynamic?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageBuffersDynamic?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindSampledImages?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindStorageImages?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindInputAttachments?: number;
}

declare interface VkPhysicalDeviceDescriptorIndexingPropertiesConstructor {
  readonly prototype: VkPhysicalDeviceDescriptorIndexingProperties;
  new(param?: VkPhysicalDeviceDescriptorIndexingPropertiesInitializer | null): VkPhysicalDeviceDescriptorIndexingProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDescriptorIndexingProperties: VkPhysicalDeviceDescriptorIndexingPropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceDescriptorIndexingFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderInputAttachmentArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderUniformBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderSampledImageArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderStorageBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderStorageImageArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderInputAttachmentArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    descriptorBindingUniformBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingSampledImageUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingStorageImageUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingStorageBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingUniformTexelBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingStorageTexelBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingUpdateUnusedWhilePending: boolean;

    /**
     *
     */
    descriptorBindingPartiallyBound: boolean;

    /**
     *
     */
    descriptorBindingVariableDescriptorCount: boolean;

    /**
     *
     */
    runtimeDescriptorArray: boolean;

}

declare interface VkPhysicalDeviceDescriptorIndexingFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderInputAttachmentArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderUniformBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderSampledImageArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderStorageBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderStorageImageArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderInputAttachmentArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    descriptorBindingUniformBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingSampledImageUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingStorageImageUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingStorageBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingUniformTexelBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingStorageTexelBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingUpdateUnusedWhilePending?: boolean;

    /**
     *
     */
    descriptorBindingPartiallyBound?: boolean;

    /**
     *
     */
    descriptorBindingVariableDescriptorCount?: boolean;

    /**
     *
     */
    runtimeDescriptorArray?: boolean;
}

declare interface VkPhysicalDeviceDescriptorIndexingFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceDescriptorIndexingFeaturesEXT;
  new(param?: VkPhysicalDeviceDescriptorIndexingFeaturesEXTInitializer | null): VkPhysicalDeviceDescriptorIndexingFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDescriptorIndexingFeaturesEXT: VkPhysicalDeviceDescriptorIndexingFeaturesEXTConstructor;



  /**
   * Structure describing descriptor indexing features that can be supported by an implementation
   */
interface VkPhysicalDeviceDescriptorIndexingFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderInputAttachmentArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderUniformBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderSampledImageArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderStorageBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderStorageImageArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderInputAttachmentArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayNonUniformIndexing: boolean;

    /**
     *
     */
    descriptorBindingUniformBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingSampledImageUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingStorageImageUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingStorageBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingUniformTexelBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingStorageTexelBufferUpdateAfterBind: boolean;

    /**
     *
     */
    descriptorBindingUpdateUnusedWhilePending: boolean;

    /**
     *
     */
    descriptorBindingPartiallyBound: boolean;

    /**
     *
     */
    descriptorBindingVariableDescriptorCount: boolean;

    /**
     *
     */
    runtimeDescriptorArray: boolean;

}

declare interface VkPhysicalDeviceDescriptorIndexingFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderInputAttachmentArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderUniformBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderSampledImageArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderStorageBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderStorageImageArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderInputAttachmentArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderUniformTexelBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    shaderStorageTexelBufferArrayNonUniformIndexing?: boolean;

    /**
     *
     */
    descriptorBindingUniformBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingSampledImageUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingStorageImageUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingStorageBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingUniformTexelBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingStorageTexelBufferUpdateAfterBind?: boolean;

    /**
     *
     */
    descriptorBindingUpdateUnusedWhilePending?: boolean;

    /**
     *
     */
    descriptorBindingPartiallyBound?: boolean;

    /**
     *
     */
    descriptorBindingVariableDescriptorCount?: boolean;

    /**
     *
     */
    runtimeDescriptorArray?: boolean;
}

declare interface VkPhysicalDeviceDescriptorIndexingFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceDescriptorIndexingFeatures;
  new(param?: VkPhysicalDeviceDescriptorIndexingFeaturesInitializer | null): VkPhysicalDeviceDescriptorIndexingFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDescriptorIndexingFeatures: VkPhysicalDeviceDescriptorIndexingFeaturesConstructor;



  /**
   * Structure specifying conservative raster state
   */
interface VkPipelineRasterizationConservativeStateCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is the conservative rasterization mode to use.
     */
    conservativeRasterizationMode: VkConservativeRasterizationModeEXT;

    /**
     * is the extra size in pixels to increase the generating primitive during conservative rasterization at each of its edges in `X` and `Y` equally in screen space beyond the base overestimation specified in 'VkPhysicalDeviceConservativeRasterizationPropertiesEXT'::'primitiveOverestimationSize'.
     */
    extraPrimitiveOverestimationSize: number;

}

declare interface VkPipelineRasterizationConservativeStateCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is the conservative rasterization mode to use.
     */
    conservativeRasterizationMode?: VkConservativeRasterizationModeEXT;

    /**
     * is the extra size in pixels to increase the generating primitive during conservative rasterization at each of its edges in `X` and `Y` equally in screen space beyond the base overestimation specified in 'VkPhysicalDeviceConservativeRasterizationPropertiesEXT'::'primitiveOverestimationSize'.
     */
    extraPrimitiveOverestimationSize?: number;
}

declare interface VkPipelineRasterizationConservativeStateCreateInfoEXTConstructor {
  readonly prototype: VkPipelineRasterizationConservativeStateCreateInfoEXT;
  new(param?: VkPipelineRasterizationConservativeStateCreateInfoEXTInitializer | null): VkPipelineRasterizationConservativeStateCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineRasterizationConservativeStateCreateInfoEXT: VkPipelineRasterizationConservativeStateCreateInfoEXTConstructor;



  /**
   * Structure describing shader core properties that can be supported by an implementation
   */
interface VkPhysicalDeviceShaderCoreProperties2AMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a bitmask of 'VkShaderCorePropertiesFlagBitsAMD' indicating the set of features supported by the shader core.
     */
    readonly shaderCoreFeatures: VkShaderCorePropertiesFlagBitsAMD;

    /**
     * is a number value indicating the number of compute units that have been enabled.
     */
    readonly activeComputeUnitCount: number;

}

declare interface VkPhysicalDeviceShaderCoreProperties2AMDInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a bitmask of 'VkShaderCorePropertiesFlagBitsAMD' indicating the set of features supported by the shader core.
     */
    readonly shaderCoreFeatures?: VkShaderCorePropertiesFlagBitsAMD;

    /**
     * is a number value indicating the number of compute units that have been enabled.
     */
    readonly activeComputeUnitCount?: number;
}

declare interface VkPhysicalDeviceShaderCoreProperties2AMDConstructor {
  readonly prototype: VkPhysicalDeviceShaderCoreProperties2AMD;
  new(param?: VkPhysicalDeviceShaderCoreProperties2AMDInitializer | null): VkPhysicalDeviceShaderCoreProperties2AMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderCoreProperties2AMD: VkPhysicalDeviceShaderCoreProperties2AMDConstructor;



  /**
   * Structure describing shader core properties that can be supported by an implementation
   */
interface VkPhysicalDeviceShaderCorePropertiesAMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a number value indicating the number of shader engines found inside the shader core of the physical device.
     */
    readonly shaderEngineCount: number;

    /**
     * is a number value indicating the number of shader arrays inside a shader engine. Each shader array has its own scan converter, set of compute units, and a render back end (color and depth buffers). Shader arrays within a shader engine share shader processor input (wave launcher) and shader export (export buffer) units. Currently, a shader engine can have one or two shader arrays.
     */
    readonly shaderArraysPerEngineCount: number;

    /**
     * is a number value indicating the physical number of compute units within a shader array. The active number of compute units in a shader array 'may' be lower. A compute unit houses a set of SIMDs along with a sequencer module and a local data store.
     */
    readonly computeUnitsPerShaderArray: number;

    /**
     * is a number value indicating the number of SIMDs inside a compute unit. Each SIMD processes a single instruction at a time.
     */
    readonly simdPerComputeUnit: number;

    /**
     *
     */
    readonly wavefrontsPerSimd: number;

    /**
     * is a number value indicating the maximum size of a subgroup.
     */
    readonly wavefrontSize: number;

    /**
     * is a number value indicating the number of physical Scalar General Purpose Registers (SGPRs) per SIMD.
     */
    readonly sgprsPerSimd: number;

    /**
     * is a number value indicating the minimum number of SGPRs allocated for a wave.
     */
    readonly minSgprAllocation: number;

    /**
     * is a number value indicating the maximum number of SGPRs allocated for a wave.
     */
    readonly maxSgprAllocation: number;

    /**
     * is a number value indicating the granularity of SGPR allocation for a wave.
     */
    readonly sgprAllocationGranularity: number;

    /**
     * is a number value indicating the number of physical Vector General Purpose Registers (VGPRs) per SIMD.
     */
    readonly vgprsPerSimd: number;

    /**
     * is a number value indicating the minimum number of VGPRs allocated for a wave.
     */
    readonly minVgprAllocation: number;

    /**
     * is a number value indicating the maximum number of VGPRs allocated for a wave.
     */
    readonly maxVgprAllocation: number;

    /**
     * is a number value indicating the granularity of VGPR allocation for a wave.
     */
    readonly vgprAllocationGranularity: number;

}

declare interface VkPhysicalDeviceShaderCorePropertiesAMDInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a number value indicating the number of shader engines found inside the shader core of the physical device.
     */
    readonly shaderEngineCount?: number;

    /**
     * is a number value indicating the number of shader arrays inside a shader engine. Each shader array has its own scan converter, set of compute units, and a render back end (color and depth buffers). Shader arrays within a shader engine share shader processor input (wave launcher) and shader export (export buffer) units. Currently, a shader engine can have one or two shader arrays.
     */
    readonly shaderArraysPerEngineCount?: number;

    /**
     * is a number value indicating the physical number of compute units within a shader array. The active number of compute units in a shader array 'may' be lower. A compute unit houses a set of SIMDs along with a sequencer module and a local data store.
     */
    readonly computeUnitsPerShaderArray?: number;

    /**
     * is a number value indicating the number of SIMDs inside a compute unit. Each SIMD processes a single instruction at a time.
     */
    readonly simdPerComputeUnit?: number;

    /**
     *
     */
    readonly wavefrontsPerSimd?: number;

    /**
     * is a number value indicating the maximum size of a subgroup.
     */
    readonly wavefrontSize?: number;

    /**
     * is a number value indicating the number of physical Scalar General Purpose Registers (SGPRs) per SIMD.
     */
    readonly sgprsPerSimd?: number;

    /**
     * is a number value indicating the minimum number of SGPRs allocated for a wave.
     */
    readonly minSgprAllocation?: number;

    /**
     * is a number value indicating the maximum number of SGPRs allocated for a wave.
     */
    readonly maxSgprAllocation?: number;

    /**
     * is a number value indicating the granularity of SGPR allocation for a wave.
     */
    readonly sgprAllocationGranularity?: number;

    /**
     * is a number value indicating the number of physical Vector General Purpose Registers (VGPRs) per SIMD.
     */
    readonly vgprsPerSimd?: number;

    /**
     * is a number value indicating the minimum number of VGPRs allocated for a wave.
     */
    readonly minVgprAllocation?: number;

    /**
     * is a number value indicating the maximum number of VGPRs allocated for a wave.
     */
    readonly maxVgprAllocation?: number;

    /**
     * is a number value indicating the granularity of VGPR allocation for a wave.
     */
    readonly vgprAllocationGranularity?: number;
}

declare interface VkPhysicalDeviceShaderCorePropertiesAMDConstructor {
  readonly prototype: VkPhysicalDeviceShaderCorePropertiesAMD;
  new(param?: VkPhysicalDeviceShaderCorePropertiesAMDInitializer | null): VkPhysicalDeviceShaderCorePropertiesAMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderCorePropertiesAMD: VkPhysicalDeviceShaderCorePropertiesAMDConstructor;



  /**
   * Structure specifying the input parameters of a calibrated timestamp query
   */
interface VkCalibratedTimestampInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkTimeDomainEXT' value specifying the time domain from which the calibrated timestamp value should be returned.
     */
    timeDomain: VkTimeDomainEXT;

}

declare interface VkCalibratedTimestampInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkTimeDomainEXT' value specifying the time domain from which the calibrated timestamp value should be returned.
     */
    timeDomain?: VkTimeDomainEXT;
}

declare interface VkCalibratedTimestampInfoEXTConstructor {
  readonly prototype: VkCalibratedTimestampInfoEXT;
  new(param?: VkCalibratedTimestampInfoEXTInitializer | null): VkCalibratedTimestampInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCalibratedTimestampInfoEXT: VkCalibratedTimestampInfoEXTConstructor;



  /**
   * Structure describing conservative raster properties that can be supported by an implementation
   */
interface VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the size in pixels the generating primitive is increased at each of its edges during conservative rasterization overestimation mode. Even with a size of 0.0, conservative rasterization overestimation rules still apply and if any part of the pixel rectangle is covered by the generating primitive, fragments are generated for the entire pixel. However implementations 'may' make the pixel coverage area even more conservative by increasing the size of the generating primitive.
     */
    readonly primitiveOverestimationSize: number;

    /**
     *
     */
    readonly maxExtraPrimitiveOverestimationSize: number;

    /**
     *
     */
    readonly extraPrimitiveOverestimationSizeGranularity: number;

    /**
     *
     */
    readonly primitiveUnderestimation: boolean;

    /**
     *
     */
    readonly conservativePointAndLineRasterization: boolean;

    /**
     *
     */
    readonly degenerateTrianglesRasterized: boolean;

    /**
     *
     */
    readonly degenerateLinesRasterized: boolean;

    /**
     *
     */
    readonly fullyCoveredFragmentShaderInputVariable: boolean;

    /**
     *
     */
    readonly conservativeRasterizationPostDepthCoverage: boolean;

}

declare interface VkPhysicalDeviceConservativeRasterizationPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the size in pixels the generating primitive is increased at each of its edges during conservative rasterization overestimation mode. Even with a size of 0.0, conservative rasterization overestimation rules still apply and if any part of the pixel rectangle is covered by the generating primitive, fragments are generated for the entire pixel. However implementations 'may' make the pixel coverage area even more conservative by increasing the size of the generating primitive.
     */
    readonly primitiveOverestimationSize?: number;

    /**
     *
     */
    readonly maxExtraPrimitiveOverestimationSize?: number;

    /**
     *
     */
    readonly extraPrimitiveOverestimationSizeGranularity?: number;

    /**
     *
     */
    readonly primitiveUnderestimation?: boolean;

    /**
     *
     */
    readonly conservativePointAndLineRasterization?: boolean;

    /**
     *
     */
    readonly degenerateTrianglesRasterized?: boolean;

    /**
     *
     */
    readonly degenerateLinesRasterized?: boolean;

    /**
     *
     */
    readonly fullyCoveredFragmentShaderInputVariable?: boolean;

    /**
     *
     */
    readonly conservativeRasterizationPostDepthCoverage?: boolean;
}

declare interface VkPhysicalDeviceConservativeRasterizationPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceConservativeRasterizationPropertiesEXT;
  new(param?: VkPhysicalDeviceConservativeRasterizationPropertiesEXTInitializer | null): VkPhysicalDeviceConservativeRasterizationPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceConservativeRasterizationPropertiesEXT: VkPhysicalDeviceConservativeRasterizationPropertiesEXTConstructor;



  /**
   * Structure describing external memory host reference limits that can be supported by an implementation
   */
interface VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the minimum 'required' alignment, in bytes, for the base address and size of host references that 'can' be imported to a Vulkan memory object.
     */
    readonly minImportedHostPointerAlignment: bigint | number;

}

declare interface VkPhysicalDeviceExternalMemoryHostPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the minimum 'required' alignment, in bytes, for the base address and size of host references that 'can' be imported to a Vulkan memory object.
     */
    readonly minImportedHostPointerAlignment?: bigint | number;
}

declare interface VkPhysicalDeviceExternalMemoryHostPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceExternalMemoryHostPropertiesEXT;
  new(param?: VkPhysicalDeviceExternalMemoryHostPropertiesEXTInitializer | null): VkPhysicalDeviceExternalMemoryHostPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExternalMemoryHostPropertiesEXT: VkPhysicalDeviceExternalMemoryHostPropertiesEXTConstructor;



  /**
   * Properties of external memory host reference
   */
interface VkMemoryHostPointerPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a bitmask containing one bit set for every memory type which the specified host reference 'can' be imported as.
     */
    readonly memoryTypeBits: number;

}

declare interface VkMemoryHostPointerPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a bitmask containing one bit set for every memory type which the specified host reference 'can' be imported as.
     */
    readonly memoryTypeBits?: number;
}

declare interface VkMemoryHostPointerPropertiesEXTConstructor {
  readonly prototype: VkMemoryHostPointerPropertiesEXT;
  new(param?: VkMemoryHostPointerPropertiesEXTInitializer | null): VkMemoryHostPointerPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryHostPointerPropertiesEXT: VkMemoryHostPointerPropertiesEXTConstructor;



  /**
   * import memory from a host reference
   */
interface VkImportMemoryHostPointerInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies the handle type.
     */
    handleType: VkExternalMemoryHandleTypeFlagBits;

    /**
     * is the host reference to import from.
     */
    pHostPointer: ArrayBuffer | null;

}

declare interface VkImportMemoryHostPointerInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies the handle type.
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits;

    /**
     * is the host reference to import from.
     */
    pHostPointer?: ArrayBuffer | null;
}

declare interface VkImportMemoryHostPointerInfoEXTConstructor {
  readonly prototype: VkImportMemoryHostPointerInfoEXT;
  new(param?: VkImportMemoryHostPointerInfoEXTInitializer | null): VkImportMemoryHostPointerInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImportMemoryHostPointerInfoEXT: VkImportMemoryHostPointerInfoEXTConstructor;



  /**
   * Structure specifying parameters returned to the callback
   */
interface VkDeviceMemoryReportCallbackDataEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is 0 and reserved for future use.
     */
    readonly flags: number;

    /**
     * is a 'VkDeviceMemoryReportEventTypeEXT' type specifying the type of event reported in this 'VkDeviceMemoryReportCallbackDataEXT' structure.
     */
    readonly type: VkDeviceMemoryReportEventTypeEXT;

    /**
     * is the unique id for the underlying memory object as described below.
     */
    readonly memoryObjectId: bigint | number;

    /**
     * is the size of the memory object in bytes. If 'type' is 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT', 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT' or 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT', 'size' 'must' be a valid 'VkDeviceSize' value.
     */
    readonly size: bigint | number;

    /**
     * is a 'VkObjectType' value specifying the type of the object associated with this device memory report event. If 'type' is 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT', 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT' or 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT', 'objectType' 'must' be a valid 'VkObjectType' enum.
     */
    readonly objectType: VkObjectType;

    /**
     * is the object this device memory report event is attributed to. If 'type' is 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT', 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT', 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT' or 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT', 'objectHandle' 'must' be a valid Vulkan handle of the type associated with 'objectType' as defined in the <<debugging-object-types, VkObjectType and Vulkan Handle Relationship>> table.
     */
    readonly objectHandle: bigint | number;

    /**
     * describes which memory heap this device memory allocation is made from. If 'type' is 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT' or 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT', 'heapIndex' 'must' correspond to one of the valid heaps from the 'VkPhysicalDeviceMemoryProperties' structure. Otherwise, 'heapIndex' is 'undefined'.
     */
    readonly heapIndex: number;

}

declare interface VkDeviceMemoryReportCallbackDataEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is 0 and reserved for future use.
     */
    readonly flags?: number;

    /**
     * is a 'VkDeviceMemoryReportEventTypeEXT' type specifying the type of event reported in this 'VkDeviceMemoryReportCallbackDataEXT' structure.
     */
    readonly type?: VkDeviceMemoryReportEventTypeEXT;

    /**
     * is the unique id for the underlying memory object as described below.
     */
    readonly memoryObjectId?: bigint | number;

    /**
     * is the size of the memory object in bytes. If 'type' is 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT', 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT' or 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT', 'size' 'must' be a valid 'VkDeviceSize' value.
     */
    readonly size?: bigint | number;

    /**
     * is a 'VkObjectType' value specifying the type of the object associated with this device memory report event. If 'type' is 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT', 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT' or 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT', 'objectType' 'must' be a valid 'VkObjectType' enum.
     */
    readonly objectType?: VkObjectType;

    /**
     * is the object this device memory report event is attributed to. If 'type' is 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT', 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT', 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT' or 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT', 'objectHandle' 'must' be a valid Vulkan handle of the type associated with 'objectType' as defined in the <<debugging-object-types, VkObjectType and Vulkan Handle Relationship>> table.
     */
    readonly objectHandle?: bigint | number;

    /**
     * describes which memory heap this device memory allocation is made from. If 'type' is 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT' or 'VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT', 'heapIndex' 'must' correspond to one of the valid heaps from the 'VkPhysicalDeviceMemoryProperties' structure. Otherwise, 'heapIndex' is 'undefined'.
     */
    readonly heapIndex?: number;
}

declare interface VkDeviceMemoryReportCallbackDataEXTConstructor {
  readonly prototype: VkDeviceMemoryReportCallbackDataEXT;
  new(param?: VkDeviceMemoryReportCallbackDataEXTInitializer | null): VkDeviceMemoryReportCallbackDataEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceMemoryReportCallbackDataEXT: VkDeviceMemoryReportCallbackDataEXTConstructor;



  /**
   * Register device memory report callbacks for a Vulkan device
   */
interface VkDeviceDeviceMemoryReportCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is 0 and reserved for future use.
     */
    flags: number;

    /**
     * is the application callback function to call.
     */
    pfnUserCallback: vkDeviceMemoryReportCallbackEXT | null;

    /**
     * is user data to be passed to the callback.
     */
    pUserData: ArrayBuffer | null;

}

declare interface VkDeviceDeviceMemoryReportCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is 0 and reserved for future use.
     */
    flags?: number;

    /**
     * is the application callback function to call.
     */
    pfnUserCallback?: vkDeviceMemoryReportCallbackEXT | null;

    /**
     * is user data to be passed to the callback.
     */
    pUserData?: ArrayBuffer | null;
}

declare interface VkDeviceDeviceMemoryReportCreateInfoEXTConstructor {
  readonly prototype: VkDeviceDeviceMemoryReportCreateInfoEXT;
  new(param?: VkDeviceDeviceMemoryReportCreateInfoEXTInitializer | null): VkDeviceDeviceMemoryReportCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceDeviceMemoryReportCreateInfoEXT: VkDeviceDeviceMemoryReportCreateInfoEXTConstructor;



  /**
   * Structure describing whether device memory report callback can be supported by an implementation
   */
interface VkPhysicalDeviceDeviceMemoryReportFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports the ability to register device memory report callbacks.
     */
    deviceMemoryReport: boolean;

}

declare interface VkPhysicalDeviceDeviceMemoryReportFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports the ability to register device memory report callbacks.
     */
    deviceMemoryReport?: boolean;
}

declare interface VkPhysicalDeviceDeviceMemoryReportFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceDeviceMemoryReportFeaturesEXT;
  new(param?: VkPhysicalDeviceDeviceMemoryReportFeaturesEXTInitializer | null): VkPhysicalDeviceDeviceMemoryReportFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDeviceMemoryReportFeaturesEXT: VkPhysicalDeviceDeviceMemoryReportFeaturesEXTConstructor;



  /**
   * Structure specifying parameters returned to the callback
   */
interface VkDebugUtilsMessengerCallbackDataEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is `0` and is reserved for future use.
     */
    flags: number;

    /**
     * is a string that identifies the particular message ID that is associated with the provided message. If the message corresponds to a validation layer message, then this string may contain the portion of the Vulkan specification that is believed to have been violated.
     */
    pMessageIdName: string | null;

    /**
     * is the ID number of the triggering message. If the message corresponds to a validation layer message, then this number is related to the internal number associated with the message being triggered.
     */
    messageIdNumber: number;

    /**
     * is a string detailing the trigger conditions.
     */
    pMessage: string | null;

    /**
     * is a count of items contained in the 'pQueueLabels' array.
     */
    queueLabelCount: number;

    /**
     * is <i>null</i> or a reference to an array of 'VkDebugUtilsLabelEXT' active in the current 'VkQueue' at the time the callback was triggered. Refer to <<debugging-queue-labels,Queue Labels>> for more information.
     */
    pQueueLabels: VkDebugUtilsLabelEXT[] | null;

    /**
     * is a count of items contained in the 'pCmdBufLabels' array.
     */
    cmdBufLabelCount: number;

    /**
     * is <i>null</i> or a reference to an array of 'VkDebugUtilsLabelEXT' active in the current 'VkCommandBuffer' at the time the callback was triggered. Refer to <<debugging-command-buffer-labels, Command Buffer Labels>> for more information.
     */
    pCmdBufLabels: VkDebugUtilsLabelEXT[] | null;

    /**
     *
     */
    objectCount: number;

    /**
     * is an array of 'VkDebugUtilsObjectNameInfoEXT' objects related to the detected issue. The array is roughly in order or importance, but the 0th element is always guaranteed to be the most important object for this message.
     */
    pObjects: VkDebugUtilsObjectNameInfoEXT[] | null;

}

declare interface VkDebugUtilsMessengerCallbackDataEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is `0` and is reserved for future use.
     */
    flags?: number;

    /**
     * is a string that identifies the particular message ID that is associated with the provided message. If the message corresponds to a validation layer message, then this string may contain the portion of the Vulkan specification that is believed to have been violated.
     */
    pMessageIdName?: string | null;

    /**
     * is the ID number of the triggering message. If the message corresponds to a validation layer message, then this number is related to the internal number associated with the message being triggered.
     */
    messageIdNumber?: number;

    /**
     * is a string detailing the trigger conditions.
     */
    pMessage?: string | null;

    /**
     * is a count of items contained in the 'pQueueLabels' array.
     */
    queueLabelCount?: number;

    /**
     * is <i>null</i> or a reference to an array of 'VkDebugUtilsLabelEXT' active in the current 'VkQueue' at the time the callback was triggered. Refer to <<debugging-queue-labels,Queue Labels>> for more information.
     */
    pQueueLabels?: VkDebugUtilsLabelEXT[] | null;

    /**
     * is a count of items contained in the 'pCmdBufLabels' array.
     */
    cmdBufLabelCount?: number;

    /**
     * is <i>null</i> or a reference to an array of 'VkDebugUtilsLabelEXT' active in the current 'VkCommandBuffer' at the time the callback was triggered. Refer to <<debugging-command-buffer-labels, Command Buffer Labels>> for more information.
     */
    pCmdBufLabels?: VkDebugUtilsLabelEXT[] | null;

    /**
     *
     */
    objectCount?: number;

    /**
     * is an array of 'VkDebugUtilsObjectNameInfoEXT' objects related to the detected issue. The array is roughly in order or importance, but the 0th element is always guaranteed to be the most important object for this message.
     */
    pObjects?: VkDebugUtilsObjectNameInfoEXT[] | null;
}

declare interface VkDebugUtilsMessengerCallbackDataEXTConstructor {
  readonly prototype: VkDebugUtilsMessengerCallbackDataEXT;
  new(param?: VkDebugUtilsMessengerCallbackDataEXTInitializer | null): VkDebugUtilsMessengerCallbackDataEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDebugUtilsMessengerCallbackDataEXT: VkDebugUtilsMessengerCallbackDataEXTConstructor;



  /**
   * Structure specifying parameters of a newly created debug messenger
   */
interface VkDebugUtilsMessengerCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is `0` and is reserved for future use.
     */
    flags: number;

    /**
     * is a bitmask of 'VkDebugUtilsMessageSeverityFlagBitsEXT' specifying which severity of event(s) will cause this callback to be called.
     */
    messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT;

    /**
     * is a bitmask of 'VkDebugUtilsMessageTypeFlagBitsEXT' specifying which type of event(s) will cause this callback to be called.
     */
    messageType: VkDebugUtilsMessageTypeFlagBitsEXT;

    /**
     * is the application callback function to call.
     */
    pfnUserCallback: vkDebugUtilsMessengerCallbackEXT | null;

    /**
     * is user data to be passed to the callback.
     */
    pUserData: ArrayBuffer | null;

}

declare interface VkDebugUtilsMessengerCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is `0` and is reserved for future use.
     */
    flags?: number;

    /**
     * is a bitmask of 'VkDebugUtilsMessageSeverityFlagBitsEXT' specifying which severity of event(s) will cause this callback to be called.
     */
    messageSeverity?: VkDebugUtilsMessageSeverityFlagBitsEXT;

    /**
     * is a bitmask of 'VkDebugUtilsMessageTypeFlagBitsEXT' specifying which type of event(s) will cause this callback to be called.
     */
    messageType?: VkDebugUtilsMessageTypeFlagBitsEXT;

    /**
     * is the application callback function to call.
     */
    pfnUserCallback?: vkDebugUtilsMessengerCallbackEXT | null;

    /**
     * is user data to be passed to the callback.
     */
    pUserData?: ArrayBuffer | null;
}

declare interface VkDebugUtilsMessengerCreateInfoEXTConstructor {
  readonly prototype: VkDebugUtilsMessengerCreateInfoEXT;
  new(param?: VkDebugUtilsMessengerCreateInfoEXTInitializer | null): VkDebugUtilsMessengerCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDebugUtilsMessengerCreateInfoEXT: VkDebugUtilsMessengerCreateInfoEXTConstructor;



  /**
   * Specify parameters of a label region
   */
interface VkDebugUtilsLabelEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a reference to a string containing the name of the label.
     */
    pLabelName: string | null;

    /**
     * is an optional RGBA color value that can be associated with the label. A particular implementation 'may' choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in 'color' are set to 0.0 then it is ignored.
     */
    color: number[] | null;

}

declare interface VkDebugUtilsLabelEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a reference to a string containing the name of the label.
     */
    pLabelName?: string | null;

    /**
     * is an optional RGBA color value that can be associated with the label. A particular implementation 'may' choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in 'color' are set to 0.0 then it is ignored.
     */
    color?: number[] | null;
}

declare interface VkDebugUtilsLabelEXTConstructor {
  readonly prototype: VkDebugUtilsLabelEXT;
  new(param?: VkDebugUtilsLabelEXTInitializer | null): VkDebugUtilsLabelEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDebugUtilsLabelEXT: VkDebugUtilsLabelEXTConstructor;



  /**
   * Specify parameters of a tag to attach to an object
   */
interface VkDebugUtilsObjectTagInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkObjectType' specifying the type of the object to be named.
     */
    objectType: VkObjectType;

    /**
     * is the object to be tagged.
     */
    objectHandle: bigint | number;

    /**
     * is a numerical identifier of the tag.
     */
    tagName: bigint | number;

    /**
     * bytes containing the data to be associated with the object.
     */
    tagSize: bigint | number;

    /**
     *
     */
    pTag: ArrayBuffer | null;

}

declare interface VkDebugUtilsObjectTagInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkObjectType' specifying the type of the object to be named.
     */
    objectType?: VkObjectType;

    /**
     * is the object to be tagged.
     */
    objectHandle?: bigint | number;

    /**
     * is a numerical identifier of the tag.
     */
    tagName?: bigint | number;

    /**
     * bytes containing the data to be associated with the object.
     */
    tagSize?: bigint | number;

    /**
     *
     */
    pTag?: ArrayBuffer | null;
}

declare interface VkDebugUtilsObjectTagInfoEXTConstructor {
  readonly prototype: VkDebugUtilsObjectTagInfoEXT;
  new(param?: VkDebugUtilsObjectTagInfoEXTInitializer | null): VkDebugUtilsObjectTagInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDebugUtilsObjectTagInfoEXT: VkDebugUtilsObjectTagInfoEXTConstructor;



  /**
   * Specify parameters of a name to give to an object
   */
interface VkDebugUtilsObjectNameInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkObjectType' specifying the type of the object to be named.
     */
    objectType: VkObjectType;

    /**
     * is the object to be named.
     */
    objectHandle: bigint | number;

    /**
     * is either <i>null</i> or a string specifying the name to apply to 'objectHandle'.
     */
    pObjectName: string | null;

}

declare interface VkDebugUtilsObjectNameInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkObjectType' specifying the type of the object to be named.
     */
    objectType?: VkObjectType;

    /**
     * is the object to be named.
     */
    objectHandle?: bigint | number;

    /**
     * is either <i>null</i> or a string specifying the name to apply to 'objectHandle'.
     */
    pObjectName?: string | null;
}

declare interface VkDebugUtilsObjectNameInfoEXTConstructor {
  readonly prototype: VkDebugUtilsObjectNameInfoEXT;
  new(param?: VkDebugUtilsObjectNameInfoEXTInitializer | null): VkDebugUtilsObjectNameInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDebugUtilsObjectNameInfoEXT: VkDebugUtilsObjectNameInfoEXTConstructor;



  /**
   * Specify a system wide priority
   */
interface VkDeviceQueueGlobalPriorityCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the system-wide priority associated to this queue as specified by 'VkQueueGlobalPriorityEXT'
     */
    globalPriority: VkQueueGlobalPriorityEXT;

}

declare interface VkDeviceQueueGlobalPriorityCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the system-wide priority associated to this queue as specified by 'VkQueueGlobalPriorityEXT'
     */
    globalPriority?: VkQueueGlobalPriorityEXT;
}

declare interface VkDeviceQueueGlobalPriorityCreateInfoEXTConstructor {
  readonly prototype: VkDeviceQueueGlobalPriorityCreateInfoEXT;
  new(param?: VkDeviceQueueGlobalPriorityCreateInfoEXTInitializer | null): VkDeviceQueueGlobalPriorityCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceQueueGlobalPriorityCreateInfoEXT: VkDeviceQueueGlobalPriorityCreateInfoEXTConstructor;



  /**
   * Statistical information about a particular shader within a pipeline
   */
interface VkShaderStatisticsInfoAMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly shaderStageMask: VkShaderStageFlagBits;

    /**
     *
     */
    readonly resourceUsage: VkShaderResourceUsageAMD | null;

    /**
     *
     */
    readonly numPhysicalVgprs: number;

    /**
     *
     */
    readonly numPhysicalSgprs: number;

    /**
     *
     */
    readonly numAvailableVgprs: number;

    /**
     *
     */
    readonly numAvailableSgprs: number;

    /**
     *
     */
    readonly computeWorkGroupSize: number[] | null;

}

declare interface VkShaderStatisticsInfoAMDInitializer {
  
    /**
     *
     */
    readonly shaderStageMask?: VkShaderStageFlagBits;

    /**
     *
     */
    readonly resourceUsage?: VkShaderResourceUsageAMD | null;

    /**
     *
     */
    readonly numPhysicalVgprs?: number;

    /**
     *
     */
    readonly numPhysicalSgprs?: number;

    /**
     *
     */
    readonly numAvailableVgprs?: number;

    /**
     *
     */
    readonly numAvailableSgprs?: number;

    /**
     *
     */
    readonly computeWorkGroupSize?: number[] | null;
}

declare interface VkShaderStatisticsInfoAMDConstructor {
  readonly prototype: VkShaderStatisticsInfoAMD;
  new(param?: VkShaderStatisticsInfoAMDInitializer | null): VkShaderStatisticsInfoAMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkShaderStatisticsInfoAMD: VkShaderStatisticsInfoAMDConstructor;



  /**
   * Resource usage information about a particular shader within a pipeline
   */
interface VkShaderResourceUsageAMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the number of vector instruction general-purpose registers used by this shader.
     */
    readonly numUsedVgprs: number;

    /**
     * is the number of scalar instruction general-purpose registers used by this shader.
     */
    readonly numUsedSgprs: number;

    /**
     * is the maximum local data store size per work group in bytes.
     */
    readonly ldsSizePerLocalWorkGroup: number;

    /**
     * is the LDS usage size in bytes per work group by this shader.
     */
    readonly ldsUsageSizeInBytes: bigint | number;

    /**
     * is the scratch memory usage in bytes by this shader.
     */
    readonly scratchMemUsageInBytes: bigint | number;

}

declare interface VkShaderResourceUsageAMDInitializer {
  
    /**
     * is the number of vector instruction general-purpose registers used by this shader.
     */
    readonly numUsedVgprs?: number;

    /**
     * is the number of scalar instruction general-purpose registers used by this shader.
     */
    readonly numUsedSgprs?: number;

    /**
     * is the maximum local data store size per work group in bytes.
     */
    readonly ldsSizePerLocalWorkGroup?: number;

    /**
     * is the LDS usage size in bytes per work group by this shader.
     */
    readonly ldsUsageSizeInBytes?: bigint | number;

    /**
     * is the scratch memory usage in bytes by this shader.
     */
    readonly scratchMemUsageInBytes?: bigint | number;
}

declare interface VkShaderResourceUsageAMDConstructor {
  readonly prototype: VkShaderResourceUsageAMD;
  new(param?: VkShaderResourceUsageAMDInitializer | null): VkShaderResourceUsageAMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkShaderResourceUsageAMD: VkShaderResourceUsageAMDConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceHostQueryResetFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    hostQueryReset: boolean;

}

declare interface VkPhysicalDeviceHostQueryResetFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    hostQueryReset?: boolean;
}

declare interface VkPhysicalDeviceHostQueryResetFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceHostQueryResetFeaturesEXT;
  new(param?: VkPhysicalDeviceHostQueryResetFeaturesEXTInitializer | null): VkPhysicalDeviceHostQueryResetFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceHostQueryResetFeaturesEXT: VkPhysicalDeviceHostQueryResetFeaturesEXTConstructor;



  /**
   * Structure describing whether queries can be reset from the host
   */
interface VkPhysicalDeviceHostQueryResetFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    hostQueryReset: boolean;

}

declare interface VkPhysicalDeviceHostQueryResetFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    hostQueryReset?: boolean;
}

declare interface VkPhysicalDeviceHostQueryResetFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceHostQueryResetFeatures;
  new(param?: VkPhysicalDeviceHostQueryResetFeaturesInitializer | null): VkPhysicalDeviceHostQueryResetFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceHostQueryResetFeatures: VkPhysicalDeviceHostQueryResetFeaturesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceFloatControlsPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly denormBehaviorIndependence: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly roundingModeIndependence: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat16: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat32: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat64: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat16: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat32: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat64: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat16: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat32: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat64: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat16: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat32: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat64: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat16: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat32: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat64: boolean;

}

declare interface VkPhysicalDeviceFloatControlsPropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly denormBehaviorIndependence?: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly roundingModeIndependence?: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat16?: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat32?: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat64?: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat16?: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat32?: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat64?: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat16?: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat32?: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat64?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat16?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat32?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat64?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat16?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat32?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat64?: boolean;
}

declare interface VkPhysicalDeviceFloatControlsPropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceFloatControlsPropertiesKHR;
  new(param?: VkPhysicalDeviceFloatControlsPropertiesKHRInitializer | null): VkPhysicalDeviceFloatControlsPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFloatControlsPropertiesKHR: VkPhysicalDeviceFloatControlsPropertiesKHRConstructor;



  /**
   * Structure describing properties supported by VK_KHR_shader_float_controls
   */
interface VkPhysicalDeviceFloatControlsProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly denormBehaviorIndependence: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly roundingModeIndependence: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat16: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat32: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat64: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat16: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat32: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat64: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat16: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat32: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat64: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat16: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat32: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat64: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat16: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat32: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat64: boolean;

}

declare interface VkPhysicalDeviceFloatControlsPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly denormBehaviorIndependence?: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly roundingModeIndependence?: VkShaderFloatControlsIndependence;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat16?: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat32?: boolean;

    /**
     *
     */
    readonly shaderSignedZeroInfNanPreserveFloat64?: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat16?: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat32?: boolean;

    /**
     *
     */
    readonly shaderDenormPreserveFloat64?: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat16?: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat32?: boolean;

    /**
     *
     */
    readonly shaderDenormFlushToZeroFloat64?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat16?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat32?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTEFloat64?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat16?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat32?: boolean;

    /**
     *
     */
    readonly shaderRoundingModeRTZFloat64?: boolean;
}

declare interface VkPhysicalDeviceFloatControlsPropertiesConstructor {
  readonly prototype: VkPhysicalDeviceFloatControlsProperties;
  new(param?: VkPhysicalDeviceFloatControlsPropertiesInitializer | null): VkPhysicalDeviceFloatControlsProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFloatControlsProperties: VkPhysicalDeviceFloatControlsPropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceFloat16Int8FeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderFloat16: boolean;

    /**
     *
     */
    shaderInt8: boolean;

}

declare interface VkPhysicalDeviceFloat16Int8FeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderFloat16?: boolean;

    /**
     *
     */
    shaderInt8?: boolean;
}

declare interface VkPhysicalDeviceFloat16Int8FeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceFloat16Int8FeaturesKHR;
  new(param?: VkPhysicalDeviceFloat16Int8FeaturesKHRInitializer | null): VkPhysicalDeviceFloat16Int8FeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFloat16Int8FeaturesKHR: VkPhysicalDeviceFloat16Int8FeaturesKHRConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceShaderFloat16Int8FeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderFloat16: boolean;

    /**
     *
     */
    shaderInt8: boolean;

}

declare interface VkPhysicalDeviceShaderFloat16Int8FeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderFloat16?: boolean;

    /**
     *
     */
    shaderInt8?: boolean;
}

declare interface VkPhysicalDeviceShaderFloat16Int8FeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceShaderFloat16Int8FeaturesKHR;
  new(param?: VkPhysicalDeviceShaderFloat16Int8FeaturesKHRInitializer | null): VkPhysicalDeviceShaderFloat16Int8FeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderFloat16Int8FeaturesKHR: VkPhysicalDeviceShaderFloat16Int8FeaturesKHRConstructor;



  /**
   * Structure describing features supported by VK_KHR_shader_float16_int8
   */
interface VkPhysicalDeviceShaderFloat16Int8Features {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderFloat16: boolean;

    /**
     *
     */
    shaderInt8: boolean;

}

declare interface VkPhysicalDeviceShaderFloat16Int8FeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderFloat16?: boolean;

    /**
     *
     */
    shaderInt8?: boolean;
}

declare interface VkPhysicalDeviceShaderFloat16Int8FeaturesConstructor {
  readonly prototype: VkPhysicalDeviceShaderFloat16Int8Features;
  new(param?: VkPhysicalDeviceShaderFloat16Int8FeaturesInitializer | null): VkPhysicalDeviceShaderFloat16Int8Features;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderFloat16Int8Features: VkPhysicalDeviceShaderFloat16Int8FeaturesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceShaderDrawParameterFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderDrawParameters: boolean;

}

declare interface VkPhysicalDeviceShaderDrawParameterFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderDrawParameters?: boolean;
}

declare interface VkPhysicalDeviceShaderDrawParameterFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceShaderDrawParameterFeatures;
  new(param?: VkPhysicalDeviceShaderDrawParameterFeaturesInitializer | null): VkPhysicalDeviceShaderDrawParameterFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderDrawParameterFeatures: VkPhysicalDeviceShaderDrawParameterFeaturesConstructor;



  /**
   * Structure describing shader draw parameter features that can be supported by an implementation
   */
interface VkPhysicalDeviceShaderDrawParametersFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderDrawParameters: boolean;

}

declare interface VkPhysicalDeviceShaderDrawParametersFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderDrawParameters?: boolean;
}

declare interface VkPhysicalDeviceShaderDrawParametersFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceShaderDrawParametersFeatures;
  new(param?: VkPhysicalDeviceShaderDrawParametersFeaturesInitializer | null): VkPhysicalDeviceShaderDrawParametersFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderDrawParametersFeatures: VkPhysicalDeviceShaderDrawParametersFeaturesConstructor;



  /**
   * 
   */
interface VkDescriptorSetLayoutSupportKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly supported: boolean;

}

declare interface VkDescriptorSetLayoutSupportKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly supported?: boolean;
}

declare interface VkDescriptorSetLayoutSupportKHRConstructor {
  readonly prototype: VkDescriptorSetLayoutSupportKHR;
  new(param?: VkDescriptorSetLayoutSupportKHRInitializer | null): VkDescriptorSetLayoutSupportKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetLayoutSupportKHR: VkDescriptorSetLayoutSupportKHRConstructor;



  /**
   * Structure returning information about whether a descriptor set layout can be supported
   */
interface VkDescriptorSetLayoutSupport {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly supported: boolean;

}

declare interface VkDescriptorSetLayoutSupportInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly supported?: boolean;
}

declare interface VkDescriptorSetLayoutSupportConstructor {
  readonly prototype: VkDescriptorSetLayoutSupport;
  new(param?: VkDescriptorSetLayoutSupportInitializer | null): VkDescriptorSetLayoutSupport;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetLayoutSupport: VkDescriptorSetLayoutSupportConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceMaintenance3PropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxPerSetDescriptors: number;

    /**
     *
     */
    readonly maxMemoryAllocationSize: bigint | number;

}

declare interface VkPhysicalDeviceMaintenance3PropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxPerSetDescriptors?: number;

    /**
     *
     */
    readonly maxMemoryAllocationSize?: bigint | number;
}

declare interface VkPhysicalDeviceMaintenance3PropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceMaintenance3PropertiesKHR;
  new(param?: VkPhysicalDeviceMaintenance3PropertiesKHRInitializer | null): VkPhysicalDeviceMaintenance3PropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMaintenance3PropertiesKHR: VkPhysicalDeviceMaintenance3PropertiesKHRConstructor;



  /**
   * Structure describing descriptor set properties
   */
interface VkPhysicalDeviceMaintenance3Properties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxPerSetDescriptors: number;

    /**
     *
     */
    readonly maxMemoryAllocationSize: bigint | number;

}

declare interface VkPhysicalDeviceMaintenance3PropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxPerSetDescriptors?: number;

    /**
     *
     */
    readonly maxMemoryAllocationSize?: bigint | number;
}

declare interface VkPhysicalDeviceMaintenance3PropertiesConstructor {
  readonly prototype: VkPhysicalDeviceMaintenance3Properties;
  new(param?: VkPhysicalDeviceMaintenance3PropertiesInitializer | null): VkPhysicalDeviceMaintenance3Properties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMaintenance3Properties: VkPhysicalDeviceMaintenance3PropertiesConstructor;



  /**
   * Specify validation cache to use during shader module creation
   */
interface VkShaderModuleValidationCacheCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the validation cache object from which the results of prior validation attempts will be written, and to which new validation results for this 'VkShaderModule' will be written (if not already present).
     */
    validationCache: VkValidationCacheEXT | null;

}

declare interface VkShaderModuleValidationCacheCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the validation cache object from which the results of prior validation attempts will be written, and to which new validation results for this 'VkShaderModule' will be written (if not already present).
     */
    validationCache?: VkValidationCacheEXT | null;
}

declare interface VkShaderModuleValidationCacheCreateInfoEXTConstructor {
  readonly prototype: VkShaderModuleValidationCacheCreateInfoEXT;
  new(param?: VkShaderModuleValidationCacheCreateInfoEXTInitializer | null): VkShaderModuleValidationCacheCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkShaderModuleValidationCacheCreateInfoEXT: VkShaderModuleValidationCacheCreateInfoEXTConstructor;



  /**
   * Structure specifying parameters of a newly created validation cache
   */
interface VkValidationCacheCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     *
     */
    initialDataSize: bigint | number;

    /**
     * is a reference to previously retrieved validation cache data. If the validation cache data is incompatible (as defined below) with the device, the validation cache will be initially empty. If 'initialDataSize' is zero, 'pInitialData' is ignored.
     */
    pInitialData: ArrayBuffer | null;

}

declare interface VkValidationCacheCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     *
     */
    initialDataSize?: bigint | number;

    /**
     * is a reference to previously retrieved validation cache data. If the validation cache data is incompatible (as defined below) with the device, the validation cache will be initially empty. If 'initialDataSize' is zero, 'pInitialData' is ignored.
     */
    pInitialData?: ArrayBuffer | null;
}

declare interface VkValidationCacheCreateInfoEXTConstructor {
  readonly prototype: VkValidationCacheCreateInfoEXT;
  new(param?: VkValidationCacheCreateInfoEXTInitializer | null): VkValidationCacheCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkValidationCacheCreateInfoEXT: VkValidationCacheCreateInfoEXTConstructor;



  /**
   * 
   */
interface VkImageFormatListCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    viewFormatCount: number;

    /**
     *
     */
    pViewFormats: Int32Array | null;

}

declare interface VkImageFormatListCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    viewFormatCount?: number;

    /**
     *
     */
    pViewFormats?: Int32Array | null;
}

declare interface VkImageFormatListCreateInfoKHRConstructor {
  readonly prototype: VkImageFormatListCreateInfoKHR;
  new(param?: VkImageFormatListCreateInfoKHRInitializer | null): VkImageFormatListCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageFormatListCreateInfoKHR: VkImageFormatListCreateInfoKHRConstructor;



  /**
   * Specify that an image {#0#} be used with a particular set of formats
   */
interface VkImageFormatListCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    viewFormatCount: number;

    /**
     *
     */
    pViewFormats: Int32Array | null;

}

declare interface VkImageFormatListCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    viewFormatCount?: number;

    /**
     *
     */
    pViewFormats?: Int32Array | null;
}

declare interface VkImageFormatListCreateInfoConstructor {
  readonly prototype: VkImageFormatListCreateInfo;
  new(param?: VkImageFormatListCreateInfoInitializer | null): VkImageFormatListCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageFormatListCreateInfo: VkImageFormatListCreateInfoConstructor;



  /**
   * Structure specifying parameters controlling coverage modulation
   */
interface VkPipelineCoverageModulationStateCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is a 'VkCoverageModulationModeNV' value controlling which color components are modulated.
     */
    coverageModulationMode: VkCoverageModulationModeNV;

    /**
     * controls whether the modulation factor is looked up from a table in 'pCoverageModulationTable'.
     */
    coverageModulationTableEnable: boolean;

    /**
     * is the number of elements in 'pCoverageModulationTable'.
     */
    coverageModulationTableCount: number;

    /**
     * is a table of modulation factors containing a value for each number of covered samples.
     */
    pCoverageModulationTable: Float32Array | null;

}

declare interface VkPipelineCoverageModulationStateCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is a 'VkCoverageModulationModeNV' value controlling which color components are modulated.
     */
    coverageModulationMode?: VkCoverageModulationModeNV;

    /**
     * controls whether the modulation factor is looked up from a table in 'pCoverageModulationTable'.
     */
    coverageModulationTableEnable?: boolean;

    /**
     * is the number of elements in 'pCoverageModulationTable'.
     */
    coverageModulationTableCount?: number;

    /**
     * is a table of modulation factors containing a value for each number of covered samples.
     */
    pCoverageModulationTable?: Float32Array | null;
}

declare interface VkPipelineCoverageModulationStateCreateInfoNVConstructor {
  readonly prototype: VkPipelineCoverageModulationStateCreateInfoNV;
  new(param?: VkPipelineCoverageModulationStateCreateInfoNVInitializer | null): VkPipelineCoverageModulationStateCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineCoverageModulationStateCreateInfoNV: VkPipelineCoverageModulationStateCreateInfoNVConstructor;



  /**
   * Structure specifying the maximum number of inline uniform block bindings of a newly created descriptor pool
   */
interface VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of inline uniform block bindings to allocate.
     */
    maxInlineUniformBlockBindings: number;

}

declare interface VkDescriptorPoolInlineUniformBlockCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of inline uniform block bindings to allocate.
     */
    maxInlineUniformBlockBindings?: number;
}

declare interface VkDescriptorPoolInlineUniformBlockCreateInfoEXTConstructor {
  readonly prototype: VkDescriptorPoolInlineUniformBlockCreateInfoEXT;
  new(param?: VkDescriptorPoolInlineUniformBlockCreateInfoEXTInitializer | null): VkDescriptorPoolInlineUniformBlockCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorPoolInlineUniformBlockCreateInfoEXT: VkDescriptorPoolInlineUniformBlockCreateInfoEXTConstructor;



  /**
   * Structure specifying inline uniform block data
   */
interface VkWriteDescriptorSetInlineUniformBlockEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * number of bytes of data to write to the inline uniform block.
     */
    dataSize: number;

    /**
     *
     */
    pData: ArrayBuffer | null;

}

declare interface VkWriteDescriptorSetInlineUniformBlockEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * number of bytes of data to write to the inline uniform block.
     */
    dataSize?: number;

    /**
     *
     */
    pData?: ArrayBuffer | null;
}

declare interface VkWriteDescriptorSetInlineUniformBlockEXTConstructor {
  readonly prototype: VkWriteDescriptorSetInlineUniformBlockEXT;
  new(param?: VkWriteDescriptorSetInlineUniformBlockEXTInitializer | null): VkWriteDescriptorSetInlineUniformBlockEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkWriteDescriptorSetInlineUniformBlockEXT: VkWriteDescriptorSetInlineUniformBlockEXTConstructor;



  /**
   * Structure describing inline uniform block properties that can be supported by an implementation
   */
interface VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the maximum size in bytes of an <<descriptorsets-inlineuniformblock, inline uniform block>> binding.
     */
    readonly maxInlineUniformBlockSize: number;

    /**
     *
     */
    readonly maxPerStageDescriptorInlineUniformBlocks: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: number;

    /**
     *
     */
    readonly maxDescriptorSetInlineUniformBlocks: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindInlineUniformBlocks: number;

}

declare interface VkPhysicalDeviceInlineUniformBlockPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the maximum size in bytes of an <<descriptorsets-inlineuniformblock, inline uniform block>> binding.
     */
    readonly maxInlineUniformBlockSize?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorInlineUniformBlocks?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks?: number;

    /**
     *
     */
    readonly maxDescriptorSetInlineUniformBlocks?: number;

    /**
     *
     */
    readonly maxDescriptorSetUpdateAfterBindInlineUniformBlocks?: number;
}

declare interface VkPhysicalDeviceInlineUniformBlockPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceInlineUniformBlockPropertiesEXT;
  new(param?: VkPhysicalDeviceInlineUniformBlockPropertiesEXTInitializer | null): VkPhysicalDeviceInlineUniformBlockPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceInlineUniformBlockPropertiesEXT: VkPhysicalDeviceInlineUniformBlockPropertiesEXTConstructor;



  /**
   * Structure describing inline uniform block features that can be supported by an implementation
   */
interface VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports inline uniform block descriptors. If this feature is not enabled, 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' 'must' not be used.
     */
    inlineUniformBlock: boolean;

    /**
     *ifndef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[] is 'VK_FALSE' and reserved for future use.endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[] indicates whether the implementation supports updating inline uniform block descriptors after a set is bound. If this feature is not enabled, 'VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT' 'must' not be used with 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT'.
     */
    descriptorBindingInlineUniformBlockUpdateAfterBind: boolean;

}

declare interface VkPhysicalDeviceInlineUniformBlockFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports inline uniform block descriptors. If this feature is not enabled, 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' 'must' not be used.
     */
    inlineUniformBlock?: boolean;

    /**
     *ifndef::VK_VERSION_1_2,VK_EXT_descriptor_indexing[] is 'VK_FALSE' and reserved for future use.endif::VK_VERSION_1_2,VK_EXT_descriptor_indexing[] indicates whether the implementation supports updating inline uniform block descriptors after a set is bound. If this feature is not enabled, 'VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT' 'must' not be used with 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT'.
     */
    descriptorBindingInlineUniformBlockUpdateAfterBind?: boolean;
}

declare interface VkPhysicalDeviceInlineUniformBlockFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceInlineUniformBlockFeaturesEXT;
  new(param?: VkPhysicalDeviceInlineUniformBlockFeaturesEXTInitializer | null): VkPhysicalDeviceInlineUniformBlockFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceInlineUniformBlockFeaturesEXT: VkPhysicalDeviceInlineUniformBlockFeaturesEXTConstructor;



  /**
   * Structure specifying parameters that affect advanced blend operations
   */
interface VkPipelineColorBlendAdvancedStateCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies whether the source color of the blend operation is treated as premultiplied.
     */
    srcPremultiplied: boolean;

    /**
     * specifies whether the destination color of the blend operation is treated as premultiplied.
     */
    dstPremultiplied: boolean;

    /**
     * is a 'VkBlendOverlapEXT' value specifying how the source and destination sample's coverage is correlated.
     */
    blendOverlap: VkBlendOverlapEXT;

}

declare interface VkPipelineColorBlendAdvancedStateCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies whether the source color of the blend operation is treated as premultiplied.
     */
    srcPremultiplied?: boolean;

    /**
     * specifies whether the destination color of the blend operation is treated as premultiplied.
     */
    dstPremultiplied?: boolean;

    /**
     * is a 'VkBlendOverlapEXT' value specifying how the source and destination sample's coverage is correlated.
     */
    blendOverlap?: VkBlendOverlapEXT;
}

declare interface VkPipelineColorBlendAdvancedStateCreateInfoEXTConstructor {
  readonly prototype: VkPipelineColorBlendAdvancedStateCreateInfoEXT;
  new(param?: VkPipelineColorBlendAdvancedStateCreateInfoEXTInitializer | null): VkPipelineColorBlendAdvancedStateCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineColorBlendAdvancedStateCreateInfoEXT: VkPipelineColorBlendAdvancedStateCreateInfoEXTConstructor;



  /**
   * Structure describing advanced blending limits that can be supported by an implementation
   */
interface VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is one greater than the highest color attachment index that 'can' be used in a subpass, for a pipeline that uses an <<framebuffer-blend-advanced,advanced blend operation>>.
     */
    readonly advancedBlendMaxColorAttachments: number;

    /**
     * specifies whether advanced blend operations 'can' vary per-attachment.
     */
    readonly advancedBlendIndependentBlend: boolean;

    /**
     * specifies whether the source color 'can' be treated as non-premultiplied. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'srcPremultiplied' 'must' be 'VK_TRUE'.
     */
    readonly advancedBlendNonPremultipliedSrcColor: boolean;

    /**
     * specifies whether the destination color 'can' be treated as non-premultiplied. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'dstPremultiplied' 'must' be 'VK_TRUE'.
     */
    readonly advancedBlendNonPremultipliedDstColor: boolean;

    /**
     * specifies whether the overlap mode 'can' be treated as correlated. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'blendOverlap' 'must' be 'VK_BLEND_OVERLAP_UNCORRELATED_EXT'.
     */
    readonly advancedBlendCorrelatedOverlap: boolean;

    /**
     * specifies whether all advanced blend operation enums are supported. See the valid usage of 'VkPipelineColorBlendAttachmentState'.
     */
    readonly advancedBlendAllOperations: boolean;

}

declare interface VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is one greater than the highest color attachment index that 'can' be used in a subpass, for a pipeline that uses an <<framebuffer-blend-advanced,advanced blend operation>>.
     */
    readonly advancedBlendMaxColorAttachments?: number;

    /**
     * specifies whether advanced blend operations 'can' vary per-attachment.
     */
    readonly advancedBlendIndependentBlend?: boolean;

    /**
     * specifies whether the source color 'can' be treated as non-premultiplied. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'srcPremultiplied' 'must' be 'VK_TRUE'.
     */
    readonly advancedBlendNonPremultipliedSrcColor?: boolean;

    /**
     * specifies whether the destination color 'can' be treated as non-premultiplied. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'dstPremultiplied' 'must' be 'VK_TRUE'.
     */
    readonly advancedBlendNonPremultipliedDstColor?: boolean;

    /**
     * specifies whether the overlap mode 'can' be treated as correlated. If this is 'VK_FALSE', then 'VkPipelineColorBlendAdvancedStateCreateInfoEXT'::'blendOverlap' 'must' be 'VK_BLEND_OVERLAP_UNCORRELATED_EXT'.
     */
    readonly advancedBlendCorrelatedOverlap?: boolean;

    /**
     * specifies whether all advanced blend operation enums are supported. See the valid usage of 'VkPipelineColorBlendAttachmentState'.
     */
    readonly advancedBlendAllOperations?: boolean;
}

declare interface VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT;
  new(param?: VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTInitializer | null): VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT: VkPhysicalDeviceBlendOperationAdvancedPropertiesEXTConstructor;



  /**
   * Structure describing advanced blending features that can be supported by an implementation
   */
interface VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    advancedBlendCoherentOperations: boolean;

}

declare interface VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    advancedBlendCoherentOperations?: boolean;
}

declare interface VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT;
  new(param?: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTInitializer | null): VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXTConstructor;



  /**
   * 
   */
interface VkSamplerReductionModeCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    reductionMode: VkSamplerReductionMode;

}

declare interface VkSamplerReductionModeCreateInfoEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    reductionMode?: VkSamplerReductionMode;
}

declare interface VkSamplerReductionModeCreateInfoEXTConstructor {
  readonly prototype: VkSamplerReductionModeCreateInfoEXT;
  new(param?: VkSamplerReductionModeCreateInfoEXTInitializer | null): VkSamplerReductionModeCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSamplerReductionModeCreateInfoEXT: VkSamplerReductionModeCreateInfoEXTConstructor;



  /**
   * Structure specifying sampler reduction mode
   */
interface VkSamplerReductionModeCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    reductionMode: VkSamplerReductionMode;

}

declare interface VkSamplerReductionModeCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    reductionMode?: VkSamplerReductionMode;
}

declare interface VkSamplerReductionModeCreateInfoConstructor {
  readonly prototype: VkSamplerReductionModeCreateInfo;
  new(param?: VkSamplerReductionModeCreateInfoInitializer | null): VkSamplerReductionModeCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSamplerReductionModeCreateInfo: VkSamplerReductionModeCreateInfoConstructor;



  /**
   * Structure returning information about sample count specific additional multisampling capabilities
   */
interface VkMultisamplePropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the maximum size of the pixel grid in which sample locations 'can' vary.
     */
    readonly maxSampleLocationGridSize: VkExtent2D | null;

}

declare interface VkMultisamplePropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the maximum size of the pixel grid in which sample locations 'can' vary.
     */
    readonly maxSampleLocationGridSize?: VkExtent2D | null;
}

declare interface VkMultisamplePropertiesEXTConstructor {
  readonly prototype: VkMultisamplePropertiesEXT;
  new(param?: VkMultisamplePropertiesEXTInitializer | null): VkMultisamplePropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMultisamplePropertiesEXT: VkMultisamplePropertiesEXTConstructor;



  /**
   * Structure describing sample location limits that can be supported by an implementation
   */
interface VkPhysicalDeviceSampleLocationsPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a bitmask of 'VkSampleCountFlagBits' indicating the sample counts supporting custom sample locations.
     */
    readonly sampleLocationSampleCounts: VkSampleCountFlagBits;

    /**
     * is the maximum size of the pixel grid in which sample locations 'can' vary that is supported for all sample counts in 'sampleLocationSampleCounts'.
     */
    readonly maxSampleLocationGridSize: VkExtent2D | null;

    /**
     *
     */
    readonly sampleLocationCoordinateRange: number[] | null;

    /**
     * is the number of bits of subpixel precision for sample locations.
     */
    readonly sampleLocationSubPixelBits: number;

    /**
     * specifies whether the sample locations used by all pipelines that will be bound to a command buffer during a subpass 'must' match. If set to 'VK_TRUE', the implementation supports variable sample locations in a subpass. If set to 'VK_FALSE', then the sample locations 'must' stay constant in each subpass.
     */
    readonly variableSampleLocations: boolean;

}

declare interface VkPhysicalDeviceSampleLocationsPropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a bitmask of 'VkSampleCountFlagBits' indicating the sample counts supporting custom sample locations.
     */
    readonly sampleLocationSampleCounts?: VkSampleCountFlagBits;

    /**
     * is the maximum size of the pixel grid in which sample locations 'can' vary that is supported for all sample counts in 'sampleLocationSampleCounts'.
     */
    readonly maxSampleLocationGridSize?: VkExtent2D | null;

    /**
     *
     */
    readonly sampleLocationCoordinateRange?: number[] | null;

    /**
     * is the number of bits of subpixel precision for sample locations.
     */
    readonly sampleLocationSubPixelBits?: number;

    /**
     * specifies whether the sample locations used by all pipelines that will be bound to a command buffer during a subpass 'must' match. If set to 'VK_TRUE', the implementation supports variable sample locations in a subpass. If set to 'VK_FALSE', then the sample locations 'must' stay constant in each subpass.
     */
    readonly variableSampleLocations?: boolean;
}

declare interface VkPhysicalDeviceSampleLocationsPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceSampleLocationsPropertiesEXT;
  new(param?: VkPhysicalDeviceSampleLocationsPropertiesEXTInitializer | null): VkPhysicalDeviceSampleLocationsPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSampleLocationsPropertiesEXT: VkPhysicalDeviceSampleLocationsPropertiesEXTConstructor;



  /**
   * Structure specifying sample locations for a pipeline
   */
interface VkPipelineSampleLocationsStateCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * controls whether custom sample locations are used. If 'sampleLocationsEnable' is 'VK_FALSE', the default sample locations are used and the values specified in 'sampleLocationsInfo' are ignored.
     */
    sampleLocationsEnable: boolean;

    /**
     * is the sample locations to use during rasterization if 'sampleLocationsEnable' is 'VK_TRUE' and the graphics pipeline is not created with 'VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT'.
     */
    sampleLocationsInfo: VkSampleLocationsInfoEXT | null;

}

declare interface VkPipelineSampleLocationsStateCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * controls whether custom sample locations are used. If 'sampleLocationsEnable' is 'VK_FALSE', the default sample locations are used and the values specified in 'sampleLocationsInfo' are ignored.
     */
    sampleLocationsEnable?: boolean;

    /**
     * is the sample locations to use during rasterization if 'sampleLocationsEnable' is 'VK_TRUE' and the graphics pipeline is not created with 'VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT'.
     */
    sampleLocationsInfo?: VkSampleLocationsInfoEXT | null;
}

declare interface VkPipelineSampleLocationsStateCreateInfoEXTConstructor {
  readonly prototype: VkPipelineSampleLocationsStateCreateInfoEXT;
  new(param?: VkPipelineSampleLocationsStateCreateInfoEXTInitializer | null): VkPipelineSampleLocationsStateCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineSampleLocationsStateCreateInfoEXT: VkPipelineSampleLocationsStateCreateInfoEXTConstructor;



  /**
   * Structure specifying sample locations to use for the layout transition of custom sample locations compatible depth/stencil attachments
   */
interface VkRenderPassSampleLocationsBeginInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of elements in the 'pAttachmentInitialSampleLocations' array.
     */
    attachmentInitialSampleLocationsCount: number;

    /**
     * is an array of 'attachmentInitialSampleLocationsCount' 'VkAttachmentSampleLocationsEXT' structures specifying the attachment indices and their corresponding sample location state. Each element of 'pAttachmentInitialSampleLocations' 'can' specify the sample location state to use in the automatic layout transition performed to transition a depth/stencil attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.
     */
    pAttachmentInitialSampleLocations: VkAttachmentSampleLocationsEXT[] | null;

    /**
     * is the number of elements in the 'pPostSubpassSampleLocations' array.
     */
    postSubpassSampleLocationsCount: number;

    /**
     * is an array of 'postSubpassSampleLocationsCount' 'VkSubpassSampleLocationsEXT' structures specifying the subpass indices and their corresponding sample location state. Each element of 'pPostSubpassSampleLocations' 'can' specify the sample location state to use in the automatic layout transition performed to transition the depth/stencil attachment used by the specified subpass to the image layout specified in a dependent subpass or to the final layout of the attachment in case the specified subpass is the last subpass using that attachment. In addition, if 'VkPhysicalDeviceSampleLocationsPropertiesEXT'::'variableSampleLocations' is 'VK_FALSE', each element of 'pPostSubpassSampleLocations' 'must' specify the sample location state that matches the sample locations used by all pipelines that will be bound to a command buffer during the specified subpass. If 'variableSampleLocations' is 'VK_TRUE', the sample locations used for rasterization do not depend on 'pPostSubpassSampleLocations'.
     */
    pPostSubpassSampleLocations: VkSubpassSampleLocationsEXT[] | null;

}

declare interface VkRenderPassSampleLocationsBeginInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of elements in the 'pAttachmentInitialSampleLocations' array.
     */
    attachmentInitialSampleLocationsCount?: number;

    /**
     * is an array of 'attachmentInitialSampleLocationsCount' 'VkAttachmentSampleLocationsEXT' structures specifying the attachment indices and their corresponding sample location state. Each element of 'pAttachmentInitialSampleLocations' 'can' specify the sample location state to use in the automatic layout transition performed to transition a depth/stencil attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.
     */
    pAttachmentInitialSampleLocations?: VkAttachmentSampleLocationsEXT[] | null;

    /**
     * is the number of elements in the 'pPostSubpassSampleLocations' array.
     */
    postSubpassSampleLocationsCount?: number;

    /**
     * is an array of 'postSubpassSampleLocationsCount' 'VkSubpassSampleLocationsEXT' structures specifying the subpass indices and their corresponding sample location state. Each element of 'pPostSubpassSampleLocations' 'can' specify the sample location state to use in the automatic layout transition performed to transition the depth/stencil attachment used by the specified subpass to the image layout specified in a dependent subpass or to the final layout of the attachment in case the specified subpass is the last subpass using that attachment. In addition, if 'VkPhysicalDeviceSampleLocationsPropertiesEXT'::'variableSampleLocations' is 'VK_FALSE', each element of 'pPostSubpassSampleLocations' 'must' specify the sample location state that matches the sample locations used by all pipelines that will be bound to a command buffer during the specified subpass. If 'variableSampleLocations' is 'VK_TRUE', the sample locations used for rasterization do not depend on 'pPostSubpassSampleLocations'.
     */
    pPostSubpassSampleLocations?: VkSubpassSampleLocationsEXT[] | null;
}

declare interface VkRenderPassSampleLocationsBeginInfoEXTConstructor {
  readonly prototype: VkRenderPassSampleLocationsBeginInfoEXT;
  new(param?: VkRenderPassSampleLocationsBeginInfoEXTInitializer | null): VkRenderPassSampleLocationsBeginInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassSampleLocationsBeginInfoEXT: VkRenderPassSampleLocationsBeginInfoEXTConstructor;



  /**
   * Structure specifying the sample locations state to use for layout transitions of attachments performed after a given subpass
   */
interface VkSubpassSampleLocationsEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the index of the subpass for which the sample locations state is provided.
     */
    subpassIndex: number;

    /**
     * is the sample locations state to use for the layout transition of the depth/stencil attachment away from the image layout the attachment is used with in the subpass specified in 'subpassIndex'.
     */
    sampleLocationsInfo: VkSampleLocationsInfoEXT | null;

}

declare interface VkSubpassSampleLocationsEXTInitializer {
  
    /**
     * is the index of the subpass for which the sample locations state is provided.
     */
    subpassIndex?: number;

    /**
     * is the sample locations state to use for the layout transition of the depth/stencil attachment away from the image layout the attachment is used with in the subpass specified in 'subpassIndex'.
     */
    sampleLocationsInfo?: VkSampleLocationsInfoEXT | null;
}

declare interface VkSubpassSampleLocationsEXTConstructor {
  readonly prototype: VkSubpassSampleLocationsEXT;
  new(param?: VkSubpassSampleLocationsEXTInitializer | null): VkSubpassSampleLocationsEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassSampleLocationsEXT: VkSubpassSampleLocationsEXTConstructor;



  /**
   * Structure specifying the sample locations state to use in the initial layout transition of attachments
   */
interface VkAttachmentSampleLocationsEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the index of the attachment for which the sample locations state is provided.
     */
    attachmentIndex: number;

    /**
     * is the sample locations state to use for the layout transition of the given attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.
     */
    sampleLocationsInfo: VkSampleLocationsInfoEXT | null;

}

declare interface VkAttachmentSampleLocationsEXTInitializer {
  
    /**
     * is the index of the attachment for which the sample locations state is provided.
     */
    attachmentIndex?: number;

    /**
     * is the sample locations state to use for the layout transition of the given attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.
     */
    sampleLocationsInfo?: VkSampleLocationsInfoEXT | null;
}

declare interface VkAttachmentSampleLocationsEXTConstructor {
  readonly prototype: VkAttachmentSampleLocationsEXT;
  new(param?: VkAttachmentSampleLocationsEXTInitializer | null): VkAttachmentSampleLocationsEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentSampleLocationsEXT: VkAttachmentSampleLocationsEXTConstructor;



  /**
   * Structure specifying a set of sample locations
   */
interface VkSampleLocationsInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of sample locations per pixel.
     */
    sampleLocationsPerPixel: VkSampleCountFlagBits;

    /**
     * is the size of the sample location grid to select custom sample locations for.
     */
    sampleLocationGridSize: VkExtent2D | null;

    /**
     * is the number of sample locations in 'pSampleLocations'.
     */
    sampleLocationsCount: number;

    /**
     * is an array of 'sampleLocationsCount' 'VkSampleLocationEXT' structures.
     */
    pSampleLocations: VkSampleLocationEXT[] | null;

}

declare interface VkSampleLocationsInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of sample locations per pixel.
     */
    sampleLocationsPerPixel?: VkSampleCountFlagBits;

    /**
     * is the size of the sample location grid to select custom sample locations for.
     */
    sampleLocationGridSize?: VkExtent2D | null;

    /**
     * is the number of sample locations in 'pSampleLocations'.
     */
    sampleLocationsCount?: number;

    /**
     * is an array of 'sampleLocationsCount' 'VkSampleLocationEXT' structures.
     */
    pSampleLocations?: VkSampleLocationEXT[] | null;
}

declare interface VkSampleLocationsInfoEXTConstructor {
  readonly prototype: VkSampleLocationsInfoEXT;
  new(param?: VkSampleLocationsInfoEXTInitializer | null): VkSampleLocationsInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSampleLocationsInfoEXT: VkSampleLocationsInfoEXTConstructor;



  /**
   * Structure specifying the coordinates of a sample location
   */
interface VkSampleLocationEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the horizontal coordinate of the sample's location.
     */
    x: number;

    /**
     * is the vertical coordinate of the sample's location.
     */
    y: number;

}

declare interface VkSampleLocationEXTInitializer {
  
    /**
     * is the horizontal coordinate of the sample's location.
     */
    x?: number;

    /**
     * is the vertical coordinate of the sample's location.
     */
    y?: number;
}

declare interface VkSampleLocationEXTConstructor {
  readonly prototype: VkSampleLocationEXT;
  new(param?: VkSampleLocationEXTInitializer | null): VkSampleLocationEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSampleLocationEXT: VkSampleLocationEXTConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly filterMinmaxSingleComponentFormats: boolean;

    /**
     *
     */
    readonly filterMinmaxImageComponentMapping: boolean;

}

declare interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly filterMinmaxSingleComponentFormats?: boolean;

    /**
     *
     */
    readonly filterMinmaxImageComponentMapping?: boolean;
}

declare interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT;
  new(param?: VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTInitializer | null): VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT: VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTConstructor;



  /**
   * Structure describing sampler filter minmax limits that can be supported by an implementation
   */
interface VkPhysicalDeviceSamplerFilterMinmaxProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly filterMinmaxSingleComponentFormats: boolean;

    /**
     *
     */
    readonly filterMinmaxImageComponentMapping: boolean;

}

declare interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly filterMinmaxSingleComponentFormats?: boolean;

    /**
     *
     */
    readonly filterMinmaxImageComponentMapping?: boolean;
}

declare interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesConstructor {
  readonly prototype: VkPhysicalDeviceSamplerFilterMinmaxProperties;
  new(param?: VkPhysicalDeviceSamplerFilterMinmaxPropertiesInitializer | null): VkPhysicalDeviceSamplerFilterMinmaxProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSamplerFilterMinmaxProperties: VkPhysicalDeviceSamplerFilterMinmaxPropertiesConstructor;



  /**
   * Structure specifying whether fragment coverage replaces a color
   */
interface VkPipelineCoverageToColorStateCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * controls whether the fragment coverage value replaces a fragment color output.
     */
    coverageToColorEnable: boolean;

    /**
     * controls which fragment shader color output value is replaced.
     */
    coverageToColorLocation: number;

}

declare interface VkPipelineCoverageToColorStateCreateInfoNVInitializer {
  
    /**
     * is the type of this structure
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * controls whether the fragment coverage value replaces a fragment color output.
     */
    coverageToColorEnable?: boolean;

    /**
     * controls which fragment shader color output value is replaced.
     */
    coverageToColorLocation?: number;
}

declare interface VkPipelineCoverageToColorStateCreateInfoNVConstructor {
  readonly prototype: VkPipelineCoverageToColorStateCreateInfoNV;
  new(param?: VkPipelineCoverageToColorStateCreateInfoNVInitializer | null): VkPipelineCoverageToColorStateCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineCoverageToColorStateCreateInfoNV: VkPipelineCoverageToColorStateCreateInfoNVConstructor;



  /**
   * Structure specifying the parameters used for device queue creation
   */
interface VkDeviceQueueInfo2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure. The 'pNext' chain of 'VkDeviceQueueInfo2' is used to provide additional image parameters to 'vkGetDeviceQueue2'.
     */
    pNext: null;

    /**
     * is a 'VkDeviceQueueCreateFlags' value indicating the flags used to create the device queue.
     */
    flags: VkDeviceQueueCreateFlagBits;

    /**
     * is the index of the queue family to which the queue belongs.
     */
    queueFamilyIndex: number;

    /**
     * is the index within this queue family of the queue to retrieve.
     */
    queueIndex: number;

}

declare interface VkDeviceQueueInfo2Initializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure. The 'pNext' chain of 'VkDeviceQueueInfo2' is used to provide additional image parameters to 'vkGetDeviceQueue2'.
     */
    pNext?: null;

    /**
     * is a 'VkDeviceQueueCreateFlags' value indicating the flags used to create the device queue.
     */
    flags?: VkDeviceQueueCreateFlagBits;

    /**
     * is the index of the queue family to which the queue belongs.
     */
    queueFamilyIndex?: number;

    /**
     * is the index within this queue family of the queue to retrieve.
     */
    queueIndex?: number;
}

declare interface VkDeviceQueueInfo2Constructor {
  readonly prototype: VkDeviceQueueInfo2;
  new(param?: VkDeviceQueueInfo2Initializer | null): VkDeviceQueueInfo2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceQueueInfo2: VkDeviceQueueInfo2Constructor;



  /**
   * Structure describing protected memory properties that can be supported by an implementation
   */
interface VkPhysicalDeviceProtectedMemoryProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     *
     */
    readonly protectedNoFault: boolean;

}

declare interface VkPhysicalDeviceProtectedMemoryPropertiesInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly protectedNoFault?: boolean;
}

declare interface VkPhysicalDeviceProtectedMemoryPropertiesConstructor {
  readonly prototype: VkPhysicalDeviceProtectedMemoryProperties;
  new(param?: VkPhysicalDeviceProtectedMemoryPropertiesInitializer | null): VkPhysicalDeviceProtectedMemoryProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceProtectedMemoryProperties: VkPhysicalDeviceProtectedMemoryPropertiesConstructor;



  /**
   * Structure describing protected memory features that can be supported by an implementation
   */
interface VkPhysicalDeviceProtectedMemoryFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * specifies whether protected memory is supported.// end::VK_KHR_protected_memory-features[]
     */
    protectedMemory: boolean;

}

declare interface VkPhysicalDeviceProtectedMemoryFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * specifies whether protected memory is supported.// end::VK_KHR_protected_memory-features[]
     */
    protectedMemory?: boolean;
}

declare interface VkPhysicalDeviceProtectedMemoryFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceProtectedMemoryFeatures;
  new(param?: VkPhysicalDeviceProtectedMemoryFeaturesInitializer | null): VkPhysicalDeviceProtectedMemoryFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceProtectedMemoryFeatures: VkPhysicalDeviceProtectedMemoryFeaturesConstructor;



  /**
   * Structure indicating whether the submission is protected
   */
interface VkProtectedSubmitInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * specifies whether the batch is protected. If 'protectedSubmit' is 'VK_TRUE', the batch is protected. If 'protectedSubmit' is 'VK_FALSE', the batch is unprotected. If the 'VkSubmitInfo'::'pNext' chain does not include this structure, the batch is unprotected.
     */
    protectedSubmit: boolean;

}

declare interface VkProtectedSubmitInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * specifies whether the batch is protected. If 'protectedSubmit' is 'VK_TRUE', the batch is protected. If 'protectedSubmit' is 'VK_FALSE', the batch is unprotected. If the 'VkSubmitInfo'::'pNext' chain does not include this structure, the batch is unprotected.
     */
    protectedSubmit?: boolean;
}

declare interface VkProtectedSubmitInfoConstructor {
  readonly prototype: VkProtectedSubmitInfo;
  new(param?: VkProtectedSubmitInfoInitializer | null): VkProtectedSubmitInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkProtectedSubmitInfo: VkProtectedSubmitInfoConstructor;



  /**
   * Structure specifying conditional rendering begin info
   */
interface VkConditionalRenderingBeginInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * where the predicate is located.
     */
    buffer: VkBuffer | null;

    /**
     *
     */
    offset: bigint | number;

    /**
     * is a bitmask of 'VkConditionalRenderingFlagsEXT' specifying the behavior of conditional rendering.
     */
    flags: VkConditionalRenderingFlagBitsEXT;

}

declare interface VkConditionalRenderingBeginInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * where the predicate is located.
     */
    buffer?: VkBuffer | null;

    /**
     *
     */
    offset?: bigint | number;

    /**
     * is a bitmask of 'VkConditionalRenderingFlagsEXT' specifying the behavior of conditional rendering.
     */
    flags?: VkConditionalRenderingFlagBitsEXT;
}

declare interface VkConditionalRenderingBeginInfoEXTConstructor {
  readonly prototype: VkConditionalRenderingBeginInfoEXT;
  new(param?: VkConditionalRenderingBeginInfoEXTInitializer | null): VkConditionalRenderingBeginInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkConditionalRenderingBeginInfoEXT: VkConditionalRenderingBeginInfoEXTConstructor;



  /**
   * Structure informing whether or not texture gather bias/LOD functionality is supported for a given image format and a given physical device.
   */
interface VkTextureLODGatherFormatPropertiesAMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i>.
     */
    readonly pNext: null;

    /**
     * tells if the image format can be used with texture gather bias/LOD functions, as introduced by the `<<VK_AMD_texture_gather_bias_lod>>` extension. This field is set by the implementation. User-specified value is ignored.
     */
    readonly supportsTextureGatherLODBiasAMD: boolean;

}

declare interface VkTextureLODGatherFormatPropertiesAMDInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i>.
     */
    readonly pNext?: null;

    /**
     * tells if the image format can be used with texture gather bias/LOD functions, as introduced by the `<<VK_AMD_texture_gather_bias_lod>>` extension. This field is set by the implementation. User-specified value is ignored.
     */
    readonly supportsTextureGatherLODBiasAMD?: boolean;
}

declare interface VkTextureLODGatherFormatPropertiesAMDConstructor {
  readonly prototype: VkTextureLODGatherFormatPropertiesAMD;
  new(param?: VkTextureLODGatherFormatPropertiesAMDInitializer | null): VkTextureLODGatherFormatPropertiesAMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkTextureLODGatherFormatPropertiesAMD: VkTextureLODGatherFormatPropertiesAMDConstructor;



  /**
   * 
   */
interface VkSamplerYcbcrConversionImageFormatPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly combinedImageSamplerDescriptorCount: number;

}

declare interface VkSamplerYcbcrConversionImageFormatPropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly combinedImageSamplerDescriptorCount?: number;
}

declare interface VkSamplerYcbcrConversionImageFormatPropertiesKHRConstructor {
  readonly prototype: VkSamplerYcbcrConversionImageFormatPropertiesKHR;
  new(param?: VkSamplerYcbcrConversionImageFormatPropertiesKHRInitializer | null): VkSamplerYcbcrConversionImageFormatPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSamplerYcbcrConversionImageFormatPropertiesKHR: VkSamplerYcbcrConversionImageFormatPropertiesKHRConstructor;



  /**
   * Structure specifying combined image sampler descriptor count for multi-planar images
   */
interface VkSamplerYcbcrConversionImageFormatProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly combinedImageSamplerDescriptorCount: number;

}

declare interface VkSamplerYcbcrConversionImageFormatPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly combinedImageSamplerDescriptorCount?: number;
}

declare interface VkSamplerYcbcrConversionImageFormatPropertiesConstructor {
  readonly prototype: VkSamplerYcbcrConversionImageFormatProperties;
  new(param?: VkSamplerYcbcrConversionImageFormatPropertiesInitializer | null): VkSamplerYcbcrConversionImageFormatProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSamplerYcbcrConversionImageFormatProperties: VkSamplerYcbcrConversionImageFormatPropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    samplerYcbcrConversion: boolean;

}

declare interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    samplerYcbcrConversion?: boolean;
}

declare interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR;
  new(param?: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRInitializer | null): VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRConstructor;



  /**
   * Structure describing Y\
   */
interface VkPhysicalDeviceSamplerYcbcrConversionFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    samplerYcbcrConversion: boolean;

}

declare interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    samplerYcbcrConversion?: boolean;
}

declare interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceSamplerYcbcrConversionFeatures;
  new(param?: VkPhysicalDeviceSamplerYcbcrConversionFeaturesInitializer | null): VkPhysicalDeviceSamplerYcbcrConversionFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSamplerYcbcrConversionFeatures: VkPhysicalDeviceSamplerYcbcrConversionFeaturesConstructor;



  /**
   * 
   */
interface VkImagePlaneMemoryRequirementsInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    planeAspect: VkImageAspectFlagBits;

}

declare interface VkImagePlaneMemoryRequirementsInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    planeAspect?: VkImageAspectFlagBits;
}

declare interface VkImagePlaneMemoryRequirementsInfoKHRConstructor {
  readonly prototype: VkImagePlaneMemoryRequirementsInfoKHR;
  new(param?: VkImagePlaneMemoryRequirementsInfoKHRInitializer | null): VkImagePlaneMemoryRequirementsInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImagePlaneMemoryRequirementsInfoKHR: VkImagePlaneMemoryRequirementsInfoKHRConstructor;



  /**
   * Structure specifying image plane for memory requirements
   */
interface VkImagePlaneMemoryRequirementsInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    planeAspect: VkImageAspectFlagBits;

}

declare interface VkImagePlaneMemoryRequirementsInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    planeAspect?: VkImageAspectFlagBits;
}

declare interface VkImagePlaneMemoryRequirementsInfoConstructor {
  readonly prototype: VkImagePlaneMemoryRequirementsInfo;
  new(param?: VkImagePlaneMemoryRequirementsInfoInitializer | null): VkImagePlaneMemoryRequirementsInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImagePlaneMemoryRequirementsInfo: VkImagePlaneMemoryRequirementsInfoConstructor;



  /**
   * 
   */
interface VkBindImagePlaneMemoryInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    planeAspect: VkImageAspectFlagBits;

}

declare interface VkBindImagePlaneMemoryInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    planeAspect?: VkImageAspectFlagBits;
}

declare interface VkBindImagePlaneMemoryInfoKHRConstructor {
  readonly prototype: VkBindImagePlaneMemoryInfoKHR;
  new(param?: VkBindImagePlaneMemoryInfoKHRInitializer | null): VkBindImagePlaneMemoryInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindImagePlaneMemoryInfoKHR: VkBindImagePlaneMemoryInfoKHRConstructor;



  /**
   * Structure specifying how to bind an image plane to memory
   */
interface VkBindImagePlaneMemoryInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    planeAspect: VkImageAspectFlagBits;

}

declare interface VkBindImagePlaneMemoryInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    planeAspect?: VkImageAspectFlagBits;
}

declare interface VkBindImagePlaneMemoryInfoConstructor {
  readonly prototype: VkBindImagePlaneMemoryInfo;
  new(param?: VkBindImagePlaneMemoryInfoInitializer | null): VkBindImagePlaneMemoryInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindImagePlaneMemoryInfo: VkBindImagePlaneMemoryInfoConstructor;



  /**
   * 
   */
interface VkSamplerYcbcrConversionCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    format: VkFormat;

    /**
     *
     */
    ycbcrModel: VkSamplerYcbcrModelConversion;

    /**
     *
     */
    ycbcrRange: VkSamplerYcbcrRange;

    /**
     *
     */
    components: VkComponentMapping | null;

    /**
     *
     */
    xChromaOffset: VkChromaLocation;

    /**
     *
     */
    yChromaOffset: VkChromaLocation;

    /**
     *
     */
    chromaFilter: VkFilter;

    /**
     *
     */
    forceExplicitReconstruction: boolean;

}

declare interface VkSamplerYcbcrConversionCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    format?: VkFormat;

    /**
     *
     */
    ycbcrModel?: VkSamplerYcbcrModelConversion;

    /**
     *
     */
    ycbcrRange?: VkSamplerYcbcrRange;

    /**
     *
     */
    components?: VkComponentMapping | null;

    /**
     *
     */
    xChromaOffset?: VkChromaLocation;

    /**
     *
     */
    yChromaOffset?: VkChromaLocation;

    /**
     *
     */
    chromaFilter?: VkFilter;

    /**
     *
     */
    forceExplicitReconstruction?: boolean;
}

declare interface VkSamplerYcbcrConversionCreateInfoKHRConstructor {
  readonly prototype: VkSamplerYcbcrConversionCreateInfoKHR;
  new(param?: VkSamplerYcbcrConversionCreateInfoKHRInitializer | null): VkSamplerYcbcrConversionCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSamplerYcbcrConversionCreateInfoKHR: VkSamplerYcbcrConversionCreateInfoKHRConstructor;



  /**
   * Structure specifying the parameters of the newly created conversion
   */
interface VkSamplerYcbcrConversionCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    format: VkFormat;

    /**
     *
     */
    ycbcrModel: VkSamplerYcbcrModelConversion;

    /**
     *
     */
    ycbcrRange: VkSamplerYcbcrRange;

    /**
     *
     */
    components: VkComponentMapping | null;

    /**
     *
     */
    xChromaOffset: VkChromaLocation;

    /**
     *
     */
    yChromaOffset: VkChromaLocation;

    /**
     *
     */
    chromaFilter: VkFilter;

    /**
     *
     */
    forceExplicitReconstruction: boolean;

}

declare interface VkSamplerYcbcrConversionCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    format?: VkFormat;

    /**
     *
     */
    ycbcrModel?: VkSamplerYcbcrModelConversion;

    /**
     *
     */
    ycbcrRange?: VkSamplerYcbcrRange;

    /**
     *
     */
    components?: VkComponentMapping | null;

    /**
     *
     */
    xChromaOffset?: VkChromaLocation;

    /**
     *
     */
    yChromaOffset?: VkChromaLocation;

    /**
     *
     */
    chromaFilter?: VkFilter;

    /**
     *
     */
    forceExplicitReconstruction?: boolean;
}

declare interface VkSamplerYcbcrConversionCreateInfoConstructor {
  readonly prototype: VkSamplerYcbcrConversionCreateInfo;
  new(param?: VkSamplerYcbcrConversionCreateInfoInitializer | null): VkSamplerYcbcrConversionCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSamplerYcbcrConversionCreateInfo: VkSamplerYcbcrConversionCreateInfoConstructor;



  /**
   * 
   */
interface VkSamplerYcbcrConversionInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    conversion: VkSamplerYcbcrConversion | null;

}

declare interface VkSamplerYcbcrConversionInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    conversion?: VkSamplerYcbcrConversion | null;
}

declare interface VkSamplerYcbcrConversionInfoKHRConstructor {
  readonly prototype: VkSamplerYcbcrConversionInfoKHR;
  new(param?: VkSamplerYcbcrConversionInfoKHRInitializer | null): VkSamplerYcbcrConversionInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSamplerYcbcrConversionInfoKHR: VkSamplerYcbcrConversionInfoKHRConstructor;



  /**
   * 
   */
interface VkSamplerYcbcrConversionInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    conversion: VkSamplerYcbcrConversion | null;

}

declare interface VkSamplerYcbcrConversionInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    conversion?: VkSamplerYcbcrConversion | null;
}

declare interface VkSamplerYcbcrConversionInfoConstructor {
  readonly prototype: VkSamplerYcbcrConversionInfo;
  new(param?: VkSamplerYcbcrConversionInfoInitializer | null): VkSamplerYcbcrConversionInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSamplerYcbcrConversionInfo: VkSamplerYcbcrConversionInfoConstructor;



  /**
   * 
   */
interface VkPipelineTessellationDomainOriginStateCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    domainOrigin: VkTessellationDomainOrigin;

}

declare interface VkPipelineTessellationDomainOriginStateCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    domainOrigin?: VkTessellationDomainOrigin;
}

declare interface VkPipelineTessellationDomainOriginStateCreateInfoKHRConstructor {
  readonly prototype: VkPipelineTessellationDomainOriginStateCreateInfoKHR;
  new(param?: VkPipelineTessellationDomainOriginStateCreateInfoKHRInitializer | null): VkPipelineTessellationDomainOriginStateCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineTessellationDomainOriginStateCreateInfoKHR: VkPipelineTessellationDomainOriginStateCreateInfoKHRConstructor;



  /**
   * Structure specifying the orientation of the tessellation domain
   */
interface VkPipelineTessellationDomainOriginStateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    domainOrigin: VkTessellationDomainOrigin;

}

declare interface VkPipelineTessellationDomainOriginStateCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    domainOrigin?: VkTessellationDomainOrigin;
}

declare interface VkPipelineTessellationDomainOriginStateCreateInfoConstructor {
  readonly prototype: VkPipelineTessellationDomainOriginStateCreateInfo;
  new(param?: VkPipelineTessellationDomainOriginStateCreateInfoInitializer | null): VkPipelineTessellationDomainOriginStateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineTessellationDomainOriginStateCreateInfo: VkPipelineTessellationDomainOriginStateCreateInfoConstructor;



  /**
   * 
   */
interface VkImageViewUsageCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    usage: VkImageUsageFlagBits;

}

declare interface VkImageViewUsageCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    usage?: VkImageUsageFlagBits;
}

declare interface VkImageViewUsageCreateInfoKHRConstructor {
  readonly prototype: VkImageViewUsageCreateInfoKHR;
  new(param?: VkImageViewUsageCreateInfoKHRInitializer | null): VkImageViewUsageCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageViewUsageCreateInfoKHR: VkImageViewUsageCreateInfoKHRConstructor;



  /**
   * Specify the intended usage of an image view
   */
interface VkImageViewUsageCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    usage: VkImageUsageFlagBits;

}

declare interface VkImageViewUsageCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    usage?: VkImageUsageFlagBits;
}

declare interface VkImageViewUsageCreateInfoConstructor {
  readonly prototype: VkImageViewUsageCreateInfo;
  new(param?: VkImageViewUsageCreateInfoInitializer | null): VkImageViewUsageCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageViewUsageCreateInfo: VkImageViewUsageCreateInfoConstructor;



  /**
   * 
   */
interface VkMemoryDedicatedAllocateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    image: VkImage | null;

    /**
     *
     */
    buffer: VkBuffer | null;

}

declare interface VkMemoryDedicatedAllocateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    image?: VkImage | null;

    /**
     *
     */
    buffer?: VkBuffer | null;
}

declare interface VkMemoryDedicatedAllocateInfoKHRConstructor {
  readonly prototype: VkMemoryDedicatedAllocateInfoKHR;
  new(param?: VkMemoryDedicatedAllocateInfoKHRInitializer | null): VkMemoryDedicatedAllocateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryDedicatedAllocateInfoKHR: VkMemoryDedicatedAllocateInfoKHRConstructor;



  /**
   * Specify a dedicated memory allocation resource
   */
interface VkMemoryDedicatedAllocateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    image: VkImage | null;

    /**
     *
     */
    buffer: VkBuffer | null;

}

declare interface VkMemoryDedicatedAllocateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    image?: VkImage | null;

    /**
     *
     */
    buffer?: VkBuffer | null;
}

declare interface VkMemoryDedicatedAllocateInfoConstructor {
  readonly prototype: VkMemoryDedicatedAllocateInfo;
  new(param?: VkMemoryDedicatedAllocateInfoInitializer | null): VkMemoryDedicatedAllocateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryDedicatedAllocateInfo: VkMemoryDedicatedAllocateInfoConstructor;



  /**
   * 
   */
interface VkMemoryDedicatedRequirementsKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly prefersDedicatedAllocation: boolean;

    /**
     *
     */
    readonly requiresDedicatedAllocation: boolean;

}

declare interface VkMemoryDedicatedRequirementsKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly prefersDedicatedAllocation?: boolean;

    /**
     *
     */
    readonly requiresDedicatedAllocation?: boolean;
}

declare interface VkMemoryDedicatedRequirementsKHRConstructor {
  readonly prototype: VkMemoryDedicatedRequirementsKHR;
  new(param?: VkMemoryDedicatedRequirementsKHRInitializer | null): VkMemoryDedicatedRequirementsKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryDedicatedRequirementsKHR: VkMemoryDedicatedRequirementsKHRConstructor;



  /**
   * Structure describing dedicated allocation requirements of buffer and image resources
   */
interface VkMemoryDedicatedRequirements {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly prefersDedicatedAllocation: boolean;

    /**
     *
     */
    readonly requiresDedicatedAllocation: boolean;

}

declare interface VkMemoryDedicatedRequirementsInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly prefersDedicatedAllocation?: boolean;

    /**
     *
     */
    readonly requiresDedicatedAllocation?: boolean;
}

declare interface VkMemoryDedicatedRequirementsConstructor {
  readonly prototype: VkMemoryDedicatedRequirements;
  new(param?: VkMemoryDedicatedRequirementsInitializer | null): VkMemoryDedicatedRequirements;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryDedicatedRequirements: VkMemoryDedicatedRequirementsConstructor;



  /**
   * 
   */
interface VkPhysicalDevicePointClippingPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly pointClippingBehavior: VkPointClippingBehavior;

}

declare interface VkPhysicalDevicePointClippingPropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly pointClippingBehavior?: VkPointClippingBehavior;
}

declare interface VkPhysicalDevicePointClippingPropertiesKHRConstructor {
  readonly prototype: VkPhysicalDevicePointClippingPropertiesKHR;
  new(param?: VkPhysicalDevicePointClippingPropertiesKHRInitializer | null): VkPhysicalDevicePointClippingPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevicePointClippingPropertiesKHR: VkPhysicalDevicePointClippingPropertiesKHRConstructor;



  /**
   * Structure describing the point clipping behavior supported by an implementation
   */
interface VkPhysicalDevicePointClippingProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly pointClippingBehavior: VkPointClippingBehavior;

}

declare interface VkPhysicalDevicePointClippingPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly pointClippingBehavior?: VkPointClippingBehavior;
}

declare interface VkPhysicalDevicePointClippingPropertiesConstructor {
  readonly prototype: VkPhysicalDevicePointClippingProperties;
  new(param?: VkPhysicalDevicePointClippingPropertiesInitializer | null): VkPhysicalDevicePointClippingProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevicePointClippingProperties: VkPhysicalDevicePointClippingPropertiesConstructor;



  /**
   * 
   */
interface VkSparseImageMemoryRequirements2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly memoryRequirements: VkSparseImageMemoryRequirements | null;

}

declare interface VkSparseImageMemoryRequirements2KHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly memoryRequirements?: VkSparseImageMemoryRequirements | null;
}

declare interface VkSparseImageMemoryRequirements2KHRConstructor {
  readonly prototype: VkSparseImageMemoryRequirements2KHR;
  new(param?: VkSparseImageMemoryRequirements2KHRInitializer | null): VkSparseImageMemoryRequirements2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseImageMemoryRequirements2KHR: VkSparseImageMemoryRequirements2KHRConstructor;



  /**
   * (None)
   */
interface VkSparseImageMemoryRequirements2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly memoryRequirements: VkSparseImageMemoryRequirements | null;

}

declare interface VkSparseImageMemoryRequirements2Initializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly memoryRequirements?: VkSparseImageMemoryRequirements | null;
}

declare interface VkSparseImageMemoryRequirements2Constructor {
  readonly prototype: VkSparseImageMemoryRequirements2;
  new(param?: VkSparseImageMemoryRequirements2Initializer | null): VkSparseImageMemoryRequirements2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseImageMemoryRequirements2: VkSparseImageMemoryRequirements2Constructor;



  /**
   * 
   */
interface VkMemoryRequirements2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly memoryRequirements: VkMemoryRequirements | null;

}

declare interface VkMemoryRequirements2KHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly memoryRequirements?: VkMemoryRequirements | null;
}

declare interface VkMemoryRequirements2KHRConstructor {
  readonly prototype: VkMemoryRequirements2KHR;
  new(param?: VkMemoryRequirements2KHRInitializer | null): VkMemoryRequirements2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryRequirements2KHR: VkMemoryRequirements2KHRConstructor;



  /**
   * Structure specifying memory requirements
   */
interface VkMemoryRequirements2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly memoryRequirements: VkMemoryRequirements | null;

}

declare interface VkMemoryRequirements2Initializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly memoryRequirements?: VkMemoryRequirements | null;
}

declare interface VkMemoryRequirements2Constructor {
  readonly prototype: VkMemoryRequirements2;
  new(param?: VkMemoryRequirements2Initializer | null): VkMemoryRequirements2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryRequirements2: VkMemoryRequirements2Constructor;



  /**
   * 
   */
interface VkImageSparseMemoryRequirementsInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    image: VkImage | null;

}

declare interface VkImageSparseMemoryRequirementsInfo2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    image?: VkImage | null;
}

declare interface VkImageSparseMemoryRequirementsInfo2KHRConstructor {
  readonly prototype: VkImageSparseMemoryRequirementsInfo2KHR;
  new(param?: VkImageSparseMemoryRequirementsInfo2KHRInitializer | null): VkImageSparseMemoryRequirementsInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageSparseMemoryRequirementsInfo2KHR: VkImageSparseMemoryRequirementsInfo2KHRConstructor;



  /**
   * (None)
   */
interface VkImageSparseMemoryRequirementsInfo2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    image: VkImage | null;

}

declare interface VkImageSparseMemoryRequirementsInfo2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    image?: VkImage | null;
}

declare interface VkImageSparseMemoryRequirementsInfo2Constructor {
  readonly prototype: VkImageSparseMemoryRequirementsInfo2;
  new(param?: VkImageSparseMemoryRequirementsInfo2Initializer | null): VkImageSparseMemoryRequirementsInfo2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageSparseMemoryRequirementsInfo2: VkImageSparseMemoryRequirementsInfo2Constructor;



  /**
   * 
   */
interface VkImageMemoryRequirementsInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    image: VkImage | null;

}

declare interface VkImageMemoryRequirementsInfo2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    image?: VkImage | null;
}

declare interface VkImageMemoryRequirementsInfo2KHRConstructor {
  readonly prototype: VkImageMemoryRequirementsInfo2KHR;
  new(param?: VkImageMemoryRequirementsInfo2KHRInitializer | null): VkImageMemoryRequirementsInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageMemoryRequirementsInfo2KHR: VkImageMemoryRequirementsInfo2KHRConstructor;



  /**
   * (None)
   */
interface VkImageMemoryRequirementsInfo2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    image: VkImage | null;

}

declare interface VkImageMemoryRequirementsInfo2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    image?: VkImage | null;
}

declare interface VkImageMemoryRequirementsInfo2Constructor {
  readonly prototype: VkImageMemoryRequirementsInfo2;
  new(param?: VkImageMemoryRequirementsInfo2Initializer | null): VkImageMemoryRequirementsInfo2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageMemoryRequirementsInfo2: VkImageMemoryRequirementsInfo2Constructor;



  /**
   * 
   */
interface VkBufferMemoryRequirementsInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    buffer: VkBuffer | null;

}

declare interface VkBufferMemoryRequirementsInfo2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    buffer?: VkBuffer | null;
}

declare interface VkBufferMemoryRequirementsInfo2KHRConstructor {
  readonly prototype: VkBufferMemoryRequirementsInfo2KHR;
  new(param?: VkBufferMemoryRequirementsInfo2KHRInitializer | null): VkBufferMemoryRequirementsInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferMemoryRequirementsInfo2KHR: VkBufferMemoryRequirementsInfo2KHRConstructor;



  /**
   * (None)
   */
interface VkBufferMemoryRequirementsInfo2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    buffer: VkBuffer | null;

}

declare interface VkBufferMemoryRequirementsInfo2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    buffer?: VkBuffer | null;
}

declare interface VkBufferMemoryRequirementsInfo2Constructor {
  readonly prototype: VkBufferMemoryRequirementsInfo2;
  new(param?: VkBufferMemoryRequirementsInfo2Initializer | null): VkBufferMemoryRequirementsInfo2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferMemoryRequirementsInfo2: VkBufferMemoryRequirementsInfo2Constructor;



  /**
   * 
   */
interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderSubgroupExtendedTypes: boolean;

}

declare interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderSubgroupExtendedTypes?: boolean;
}

declare interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR;
  new(param?: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRInitializer | null): VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRConstructor;



  /**
   * Structure describing the extended types subgroups support feature for an implementation
   */
interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    shaderSubgroupExtendedTypes: boolean;

}

declare interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    shaderSubgroupExtendedTypes?: boolean;
}

declare interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
  new(param?: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesInitializer | null): VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesConstructor;



  /**
   * Structure describing subgroup support for an implementation
   */
interface VkPhysicalDeviceSubgroupProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     *
     */
    readonly subgroupSize: number;

    /**
     *
     */
    readonly supportedStages: VkShaderStageFlagBits;

    /**
     *
     */
    readonly supportedOperations: VkSubgroupFeatureFlagBits;

    /**
     *
     */
    readonly quadOperationsInAllStages: boolean;

}

declare interface VkPhysicalDeviceSubgroupPropertiesInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly subgroupSize?: number;

    /**
     *
     */
    readonly supportedStages?: VkShaderStageFlagBits;

    /**
     *
     */
    readonly supportedOperations?: VkSubgroupFeatureFlagBits;

    /**
     *
     */
    readonly quadOperationsInAllStages?: boolean;
}

declare interface VkPhysicalDeviceSubgroupPropertiesConstructor {
  readonly prototype: VkPhysicalDeviceSubgroupProperties;
  new(param?: VkPhysicalDeviceSubgroupPropertiesInitializer | null): VkPhysicalDeviceSubgroupProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSubgroupProperties: VkPhysicalDeviceSubgroupPropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDevice16BitStorageFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    storageBuffer16BitAccess: boolean;

    /**
     *
     */
    uniformAndStorageBuffer16BitAccess: boolean;

    /**
     *
     */
    storagePushConstant16: boolean;

    /**
     *
     */
    storageInputOutput16: boolean;

}

declare interface VkPhysicalDevice16BitStorageFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    storageBuffer16BitAccess?: boolean;

    /**
     *
     */
    uniformAndStorageBuffer16BitAccess?: boolean;

    /**
     *
     */
    storagePushConstant16?: boolean;

    /**
     *
     */
    storageInputOutput16?: boolean;
}

declare interface VkPhysicalDevice16BitStorageFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDevice16BitStorageFeaturesKHR;
  new(param?: VkPhysicalDevice16BitStorageFeaturesKHRInitializer | null): VkPhysicalDevice16BitStorageFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevice16BitStorageFeaturesKHR: VkPhysicalDevice16BitStorageFeaturesKHRConstructor;



  /**
   * Structure describing features supported by VK_KHR_16bit_storage
   */
interface VkPhysicalDevice16BitStorageFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    storageBuffer16BitAccess: boolean;

    /**
     *
     */
    uniformAndStorageBuffer16BitAccess: boolean;

    /**
     *
     */
    storagePushConstant16: boolean;

    /**
     *
     */
    storageInputOutput16: boolean;

}

declare interface VkPhysicalDevice16BitStorageFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    storageBuffer16BitAccess?: boolean;

    /**
     *
     */
    uniformAndStorageBuffer16BitAccess?: boolean;

    /**
     *
     */
    storagePushConstant16?: boolean;

    /**
     *
     */
    storageInputOutput16?: boolean;
}

declare interface VkPhysicalDevice16BitStorageFeaturesConstructor {
  readonly prototype: VkPhysicalDevice16BitStorageFeatures;
  new(param?: VkPhysicalDevice16BitStorageFeaturesInitializer | null): VkPhysicalDevice16BitStorageFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevice16BitStorageFeatures: VkPhysicalDevice16BitStorageFeaturesConstructor;



  /**
   * structure describing capabilities of a surface for shared presentation
   */
interface VkSharedPresentSurfaceCapabilitiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a bitmask of 'VkImageUsageFlagBits' representing the ways the application 'can' use the shared presentable image from a swapchain created with 'VkPresentModeKHR' set to 'VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR' or 'VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR' for the surface on the specified device. 'VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT' 'must' be included in the set but implementations 'may' support additional usages.
     */
    readonly sharedPresentSupportedUsageFlags: VkImageUsageFlagBits;

}

declare interface VkSharedPresentSurfaceCapabilitiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a bitmask of 'VkImageUsageFlagBits' representing the ways the application 'can' use the shared presentable image from a swapchain created with 'VkPresentModeKHR' set to 'VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR' or 'VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR' for the surface on the specified device. 'VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT' 'must' be included in the set but implementations 'may' support additional usages.
     */
    readonly sharedPresentSupportedUsageFlags?: VkImageUsageFlagBits;
}

declare interface VkSharedPresentSurfaceCapabilitiesKHRConstructor {
  readonly prototype: VkSharedPresentSurfaceCapabilitiesKHR;
  new(param?: VkSharedPresentSurfaceCapabilitiesKHRInitializer | null): VkSharedPresentSurfaceCapabilitiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSharedPresentSurfaceCapabilitiesKHR: VkSharedPresentSurfaceCapabilitiesKHRConstructor;



  /**
   * Structure describing the capabilities of a mode and plane combination
   */
interface VkDisplayPlaneCapabilities2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a 'VkDisplayPlaneCapabilitiesKHR' structure.
     */
    readonly capabilities: VkDisplayPlaneCapabilitiesKHR | null;

}

declare interface VkDisplayPlaneCapabilities2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a 'VkDisplayPlaneCapabilitiesKHR' structure.
     */
    readonly capabilities?: VkDisplayPlaneCapabilitiesKHR | null;
}

declare interface VkDisplayPlaneCapabilities2KHRConstructor {
  readonly prototype: VkDisplayPlaneCapabilities2KHR;
  new(param?: VkDisplayPlaneCapabilities2KHRInitializer | null): VkDisplayPlaneCapabilities2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayPlaneCapabilities2KHR: VkDisplayPlaneCapabilities2KHRConstructor;



  /**
   * Structure defining the intended configuration of a display plane
   */
interface VkDisplayPlaneInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the display mode the application intends to program when using the specified plane.
     */
    mode: VkDisplayModeKHR | null;

    /**
     *
     */
    planeIndex: number;

}

declare interface VkDisplayPlaneInfo2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the display mode the application intends to program when using the specified plane.
     */
    mode?: VkDisplayModeKHR | null;

    /**
     *
     */
    planeIndex?: number;
}

declare interface VkDisplayPlaneInfo2KHRConstructor {
  readonly prototype: VkDisplayPlaneInfo2KHR;
  new(param?: VkDisplayPlaneInfo2KHRInitializer | null): VkDisplayPlaneInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayPlaneInfo2KHR: VkDisplayPlaneInfo2KHRConstructor;



  /**
   * Structure describing an available display mode
   */
interface VkDisplayModeProperties2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a 'VkDisplayModePropertiesKHR' structure.
     */
    readonly displayModeProperties: VkDisplayModePropertiesKHR | null;

}

declare interface VkDisplayModeProperties2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a 'VkDisplayModePropertiesKHR' structure.
     */
    readonly displayModeProperties?: VkDisplayModePropertiesKHR | null;
}

declare interface VkDisplayModeProperties2KHRConstructor {
  readonly prototype: VkDisplayModeProperties2KHR;
  new(param?: VkDisplayModeProperties2KHRInitializer | null): VkDisplayModeProperties2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayModeProperties2KHR: VkDisplayModeProperties2KHRConstructor;



  /**
   * Structure describing an available display plane
   */
interface VkDisplayPlaneProperties2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a 'VkDisplayPlanePropertiesKHR' structure.
     */
    readonly displayPlaneProperties: VkDisplayPlanePropertiesKHR | null;

}

declare interface VkDisplayPlaneProperties2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a 'VkDisplayPlanePropertiesKHR' structure.
     */
    readonly displayPlaneProperties?: VkDisplayPlanePropertiesKHR | null;
}

declare interface VkDisplayPlaneProperties2KHRConstructor {
  readonly prototype: VkDisplayPlaneProperties2KHR;
  new(param?: VkDisplayPlaneProperties2KHRInitializer | null): VkDisplayPlaneProperties2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayPlaneProperties2KHR: VkDisplayPlaneProperties2KHRConstructor;



  /**
   * Structure describing an available display device
   */
interface VkDisplayProperties2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a 'VkDisplayPropertiesKHR' structure.
     */
    readonly displayProperties: VkDisplayPropertiesKHR | null;

}

declare interface VkDisplayProperties2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a 'VkDisplayPropertiesKHR' structure.
     */
    readonly displayProperties?: VkDisplayPropertiesKHR | null;
}

declare interface VkDisplayProperties2KHRConstructor {
  readonly prototype: VkDisplayProperties2KHR;
  new(param?: VkDisplayProperties2KHRInitializer | null): VkDisplayProperties2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayProperties2KHR: VkDisplayProperties2KHRConstructor;



  /**
   * Structure describing a supported swapchain format tuple
   */
interface VkSurfaceFormat2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a 'VkSurfaceFormatKHR' structure describing a format-color space pair that is compatible with the specified surface.
     */
    readonly surfaceFormat: VkSurfaceFormatKHR | null;

}

declare interface VkSurfaceFormat2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a 'VkSurfaceFormatKHR' structure describing a format-color space pair that is compatible with the specified surface.
     */
    readonly surfaceFormat?: VkSurfaceFormatKHR | null;
}

declare interface VkSurfaceFormat2KHRConstructor {
  readonly prototype: VkSurfaceFormat2KHR;
  new(param?: VkSurfaceFormat2KHRInitializer | null): VkSurfaceFormat2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSurfaceFormat2KHR: VkSurfaceFormat2KHRConstructor;



  /**
   * Structure describing capabilities of a surface
   */
interface VkSurfaceCapabilities2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a 'VkSurfaceCapabilitiesKHR' structure describing the capabilities of the specified surface.
     */
    readonly surfaceCapabilities: VkSurfaceCapabilitiesKHR | null;

}

declare interface VkSurfaceCapabilities2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a 'VkSurfaceCapabilitiesKHR' structure describing the capabilities of the specified surface.
     */
    readonly surfaceCapabilities?: VkSurfaceCapabilitiesKHR | null;
}

declare interface VkSurfaceCapabilities2KHRConstructor {
  readonly prototype: VkSurfaceCapabilities2KHR;
  new(param?: VkSurfaceCapabilities2KHRInitializer | null): VkSurfaceCapabilities2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSurfaceCapabilities2KHR: VkSurfaceCapabilities2KHRConstructor;



  /**
   * Structure specifying a surface and related swapchain creation parameters
   */
interface VkPhysicalDeviceSurfaceInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the surface that will be associated with the swapchain.
     */
    surface: VkSurfaceKHR | null;

}

declare interface VkPhysicalDeviceSurfaceInfo2KHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the surface that will be associated with the swapchain.
     */
    surface?: VkSurfaceKHR | null;
}

declare interface VkPhysicalDeviceSurfaceInfo2KHRConstructor {
  readonly prototype: VkPhysicalDeviceSurfaceInfo2KHR;
  new(param?: VkPhysicalDeviceSurfaceInfo2KHRInitializer | null): VkPhysicalDeviceSurfaceInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSurfaceInfo2KHR: VkPhysicalDeviceSurfaceInfo2KHRConstructor;



  /**
   * 
   */
interface VkRenderPassInputAttachmentAspectCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    aspectReferenceCount: number;

    /**
     *
     */
    pAspectReferences: VkInputAttachmentAspectReference[] | null;

}

declare interface VkRenderPassInputAttachmentAspectCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    aspectReferenceCount?: number;

    /**
     *
     */
    pAspectReferences?: VkInputAttachmentAspectReference[] | null;
}

declare interface VkRenderPassInputAttachmentAspectCreateInfoKHRConstructor {
  readonly prototype: VkRenderPassInputAttachmentAspectCreateInfoKHR;
  new(param?: VkRenderPassInputAttachmentAspectCreateInfoKHRInitializer | null): VkRenderPassInputAttachmentAspectCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassInputAttachmentAspectCreateInfoKHR: VkRenderPassInputAttachmentAspectCreateInfoKHRConstructor;



  /**
   * Structure specifying, for a given subpass/input attachment pair, which aspect {#0#} be read.
   */
interface VkRenderPassInputAttachmentAspectCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    aspectReferenceCount: number;

    /**
     *
     */
    pAspectReferences: VkInputAttachmentAspectReference[] | null;

}

declare interface VkRenderPassInputAttachmentAspectCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    aspectReferenceCount?: number;

    /**
     *
     */
    pAspectReferences?: VkInputAttachmentAspectReference[] | null;
}

declare interface VkRenderPassInputAttachmentAspectCreateInfoConstructor {
  readonly prototype: VkRenderPassInputAttachmentAspectCreateInfo;
  new(param?: VkRenderPassInputAttachmentAspectCreateInfoInitializer | null): VkRenderPassInputAttachmentAspectCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassInputAttachmentAspectCreateInfo: VkRenderPassInputAttachmentAspectCreateInfoConstructor;



  /**
   * 
   */
interface VkInputAttachmentAspectReferenceKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    subpass: number;

    /**
     *
     */
    inputAttachmentIndex: number;

    /**
     *
     */
    aspectMask: VkImageAspectFlagBits;

}

declare interface VkInputAttachmentAspectReferenceKHRInitializer {
  
    /**
     *
     */
    subpass?: number;

    /**
     *
     */
    inputAttachmentIndex?: number;

    /**
     *
     */
    aspectMask?: VkImageAspectFlagBits;
}

declare interface VkInputAttachmentAspectReferenceKHRConstructor {
  readonly prototype: VkInputAttachmentAspectReferenceKHR;
  new(param?: VkInputAttachmentAspectReferenceKHRInitializer | null): VkInputAttachmentAspectReferenceKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkInputAttachmentAspectReferenceKHR: VkInputAttachmentAspectReferenceKHRConstructor;



  /**
   * Structure specifying a subpass/input attachment pair and an aspect mask that {#0#} be read.
   */
interface VkInputAttachmentAspectReference {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    subpass: number;

    /**
     *
     */
    inputAttachmentIndex: number;

    /**
     *
     */
    aspectMask: VkImageAspectFlagBits;

}

declare interface VkInputAttachmentAspectReferenceInitializer {
  
    /**
     *
     */
    subpass?: number;

    /**
     *
     */
    inputAttachmentIndex?: number;

    /**
     *
     */
    aspectMask?: VkImageAspectFlagBits;
}

declare interface VkInputAttachmentAspectReferenceConstructor {
  readonly prototype: VkInputAttachmentAspectReference;
  new(param?: VkInputAttachmentAspectReferenceInitializer | null): VkInputAttachmentAspectReference;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkInputAttachmentAspectReference: VkInputAttachmentAspectReferenceConstructor;



  /**
   * Structure describing multiview limits that can be supported by an implementation
   */
interface VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     *
     */
    readonly perViewPositionAllComponents: boolean;

}

declare interface VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly perViewPositionAllComponents?: boolean;
}

declare interface VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXConstructor {
  readonly prototype: VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
  new(param?: VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXInitializer | null): VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX: VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXConstructor;



  /**
   * Structure specifying discard rectangle
   */
interface VkPipelineDiscardRectangleStateCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is a 'VkDiscardRectangleModeEXT' value determining whether the discard rectangle test is inclusive or exclusive.
     */
    discardRectangleMode: VkDiscardRectangleModeEXT;

    /**
     * is the number of discard rectangles to use.
     */
    discardRectangleCount: number;

    /**
     * is an array of 'VkRect2D' structures defining discard rectangles.
     */
    pDiscardRectangles: VkRect2D[] | null;

}

declare interface VkPipelineDiscardRectangleStateCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is a 'VkDiscardRectangleModeEXT' value determining whether the discard rectangle test is inclusive or exclusive.
     */
    discardRectangleMode?: VkDiscardRectangleModeEXT;

    /**
     * is the number of discard rectangles to use.
     */
    discardRectangleCount?: number;

    /**
     * is an array of 'VkRect2D' structures defining discard rectangles.
     */
    pDiscardRectangles?: VkRect2D[] | null;
}

declare interface VkPipelineDiscardRectangleStateCreateInfoEXTConstructor {
  readonly prototype: VkPipelineDiscardRectangleStateCreateInfoEXT;
  new(param?: VkPipelineDiscardRectangleStateCreateInfoEXTInitializer | null): VkPipelineDiscardRectangleStateCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineDiscardRectangleStateCreateInfoEXT: VkPipelineDiscardRectangleStateCreateInfoEXTConstructor;



  /**
   * Structure describing discard rectangle limits that can be supported by an implementation
   */
interface VkPhysicalDeviceDiscardRectanglePropertiesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the maximum number of active discard rectangles that 'can' be specified.
     */
    readonly maxDiscardRectangles: number;

}

declare interface VkPhysicalDeviceDiscardRectanglePropertiesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the maximum number of active discard rectangles that 'can' be specified.
     */
    readonly maxDiscardRectangles?: number;
}

declare interface VkPhysicalDeviceDiscardRectanglePropertiesEXTConstructor {
  readonly prototype: VkPhysicalDeviceDiscardRectanglePropertiesEXT;
  new(param?: VkPhysicalDeviceDiscardRectanglePropertiesEXTInitializer | null): VkPhysicalDeviceDiscardRectanglePropertiesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDiscardRectanglePropertiesEXT: VkPhysicalDeviceDiscardRectanglePropertiesEXTConstructor;



  /**
   * Structure specifying swizzle applied to primitive clip coordinates
   */
interface VkPipelineViewportSwizzleStateCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is the number of viewport swizzles used by the pipeline.
     */
    viewportCount: number;

    /**
     * is an array of 'VkViewportSwizzleNV' structures, defining the viewport swizzles.
     */
    pViewportSwizzles: VkViewportSwizzleNV[] | null;

}

declare interface VkPipelineViewportSwizzleStateCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is the number of viewport swizzles used by the pipeline.
     */
    viewportCount?: number;

    /**
     * is an array of 'VkViewportSwizzleNV' structures, defining the viewport swizzles.
     */
    pViewportSwizzles?: VkViewportSwizzleNV[] | null;
}

declare interface VkPipelineViewportSwizzleStateCreateInfoNVConstructor {
  readonly prototype: VkPipelineViewportSwizzleStateCreateInfoNV;
  new(param?: VkPipelineViewportSwizzleStateCreateInfoNVInitializer | null): VkPipelineViewportSwizzleStateCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineViewportSwizzleStateCreateInfoNV: VkPipelineViewportSwizzleStateCreateInfoNVConstructor;



  /**
   * Structure specifying a viewport swizzle
   */
interface VkViewportSwizzleNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the x component of the primitive
     */
    x: VkViewportCoordinateSwizzleNV;

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the y component of the primitive
     */
    y: VkViewportCoordinateSwizzleNV;

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the z component of the primitive
     */
    z: VkViewportCoordinateSwizzleNV;

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the w component of the primitive
     */
    w: VkViewportCoordinateSwizzleNV;

}

declare interface VkViewportSwizzleNVInitializer {
  
    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the x component of the primitive
     */
    x?: VkViewportCoordinateSwizzleNV;

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the y component of the primitive
     */
    y?: VkViewportCoordinateSwizzleNV;

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the z component of the primitive
     */
    z?: VkViewportCoordinateSwizzleNV;

    /**
     * is a 'VkViewportCoordinateSwizzleNV' value specifying the swizzle operation to apply to the w component of the primitive
     */
    w?: VkViewportCoordinateSwizzleNV;
}

declare interface VkViewportSwizzleNVConstructor {
  readonly prototype: VkViewportSwizzleNV;
  new(param?: VkViewportSwizzleNVInitializer | null): VkViewportSwizzleNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkViewportSwizzleNV: VkViewportSwizzleNVConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline viewport W scaling state
   */
interface VkPipelineViewportWScalingStateCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * controls whether viewport 
     */
    viewportWScalingEnable: boolean;

    /**
     * is the number of viewports used by 
     */
    viewportCount: number;

    /**
     * is an array of 'VkViewportWScalingNV' structures defining the 
     */
    pViewportWScalings: VkViewportWScalingNV[] | null;

}

declare interface VkPipelineViewportWScalingStateCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * controls whether viewport 
     */
    viewportWScalingEnable?: boolean;

    /**
     * is the number of viewports used by 
     */
    viewportCount?: number;

    /**
     * is an array of 'VkViewportWScalingNV' structures defining the 
     */
    pViewportWScalings?: VkViewportWScalingNV[] | null;
}

declare interface VkPipelineViewportWScalingStateCreateInfoNVConstructor {
  readonly prototype: VkPipelineViewportWScalingStateCreateInfoNV;
  new(param?: VkPipelineViewportWScalingStateCreateInfoNVInitializer | null): VkPipelineViewportWScalingStateCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineViewportWScalingStateCreateInfoNV: VkPipelineViewportWScalingStateCreateInfoNVConstructor;



  /**
   * Structure specifying a viewport
   */
interface VkViewportWScalingNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    xcoeff: number;

    /**
     * are the viewport's W scaling factor for x and y respectively.
     */
    ycoeff: number;

}

declare interface VkViewportWScalingNVInitializer {
  
    /**
     *
     */
    xcoeff?: number;

    /**
     * are the viewport's W scaling factor for x and y respectively.
     */
    ycoeff?: number;
}

declare interface VkViewportWScalingNVConstructor {
  readonly prototype: VkViewportWScalingNV;
  new(param?: VkViewportWScalingNVInitializer | null): VkViewportWScalingNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkViewportWScalingNV: VkViewportWScalingNVConstructor;



  /**
   * The earliest time image should be presented
   */
interface VkPresentTimeGOOGLE {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is an application-provided identification value, that 'can' be used with the results of 'vkGetPastPresentationTimingGOOGLE', in order to uniquely identify this present. In order to be useful to the application, it 'should' be unique within some period of time that is meaningful to the application.
     */
    presentID: number;

    /**
     * specifies that the image given 'should' not be displayed to the user any earlier than this time. 'desiredPresentTime' is a time in nanoseconds, relative to a monotonically-increasing clock (e.g. `CLOCK_MONOTONIC` (see clock_gettime(2)) on Android and Linux). A value of zero specifies that the presentation engine 'may' display the image at any time. This is useful when the application desires to provide 'presentID', but does not need a specific 'desiredPresentTime'.
     */
    desiredPresentTime: bigint | number;

}

declare interface VkPresentTimeGOOGLEInitializer {
  
    /**
     * is an application-provided identification value, that 'can' be used with the results of 'vkGetPastPresentationTimingGOOGLE', in order to uniquely identify this present. In order to be useful to the application, it 'should' be unique within some period of time that is meaningful to the application.
     */
    presentID?: number;

    /**
     * specifies that the image given 'should' not be displayed to the user any earlier than this time. 'desiredPresentTime' is a time in nanoseconds, relative to a monotonically-increasing clock (e.g. `CLOCK_MONOTONIC` (see clock_gettime(2)) on Android and Linux). A value of zero specifies that the presentation engine 'may' display the image at any time. This is useful when the application desires to provide 'presentID', but does not need a specific 'desiredPresentTime'.
     */
    desiredPresentTime?: bigint | number;
}

declare interface VkPresentTimeGOOGLEConstructor {
  readonly prototype: VkPresentTimeGOOGLE;
  new(param?: VkPresentTimeGOOGLEInitializer | null): VkPresentTimeGOOGLE;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPresentTimeGOOGLE: VkPresentTimeGOOGLEConstructor;



  /**
   * The earliest time each image should be presented
   */
interface VkPresentTimesInfoGOOGLE {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount: number;

    /**
     * is <i>null</i> or a reference to an array of 'VkPresentTimeGOOGLE' elements with 'swapchainCount' entries. If not <i>null</i>, each element of 'pTimes' contains the earliest time to present the image corresponding to the entry in the 'VkPresentInfoKHR'::'pImageIndices' array.
     */
    pTimes: VkPresentTimeGOOGLE[] | null;

}

declare interface VkPresentTimesInfoGOOGLEInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount?: number;

    /**
     * is <i>null</i> or a reference to an array of 'VkPresentTimeGOOGLE' elements with 'swapchainCount' entries. If not <i>null</i>, each element of 'pTimes' contains the earliest time to present the image corresponding to the entry in the 'VkPresentInfoKHR'::'pImageIndices' array.
     */
    pTimes?: VkPresentTimeGOOGLE[] | null;
}

declare interface VkPresentTimesInfoGOOGLEConstructor {
  readonly prototype: VkPresentTimesInfoGOOGLE;
  new(param?: VkPresentTimesInfoGOOGLEInitializer | null): VkPresentTimesInfoGOOGLE;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPresentTimesInfoGOOGLE: VkPresentTimesInfoGOOGLEConstructor;



  /**
   * Structure containing timing information about a previously-presented image
   */
interface VkPastPresentationTimingGOOGLE {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is an application-provided value that was given to a previous 'vkQueuePresentKHR' command via 'VkPresentTimeGOOGLE'::'presentID' (see below). It 'can' be used to uniquely identify a previous present with the 'vkQueuePresentKHR' command.
     */
    readonly presentID: number;

    /**
     * is an application-provided value that was given to a previous 'vkQueuePresentKHR' command via 'VkPresentTimeGOOGLE'::'desiredPresentTime'. If non-zero, it was used by the application to indicate that an image not be presented any sooner than 'desiredPresentTime'.
     */
    readonly desiredPresentTime: bigint | number;

    /**
     * is the time when the image of the 'swapchain' was actually displayed.
     */
    readonly actualPresentTime: bigint | number;

    /**
     * is the time when the image of the 'swapchain' could have been displayed. This 'may' differ from 'actualPresentTime' if the application requested that the image be presented no sooner than 'VkPresentTimeGOOGLE'::'desiredPresentTime'.
     */
    readonly earliestPresentTime: bigint | number;

    /**
     * is an indication of how early the 'vkQueuePresentKHR' command was processed compared to how soon it needed to be processed, and still be presented at 'earliestPresentTime'.
     */
    readonly presentMargin: bigint | number;

}

declare interface VkPastPresentationTimingGOOGLEInitializer {
  
    /**
     * is an application-provided value that was given to a previous 'vkQueuePresentKHR' command via 'VkPresentTimeGOOGLE'::'presentID' (see below). It 'can' be used to uniquely identify a previous present with the 'vkQueuePresentKHR' command.
     */
    readonly presentID?: number;

    /**
     * is an application-provided value that was given to a previous 'vkQueuePresentKHR' command via 'VkPresentTimeGOOGLE'::'desiredPresentTime'. If non-zero, it was used by the application to indicate that an image not be presented any sooner than 'desiredPresentTime'.
     */
    readonly desiredPresentTime?: bigint | number;

    /**
     * is the time when the image of the 'swapchain' was actually displayed.
     */
    readonly actualPresentTime?: bigint | number;

    /**
     * is the time when the image of the 'swapchain' could have been displayed. This 'may' differ from 'actualPresentTime' if the application requested that the image be presented no sooner than 'VkPresentTimeGOOGLE'::'desiredPresentTime'.
     */
    readonly earliestPresentTime?: bigint | number;

    /**
     * is an indication of how early the 'vkQueuePresentKHR' command was processed compared to how soon it needed to be processed, and still be presented at 'earliestPresentTime'.
     */
    readonly presentMargin?: bigint | number;
}

declare interface VkPastPresentationTimingGOOGLEConstructor {
  readonly prototype: VkPastPresentationTimingGOOGLE;
  new(param?: VkPastPresentationTimingGOOGLEInitializer | null): VkPastPresentationTimingGOOGLE;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPastPresentationTimingGOOGLE: VkPastPresentationTimingGOOGLEConstructor;



  /**
   * Structure containing the RC duration of a display
   */
interface VkRefreshCycleDurationGOOGLE {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the number of nanoseconds from the start of one refresh cycle to the next.
     */
    readonly refreshDuration: bigint | number;

}

declare interface VkRefreshCycleDurationGOOGLEInitializer {
  
    /**
     * is the number of nanoseconds from the start of one refresh cycle to the next.
     */
    readonly refreshDuration?: bigint | number;
}

declare interface VkRefreshCycleDurationGOOGLEConstructor {
  readonly prototype: VkRefreshCycleDurationGOOGLE;
  new(param?: VkRefreshCycleDurationGOOGLEInitializer | null): VkRefreshCycleDurationGOOGLE;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRefreshCycleDurationGOOGLE: VkRefreshCycleDurationGOOGLEConstructor;



  /**
   * Structure specifying display native HDR parameters of a newly created swapchain object
   */
interface VkSwapchainDisplayNativeHdrCreateInfoAMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies whether local dimming is enabled for the swapchain.
     */
    localDimmingEnable: boolean;

}

declare interface VkSwapchainDisplayNativeHdrCreateInfoAMDInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies whether local dimming is enabled for the swapchain.
     */
    localDimmingEnable?: boolean;
}

declare interface VkSwapchainDisplayNativeHdrCreateInfoAMDConstructor {
  readonly prototype: VkSwapchainDisplayNativeHdrCreateInfoAMD;
  new(param?: VkSwapchainDisplayNativeHdrCreateInfoAMDInitializer | null): VkSwapchainDisplayNativeHdrCreateInfoAMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSwapchainDisplayNativeHdrCreateInfoAMD: VkSwapchainDisplayNativeHdrCreateInfoAMDConstructor;



  /**
   * Structure describing display native HDR specific capabilities of a surface
   */
interface VkDisplayNativeHdrSurfaceCapabilitiesAMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * specifies whether the surface supports local dimming. If this is 'VK_TRUE', 'VkSwapchainDisplayNativeHdrCreateInfoAMD' 'can' be used to explicitly enable or disable local dimming for the surface. Local dimming may also be overriden by 'vkSetLocalDimmingAMD' during the lifetime of the swapchain.
     */
    readonly localDimmingSupport: boolean;

}

declare interface VkDisplayNativeHdrSurfaceCapabilitiesAMDInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * specifies whether the surface supports local dimming. If this is 'VK_TRUE', 'VkSwapchainDisplayNativeHdrCreateInfoAMD' 'can' be used to explicitly enable or disable local dimming for the surface. Local dimming may also be overriden by 'vkSetLocalDimmingAMD' during the lifetime of the swapchain.
     */
    readonly localDimmingSupport?: boolean;
}

declare interface VkDisplayNativeHdrSurfaceCapabilitiesAMDConstructor {
  readonly prototype: VkDisplayNativeHdrSurfaceCapabilitiesAMD;
  new(param?: VkDisplayNativeHdrSurfaceCapabilitiesAMDInitializer | null): VkDisplayNativeHdrSurfaceCapabilitiesAMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayNativeHdrSurfaceCapabilitiesAMD: VkDisplayNativeHdrSurfaceCapabilitiesAMDConstructor;



  /**
   * structure to specify Hdr metadata
   */
interface VkHdrMetadataEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the reference monitor's red primary in chromaticity coordinates
     */
    displayPrimaryRed: VkXYColorEXT | null;

    /**
     * is the reference monitor's green primary in chromaticity coordinates
     */
    displayPrimaryGreen: VkXYColorEXT | null;

    /**
     * is the reference monitor's blue primary in chromaticity coordinates
     */
    displayPrimaryBlue: VkXYColorEXT | null;

    /**
     * is the reference monitor's white-point in chromaticity coordinates
     */
    whitePoint: VkXYColorEXT | null;

    /**
     * is the maximum luminance of the reference monitor in nits
     */
    maxLuminance: number;

    /**
     * is the minimum luminance of the reference monitor in nits
     */
    minLuminance: number;

    /**
     * is content's maximum luminance in nits
     */
    maxContentLightLevel: number;

    /**
     * is the maximum frame average light level in nits
     */
    maxFrameAverageLightLevel: number;

}

declare interface VkHdrMetadataEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the reference monitor's red primary in chromaticity coordinates
     */
    displayPrimaryRed?: VkXYColorEXT | null;

    /**
     * is the reference monitor's green primary in chromaticity coordinates
     */
    displayPrimaryGreen?: VkXYColorEXT | null;

    /**
     * is the reference monitor's blue primary in chromaticity coordinates
     */
    displayPrimaryBlue?: VkXYColorEXT | null;

    /**
     * is the reference monitor's white-point in chromaticity coordinates
     */
    whitePoint?: VkXYColorEXT | null;

    /**
     * is the maximum luminance of the reference monitor in nits
     */
    maxLuminance?: number;

    /**
     * is the minimum luminance of the reference monitor in nits
     */
    minLuminance?: number;

    /**
     * is content's maximum luminance in nits
     */
    maxContentLightLevel?: number;

    /**
     * is the maximum frame average light level in nits
     */
    maxFrameAverageLightLevel?: number;
}

declare interface VkHdrMetadataEXTConstructor {
  readonly prototype: VkHdrMetadataEXT;
  new(param?: VkHdrMetadataEXTInitializer | null): VkHdrMetadataEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkHdrMetadataEXT: VkHdrMetadataEXTConstructor;



  /**
   * structure to specify X,Y chromaticity coordinates
   */
interface VkXYColorEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    x: number;

    /**
     *
     */
    y: number;

}

declare interface VkXYColorEXTInitializer {
  
    /**
     *
     */
    x?: number;

    /**
     *
     */
    y?: number;
}

declare interface VkXYColorEXTConstructor {
  readonly prototype: VkXYColorEXT;
  new(param?: VkXYColorEXTInitializer | null): VkXYColorEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkXYColorEXT: VkXYColorEXTConstructor;



  /**
   * 
   */
interface VkDescriptorUpdateTemplateCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: number;

    /**
     *
     */
    descriptorUpdateEntryCount: number;

    /**
     *
     */
    pDescriptorUpdateEntries: VkDescriptorUpdateTemplateEntry[] | null;

    /**
     *
     */
    templateType: VkDescriptorUpdateTemplateType;

    /**
     *
     */
    descriptorSetLayout: VkDescriptorSetLayout | null;

    /**
     *
     */
    pipelineBindPoint: VkPipelineBindPoint;

    /**
     *
     */
    pipelineLayout: VkPipelineLayout | null;

    /**
     *
     */
    set: number;

}

declare interface VkDescriptorUpdateTemplateCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: number;

    /**
     *
     */
    descriptorUpdateEntryCount?: number;

    /**
     *
     */
    pDescriptorUpdateEntries?: VkDescriptorUpdateTemplateEntry[] | null;

    /**
     *
     */
    templateType?: VkDescriptorUpdateTemplateType;

    /**
     *
     */
    descriptorSetLayout?: VkDescriptorSetLayout | null;

    /**
     *
     */
    pipelineBindPoint?: VkPipelineBindPoint;

    /**
     *
     */
    pipelineLayout?: VkPipelineLayout | null;

    /**
     *
     */
    set?: number;
}

declare interface VkDescriptorUpdateTemplateCreateInfoKHRConstructor {
  readonly prototype: VkDescriptorUpdateTemplateCreateInfoKHR;
  new(param?: VkDescriptorUpdateTemplateCreateInfoKHRInitializer | null): VkDescriptorUpdateTemplateCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorUpdateTemplateCreateInfoKHR: VkDescriptorUpdateTemplateCreateInfoKHRConstructor;



  /**
   * Structure specifying parameters of a newly created descriptor update template
   */
interface VkDescriptorUpdateTemplateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: number;

    /**
     *
     */
    descriptorUpdateEntryCount: number;

    /**
     *
     */
    pDescriptorUpdateEntries: VkDescriptorUpdateTemplateEntry[] | null;

    /**
     *
     */
    templateType: VkDescriptorUpdateTemplateType;

    /**
     *
     */
    descriptorSetLayout: VkDescriptorSetLayout | null;

    /**
     *
     */
    pipelineBindPoint: VkPipelineBindPoint;

    /**
     *
     */
    pipelineLayout: VkPipelineLayout | null;

    /**
     *
     */
    set: number;

}

declare interface VkDescriptorUpdateTemplateCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: number;

    /**
     *
     */
    descriptorUpdateEntryCount?: number;

    /**
     *
     */
    pDescriptorUpdateEntries?: VkDescriptorUpdateTemplateEntry[] | null;

    /**
     *
     */
    templateType?: VkDescriptorUpdateTemplateType;

    /**
     *
     */
    descriptorSetLayout?: VkDescriptorSetLayout | null;

    /**
     *
     */
    pipelineBindPoint?: VkPipelineBindPoint;

    /**
     *
     */
    pipelineLayout?: VkPipelineLayout | null;

    /**
     *
     */
    set?: number;
}

declare interface VkDescriptorUpdateTemplateCreateInfoConstructor {
  readonly prototype: VkDescriptorUpdateTemplateCreateInfo;
  new(param?: VkDescriptorUpdateTemplateCreateInfoInitializer | null): VkDescriptorUpdateTemplateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorUpdateTemplateCreateInfo: VkDescriptorUpdateTemplateCreateInfoConstructor;



  /**
   * 
   */
interface VkDescriptorUpdateTemplateEntryKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    dstBinding: number;

    /**
     *
     */
    dstArrayElement: number;

    /**
     *
     */
    descriptorCount: number;

    /**
     *
     */
    descriptorType: VkDescriptorType;

    /**
     *
     */
    offset: bigint | number;

    /**
     *
     */
    stride: bigint | number;

}

declare interface VkDescriptorUpdateTemplateEntryKHRInitializer {
  
    /**
     *
     */
    dstBinding?: number;

    /**
     *
     */
    dstArrayElement?: number;

    /**
     *
     */
    descriptorCount?: number;

    /**
     *
     */
    descriptorType?: VkDescriptorType;

    /**
     *
     */
    offset?: bigint | number;

    /**
     *
     */
    stride?: bigint | number;
}

declare interface VkDescriptorUpdateTemplateEntryKHRConstructor {
  readonly prototype: VkDescriptorUpdateTemplateEntryKHR;
  new(param?: VkDescriptorUpdateTemplateEntryKHRInitializer | null): VkDescriptorUpdateTemplateEntryKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorUpdateTemplateEntryKHR: VkDescriptorUpdateTemplateEntryKHRConstructor;



  /**
   * Describes a single descriptor update of the descriptor update template
   */
interface VkDescriptorUpdateTemplateEntry {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    dstBinding: number;

    /**
     *
     */
    dstArrayElement: number;

    /**
     *
     */
    descriptorCount: number;

    /**
     *
     */
    descriptorType: VkDescriptorType;

    /**
     *
     */
    offset: bigint | number;

    /**
     *
     */
    stride: bigint | number;

}

declare interface VkDescriptorUpdateTemplateEntryInitializer {
  
    /**
     *
     */
    dstBinding?: number;

    /**
     *
     */
    dstArrayElement?: number;

    /**
     *
     */
    descriptorCount?: number;

    /**
     *
     */
    descriptorType?: VkDescriptorType;

    /**
     *
     */
    offset?: bigint | number;

    /**
     *
     */
    stride?: bigint | number;
}

declare interface VkDescriptorUpdateTemplateEntryConstructor {
  readonly prototype: VkDescriptorUpdateTemplateEntry;
  new(param?: VkDescriptorUpdateTemplateEntryInitializer | null): VkDescriptorUpdateTemplateEntry;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorUpdateTemplateEntry: VkDescriptorUpdateTemplateEntryConstructor;



  /**
   * Structure specifying parameters of a newly created swapchain object
   */
interface VkDeviceGroupSwapchainCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitfield of modes that the swapchain 'can' be used with.
     */
    modes: VkDeviceGroupPresentModeFlagBitsKHR;

}

declare interface VkDeviceGroupSwapchainCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitfield of modes that the swapchain 'can' be used with.
     */
    modes?: VkDeviceGroupPresentModeFlagBitsKHR;
}

declare interface VkDeviceGroupSwapchainCreateInfoKHRConstructor {
  readonly prototype: VkDeviceGroupSwapchainCreateInfoKHR;
  new(param?: VkDeviceGroupSwapchainCreateInfoKHRInitializer | null): VkDeviceGroupSwapchainCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupSwapchainCreateInfoKHR: VkDeviceGroupSwapchainCreateInfoKHRConstructor;



  /**
   * 
   */
interface VkDeviceGroupDeviceCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    physicalDeviceCount: number;

    /**
     *
     */
    pPhysicalDevices: VkPhysicalDevice[] | null;

}

declare interface VkDeviceGroupDeviceCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    physicalDeviceCount?: number;

    /**
     *
     */
    pPhysicalDevices?: VkPhysicalDevice[] | null;
}

declare interface VkDeviceGroupDeviceCreateInfoKHRConstructor {
  readonly prototype: VkDeviceGroupDeviceCreateInfoKHR;
  new(param?: VkDeviceGroupDeviceCreateInfoKHRInitializer | null): VkDeviceGroupDeviceCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupDeviceCreateInfoKHR: VkDeviceGroupDeviceCreateInfoKHRConstructor;



  /**
   * Create a logical device from multiple physical devices
   */
interface VkDeviceGroupDeviceCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    physicalDeviceCount: number;

    /**
     *
     */
    pPhysicalDevices: VkPhysicalDevice[] | null;

}

declare interface VkDeviceGroupDeviceCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    physicalDeviceCount?: number;

    /**
     *
     */
    pPhysicalDevices?: VkPhysicalDevice[] | null;
}

declare interface VkDeviceGroupDeviceCreateInfoConstructor {
  readonly prototype: VkDeviceGroupDeviceCreateInfo;
  new(param?: VkDeviceGroupDeviceCreateInfoInitializer | null): VkDeviceGroupDeviceCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupDeviceCreateInfo: VkDeviceGroupDeviceCreateInfoConstructor;



  /**
   * Mode and mask controlling which physical devices\
   */
interface VkDeviceGroupPresentInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is zero or the number of elements in 'pDeviceMasks'.
     */
    swapchainCount: number;

    /**
     * is an array of device masks, one for each element of 'VkPresentInfoKHR'::pSwapchains.
     */
    pDeviceMasks: Uint32Array | null;

    /**
     * is the device group present mode that will be used for this present.
     */
    mode: VkDeviceGroupPresentModeFlagBitsKHR;

}

declare interface VkDeviceGroupPresentInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is zero or the number of elements in 'pDeviceMasks'.
     */
    swapchainCount?: number;

    /**
     * is an array of device masks, one for each element of 'VkPresentInfoKHR'::pSwapchains.
     */
    pDeviceMasks?: Uint32Array | null;

    /**
     * is the device group present mode that will be used for this present.
     */
    mode?: VkDeviceGroupPresentModeFlagBitsKHR;
}

declare interface VkDeviceGroupPresentInfoKHRConstructor {
  readonly prototype: VkDeviceGroupPresentInfoKHR;
  new(param?: VkDeviceGroupPresentInfoKHRInitializer | null): VkDeviceGroupPresentInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupPresentInfoKHR: VkDeviceGroupPresentInfoKHRConstructor;



  /**
   * Structure specifying parameters of the acquire
   */
interface VkAcquireNextImageInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a non-retired swapchain from which an image is acquired.
     */
    swapchain: VkSwapchainKHR | null;

    /**
     * specifies how long the function waits, in nanoseconds, if no image is available.
     */
    timeout: bigint | number;

    /**
     * is 'VK_NULL_HANDLE' or a semaphore to signal.
     */
    semaphore: VkSemaphore | null;

    /**
     * is 'VK_NULL_HANDLE' or a fence to signal.
     */
    fence: VkFence | null;

    /**
     * is a mask of physical devices for which the swapchain image will be ready to use when the semaphore or fence is signaled.
     */
    deviceMask: number;

}

declare interface VkAcquireNextImageInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a non-retired swapchain from which an image is acquired.
     */
    swapchain?: VkSwapchainKHR | null;

    /**
     * specifies how long the function waits, in nanoseconds, if no image is available.
     */
    timeout?: bigint | number;

    /**
     * is 'VK_NULL_HANDLE' or a semaphore to signal.
     */
    semaphore?: VkSemaphore | null;

    /**
     * is 'VK_NULL_HANDLE' or a fence to signal.
     */
    fence?: VkFence | null;

    /**
     * is a mask of physical devices for which the swapchain image will be ready to use when the semaphore or fence is signaled.
     */
    deviceMask?: number;
}

declare interface VkAcquireNextImageInfoKHRConstructor {
  readonly prototype: VkAcquireNextImageInfoKHR;
  new(param?: VkAcquireNextImageInfoKHRInitializer | null): VkAcquireNextImageInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAcquireNextImageInfoKHR: VkAcquireNextImageInfoKHRConstructor;



  /**
   * Structure specifying swapchain image memory to bind to
   */
interface VkBindImageMemorySwapchainInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is 'VK_NULL_HANDLE' or a swapchain handle.
     */
    swapchain: VkSwapchainKHR | null;

    /**
     *
     */
    imageIndex: number;

}

declare interface VkBindImageMemorySwapchainInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is 'VK_NULL_HANDLE' or a swapchain handle.
     */
    swapchain?: VkSwapchainKHR | null;

    /**
     *
     */
    imageIndex?: number;
}

declare interface VkBindImageMemorySwapchainInfoKHRConstructor {
  readonly prototype: VkBindImageMemorySwapchainInfoKHR;
  new(param?: VkBindImageMemorySwapchainInfoKHRInitializer | null): VkBindImageMemorySwapchainInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindImageMemorySwapchainInfoKHR: VkBindImageMemorySwapchainInfoKHRConstructor;



  /**
   * Specify that an image will be bound to swapchain memory
   */
interface VkImageSwapchainCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is 'VK_NULL_HANDLE' or a handle of a swapchain that the image will be bound to.
     */
    swapchain: VkSwapchainKHR | null;

}

declare interface VkImageSwapchainCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is 'VK_NULL_HANDLE' or a handle of a swapchain that the image will be bound to.
     */
    swapchain?: VkSwapchainKHR | null;
}

declare interface VkImageSwapchainCreateInfoKHRConstructor {
  readonly prototype: VkImageSwapchainCreateInfoKHR;
  new(param?: VkImageSwapchainCreateInfoKHRInitializer | null): VkImageSwapchainCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageSwapchainCreateInfoKHR: VkImageSwapchainCreateInfoKHRConstructor;



  /**
   * Present capabilities from other physical devices
   */
interface VkDeviceGroupPresentCapabilitiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     *
     */
    readonly presentMask: number[] | null;

    /**
     * is a bitmask of 'VkDeviceGroupPresentModeFlagBitsKHR' indicating which device group presentation modes are supported.
     */
    readonly modes: VkDeviceGroupPresentModeFlagBitsKHR;

}

declare interface VkDeviceGroupPresentCapabilitiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly presentMask?: number[] | null;

    /**
     * is a bitmask of 'VkDeviceGroupPresentModeFlagBitsKHR' indicating which device group presentation modes are supported.
     */
    readonly modes?: VkDeviceGroupPresentModeFlagBitsKHR;
}

declare interface VkDeviceGroupPresentCapabilitiesKHRConstructor {
  readonly prototype: VkDeviceGroupPresentCapabilitiesKHR;
  new(param?: VkDeviceGroupPresentCapabilitiesKHRInitializer | null): VkDeviceGroupPresentCapabilitiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupPresentCapabilitiesKHR: VkDeviceGroupPresentCapabilitiesKHRConstructor;



  /**
   * 
   */
interface VkDeviceGroupBindSparseInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    resourceDeviceIndex: number;

    /**
     *
     */
    memoryDeviceIndex: number;

}

declare interface VkDeviceGroupBindSparseInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    resourceDeviceIndex?: number;

    /**
     *
     */
    memoryDeviceIndex?: number;
}

declare interface VkDeviceGroupBindSparseInfoKHRConstructor {
  readonly prototype: VkDeviceGroupBindSparseInfoKHR;
  new(param?: VkDeviceGroupBindSparseInfoKHRInitializer | null): VkDeviceGroupBindSparseInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupBindSparseInfoKHR: VkDeviceGroupBindSparseInfoKHRConstructor;



  /**
   * Structure indicating which instances are bound
   */
interface VkDeviceGroupBindSparseInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    resourceDeviceIndex: number;

    /**
     *
     */
    memoryDeviceIndex: number;

}

declare interface VkDeviceGroupBindSparseInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    resourceDeviceIndex?: number;

    /**
     *
     */
    memoryDeviceIndex?: number;
}

declare interface VkDeviceGroupBindSparseInfoConstructor {
  readonly prototype: VkDeviceGroupBindSparseInfo;
  new(param?: VkDeviceGroupBindSparseInfoInitializer | null): VkDeviceGroupBindSparseInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupBindSparseInfo: VkDeviceGroupBindSparseInfoConstructor;



  /**
   * 
   */
interface VkDeviceGroupSubmitInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    waitSemaphoreCount: number;

    /**
     *
     */
    pWaitSemaphoreDeviceIndices: Uint32Array | null;

    /**
     *
     */
    commandBufferCount: number;

    /**
     *
     */
    pCommandBufferDeviceMasks: Uint32Array | null;

    /**
     *
     */
    signalSemaphoreCount: number;

    /**
     *
     */
    pSignalSemaphoreDeviceIndices: Uint32Array | null;

}

declare interface VkDeviceGroupSubmitInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    waitSemaphoreCount?: number;

    /**
     *
     */
    pWaitSemaphoreDeviceIndices?: Uint32Array | null;

    /**
     *
     */
    commandBufferCount?: number;

    /**
     *
     */
    pCommandBufferDeviceMasks?: Uint32Array | null;

    /**
     *
     */
    signalSemaphoreCount?: number;

    /**
     *
     */
    pSignalSemaphoreDeviceIndices?: Uint32Array | null;
}

declare interface VkDeviceGroupSubmitInfoKHRConstructor {
  readonly prototype: VkDeviceGroupSubmitInfoKHR;
  new(param?: VkDeviceGroupSubmitInfoKHRInitializer | null): VkDeviceGroupSubmitInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupSubmitInfoKHR: VkDeviceGroupSubmitInfoKHRConstructor;



  /**
   * Structure indicating which physical devices execute semaphore operations and command buffers
   */
interface VkDeviceGroupSubmitInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    waitSemaphoreCount: number;

    /**
     *
     */
    pWaitSemaphoreDeviceIndices: Uint32Array | null;

    /**
     *
     */
    commandBufferCount: number;

    /**
     *
     */
    pCommandBufferDeviceMasks: Uint32Array | null;

    /**
     *
     */
    signalSemaphoreCount: number;

    /**
     *
     */
    pSignalSemaphoreDeviceIndices: Uint32Array | null;

}

declare interface VkDeviceGroupSubmitInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    waitSemaphoreCount?: number;

    /**
     *
     */
    pWaitSemaphoreDeviceIndices?: Uint32Array | null;

    /**
     *
     */
    commandBufferCount?: number;

    /**
     *
     */
    pCommandBufferDeviceMasks?: Uint32Array | null;

    /**
     *
     */
    signalSemaphoreCount?: number;

    /**
     *
     */
    pSignalSemaphoreDeviceIndices?: Uint32Array | null;
}

declare interface VkDeviceGroupSubmitInfoConstructor {
  readonly prototype: VkDeviceGroupSubmitInfo;
  new(param?: VkDeviceGroupSubmitInfoInitializer | null): VkDeviceGroupSubmitInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupSubmitInfo: VkDeviceGroupSubmitInfoConstructor;



  /**
   * 
   */
interface VkDeviceGroupCommandBufferBeginInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    deviceMask: number;

}

declare interface VkDeviceGroupCommandBufferBeginInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    deviceMask?: number;
}

declare interface VkDeviceGroupCommandBufferBeginInfoKHRConstructor {
  readonly prototype: VkDeviceGroupCommandBufferBeginInfoKHR;
  new(param?: VkDeviceGroupCommandBufferBeginInfoKHRInitializer | null): VkDeviceGroupCommandBufferBeginInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupCommandBufferBeginInfoKHR: VkDeviceGroupCommandBufferBeginInfoKHRConstructor;



  /**
   * Set the initial device mask for a command buffer
   */
interface VkDeviceGroupCommandBufferBeginInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    deviceMask: number;

}

declare interface VkDeviceGroupCommandBufferBeginInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    deviceMask?: number;
}

declare interface VkDeviceGroupCommandBufferBeginInfoConstructor {
  readonly prototype: VkDeviceGroupCommandBufferBeginInfo;
  new(param?: VkDeviceGroupCommandBufferBeginInfoInitializer | null): VkDeviceGroupCommandBufferBeginInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupCommandBufferBeginInfo: VkDeviceGroupCommandBufferBeginInfoConstructor;



  /**
   * 
   */
interface VkDeviceGroupRenderPassBeginInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    deviceMask: number;

    /**
     *
     */
    deviceRenderAreaCount: number;

    /**
     *
     */
    pDeviceRenderAreas: VkRect2D[] | null;

}

declare interface VkDeviceGroupRenderPassBeginInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    deviceMask?: number;

    /**
     *
     */
    deviceRenderAreaCount?: number;

    /**
     *
     */
    pDeviceRenderAreas?: VkRect2D[] | null;
}

declare interface VkDeviceGroupRenderPassBeginInfoKHRConstructor {
  readonly prototype: VkDeviceGroupRenderPassBeginInfoKHR;
  new(param?: VkDeviceGroupRenderPassBeginInfoKHRInitializer | null): VkDeviceGroupRenderPassBeginInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupRenderPassBeginInfoKHR: VkDeviceGroupRenderPassBeginInfoKHRConstructor;



  /**
   * Set the initial device mask and render areas for a render pass instance
   */
interface VkDeviceGroupRenderPassBeginInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    deviceMask: number;

    /**
     *
     */
    deviceRenderAreaCount: number;

    /**
     *
     */
    pDeviceRenderAreas: VkRect2D[] | null;

}

declare interface VkDeviceGroupRenderPassBeginInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    deviceMask?: number;

    /**
     *
     */
    deviceRenderAreaCount?: number;

    /**
     *
     */
    pDeviceRenderAreas?: VkRect2D[] | null;
}

declare interface VkDeviceGroupRenderPassBeginInfoConstructor {
  readonly prototype: VkDeviceGroupRenderPassBeginInfo;
  new(param?: VkDeviceGroupRenderPassBeginInfoInitializer | null): VkDeviceGroupRenderPassBeginInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceGroupRenderPassBeginInfo: VkDeviceGroupRenderPassBeginInfoConstructor;



  /**
   * 
   */
interface VkBindImageMemoryDeviceGroupInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    deviceIndexCount: number;

    /**
     *
     */
    pDeviceIndices: Uint32Array | null;

    /**
     *
     */
    splitInstanceBindRegionCount: number;

    /**
     *
     */
    pSplitInstanceBindRegions: VkRect2D[] | null;

}

declare interface VkBindImageMemoryDeviceGroupInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    deviceIndexCount?: number;

    /**
     *
     */
    pDeviceIndices?: Uint32Array | null;

    /**
     *
     */
    splitInstanceBindRegionCount?: number;

    /**
     *
     */
    pSplitInstanceBindRegions?: VkRect2D[] | null;
}

declare interface VkBindImageMemoryDeviceGroupInfoKHRConstructor {
  readonly prototype: VkBindImageMemoryDeviceGroupInfoKHR;
  new(param?: VkBindImageMemoryDeviceGroupInfoKHRInitializer | null): VkBindImageMemoryDeviceGroupInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindImageMemoryDeviceGroupInfoKHR: VkBindImageMemoryDeviceGroupInfoKHRConstructor;



  /**
   * Structure specifying device within a group to bind to
   */
interface VkBindImageMemoryDeviceGroupInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    deviceIndexCount: number;

    /**
     *
     */
    pDeviceIndices: Uint32Array | null;

    /**
     *
     */
    splitInstanceBindRegionCount: number;

    /**
     *
     */
    pSplitInstanceBindRegions: VkRect2D[] | null;

}

declare interface VkBindImageMemoryDeviceGroupInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    deviceIndexCount?: number;

    /**
     *
     */
    pDeviceIndices?: Uint32Array | null;

    /**
     *
     */
    splitInstanceBindRegionCount?: number;

    /**
     *
     */
    pSplitInstanceBindRegions?: VkRect2D[] | null;
}

declare interface VkBindImageMemoryDeviceGroupInfoConstructor {
  readonly prototype: VkBindImageMemoryDeviceGroupInfo;
  new(param?: VkBindImageMemoryDeviceGroupInfoInitializer | null): VkBindImageMemoryDeviceGroupInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindImageMemoryDeviceGroupInfo: VkBindImageMemoryDeviceGroupInfoConstructor;



  /**
   * 
   */
interface VkBindImageMemoryInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    image: VkImage | null;

    /**
     *
     */
    memory: VkDeviceMemory | null;

    /**
     *
     */
    memoryOffset: bigint | number;

}

declare interface VkBindImageMemoryInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    image?: VkImage | null;

    /**
     *
     */
    memory?: VkDeviceMemory | null;

    /**
     *
     */
    memoryOffset?: bigint | number;
}

declare interface VkBindImageMemoryInfoKHRConstructor {
  readonly prototype: VkBindImageMemoryInfoKHR;
  new(param?: VkBindImageMemoryInfoKHRInitializer | null): VkBindImageMemoryInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindImageMemoryInfoKHR: VkBindImageMemoryInfoKHRConstructor;



  /**
   * Structure specifying how to bind an image to memory
   */
interface VkBindImageMemoryInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    image: VkImage | null;

    /**
     *
     */
    memory: VkDeviceMemory | null;

    /**
     *
     */
    memoryOffset: bigint | number;

}

declare interface VkBindImageMemoryInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    image?: VkImage | null;

    /**
     *
     */
    memory?: VkDeviceMemory | null;

    /**
     *
     */
    memoryOffset?: bigint | number;
}

declare interface VkBindImageMemoryInfoConstructor {
  readonly prototype: VkBindImageMemoryInfo;
  new(param?: VkBindImageMemoryInfoInitializer | null): VkBindImageMemoryInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindImageMemoryInfo: VkBindImageMemoryInfoConstructor;



  /**
   * 
   */
interface VkBindBufferMemoryDeviceGroupInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    deviceIndexCount: number;

    /**
     *
     */
    pDeviceIndices: Uint32Array | null;

}

declare interface VkBindBufferMemoryDeviceGroupInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    deviceIndexCount?: number;

    /**
     *
     */
    pDeviceIndices?: Uint32Array | null;
}

declare interface VkBindBufferMemoryDeviceGroupInfoKHRConstructor {
  readonly prototype: VkBindBufferMemoryDeviceGroupInfoKHR;
  new(param?: VkBindBufferMemoryDeviceGroupInfoKHRInitializer | null): VkBindBufferMemoryDeviceGroupInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindBufferMemoryDeviceGroupInfoKHR: VkBindBufferMemoryDeviceGroupInfoKHRConstructor;



  /**
   * Structure specifying device within a group to bind to
   */
interface VkBindBufferMemoryDeviceGroupInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    deviceIndexCount: number;

    /**
     *
     */
    pDeviceIndices: Uint32Array | null;

}

declare interface VkBindBufferMemoryDeviceGroupInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    deviceIndexCount?: number;

    /**
     *
     */
    pDeviceIndices?: Uint32Array | null;
}

declare interface VkBindBufferMemoryDeviceGroupInfoConstructor {
  readonly prototype: VkBindBufferMemoryDeviceGroupInfo;
  new(param?: VkBindBufferMemoryDeviceGroupInfoInitializer | null): VkBindBufferMemoryDeviceGroupInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindBufferMemoryDeviceGroupInfo: VkBindBufferMemoryDeviceGroupInfoConstructor;



  /**
   * 
   */
interface VkBindBufferMemoryInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    buffer: VkBuffer | null;

    /**
     *
     */
    memory: VkDeviceMemory | null;

    /**
     *
     */
    memoryOffset: bigint | number;

}

declare interface VkBindBufferMemoryInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    buffer?: VkBuffer | null;

    /**
     *
     */
    memory?: VkDeviceMemory | null;

    /**
     *
     */
    memoryOffset?: bigint | number;
}

declare interface VkBindBufferMemoryInfoKHRConstructor {
  readonly prototype: VkBindBufferMemoryInfoKHR;
  new(param?: VkBindBufferMemoryInfoKHRInitializer | null): VkBindBufferMemoryInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindBufferMemoryInfoKHR: VkBindBufferMemoryInfoKHRConstructor;



  /**
   * Structure specifying how to bind a buffer to memory
   */
interface VkBindBufferMemoryInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    buffer: VkBuffer | null;

    /**
     *
     */
    memory: VkDeviceMemory | null;

    /**
     *
     */
    memoryOffset: bigint | number;

}

declare interface VkBindBufferMemoryInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    buffer?: VkBuffer | null;

    /**
     *
     */
    memory?: VkDeviceMemory | null;

    /**
     *
     */
    memoryOffset?: bigint | number;
}

declare interface VkBindBufferMemoryInfoConstructor {
  readonly prototype: VkBindBufferMemoryInfo;
  new(param?: VkBindBufferMemoryInfoInitializer | null): VkBindBufferMemoryInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindBufferMemoryInfo: VkBindBufferMemoryInfoConstructor;



  /**
   * 
   */
interface VkMemoryAllocateFlagsInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkMemoryAllocateFlagBits;

    /**
     *
     */
    deviceMask: number;

}

declare interface VkMemoryAllocateFlagsInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkMemoryAllocateFlagBits;

    /**
     *
     */
    deviceMask?: number;
}

declare interface VkMemoryAllocateFlagsInfoKHRConstructor {
  readonly prototype: VkMemoryAllocateFlagsInfoKHR;
  new(param?: VkMemoryAllocateFlagsInfoKHRInitializer | null): VkMemoryAllocateFlagsInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryAllocateFlagsInfoKHR: VkMemoryAllocateFlagsInfoKHRConstructor;



  /**
   * Structure controlling how many instances of memory will be allocated
   */
interface VkMemoryAllocateFlagsInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkMemoryAllocateFlagBits;

    /**
     *
     */
    deviceMask: number;

}

declare interface VkMemoryAllocateFlagsInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkMemoryAllocateFlagBits;

    /**
     *
     */
    deviceMask?: number;
}

declare interface VkMemoryAllocateFlagsInfoConstructor {
  readonly prototype: VkMemoryAllocateFlagsInfo;
  new(param?: VkMemoryAllocateFlagsInfoInitializer | null): VkMemoryAllocateFlagsInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryAllocateFlagsInfo: VkMemoryAllocateFlagsInfoConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceGroupPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly physicalDeviceCount: number;

    /**
     *
     */
    readonly physicalDevices: VkPhysicalDevice[] | null;

    /**
     *
     */
    readonly subsetAllocation: boolean;

}

declare interface VkPhysicalDeviceGroupPropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly physicalDeviceCount?: number;

    /**
     *
     */
    readonly physicalDevices?: VkPhysicalDevice[] | null;

    /**
     *
     */
    readonly subsetAllocation?: boolean;
}

declare interface VkPhysicalDeviceGroupPropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceGroupPropertiesKHR;
  new(param?: VkPhysicalDeviceGroupPropertiesKHRInitializer | null): VkPhysicalDeviceGroupPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceGroupPropertiesKHR: VkPhysicalDeviceGroupPropertiesKHRConstructor;



  /**
   * Structure specifying physical device group properties
   */
interface VkPhysicalDeviceGroupProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly physicalDeviceCount: number;

    /**
     *
     */
    readonly physicalDevices: VkPhysicalDevice[] | null;

    /**
     *
     */
    readonly subsetAllocation: boolean;

}

declare interface VkPhysicalDeviceGroupPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly physicalDeviceCount?: number;

    /**
     *
     */
    readonly physicalDevices?: VkPhysicalDevice[] | null;

    /**
     *
     */
    readonly subsetAllocation?: boolean;
}

declare interface VkPhysicalDeviceGroupPropertiesConstructor {
  readonly prototype: VkPhysicalDeviceGroupProperties;
  new(param?: VkPhysicalDeviceGroupPropertiesInitializer | null): VkPhysicalDeviceGroupProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceGroupProperties: VkPhysicalDeviceGroupPropertiesConstructor;



  /**
   * Specify the surface counters desired
   */
interface VkSwapchainCounterCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkSurfaceCounterFlagBitsEXT' specifying surface counters to enable for the swapchain.
     */
    surfaceCounters: VkSurfaceCounterFlagBitsEXT;

}

declare interface VkSwapchainCounterCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkSurfaceCounterFlagBitsEXT' specifying surface counters to enable for the swapchain.
     */
    surfaceCounters?: VkSurfaceCounterFlagBitsEXT;
}

declare interface VkSwapchainCounterCreateInfoEXTConstructor {
  readonly prototype: VkSwapchainCounterCreateInfoEXT;
  new(param?: VkSwapchainCounterCreateInfoEXTInitializer | null): VkSwapchainCounterCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSwapchainCounterCreateInfoEXT: VkSwapchainCounterCreateInfoEXTConstructor;



  /**
   * Describe a display event to create
   */
interface VkDisplayEventInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkDisplayEventTypeEXT' specifying when the fence will be signaled.
     */
    displayEvent: VkDisplayEventTypeEXT;

}

declare interface VkDisplayEventInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkDisplayEventTypeEXT' specifying when the fence will be signaled.
     */
    displayEvent?: VkDisplayEventTypeEXT;
}

declare interface VkDisplayEventInfoEXTConstructor {
  readonly prototype: VkDisplayEventInfoEXT;
  new(param?: VkDisplayEventInfoEXTInitializer | null): VkDisplayEventInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayEventInfoEXT: VkDisplayEventInfoEXTConstructor;



  /**
   * Describe a device event to create
   */
interface VkDeviceEventInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     *
     */
    deviceEvent: VkDeviceEventTypeEXT;

}

declare interface VkDeviceEventInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     *
     */
    deviceEvent?: VkDeviceEventTypeEXT;
}

declare interface VkDeviceEventInfoEXTConstructor {
  readonly prototype: VkDeviceEventInfoEXT;
  new(param?: VkDeviceEventInfoEXTInitializer | null): VkDeviceEventInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceEventInfoEXT: VkDeviceEventInfoEXTConstructor;



  /**
   * Describe the power state of a display
   */
interface VkDisplayPowerInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkDisplayPowerStateEXT' value specifying the new power state of the display.
     */
    powerState: VkDisplayPowerStateEXT;

}

declare interface VkDisplayPowerInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkDisplayPowerStateEXT' value specifying the new power state of the display.
     */
    powerState?: VkDisplayPowerStateEXT;
}

declare interface VkDisplayPowerInfoEXTConstructor {
  readonly prototype: VkDisplayPowerInfoEXT;
  new(param?: VkDisplayPowerInfoEXTInitializer | null): VkDisplayPowerInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayPowerInfoEXT: VkDisplayPowerInfoEXTConstructor;



  /**
   * Structure describing capabilities of a surface
   */
interface VkSurfaceCapabilities2EXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     *
     */
    readonly minImageCount: number;

    /**
     *
     */
    readonly maxImageCount: number;

    /**
     *
     */
    readonly currentExtent: VkExtent2D | null;

    /**
     *
     */
    readonly minImageExtent: VkExtent2D | null;

    /**
     *
     */
    readonly maxImageExtent: VkExtent2D | null;

    /**
     *
     */
    readonly maxImageArrayLayers: number;

    /**
     *
     */
    readonly supportedTransforms: VkSurfaceTransformFlagBitsKHR;

    /**
     *
     */
    readonly currentTransform: VkSurfaceTransformFlagBitsKHR;

    /**
     *
     */
    readonly supportedCompositeAlpha: VkCompositeAlphaFlagBitsKHR;

    /**
     *
     */
    readonly supportedUsageFlags: VkImageUsageFlagBits;

    /**
     * is a bitmask of 'VkSurfaceCounterFlagBitsEXT' indicating the supported surface counter types.
     */
    readonly supportedSurfaceCounters: VkSurfaceCounterFlagBitsEXT;

}

declare interface VkSurfaceCapabilities2EXTInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly minImageCount?: number;

    /**
     *
     */
    readonly maxImageCount?: number;

    /**
     *
     */
    readonly currentExtent?: VkExtent2D | null;

    /**
     *
     */
    readonly minImageExtent?: VkExtent2D | null;

    /**
     *
     */
    readonly maxImageExtent?: VkExtent2D | null;

    /**
     *
     */
    readonly maxImageArrayLayers?: number;

    /**
     *
     */
    readonly supportedTransforms?: VkSurfaceTransformFlagBitsKHR;

    /**
     *
     */
    readonly currentTransform?: VkSurfaceTransformFlagBitsKHR;

    /**
     *
     */
    readonly supportedCompositeAlpha?: VkCompositeAlphaFlagBitsKHR;

    /**
     *
     */
    readonly supportedUsageFlags?: VkImageUsageFlagBits;

    /**
     * is a bitmask of 'VkSurfaceCounterFlagBitsEXT' indicating the supported surface counter types.
     */
    readonly supportedSurfaceCounters?: VkSurfaceCounterFlagBitsEXT;
}

declare interface VkSurfaceCapabilities2EXTConstructor {
  readonly prototype: VkSurfaceCapabilities2EXT;
  new(param?: VkSurfaceCapabilities2EXTInitializer | null): VkSurfaceCapabilities2EXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSurfaceCapabilities2EXT: VkSurfaceCapabilities2EXTConstructor;



  /**
   * 
   */
interface VkRenderPassMultiviewCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    subpassCount: number;

    /**
     *
     */
    pViewMasks: Uint32Array | null;

    /**
     *
     */
    dependencyCount: number;

    /**
     *
     */
    pViewOffsets: Int32Array | null;

    /**
     *
     */
    correlationMaskCount: number;

    /**
     *
     */
    pCorrelationMasks: Uint32Array | null;

}

declare interface VkRenderPassMultiviewCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    subpassCount?: number;

    /**
     *
     */
    pViewMasks?: Uint32Array | null;

    /**
     *
     */
    dependencyCount?: number;

    /**
     *
     */
    pViewOffsets?: Int32Array | null;

    /**
     *
     */
    correlationMaskCount?: number;

    /**
     *
     */
    pCorrelationMasks?: Uint32Array | null;
}

declare interface VkRenderPassMultiviewCreateInfoKHRConstructor {
  readonly prototype: VkRenderPassMultiviewCreateInfoKHR;
  new(param?: VkRenderPassMultiviewCreateInfoKHRInitializer | null): VkRenderPassMultiviewCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassMultiviewCreateInfoKHR: VkRenderPassMultiviewCreateInfoKHRConstructor;



  /**
   * Structure containing multiview info for all subpasses
   */
interface VkRenderPassMultiviewCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    subpassCount: number;

    /**
     *
     */
    pViewMasks: Uint32Array | null;

    /**
     *
     */
    dependencyCount: number;

    /**
     *
     */
    pViewOffsets: Int32Array | null;

    /**
     *
     */
    correlationMaskCount: number;

    /**
     *
     */
    pCorrelationMasks: Uint32Array | null;

}

declare interface VkRenderPassMultiviewCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    subpassCount?: number;

    /**
     *
     */
    pViewMasks?: Uint32Array | null;

    /**
     *
     */
    dependencyCount?: number;

    /**
     *
     */
    pViewOffsets?: Int32Array | null;

    /**
     *
     */
    correlationMaskCount?: number;

    /**
     *
     */
    pCorrelationMasks?: Uint32Array | null;
}

declare interface VkRenderPassMultiviewCreateInfoConstructor {
  readonly prototype: VkRenderPassMultiviewCreateInfo;
  new(param?: VkRenderPassMultiviewCreateInfoInitializer | null): VkRenderPassMultiviewCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassMultiviewCreateInfo: VkRenderPassMultiviewCreateInfoConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceMultiviewPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxMultiviewViewCount: number;

    /**
     *
     */
    readonly maxMultiviewInstanceIndex: number;

}

declare interface VkPhysicalDeviceMultiviewPropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxMultiviewViewCount?: number;

    /**
     *
     */
    readonly maxMultiviewInstanceIndex?: number;
}

declare interface VkPhysicalDeviceMultiviewPropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceMultiviewPropertiesKHR;
  new(param?: VkPhysicalDeviceMultiviewPropertiesKHRInitializer | null): VkPhysicalDeviceMultiviewPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMultiviewPropertiesKHR: VkPhysicalDeviceMultiviewPropertiesKHRConstructor;



  /**
   * Structure describing multiview limits that can be supported by an implementation
   */
interface VkPhysicalDeviceMultiviewProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly maxMultiviewViewCount: number;

    /**
     *
     */
    readonly maxMultiviewInstanceIndex: number;

}

declare interface VkPhysicalDeviceMultiviewPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly maxMultiviewViewCount?: number;

    /**
     *
     */
    readonly maxMultiviewInstanceIndex?: number;
}

declare interface VkPhysicalDeviceMultiviewPropertiesConstructor {
  readonly prototype: VkPhysicalDeviceMultiviewProperties;
  new(param?: VkPhysicalDeviceMultiviewPropertiesInitializer | null): VkPhysicalDeviceMultiviewProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMultiviewProperties: VkPhysicalDeviceMultiviewPropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceMultiviewFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    multiview: boolean;

    /**
     *
     */
    multiviewGeometryShader: boolean;

    /**
     *
     */
    multiviewTessellationShader: boolean;

}

declare interface VkPhysicalDeviceMultiviewFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    multiview?: boolean;

    /**
     *
     */
    multiviewGeometryShader?: boolean;

    /**
     *
     */
    multiviewTessellationShader?: boolean;
}

declare interface VkPhysicalDeviceMultiviewFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceMultiviewFeaturesKHR;
  new(param?: VkPhysicalDeviceMultiviewFeaturesKHRInitializer | null): VkPhysicalDeviceMultiviewFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMultiviewFeaturesKHR: VkPhysicalDeviceMultiviewFeaturesKHRConstructor;



  /**
   * Structure describing multiview features that can be supported by an implementation
   */
interface VkPhysicalDeviceMultiviewFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    multiview: boolean;

    /**
     *
     */
    multiviewGeometryShader: boolean;

    /**
     *
     */
    multiviewTessellationShader: boolean;

}

declare interface VkPhysicalDeviceMultiviewFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    multiview?: boolean;

    /**
     *
     */
    multiviewGeometryShader?: boolean;

    /**
     *
     */
    multiviewTessellationShader?: boolean;
}

declare interface VkPhysicalDeviceMultiviewFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceMultiviewFeatures;
  new(param?: VkPhysicalDeviceMultiviewFeaturesInitializer | null): VkPhysicalDeviceMultiviewFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMultiviewFeatures: VkPhysicalDeviceMultiviewFeaturesConstructor;



  /**
   * Structure describing a POSIX FD fence export operation
   */
interface VkFenceGetFdInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the fence from which state will be exported.
     */
    fence: VkFence | null;

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalFenceHandleTypeFlagBits;

}

declare interface VkFenceGetFdInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the fence from which state will be exported.
     */
    fence?: VkFence | null;

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalFenceHandleTypeFlagBits;
}

declare interface VkFenceGetFdInfoKHRConstructor {
  readonly prototype: VkFenceGetFdInfoKHR;
  new(param?: VkFenceGetFdInfoKHRInitializer | null): VkFenceGetFdInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFenceGetFdInfoKHR: VkFenceGetFdInfoKHRConstructor;



  /**
   * (None)
   */
interface VkImportFenceFdInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the fence into which the payload will be imported.
     */
    fence: VkFence | null;

    /**
     * is a bitmask of 'VkFenceImportFlagBits' specifying additional parameters for the fence payload import operation.
     */
    flags: VkFenceImportFlagBits;

    /**
     *
     */
    handleType: VkExternalFenceHandleTypeFlagBits;

    /**
     * is the external handle to import.
     */
    fd: number;

}

declare interface VkImportFenceFdInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the fence into which the payload will be imported.
     */
    fence?: VkFence | null;

    /**
     * is a bitmask of 'VkFenceImportFlagBits' specifying additional parameters for the fence payload import operation.
     */
    flags?: VkFenceImportFlagBits;

    /**
     *
     */
    handleType?: VkExternalFenceHandleTypeFlagBits;

    /**
     * is the external handle to import.
     */
    fd?: number;
}

declare interface VkImportFenceFdInfoKHRConstructor {
  readonly prototype: VkImportFenceFdInfoKHR;
  new(param?: VkImportFenceFdInfoKHRInitializer | null): VkImportFenceFdInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImportFenceFdInfoKHR: VkImportFenceFdInfoKHRConstructor;



  /**
   * Structure describing a Win32 handle fence export operation
   */
interface VkFenceGetWin32HandleInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the fence from which state will be exported.
     */
    fence: VkFence | null;

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalFenceHandleTypeFlagBits;

}

declare interface VkFenceGetWin32HandleInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the fence from which state will be exported.
     */
    fence?: VkFence | null;

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalFenceHandleTypeFlagBits;
}

declare interface VkFenceGetWin32HandleInfoKHRConstructor {
  readonly prototype: VkFenceGetWin32HandleInfoKHR;
  new(param?: VkFenceGetWin32HandleInfoKHRInitializer | null): VkFenceGetWin32HandleInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFenceGetWin32HandleInfoKHR: VkFenceGetWin32HandleInfoKHRConstructor;



  /**
   * Structure specifying additional attributes of Windows handles exported from a fence
   */
interface VkExportFenceWin32HandleInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes: bigint | number;

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess: number;

    /**
     * is a UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created fence.
     */
    name: string | null;

}

declare interface VkExportFenceWin32HandleInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes?: bigint | number;

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess?: number;

    /**
     * is a UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created fence.
     */
    name?: string | null;
}

declare interface VkExportFenceWin32HandleInfoKHRConstructor {
  readonly prototype: VkExportFenceWin32HandleInfoKHR;
  new(param?: VkExportFenceWin32HandleInfoKHRInitializer | null): VkExportFenceWin32HandleInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportFenceWin32HandleInfoKHR: VkExportFenceWin32HandleInfoKHRConstructor;



  /**
   * (None)
   */
interface VkImportFenceWin32HandleInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the fence into which the state will be imported.
     */
    fence: VkFence | null;

    /**
     * is a bitmask of 'VkFenceImportFlagBits' specifying additional parameters for the fence payload import operation.
     */
    flags: VkFenceImportFlagBits;

    /**
     *
     */
    handleType: VkExternalFenceHandleTypeFlagBits;

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle: bigint | number;

    /**
     * is a UTF-16 string naming the underlying synchronization primitive to import, or <i>null</i>.
     */
    name: string | null;

}

declare interface VkImportFenceWin32HandleInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the fence into which the state will be imported.
     */
    fence?: VkFence | null;

    /**
     * is a bitmask of 'VkFenceImportFlagBits' specifying additional parameters for the fence payload import operation.
     */
    flags?: VkFenceImportFlagBits;

    /**
     *
     */
    handleType?: VkExternalFenceHandleTypeFlagBits;

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle?: bigint | number;

    /**
     * is a UTF-16 string naming the underlying synchronization primitive to import, or <i>null</i>.
     */
    name?: string | null;
}

declare interface VkImportFenceWin32HandleInfoKHRConstructor {
  readonly prototype: VkImportFenceWin32HandleInfoKHR;
  new(param?: VkImportFenceWin32HandleInfoKHRInitializer | null): VkImportFenceWin32HandleInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImportFenceWin32HandleInfoKHR: VkImportFenceWin32HandleInfoKHRConstructor;



  /**
   * 
   */
interface VkExportFenceCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleTypes: VkExternalFenceHandleTypeFlagBits;

}

declare interface VkExportFenceCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleTypes?: VkExternalFenceHandleTypeFlagBits;
}

declare interface VkExportFenceCreateInfoKHRConstructor {
  readonly prototype: VkExportFenceCreateInfoKHR;
  new(param?: VkExportFenceCreateInfoKHRInitializer | null): VkExportFenceCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportFenceCreateInfoKHR: VkExportFenceCreateInfoKHRConstructor;



  /**
   * Structure specifying handle types that can be exported from a fence
   */
interface VkExportFenceCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleTypes: VkExternalFenceHandleTypeFlagBits;

}

declare interface VkExportFenceCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleTypes?: VkExternalFenceHandleTypeFlagBits;
}

declare interface VkExportFenceCreateInfoConstructor {
  readonly prototype: VkExportFenceCreateInfo;
  new(param?: VkExportFenceCreateInfoInitializer | null): VkExportFenceCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportFenceCreateInfo: VkExportFenceCreateInfoConstructor;



  /**
   * 
   */
interface VkExternalFencePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes: VkExternalFenceHandleTypeFlagBits;

    /**
     *
     */
    readonly externalFenceFeatures: VkExternalFenceFeatureFlagBits;

}

declare interface VkExternalFencePropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly exportFromImportedHandleTypes?: VkExternalFenceHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes?: VkExternalFenceHandleTypeFlagBits;

    /**
     *
     */
    readonly externalFenceFeatures?: VkExternalFenceFeatureFlagBits;
}

declare interface VkExternalFencePropertiesKHRConstructor {
  readonly prototype: VkExternalFencePropertiesKHR;
  new(param?: VkExternalFencePropertiesKHRInitializer | null): VkExternalFencePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalFencePropertiesKHR: VkExternalFencePropertiesKHRConstructor;



  /**
   * Structure describing supported external fence handle features
   */
interface VkExternalFenceProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes: VkExternalFenceHandleTypeFlagBits;

    /**
     *
     */
    readonly externalFenceFeatures: VkExternalFenceFeatureFlagBits;

}

declare interface VkExternalFencePropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly exportFromImportedHandleTypes?: VkExternalFenceHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes?: VkExternalFenceHandleTypeFlagBits;

    /**
     *
     */
    readonly externalFenceFeatures?: VkExternalFenceFeatureFlagBits;
}

declare interface VkExternalFencePropertiesConstructor {
  readonly prototype: VkExternalFenceProperties;
  new(param?: VkExternalFencePropertiesInitializer | null): VkExternalFenceProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalFenceProperties: VkExternalFencePropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceExternalFenceInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleType: VkExternalFenceHandleTypeFlagBits;

}

declare interface VkPhysicalDeviceExternalFenceInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleType?: VkExternalFenceHandleTypeFlagBits;
}

declare interface VkPhysicalDeviceExternalFenceInfoKHRConstructor {
  readonly prototype: VkPhysicalDeviceExternalFenceInfoKHR;
  new(param?: VkPhysicalDeviceExternalFenceInfoKHRInitializer | null): VkPhysicalDeviceExternalFenceInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExternalFenceInfoKHR: VkPhysicalDeviceExternalFenceInfoKHRConstructor;



  /**
   * Structure specifying fence creation parameters.
   */
interface VkPhysicalDeviceExternalFenceInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleType: VkExternalFenceHandleTypeFlagBits;

}

declare interface VkPhysicalDeviceExternalFenceInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleType?: VkExternalFenceHandleTypeFlagBits;
}

declare interface VkPhysicalDeviceExternalFenceInfoConstructor {
  readonly prototype: VkPhysicalDeviceExternalFenceInfo;
  new(param?: VkPhysicalDeviceExternalFenceInfoInitializer | null): VkPhysicalDeviceExternalFenceInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExternalFenceInfo: VkPhysicalDeviceExternalFenceInfoConstructor;



  /**
   * Structure describing a POSIX FD semaphore export operation
   */
interface VkSemaphoreGetFdInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the semaphore from which state will be exported.
     */
    semaphore: VkSemaphore | null;

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits;

}

declare interface VkSemaphoreGetFdInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the semaphore from which state will be exported.
     */
    semaphore?: VkSemaphore | null;

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits;
}

declare interface VkSemaphoreGetFdInfoKHRConstructor {
  readonly prototype: VkSemaphoreGetFdInfoKHR;
  new(param?: VkSemaphoreGetFdInfoKHRInitializer | null): VkSemaphoreGetFdInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSemaphoreGetFdInfoKHR: VkSemaphoreGetFdInfoKHRConstructor;



  /**
   * Structure specifying POSIX file descriptor to import to a semaphore
   */
interface VkImportSemaphoreFdInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the semaphore into which the payload will be imported.
     */
    semaphore: VkSemaphore | null;

    /**
     * is a bitmask of 'VkSemaphoreImportFlagBits' specifying additional parameters for the semaphore payload import operation.
     */
    flags: VkSemaphoreImportFlagBits;

    /**
     *
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     * is the external handle to import.
     */
    fd: number;

}

declare interface VkImportSemaphoreFdInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the semaphore into which the payload will be imported.
     */
    semaphore?: VkSemaphore | null;

    /**
     * is a bitmask of 'VkSemaphoreImportFlagBits' specifying additional parameters for the semaphore payload import operation.
     */
    flags?: VkSemaphoreImportFlagBits;

    /**
     *
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     * is the external handle to import.
     */
    fd?: number;
}

declare interface VkImportSemaphoreFdInfoKHRConstructor {
  readonly prototype: VkImportSemaphoreFdInfoKHR;
  new(param?: VkImportSemaphoreFdInfoKHRInitializer | null): VkImportSemaphoreFdInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImportSemaphoreFdInfoKHR: VkImportSemaphoreFdInfoKHRConstructor;



  /**
   * Structure describing a Win32 handle semaphore export operation
   */
interface VkSemaphoreGetWin32HandleInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the semaphore from which state will be exported.
     */
    semaphore: VkSemaphore | null;

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits;

}

declare interface VkSemaphoreGetWin32HandleInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the semaphore from which state will be exported.
     */
    semaphore?: VkSemaphore | null;

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits;
}

declare interface VkSemaphoreGetWin32HandleInfoKHRConstructor {
  readonly prototype: VkSemaphoreGetWin32HandleInfoKHR;
  new(param?: VkSemaphoreGetWin32HandleInfoKHRInitializer | null): VkSemaphoreGetWin32HandleInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSemaphoreGetWin32HandleInfoKHR: VkSemaphoreGetWin32HandleInfoKHRConstructor;



  /**
   * Structure specifying values for Direct3D 12 fence-backed semaphores
   */
interface VkD3D12FenceSubmitInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of semaphore wait values specified in 'pWaitSemaphoreValues'.
     */
    waitSemaphoreValuesCount: number;

    /**
     * is an array of 'waitSemaphoreValuesCount' values for the corresponding semaphores in 'VkSubmitInfo'::'pWaitSemaphores' to wait for.
     */
    pWaitSemaphoreValues: BigUint64Array | null;

    /**
     * is the number of semaphore signal values specified in 'pSignalSemaphoreValues'.
     */
    signalSemaphoreValuesCount: number;

    /**
     * is an array of 'signalSemaphoreValuesCount' values for the corresponding semaphores in 'VkSubmitInfo'::'pSignalSemaphores' to set when signaled.
     */
    pSignalSemaphoreValues: BigUint64Array | null;

}

declare interface VkD3D12FenceSubmitInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of semaphore wait values specified in 'pWaitSemaphoreValues'.
     */
    waitSemaphoreValuesCount?: number;

    /**
     * is an array of 'waitSemaphoreValuesCount' values for the corresponding semaphores in 'VkSubmitInfo'::'pWaitSemaphores' to wait for.
     */
    pWaitSemaphoreValues?: BigUint64Array | null;

    /**
     * is the number of semaphore signal values specified in 'pSignalSemaphoreValues'.
     */
    signalSemaphoreValuesCount?: number;

    /**
     * is an array of 'signalSemaphoreValuesCount' values for the corresponding semaphores in 'VkSubmitInfo'::'pSignalSemaphores' to set when signaled.
     */
    pSignalSemaphoreValues?: BigUint64Array | null;
}

declare interface VkD3D12FenceSubmitInfoKHRConstructor {
  readonly prototype: VkD3D12FenceSubmitInfoKHR;
  new(param?: VkD3D12FenceSubmitInfoKHRInitializer | null): VkD3D12FenceSubmitInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkD3D12FenceSubmitInfoKHR: VkD3D12FenceSubmitInfoKHRConstructor;



  /**
   * Structure specifying additional attributes of Windows handles exported from a semaphore
   */
interface VkExportSemaphoreWin32HandleInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes: bigint | number;

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess: number;

    /**
     * is a UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created semaphore.
     */
    name: string | null;

}

declare interface VkExportSemaphoreWin32HandleInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes?: bigint | number;

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess?: number;

    /**
     * is a UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created semaphore.
     */
    name?: string | null;
}

declare interface VkExportSemaphoreWin32HandleInfoKHRConstructor {
  readonly prototype: VkExportSemaphoreWin32HandleInfoKHR;
  new(param?: VkExportSemaphoreWin32HandleInfoKHRInitializer | null): VkExportSemaphoreWin32HandleInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportSemaphoreWin32HandleInfoKHR: VkExportSemaphoreWin32HandleInfoKHRConstructor;



  /**
   * Structure specifying Windows handle to import to a semaphore
   */
interface VkImportSemaphoreWin32HandleInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the semaphore into which the payload will be imported.
     */
    semaphore: VkSemaphore | null;

    /**
     * is a bitmask of 'VkSemaphoreImportFlagBits' specifying additional parameters for the semaphore payload import operation.
     */
    flags: VkSemaphoreImportFlagBits;

    /**
     *
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle: bigint | number;

    /**
     * is a UTF-16 string naming the underlying synchronization primitive to import, or <i>null</i>.
     */
    name: string | null;

}

declare interface VkImportSemaphoreWin32HandleInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the semaphore into which the payload will be imported.
     */
    semaphore?: VkSemaphore | null;

    /**
     * is a bitmask of 'VkSemaphoreImportFlagBits' specifying additional parameters for the semaphore payload import operation.
     */
    flags?: VkSemaphoreImportFlagBits;

    /**
     *
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle?: bigint | number;

    /**
     * is a UTF-16 string naming the underlying synchronization primitive to import, or <i>null</i>.
     */
    name?: string | null;
}

declare interface VkImportSemaphoreWin32HandleInfoKHRConstructor {
  readonly prototype: VkImportSemaphoreWin32HandleInfoKHR;
  new(param?: VkImportSemaphoreWin32HandleInfoKHRInitializer | null): VkImportSemaphoreWin32HandleInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImportSemaphoreWin32HandleInfoKHR: VkImportSemaphoreWin32HandleInfoKHRConstructor;



  /**
   * 
   */
interface VkExportSemaphoreCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleTypes: VkExternalSemaphoreHandleTypeFlagBits;

}

declare interface VkExportSemaphoreCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleTypes?: VkExternalSemaphoreHandleTypeFlagBits;
}

declare interface VkExportSemaphoreCreateInfoKHRConstructor {
  readonly prototype: VkExportSemaphoreCreateInfoKHR;
  new(param?: VkExportSemaphoreCreateInfoKHRInitializer | null): VkExportSemaphoreCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportSemaphoreCreateInfoKHR: VkExportSemaphoreCreateInfoKHRConstructor;



  /**
   * Structure specifying handle types that can be exported from a semaphore
   */
interface VkExportSemaphoreCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleTypes: VkExternalSemaphoreHandleTypeFlagBits;

}

declare interface VkExportSemaphoreCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleTypes?: VkExternalSemaphoreHandleTypeFlagBits;
}

declare interface VkExportSemaphoreCreateInfoConstructor {
  readonly prototype: VkExportSemaphoreCreateInfo;
  new(param?: VkExportSemaphoreCreateInfoInitializer | null): VkExportSemaphoreCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportSemaphoreCreateInfo: VkExportSemaphoreCreateInfoConstructor;



  /**
   * 
   */
interface VkExternalSemaphorePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     *
     */
    readonly externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlagBits;

}

declare interface VkExternalSemaphorePropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly exportFromImportedHandleTypes?: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes?: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     *
     */
    readonly externalSemaphoreFeatures?: VkExternalSemaphoreFeatureFlagBits;
}

declare interface VkExternalSemaphorePropertiesKHRConstructor {
  readonly prototype: VkExternalSemaphorePropertiesKHR;
  new(param?: VkExternalSemaphorePropertiesKHRInitializer | null): VkExternalSemaphorePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalSemaphorePropertiesKHR: VkExternalSemaphorePropertiesKHRConstructor;



  /**
   * Structure describing supported external semaphore handle features
   */
interface VkExternalSemaphoreProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     *
     */
    readonly externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlagBits;

}

declare interface VkExternalSemaphorePropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly exportFromImportedHandleTypes?: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes?: VkExternalSemaphoreHandleTypeFlagBits;

    /**
     *
     */
    readonly externalSemaphoreFeatures?: VkExternalSemaphoreFeatureFlagBits;
}

declare interface VkExternalSemaphorePropertiesConstructor {
  readonly prototype: VkExternalSemaphoreProperties;
  new(param?: VkExternalSemaphorePropertiesInitializer | null): VkExternalSemaphoreProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalSemaphoreProperties: VkExternalSemaphorePropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceExternalSemaphoreInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits;

}

declare interface VkPhysicalDeviceExternalSemaphoreInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits;
}

declare interface VkPhysicalDeviceExternalSemaphoreInfoKHRConstructor {
  readonly prototype: VkPhysicalDeviceExternalSemaphoreInfoKHR;
  new(param?: VkPhysicalDeviceExternalSemaphoreInfoKHRInitializer | null): VkPhysicalDeviceExternalSemaphoreInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExternalSemaphoreInfoKHR: VkPhysicalDeviceExternalSemaphoreInfoKHRConstructor;



  /**
   * Structure specifying semaphore creation parameters.
   */
interface VkPhysicalDeviceExternalSemaphoreInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleType: VkExternalSemaphoreHandleTypeFlagBits;

}

declare interface VkPhysicalDeviceExternalSemaphoreInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleType?: VkExternalSemaphoreHandleTypeFlagBits;
}

declare interface VkPhysicalDeviceExternalSemaphoreInfoConstructor {
  readonly prototype: VkPhysicalDeviceExternalSemaphoreInfo;
  new(param?: VkPhysicalDeviceExternalSemaphoreInfoInitializer | null): VkPhysicalDeviceExternalSemaphoreInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExternalSemaphoreInfo: VkPhysicalDeviceExternalSemaphoreInfoConstructor;



  /**
   * Use the Windows keyed mutex mechanism to synchronize work
   */
interface VkWin32KeyedMutexAcquireReleaseInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    acquireCount: number;

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pAcquireSyncs: VkDeviceMemory[] | null;

    /**
     * is an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in 'pAcquireSyncs'.
     */
    pAcquireKeys: BigUint64Array | null;

    /**
     *
     */
    pAcquireTimeouts: Uint32Array | null;

    /**
     *
     */
    releaseCount: number;

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pReleaseSyncs: VkDeviceMemory[] | null;

    /**
     * is an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in 'pReleaseSyncs'.
     */
    pReleaseKeys: BigUint64Array | null;

}

declare interface VkWin32KeyedMutexAcquireReleaseInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    acquireCount?: number;

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pAcquireSyncs?: VkDeviceMemory[] | null;

    /**
     * is an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in 'pAcquireSyncs'.
     */
    pAcquireKeys?: BigUint64Array | null;

    /**
     *
     */
    pAcquireTimeouts?: Uint32Array | null;

    /**
     *
     */
    releaseCount?: number;

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pReleaseSyncs?: VkDeviceMemory[] | null;

    /**
     * is an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in 'pReleaseSyncs'.
     */
    pReleaseKeys?: BigUint64Array | null;
}

declare interface VkWin32KeyedMutexAcquireReleaseInfoKHRConstructor {
  readonly prototype: VkWin32KeyedMutexAcquireReleaseInfoKHR;
  new(param?: VkWin32KeyedMutexAcquireReleaseInfoKHRInitializer | null): VkWin32KeyedMutexAcquireReleaseInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkWin32KeyedMutexAcquireReleaseInfoKHR: VkWin32KeyedMutexAcquireReleaseInfoKHRConstructor;



  /**
   * Structure describing a POSIX FD semaphore export operation
   */
interface VkMemoryGetFdInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the memory object from which the handle will be exported.
     */
    memory: VkDeviceMemory | null;

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkMemoryGetFdInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the memory object from which the handle will be exported.
     */
    memory?: VkDeviceMemory | null;

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkMemoryGetFdInfoKHRConstructor {
  readonly prototype: VkMemoryGetFdInfoKHR;
  new(param?: VkMemoryGetFdInfoKHRInitializer | null): VkMemoryGetFdInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryGetFdInfoKHR: VkMemoryGetFdInfoKHRConstructor;



  /**
   * Properties of External Memory File Descriptors
   */
interface VkMemoryFdPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a bitmask containing one bit set for every memory type which the specified file descriptor 'can' be imported as.
     */
    readonly memoryTypeBits: number;

}

declare interface VkMemoryFdPropertiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a bitmask containing one bit set for every memory type which the specified file descriptor 'can' be imported as.
     */
    readonly memoryTypeBits?: number;
}

declare interface VkMemoryFdPropertiesKHRConstructor {
  readonly prototype: VkMemoryFdPropertiesKHR;
  new(param?: VkMemoryFdPropertiesKHRInitializer | null): VkMemoryFdPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryFdPropertiesKHR: VkMemoryFdPropertiesKHRConstructor;



  /**
   * import memory created on the same physical device from a file descriptor
   */
interface VkImportMemoryFdInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits;

    /**
     * is the external handle to import.
     */
    fd: number;

}

declare interface VkImportMemoryFdInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits;

    /**
     * is the external handle to import.
     */
    fd?: number;
}

declare interface VkImportMemoryFdInfoKHRConstructor {
  readonly prototype: VkImportMemoryFdInfoKHR;
  new(param?: VkImportMemoryFdInfoKHRInitializer | null): VkImportMemoryFdInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImportMemoryFdInfoKHR: VkImportMemoryFdInfoKHRConstructor;



  /**
   * Structure describing a Win32 handle semaphore export operation
   */
interface VkMemoryGetWin32HandleInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the memory object from which the handle will be exported.
     */
    memory: VkDeviceMemory | null;

    /**
     * is the type of handle requested.
     */
    handleType: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkMemoryGetWin32HandleInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the memory object from which the handle will be exported.
     */
    memory?: VkDeviceMemory | null;

    /**
     * is the type of handle requested.
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkMemoryGetWin32HandleInfoKHRConstructor {
  readonly prototype: VkMemoryGetWin32HandleInfoKHR;
  new(param?: VkMemoryGetWin32HandleInfoKHRInitializer | null): VkMemoryGetWin32HandleInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryGetWin32HandleInfoKHR: VkMemoryGetWin32HandleInfoKHRConstructor;



  /**
   * Properties of External Memory Windows Handles
   */
interface VkMemoryWin32HandlePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is a bitmask containing one bit set for every memory type which the specified windows handle 'can' be imported as.
     */
    readonly memoryTypeBits: number;

}

declare interface VkMemoryWin32HandlePropertiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is a bitmask containing one bit set for every memory type which the specified windows handle 'can' be imported as.
     */
    readonly memoryTypeBits?: number;
}

declare interface VkMemoryWin32HandlePropertiesKHRConstructor {
  readonly prototype: VkMemoryWin32HandlePropertiesKHR;
  new(param?: VkMemoryWin32HandlePropertiesKHRInitializer | null): VkMemoryWin32HandlePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryWin32HandlePropertiesKHR: VkMemoryWin32HandlePropertiesKHRConstructor;



  /**
   * Structure specifying additional attributes of Windows handles exported from a memory
   */
interface VkExportMemoryWin32HandleInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes: bigint | number;

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess: number;

    /**
     * is a UTF-16 string to associate with the payload referenced by NT handles exported from the created memory.
     */
    name: string | null;

}

declare interface VkExportMemoryWin32HandleInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes?: bigint | number;

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess?: number;

    /**
     * is a UTF-16 string to associate with the payload referenced by NT handles exported from the created memory.
     */
    name?: string | null;
}

declare interface VkExportMemoryWin32HandleInfoKHRConstructor {
  readonly prototype: VkExportMemoryWin32HandleInfoKHR;
  new(param?: VkExportMemoryWin32HandleInfoKHRInitializer | null): VkExportMemoryWin32HandleInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportMemoryWin32HandleInfoKHR: VkExportMemoryWin32HandleInfoKHRConstructor;



  /**
   * import Win32 memory created on the same physical device
   */
interface VkImportMemoryWin32HandleInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits;

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle: bigint | number;

    /**
     * is a UTF-16 string naming the payload to import, or <i>null</i>.
     */
    name: string | null;

}

declare interface VkImportMemoryWin32HandleInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits;

    /**
     * is the external handle to import, or <i>null</i>.
     */
    handle?: bigint | number;

    /**
     * is a UTF-16 string naming the payload to import, or <i>null</i>.
     */
    name?: string | null;
}

declare interface VkImportMemoryWin32HandleInfoKHRConstructor {
  readonly prototype: VkImportMemoryWin32HandleInfoKHR;
  new(param?: VkImportMemoryWin32HandleInfoKHRInitializer | null): VkImportMemoryWin32HandleInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImportMemoryWin32HandleInfoKHR: VkImportMemoryWin32HandleInfoKHRConstructor;



  /**
   * 
   */
interface VkExportMemoryAllocateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkExportMemoryAllocateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkExportMemoryAllocateInfoKHRConstructor {
  readonly prototype: VkExportMemoryAllocateInfoKHR;
  new(param?: VkExportMemoryAllocateInfoKHRInitializer | null): VkExportMemoryAllocateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportMemoryAllocateInfoKHR: VkExportMemoryAllocateInfoKHRConstructor;



  /**
   * Specify exportable handle types for a device memory object
   */
interface VkExportMemoryAllocateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkExportMemoryAllocateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkExportMemoryAllocateInfoConstructor {
  readonly prototype: VkExportMemoryAllocateInfo;
  new(param?: VkExportMemoryAllocateInfoInitializer | null): VkExportMemoryAllocateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportMemoryAllocateInfo: VkExportMemoryAllocateInfoConstructor;



  /**
   * 
   */
interface VkExternalMemoryBufferCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkExternalMemoryBufferCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkExternalMemoryBufferCreateInfoKHRConstructor {
  readonly prototype: VkExternalMemoryBufferCreateInfoKHR;
  new(param?: VkExternalMemoryBufferCreateInfoKHRInitializer | null): VkExternalMemoryBufferCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalMemoryBufferCreateInfoKHR: VkExternalMemoryBufferCreateInfoKHRConstructor;



  /**
   * Specify that a buffer may be backed by external memory
   */
interface VkExternalMemoryBufferCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkExternalMemoryBufferCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkExternalMemoryBufferCreateInfoConstructor {
  readonly prototype: VkExternalMemoryBufferCreateInfo;
  new(param?: VkExternalMemoryBufferCreateInfoInitializer | null): VkExternalMemoryBufferCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalMemoryBufferCreateInfo: VkExternalMemoryBufferCreateInfoConstructor;



  /**
   * 
   */
interface VkExternalMemoryImageCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkExternalMemoryImageCreateInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkExternalMemoryImageCreateInfoKHRConstructor {
  readonly prototype: VkExternalMemoryImageCreateInfoKHR;
  new(param?: VkExternalMemoryImageCreateInfoKHRInitializer | null): VkExternalMemoryImageCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalMemoryImageCreateInfoKHR: VkExternalMemoryImageCreateInfoKHRConstructor;



  /**
   * Specify that an image may be backed by external memory
   */
interface VkExternalMemoryImageCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkExternalMemoryImageCreateInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkExternalMemoryImageCreateInfoConstructor {
  readonly prototype: VkExternalMemoryImageCreateInfo;
  new(param?: VkExternalMemoryImageCreateInfoInitializer | null): VkExternalMemoryImageCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalMemoryImageCreateInfo: VkExternalMemoryImageCreateInfoConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceIDPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly deviceUUID: number[] | null;

    /**
     *
     */
    readonly driverUUID: number[] | null;

    /**
     *
     */
    readonly deviceLUID: number[] | null;

    /**
     *
     */
    readonly deviceNodeMask: number;

    /**
     *
     */
    readonly deviceLUIDValid: boolean;

}

declare interface VkPhysicalDeviceIDPropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly deviceUUID?: number[] | null;

    /**
     *
     */
    readonly driverUUID?: number[] | null;

    /**
     *
     */
    readonly deviceLUID?: number[] | null;

    /**
     *
     */
    readonly deviceNodeMask?: number;

    /**
     *
     */
    readonly deviceLUIDValid?: boolean;
}

declare interface VkPhysicalDeviceIDPropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceIDPropertiesKHR;
  new(param?: VkPhysicalDeviceIDPropertiesKHRInitializer | null): VkPhysicalDeviceIDPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceIDPropertiesKHR: VkPhysicalDeviceIDPropertiesKHRConstructor;



  /**
   * Structure specifying IDs related to the physical device
   */
interface VkPhysicalDeviceIDProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly deviceUUID: number[] | null;

    /**
     *
     */
    readonly driverUUID: number[] | null;

    /**
     *
     */
    readonly deviceLUID: number[] | null;

    /**
     *
     */
    readonly deviceNodeMask: number;

    /**
     *
     */
    readonly deviceLUIDValid: boolean;

}

declare interface VkPhysicalDeviceIDPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly deviceUUID?: number[] | null;

    /**
     *
     */
    readonly driverUUID?: number[] | null;

    /**
     *
     */
    readonly deviceLUID?: number[] | null;

    /**
     *
     */
    readonly deviceNodeMask?: number;

    /**
     *
     */
    readonly deviceLUIDValid?: boolean;
}

declare interface VkPhysicalDeviceIDPropertiesConstructor {
  readonly prototype: VkPhysicalDeviceIDProperties;
  new(param?: VkPhysicalDeviceIDPropertiesInitializer | null): VkPhysicalDeviceIDProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceIDProperties: VkPhysicalDeviceIDPropertiesConstructor;



  /**
   * 
   */
interface VkExternalBufferPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly externalMemoryProperties: VkExternalMemoryProperties | null;

}

declare interface VkExternalBufferPropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly externalMemoryProperties?: VkExternalMemoryProperties | null;
}

declare interface VkExternalBufferPropertiesKHRConstructor {
  readonly prototype: VkExternalBufferPropertiesKHR;
  new(param?: VkExternalBufferPropertiesKHRInitializer | null): VkExternalBufferPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalBufferPropertiesKHR: VkExternalBufferPropertiesKHRConstructor;



  /**
   * Structure specifying supported external handle capabilities
   */
interface VkExternalBufferProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly externalMemoryProperties: VkExternalMemoryProperties | null;

}

declare interface VkExternalBufferPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly externalMemoryProperties?: VkExternalMemoryProperties | null;
}

declare interface VkExternalBufferPropertiesConstructor {
  readonly prototype: VkExternalBufferProperties;
  new(param?: VkExternalBufferPropertiesInitializer | null): VkExternalBufferProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalBufferProperties: VkExternalBufferPropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceExternalBufferInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkBufferCreateFlagBits;

    /**
     *
     */
    usage: VkBufferUsageFlagBits;

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkPhysicalDeviceExternalBufferInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkBufferCreateFlagBits;

    /**
     *
     */
    usage?: VkBufferUsageFlagBits;

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkPhysicalDeviceExternalBufferInfoKHRConstructor {
  readonly prototype: VkPhysicalDeviceExternalBufferInfoKHR;
  new(param?: VkPhysicalDeviceExternalBufferInfoKHRInitializer | null): VkPhysicalDeviceExternalBufferInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExternalBufferInfoKHR: VkPhysicalDeviceExternalBufferInfoKHRConstructor;



  /**
   * Structure specifying buffer creation parameters
   */
interface VkPhysicalDeviceExternalBufferInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    flags: VkBufferCreateFlagBits;

    /**
     *
     */
    usage: VkBufferUsageFlagBits;

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkPhysicalDeviceExternalBufferInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    flags?: VkBufferCreateFlagBits;

    /**
     *
     */
    usage?: VkBufferUsageFlagBits;

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkPhysicalDeviceExternalBufferInfoConstructor {
  readonly prototype: VkPhysicalDeviceExternalBufferInfo;
  new(param?: VkPhysicalDeviceExternalBufferInfoInitializer | null): VkPhysicalDeviceExternalBufferInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExternalBufferInfo: VkPhysicalDeviceExternalBufferInfoConstructor;



  /**
   * 
   */
interface VkExternalImageFormatPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly externalMemoryProperties: VkExternalMemoryProperties | null;

}

declare interface VkExternalImageFormatPropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly externalMemoryProperties?: VkExternalMemoryProperties | null;
}

declare interface VkExternalImageFormatPropertiesKHRConstructor {
  readonly prototype: VkExternalImageFormatPropertiesKHR;
  new(param?: VkExternalImageFormatPropertiesKHRInitializer | null): VkExternalImageFormatPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalImageFormatPropertiesKHR: VkExternalImageFormatPropertiesKHRConstructor;



  /**
   * Structure specifying supported external handle properties
   */
interface VkExternalImageFormatProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly externalMemoryProperties: VkExternalMemoryProperties | null;

}

declare interface VkExternalImageFormatPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly externalMemoryProperties?: VkExternalMemoryProperties | null;
}

declare interface VkExternalImageFormatPropertiesConstructor {
  readonly prototype: VkExternalImageFormatProperties;
  new(param?: VkExternalImageFormatPropertiesInitializer | null): VkExternalImageFormatProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalImageFormatProperties: VkExternalImageFormatPropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceExternalImageFormatInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkPhysicalDeviceExternalImageFormatInfoKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkPhysicalDeviceExternalImageFormatInfoKHRConstructor {
  readonly prototype: VkPhysicalDeviceExternalImageFormatInfoKHR;
  new(param?: VkPhysicalDeviceExternalImageFormatInfoKHRInitializer | null): VkPhysicalDeviceExternalImageFormatInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExternalImageFormatInfoKHR: VkPhysicalDeviceExternalImageFormatInfoKHRConstructor;



  /**
   * Structure specifying external image creation parameters
   */
interface VkPhysicalDeviceExternalImageFormatInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    handleType: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkPhysicalDeviceExternalImageFormatInfoInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    handleType?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkPhysicalDeviceExternalImageFormatInfoConstructor {
  readonly prototype: VkPhysicalDeviceExternalImageFormatInfo;
  new(param?: VkPhysicalDeviceExternalImageFormatInfoInitializer | null): VkPhysicalDeviceExternalImageFormatInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceExternalImageFormatInfo: VkPhysicalDeviceExternalImageFormatInfoConstructor;



  /**
   * 
   */
interface VkExternalMemoryPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly externalMemoryFeatures: VkExternalMemoryFeatureFlagBits;

    /**
     *
     */
    readonly exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkExternalMemoryPropertiesKHRInitializer {
  
    /**
     *
     */
    readonly externalMemoryFeatures?: VkExternalMemoryFeatureFlagBits;

    /**
     *
     */
    readonly exportFromImportedHandleTypes?: VkExternalMemoryHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkExternalMemoryPropertiesKHRConstructor {
  readonly prototype: VkExternalMemoryPropertiesKHR;
  new(param?: VkExternalMemoryPropertiesKHRInitializer | null): VkExternalMemoryPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalMemoryPropertiesKHR: VkExternalMemoryPropertiesKHRConstructor;



  /**
   * Structure specifying external memory handle type capabilities
   */
interface VkExternalMemoryProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly externalMemoryFeatures: VkExternalMemoryFeatureFlagBits;

    /**
     *
     */
    readonly exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes: VkExternalMemoryHandleTypeFlagBits;

}

declare interface VkExternalMemoryPropertiesInitializer {
  
    /**
     *
     */
    readonly externalMemoryFeatures?: VkExternalMemoryFeatureFlagBits;

    /**
     *
     */
    readonly exportFromImportedHandleTypes?: VkExternalMemoryHandleTypeFlagBits;

    /**
     *
     */
    readonly compatibleHandleTypes?: VkExternalMemoryHandleTypeFlagBits;
}

declare interface VkExternalMemoryPropertiesConstructor {
  readonly prototype: VkExternalMemoryProperties;
  new(param?: VkExternalMemoryPropertiesInitializer | null): VkExternalMemoryProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalMemoryProperties: VkExternalMemoryPropertiesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceVariablePointerFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    variablePointersStorageBuffer: boolean;

    /**
     *
     */
    variablePointers: boolean;

}

declare interface VkPhysicalDeviceVariablePointerFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    variablePointersStorageBuffer?: boolean;

    /**
     *
     */
    variablePointers?: boolean;
}

declare interface VkPhysicalDeviceVariablePointerFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceVariablePointerFeatures;
  new(param?: VkPhysicalDeviceVariablePointerFeaturesInitializer | null): VkPhysicalDeviceVariablePointerFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVariablePointerFeatures: VkPhysicalDeviceVariablePointerFeaturesConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceVariablePointerFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    variablePointersStorageBuffer: boolean;

    /**
     *
     */
    variablePointers: boolean;

}

declare interface VkPhysicalDeviceVariablePointerFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    variablePointersStorageBuffer?: boolean;

    /**
     *
     */
    variablePointers?: boolean;
}

declare interface VkPhysicalDeviceVariablePointerFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceVariablePointerFeaturesKHR;
  new(param?: VkPhysicalDeviceVariablePointerFeaturesKHRInitializer | null): VkPhysicalDeviceVariablePointerFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVariablePointerFeaturesKHR: VkPhysicalDeviceVariablePointerFeaturesKHRConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceVariablePointersFeaturesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    variablePointersStorageBuffer: boolean;

    /**
     *
     */
    variablePointers: boolean;

}

declare interface VkPhysicalDeviceVariablePointersFeaturesKHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    variablePointersStorageBuffer?: boolean;

    /**
     *
     */
    variablePointers?: boolean;
}

declare interface VkPhysicalDeviceVariablePointersFeaturesKHRConstructor {
  readonly prototype: VkPhysicalDeviceVariablePointersFeaturesKHR;
  new(param?: VkPhysicalDeviceVariablePointersFeaturesKHRInitializer | null): VkPhysicalDeviceVariablePointersFeaturesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVariablePointersFeaturesKHR: VkPhysicalDeviceVariablePointersFeaturesKHRConstructor;



  /**
   * Structure describing variable references features that can be supported by an implementation
   */
interface VkPhysicalDeviceVariablePointersFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    variablePointersStorageBuffer: boolean;

    /**
     *
     */
    variablePointers: boolean;

}

declare interface VkPhysicalDeviceVariablePointersFeaturesInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    variablePointersStorageBuffer?: boolean;

    /**
     *
     */
    variablePointers?: boolean;
}

declare interface VkPhysicalDeviceVariablePointersFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceVariablePointersFeatures;
  new(param?: VkPhysicalDeviceVariablePointersFeaturesInitializer | null): VkPhysicalDeviceVariablePointersFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceVariablePointersFeatures: VkPhysicalDeviceVariablePointersFeaturesConstructor;



  /**
   * Structure containing a rectangle, including layer, changed by vkQueuePresentKHR for a given VkImage
   */
interface VkRectLayerKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the origin of the rectangle, in pixels.
     */
    offset: VkOffset2D | null;

    /**
     * is the size of the rectangle, in pixels.
     */
    extent: VkExtent2D | null;

    /**
     * is the layer of the image. For images with only one layer, the value of 'layer' 'must' be 0.
     */
    layer: number;

}

declare interface VkRectLayerKHRInitializer {
  
    /**
     * is the origin of the rectangle, in pixels.
     */
    offset?: VkOffset2D | null;

    /**
     * is the size of the rectangle, in pixels.
     */
    extent?: VkExtent2D | null;

    /**
     * is the layer of the image. For images with only one layer, the value of 'layer' 'must' be 0.
     */
    layer?: number;
}

declare interface VkRectLayerKHRConstructor {
  readonly prototype: VkRectLayerKHR;
  new(param?: VkRectLayerKHRInitializer | null): VkRectLayerKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRectLayerKHR: VkRectLayerKHRConstructor;



  /**
   * Structure containing rectangular region changed by vkQueuePresentKHR for a given VkImage
   */
interface VkPresentRegionKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    rectangleCount: number;

    /**
     * is either <i>null</i> or a reference to an array of 'VkRectLayerKHR' structures. The 'VkRectLayerKHR' structure is the framebuffer coordinates, plus layer, of a portion of a presentable image that has changed and 'must' be presented. If non-<i>null</i>, each entry in 'pRectangles' is a rectangle of the given image that has changed since the last image was presented to the given swapchain.
     */
    pRectangles: VkRectLayerKHR[] | null;

}

declare interface VkPresentRegionKHRInitializer {
  
    /**
     *
     */
    rectangleCount?: number;

    /**
     * is either <i>null</i> or a reference to an array of 'VkRectLayerKHR' structures. The 'VkRectLayerKHR' structure is the framebuffer coordinates, plus layer, of a portion of a presentable image that has changed and 'must' be presented. If non-<i>null</i>, each entry in 'pRectangles' is a rectangle of the given image that has changed since the last image was presented to the given swapchain.
     */
    pRectangles?: VkRectLayerKHR[] | null;
}

declare interface VkPresentRegionKHRConstructor {
  readonly prototype: VkPresentRegionKHR;
  new(param?: VkPresentRegionKHRInitializer | null): VkPresentRegionKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPresentRegionKHR: VkPresentRegionKHRConstructor;



  /**
   * Structure hint of rectangular regions changed by vkQueuePresentKHR
   */
interface VkPresentRegionsKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount: number;

    /**
     * is <i>null</i> or a reference to an array of 'VkPresentRegionKHR' elements with 'swapchainCount' entries. If not <i>null</i>, each element of 'pRegions' contains the region that has changed since the last present to the swapchain in the corresponding entry in the 'VkPresentInfoKHR'::'pSwapchains' array.
     */
    pRegions: VkPresentRegionKHR[] | null;

}

declare interface VkPresentRegionsKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount?: number;

    /**
     * is <i>null</i> or a reference to an array of 'VkPresentRegionKHR' elements with 'swapchainCount' entries. If not <i>null</i>, each element of 'pRegions' contains the region that has changed since the last present to the swapchain in the corresponding entry in the 'VkPresentInfoKHR'::'pSwapchains' array.
     */
    pRegions?: VkPresentRegionKHR[] | null;
}

declare interface VkPresentRegionsKHRConstructor {
  readonly prototype: VkPresentRegionsKHR;
  new(param?: VkPresentRegionsKHRInitializer | null): VkPresentRegionsKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPresentRegionsKHR: VkPresentRegionsKHRConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceDriverPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly driverID: VkDriverId;

    /**
     *
     */
    readonly driverName: string | null;

    /**
     *
     */
    readonly driverInfo: string | null;

    /**
     *
     */
    readonly conformanceVersion: VkConformanceVersion | null;

}

declare interface VkPhysicalDeviceDriverPropertiesKHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly driverID?: VkDriverId;

    /**
     *
     */
    readonly driverName?: string | null;

    /**
     *
     */
    readonly driverInfo?: string | null;

    /**
     *
     */
    readonly conformanceVersion?: VkConformanceVersion | null;
}

declare interface VkPhysicalDeviceDriverPropertiesKHRConstructor {
  readonly prototype: VkPhysicalDeviceDriverPropertiesKHR;
  new(param?: VkPhysicalDeviceDriverPropertiesKHRInitializer | null): VkPhysicalDeviceDriverPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDriverPropertiesKHR: VkPhysicalDeviceDriverPropertiesKHRConstructor;



  /**
   * Structure containing driver identification information
   */
interface VkPhysicalDeviceDriverProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly driverID: VkDriverId;

    /**
     *
     */
    readonly driverName: string | null;

    /**
     *
     */
    readonly driverInfo: string | null;

    /**
     *
     */
    readonly conformanceVersion: VkConformanceVersion | null;

}

declare interface VkPhysicalDeviceDriverPropertiesInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly driverID?: VkDriverId;

    /**
     *
     */
    readonly driverName?: string | null;

    /**
     *
     */
    readonly driverInfo?: string | null;

    /**
     *
     */
    readonly conformanceVersion?: VkConformanceVersion | null;
}

declare interface VkPhysicalDeviceDriverPropertiesConstructor {
  readonly prototype: VkPhysicalDeviceDriverProperties;
  new(param?: VkPhysicalDeviceDriverPropertiesInitializer | null): VkPhysicalDeviceDriverProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDriverProperties: VkPhysicalDeviceDriverPropertiesConstructor;



  /**
   * 
   */
interface VkConformanceVersionKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    major: number;

    /**
     *
     */
    minor: number;

    /**
     *
     */
    subminor: number;

    /**
     *
     */
    patch: number;

}

declare interface VkConformanceVersionKHRInitializer {
  
    /**
     *
     */
    major?: number;

    /**
     *
     */
    minor?: number;

    /**
     *
     */
    subminor?: number;

    /**
     *
     */
    patch?: number;
}

declare interface VkConformanceVersionKHRConstructor {
  readonly prototype: VkConformanceVersionKHR;
  new(param?: VkConformanceVersionKHRInitializer | null): VkConformanceVersionKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkConformanceVersionKHR: VkConformanceVersionKHRConstructor;



  /**
   * Structure containing the conformance test suite version the implementation is compliant with
   */
interface VkConformanceVersion {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    major: number;

    /**
     *
     */
    minor: number;

    /**
     *
     */
    subminor: number;

    /**
     *
     */
    patch: number;

}

declare interface VkConformanceVersionInitializer {
  
    /**
     *
     */
    major?: number;

    /**
     *
     */
    minor?: number;

    /**
     *
     */
    subminor?: number;

    /**
     *
     */
    patch?: number;
}

declare interface VkConformanceVersionConstructor {
  readonly prototype: VkConformanceVersion;
  new(param?: VkConformanceVersionInitializer | null): VkConformanceVersion;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkConformanceVersion: VkConformanceVersionConstructor;



  /**
   * Structure describing push descriptor limits that can be supported by an implementation
   */
interface VkPhysicalDevicePushDescriptorPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the maximum number of descriptors that 'can' be used in a descriptor set created with 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR' set.
     */
    readonly maxPushDescriptors: number;

}

declare interface VkPhysicalDevicePushDescriptorPropertiesKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the maximum number of descriptors that 'can' be used in a descriptor set created with 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR' set.
     */
    readonly maxPushDescriptors?: number;
}

declare interface VkPhysicalDevicePushDescriptorPropertiesKHRConstructor {
  readonly prototype: VkPhysicalDevicePushDescriptorPropertiesKHR;
  new(param?: VkPhysicalDevicePushDescriptorPropertiesKHRInitializer | null): VkPhysicalDevicePushDescriptorPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevicePushDescriptorPropertiesKHR: VkPhysicalDevicePushDescriptorPropertiesKHRConstructor;



  /**
   * 
   */
interface VkPhysicalDeviceSparseImageFormatInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    format: VkFormat;

    /**
     *
     */
    type: VkImageType;

    /**
     *
     */
    samples: VkSampleCountFlagBits;

    /**
     *
     */
    usage: VkImageUsageFlagBits;

    /**
     *
     */
    tiling: VkImageTiling;

}

declare interface VkPhysicalDeviceSparseImageFormatInfo2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    format?: VkFormat;

    /**
     *
     */
    type?: VkImageType;

    /**
     *
     */
    samples?: VkSampleCountFlagBits;

    /**
     *
     */
    usage?: VkImageUsageFlagBits;

    /**
     *
     */
    tiling?: VkImageTiling;
}

declare interface VkPhysicalDeviceSparseImageFormatInfo2KHRConstructor {
  readonly prototype: VkPhysicalDeviceSparseImageFormatInfo2KHR;
  new(param?: VkPhysicalDeviceSparseImageFormatInfo2KHRInitializer | null): VkPhysicalDeviceSparseImageFormatInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSparseImageFormatInfo2KHR: VkPhysicalDeviceSparseImageFormatInfo2KHRConstructor;



  /**
   * Structure specifying sparse image format inputs
   */
interface VkPhysicalDeviceSparseImageFormatInfo2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    format: VkFormat;

    /**
     *
     */
    type: VkImageType;

    /**
     *
     */
    samples: VkSampleCountFlagBits;

    /**
     *
     */
    usage: VkImageUsageFlagBits;

    /**
     *
     */
    tiling: VkImageTiling;

}

declare interface VkPhysicalDeviceSparseImageFormatInfo2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    format?: VkFormat;

    /**
     *
     */
    type?: VkImageType;

    /**
     *
     */
    samples?: VkSampleCountFlagBits;

    /**
     *
     */
    usage?: VkImageUsageFlagBits;

    /**
     *
     */
    tiling?: VkImageTiling;
}

declare interface VkPhysicalDeviceSparseImageFormatInfo2Constructor {
  readonly prototype: VkPhysicalDeviceSparseImageFormatInfo2;
  new(param?: VkPhysicalDeviceSparseImageFormatInfo2Initializer | null): VkPhysicalDeviceSparseImageFormatInfo2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSparseImageFormatInfo2: VkPhysicalDeviceSparseImageFormatInfo2Constructor;



  /**
   * 
   */
interface VkSparseImageFormatProperties2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly properties: VkSparseImageFormatProperties | null;

}

declare interface VkSparseImageFormatProperties2KHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly properties?: VkSparseImageFormatProperties | null;
}

declare interface VkSparseImageFormatProperties2KHRConstructor {
  readonly prototype: VkSparseImageFormatProperties2KHR;
  new(param?: VkSparseImageFormatProperties2KHRInitializer | null): VkSparseImageFormatProperties2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseImageFormatProperties2KHR: VkSparseImageFormatProperties2KHRConstructor;



  /**
   * Structure specifying sparse image format properties
   */
interface VkSparseImageFormatProperties2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly properties: VkSparseImageFormatProperties | null;

}

declare interface VkSparseImageFormatProperties2Initializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly properties?: VkSparseImageFormatProperties | null;
}

declare interface VkSparseImageFormatProperties2Constructor {
  readonly prototype: VkSparseImageFormatProperties2;
  new(param?: VkSparseImageFormatProperties2Initializer | null): VkSparseImageFormatProperties2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseImageFormatProperties2: VkSparseImageFormatProperties2Constructor;



  /**
   * 
   */
interface VkPhysicalDeviceMemoryProperties2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly memoryProperties: VkPhysicalDeviceMemoryProperties | null;

}

declare interface VkPhysicalDeviceMemoryProperties2KHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly memoryProperties?: VkPhysicalDeviceMemoryProperties | null;
}

declare interface VkPhysicalDeviceMemoryProperties2KHRConstructor {
  readonly prototype: VkPhysicalDeviceMemoryProperties2KHR;
  new(param?: VkPhysicalDeviceMemoryProperties2KHRInitializer | null): VkPhysicalDeviceMemoryProperties2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMemoryProperties2KHR: VkPhysicalDeviceMemoryProperties2KHRConstructor;



  /**
   * Structure specifying physical device memory properties
   */
interface VkPhysicalDeviceMemoryProperties2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly memoryProperties: VkPhysicalDeviceMemoryProperties | null;

}

declare interface VkPhysicalDeviceMemoryProperties2Initializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly memoryProperties?: VkPhysicalDeviceMemoryProperties | null;
}

declare interface VkPhysicalDeviceMemoryProperties2Constructor {
  readonly prototype: VkPhysicalDeviceMemoryProperties2;
  new(param?: VkPhysicalDeviceMemoryProperties2Initializer | null): VkPhysicalDeviceMemoryProperties2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMemoryProperties2: VkPhysicalDeviceMemoryProperties2Constructor;



  /**
   * 
   */
interface VkQueueFamilyProperties2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly queueFamilyProperties: VkQueueFamilyProperties | null;

}

declare interface VkQueueFamilyProperties2KHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly queueFamilyProperties?: VkQueueFamilyProperties | null;
}

declare interface VkQueueFamilyProperties2KHRConstructor {
  readonly prototype: VkQueueFamilyProperties2KHR;
  new(param?: VkQueueFamilyProperties2KHRInitializer | null): VkQueueFamilyProperties2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkQueueFamilyProperties2KHR: VkQueueFamilyProperties2KHRConstructor;



  /**
   * Structure providing information about a queue family
   */
interface VkQueueFamilyProperties2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly queueFamilyProperties: VkQueueFamilyProperties | null;

}

declare interface VkQueueFamilyProperties2Initializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly queueFamilyProperties?: VkQueueFamilyProperties | null;
}

declare interface VkQueueFamilyProperties2Constructor {
  readonly prototype: VkQueueFamilyProperties2;
  new(param?: VkQueueFamilyProperties2Initializer | null): VkQueueFamilyProperties2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkQueueFamilyProperties2: VkQueueFamilyProperties2Constructor;



  /**
   * 
   */
interface VkPhysicalDeviceImageFormatInfo2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    format: VkFormat;

    /**
     *
     */
    type: VkImageType;

    /**
     *
     */
    tiling: VkImageTiling;

    /**
     *
     */
    usage: VkImageUsageFlagBits;

    /**
     *
     */
    flags: VkImageCreateFlagBits;

}

declare interface VkPhysicalDeviceImageFormatInfo2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    format?: VkFormat;

    /**
     *
     */
    type?: VkImageType;

    /**
     *
     */
    tiling?: VkImageTiling;

    /**
     *
     */
    usage?: VkImageUsageFlagBits;

    /**
     *
     */
    flags?: VkImageCreateFlagBits;
}

declare interface VkPhysicalDeviceImageFormatInfo2KHRConstructor {
  readonly prototype: VkPhysicalDeviceImageFormatInfo2KHR;
  new(param?: VkPhysicalDeviceImageFormatInfo2KHRInitializer | null): VkPhysicalDeviceImageFormatInfo2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceImageFormatInfo2KHR: VkPhysicalDeviceImageFormatInfo2KHRConstructor;



  /**
   * Structure specifying image creation parameters
   */
interface VkPhysicalDeviceImageFormatInfo2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    format: VkFormat;

    /**
     *
     */
    type: VkImageType;

    /**
     *
     */
    tiling: VkImageTiling;

    /**
     *
     */
    usage: VkImageUsageFlagBits;

    /**
     *
     */
    flags: VkImageCreateFlagBits;

}

declare interface VkPhysicalDeviceImageFormatInfo2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    format?: VkFormat;

    /**
     *
     */
    type?: VkImageType;

    /**
     *
     */
    tiling?: VkImageTiling;

    /**
     *
     */
    usage?: VkImageUsageFlagBits;

    /**
     *
     */
    flags?: VkImageCreateFlagBits;
}

declare interface VkPhysicalDeviceImageFormatInfo2Constructor {
  readonly prototype: VkPhysicalDeviceImageFormatInfo2;
  new(param?: VkPhysicalDeviceImageFormatInfo2Initializer | null): VkPhysicalDeviceImageFormatInfo2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceImageFormatInfo2: VkPhysicalDeviceImageFormatInfo2Constructor;



  /**
   * 
   */
interface VkImageFormatProperties2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly imageFormatProperties: VkImageFormatProperties | null;

}

declare interface VkImageFormatProperties2KHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly imageFormatProperties?: VkImageFormatProperties | null;
}

declare interface VkImageFormatProperties2KHRConstructor {
  readonly prototype: VkImageFormatProperties2KHR;
  new(param?: VkImageFormatProperties2KHRInitializer | null): VkImageFormatProperties2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageFormatProperties2KHR: VkImageFormatProperties2KHRConstructor;



  /**
   * Structure specifying an image format properties
   */
interface VkImageFormatProperties2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly imageFormatProperties: VkImageFormatProperties | null;

}

declare interface VkImageFormatProperties2Initializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly imageFormatProperties?: VkImageFormatProperties | null;
}

declare interface VkImageFormatProperties2Constructor {
  readonly prototype: VkImageFormatProperties2;
  new(param?: VkImageFormatProperties2Initializer | null): VkImageFormatProperties2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageFormatProperties2: VkImageFormatProperties2Constructor;



  /**
   * 
   */
interface VkFormatProperties2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly formatProperties: VkFormatProperties | null;

}

declare interface VkFormatProperties2KHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly formatProperties?: VkFormatProperties | null;
}

declare interface VkFormatProperties2KHRConstructor {
  readonly prototype: VkFormatProperties2KHR;
  new(param?: VkFormatProperties2KHRInitializer | null): VkFormatProperties2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFormatProperties2KHR: VkFormatProperties2KHRConstructor;



  /**
   * Structure specifying image format properties
   */
interface VkFormatProperties2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly formatProperties: VkFormatProperties | null;

}

declare interface VkFormatProperties2Initializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly formatProperties?: VkFormatProperties | null;
}

declare interface VkFormatProperties2Constructor {
  readonly prototype: VkFormatProperties2;
  new(param?: VkFormatProperties2Initializer | null): VkFormatProperties2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFormatProperties2: VkFormatProperties2Constructor;



  /**
   * 
   */
interface VkPhysicalDeviceProperties2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly properties: VkPhysicalDeviceProperties | null;

}

declare interface VkPhysicalDeviceProperties2KHRInitializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly properties?: VkPhysicalDeviceProperties | null;
}

declare interface VkPhysicalDeviceProperties2KHRConstructor {
  readonly prototype: VkPhysicalDeviceProperties2KHR;
  new(param?: VkPhysicalDeviceProperties2KHRInitializer | null): VkPhysicalDeviceProperties2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceProperties2KHR: VkPhysicalDeviceProperties2KHRConstructor;



  /**
   * Structure specifying physical device properties
   */
interface VkPhysicalDeviceProperties2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly sType: VkStructureType;

    /**
     *
     */
    readonly pNext: null;

    /**
     *
     */
    readonly properties: VkPhysicalDeviceProperties | null;

}

declare interface VkPhysicalDeviceProperties2Initializer {
  
    /**
     *
     */
    readonly sType?: VkStructureType;

    /**
     *
     */
    readonly pNext?: null;

    /**
     *
     */
    readonly properties?: VkPhysicalDeviceProperties | null;
}

declare interface VkPhysicalDeviceProperties2Constructor {
  readonly prototype: VkPhysicalDeviceProperties2;
  new(param?: VkPhysicalDeviceProperties2Initializer | null): VkPhysicalDeviceProperties2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceProperties2: VkPhysicalDeviceProperties2Constructor;



  /**
   * 
   */
interface VkPhysicalDeviceFeatures2KHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    features: VkPhysicalDeviceFeatures | null;

}

declare interface VkPhysicalDeviceFeatures2KHRInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    features?: VkPhysicalDeviceFeatures | null;
}

declare interface VkPhysicalDeviceFeatures2KHRConstructor {
  readonly prototype: VkPhysicalDeviceFeatures2KHR;
  new(param?: VkPhysicalDeviceFeatures2KHRInitializer | null): VkPhysicalDeviceFeatures2KHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFeatures2KHR: VkPhysicalDeviceFeatures2KHRConstructor;



  /**
   * Structure describing the fine-grained features that can be supported by an implementation
   */
interface VkPhysicalDeviceFeatures2 {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    features: VkPhysicalDeviceFeatures | null;

}

declare interface VkPhysicalDeviceFeatures2Initializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    features?: VkPhysicalDeviceFeatures | null;
}

declare interface VkPhysicalDeviceFeatures2Constructor {
  readonly prototype: VkPhysicalDeviceFeatures2;
  new(param?: VkPhysicalDeviceFeatures2Initializer | null): VkPhysicalDeviceFeatures2;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFeatures2: VkPhysicalDeviceFeatures2Constructor;



  /**
   * Structure specifying parameters for the reservation of preprocess buffer space
   */
interface VkGeneratedCommandsMemoryRequirementsInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the 'VkPipelineBindPoint' of the 'pipeline' that this buffer memory is intended to be used with during the execution.
     */
    pipelineBindPoint: VkPipelineBindPoint;

    /**
     * is the 'VkPipeline' that this buffer memory is intended to be used with during the execution.
     */
    pipeline: VkPipeline | null;

    /**
     * is the 'VkIndirectCommandsLayoutNV' that this buffer memory is intended to be used with.
     */
    indirectCommandsLayout: VkIndirectCommandsLayoutNV | null;

    /**
     * is the maximum number of sequences that this buffer memory in combination with the other state provided 'can' be used with.
     */
    maxSequencesCount: number;

}

declare interface VkGeneratedCommandsMemoryRequirementsInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the 'VkPipelineBindPoint' of the 'pipeline' that this buffer memory is intended to be used with during the execution.
     */
    pipelineBindPoint?: VkPipelineBindPoint;

    /**
     * is the 'VkPipeline' that this buffer memory is intended to be used with during the execution.
     */
    pipeline?: VkPipeline | null;

    /**
     * is the 'VkIndirectCommandsLayoutNV' that this buffer memory is intended to be used with.
     */
    indirectCommandsLayout?: VkIndirectCommandsLayoutNV | null;

    /**
     * is the maximum number of sequences that this buffer memory in combination with the other state provided 'can' be used with.
     */
    maxSequencesCount?: number;
}

declare interface VkGeneratedCommandsMemoryRequirementsInfoNVConstructor {
  readonly prototype: VkGeneratedCommandsMemoryRequirementsInfoNV;
  new(param?: VkGeneratedCommandsMemoryRequirementsInfoNVInitializer | null): VkGeneratedCommandsMemoryRequirementsInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkGeneratedCommandsMemoryRequirementsInfoNV: VkGeneratedCommandsMemoryRequirementsInfoNVConstructor;



  /**
   * Structure specifying parameters for the generation of commands
   */
interface VkGeneratedCommandsInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the 'VkPipelineBindPoint' used for the 'pipeline'.
     */
    pipelineBindPoint: VkPipelineBindPoint;

    /**
     * is the 'VkPipeline' used in the generation and execution process.
     */
    pipeline: VkPipeline | null;

    /**
     * is the 'VkIndirectCommandsLayoutNV' that provides the command sequence to generate.
     */
    indirectCommandsLayout: VkIndirectCommandsLayoutNV | null;

    /**
     * defines the number of input streams
     */
    streamCount: number;

    /**
     * provides an array of 'VkIndirectCommandsStreamNV' that provide the input data for the tokens used in 'indirectCommandsLayout'.
     */
    pStreams: VkIndirectCommandsStreamNV[] | null;

    /**
     * is the maximum number of sequences to reserve. If 'sequencesCountBuffer' is 'VK_NULL_HANDLE', this is also the actual number of sequences generated.
     */
    sequencesCount: number;

    /**
     * where the preprocessed data is stored.
     */
    preprocessBuffer: VkBuffer | null;

    /**
     *
     */
    preprocessOffset: bigint | number;

    /**
     * is the maximum byte size within the 'preprocessBuffer' after the 'preprocessOffset' that is available for preprocessing.
     */
    preprocessSize: bigint | number;

    /**
     * is a 'VkBuffer' in which the actual number of sequences is provided as single 'uint32_t' value.
     */
    sequencesCountBuffer: VkBuffer | null;

    /**
     * is the byte offset into 'sequencesCountBuffer' where the count value is stored.
     */
    sequencesCountOffset: bigint | number;

    /**
     * is a 'VkBuffer' that encodes the used sequence indices as 'uint32_t' array.
     */
    sequencesIndexBuffer: VkBuffer | null;

    /**
     * is the byte offset into 'sequencesIndexBuffer' where the index values start.
     */
    sequencesIndexOffset: bigint | number;

}

declare interface VkGeneratedCommandsInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the 'VkPipelineBindPoint' used for the 'pipeline'.
     */
    pipelineBindPoint?: VkPipelineBindPoint;

    /**
     * is the 'VkPipeline' used in the generation and execution process.
     */
    pipeline?: VkPipeline | null;

    /**
     * is the 'VkIndirectCommandsLayoutNV' that provides the command sequence to generate.
     */
    indirectCommandsLayout?: VkIndirectCommandsLayoutNV | null;

    /**
     * defines the number of input streams
     */
    streamCount?: number;

    /**
     * provides an array of 'VkIndirectCommandsStreamNV' that provide the input data for the tokens used in 'indirectCommandsLayout'.
     */
    pStreams?: VkIndirectCommandsStreamNV[] | null;

    /**
     * is the maximum number of sequences to reserve. If 'sequencesCountBuffer' is 'VK_NULL_HANDLE', this is also the actual number of sequences generated.
     */
    sequencesCount?: number;

    /**
     * where the preprocessed data is stored.
     */
    preprocessBuffer?: VkBuffer | null;

    /**
     *
     */
    preprocessOffset?: bigint | number;

    /**
     * is the maximum byte size within the 'preprocessBuffer' after the 'preprocessOffset' that is available for preprocessing.
     */
    preprocessSize?: bigint | number;

    /**
     * is a 'VkBuffer' in which the actual number of sequences is provided as single 'uint32_t' value.
     */
    sequencesCountBuffer?: VkBuffer | null;

    /**
     * is the byte offset into 'sequencesCountBuffer' where the count value is stored.
     */
    sequencesCountOffset?: bigint | number;

    /**
     * is a 'VkBuffer' that encodes the used sequence indices as 'uint32_t' array.
     */
    sequencesIndexBuffer?: VkBuffer | null;

    /**
     * is the byte offset into 'sequencesIndexBuffer' where the index values start.
     */
    sequencesIndexOffset?: bigint | number;
}

declare interface VkGeneratedCommandsInfoNVConstructor {
  readonly prototype: VkGeneratedCommandsInfoNV;
  new(param?: VkGeneratedCommandsInfoNVInitializer | null): VkGeneratedCommandsInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkGeneratedCommandsInfoNV: VkGeneratedCommandsInfoNVConstructor;



  /**
   * Structure specifying the parameters of a newly created indirect commands layout object
   */
interface VkIndirectCommandsLayoutCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkIndirectCommandsLayoutUsageFlagBitsNV' specifying usage hints of this layout.
     */
    flags: VkIndirectCommandsLayoutUsageFlagBitsNV;

    /**
     * is the 'VkPipelineBindPoint' that this layout targets.
     */
    pipelineBindPoint: VkPipelineBindPoint;

    /**
     * is the length of the individual command sequence.
     */
    tokenCount: number;

    /**
     * is an array describing each command token in detail. See 'VkIndirectCommandsTokenTypeNV' and 'VkIndirectCommandsLayoutTokenNV' below for details.
     */
    pTokens: VkIndirectCommandsLayoutTokenNV[] | null;

    /**
     * is the number of streams used to provide the token inputs.
     */
    streamCount: number;

    /**
     * is an array defining the byte stride for each input stream.
     */
    pStreamStrides: Uint32Array | null;

}

declare interface VkIndirectCommandsLayoutCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkIndirectCommandsLayoutUsageFlagBitsNV' specifying usage hints of this layout.
     */
    flags?: VkIndirectCommandsLayoutUsageFlagBitsNV;

    /**
     * is the 'VkPipelineBindPoint' that this layout targets.
     */
    pipelineBindPoint?: VkPipelineBindPoint;

    /**
     * is the length of the individual command sequence.
     */
    tokenCount?: number;

    /**
     * is an array describing each command token in detail. See 'VkIndirectCommandsTokenTypeNV' and 'VkIndirectCommandsLayoutTokenNV' below for details.
     */
    pTokens?: VkIndirectCommandsLayoutTokenNV[] | null;

    /**
     * is the number of streams used to provide the token inputs.
     */
    streamCount?: number;

    /**
     * is an array defining the byte stride for each input stream.
     */
    pStreamStrides?: Uint32Array | null;
}

declare interface VkIndirectCommandsLayoutCreateInfoNVConstructor {
  readonly prototype: VkIndirectCommandsLayoutCreateInfoNV;
  new(param?: VkIndirectCommandsLayoutCreateInfoNVInitializer | null): VkIndirectCommandsLayoutCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkIndirectCommandsLayoutCreateInfoNV: VkIndirectCommandsLayoutCreateInfoNVConstructor;



  /**
   * Struct specifying the details of an indirect command layout token
   */
interface VkIndirectCommandsLayoutTokenNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies the token command type.
     */
    tokenType: VkIndirectCommandsTokenTypeNV;

    /**
     * is the index of the input stream that contains the token argument data.
     */
    stream: number;

    /**
     * is a relative starting offset within the input stream memory for the token argument data.
     */
    offset: number;

    /**
     * is used for the vertex buffer binding command.
     */
    vertexBindingUnit: number;

    /**
     * sets if the vertex buffer stride is provided by the binding command rather than the current bound graphics pipeline state.
     */
    vertexDynamicStride: boolean;

    /**
     * is the 'VkPipelineLayout' used for the push constant command.
     */
    pushconstantPipelineLayout: VkPipelineLayout | null;

    /**
     * are the shader stage flags used for the push constant command.
     */
    pushconstantShaderStageFlags: VkShaderStageFlagBits;

    /**
     * is the offset used for the push constant command.
     */
    pushconstantOffset: number;

    /**
     * is the size used for the push constant command.
     */
    pushconstantSize: number;

    /**
     * are the active states for the state flag command.
     */
    indirectStateFlags: VkIndirectStateFlagBitsNV;

    /**
     *
     */
    indexTypeCount: number;

    /**
     * and 'pIndexTypeValues' array pairings. If not zero, it allows to register a custom `uint32_t` value to be treated as specific 'VkIndexType'.
     */
    pIndexTypes: Int32Array | null;

    /**
     *
     */
    pIndexTypeValues: Uint32Array | null;

}

declare interface VkIndirectCommandsLayoutTokenNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies the token command type.
     */
    tokenType?: VkIndirectCommandsTokenTypeNV;

    /**
     * is the index of the input stream that contains the token argument data.
     */
    stream?: number;

    /**
     * is a relative starting offset within the input stream memory for the token argument data.
     */
    offset?: number;

    /**
     * is used for the vertex buffer binding command.
     */
    vertexBindingUnit?: number;

    /**
     * sets if the vertex buffer stride is provided by the binding command rather than the current bound graphics pipeline state.
     */
    vertexDynamicStride?: boolean;

    /**
     * is the 'VkPipelineLayout' used for the push constant command.
     */
    pushconstantPipelineLayout?: VkPipelineLayout | null;

    /**
     * are the shader stage flags used for the push constant command.
     */
    pushconstantShaderStageFlags?: VkShaderStageFlagBits;

    /**
     * is the offset used for the push constant command.
     */
    pushconstantOffset?: number;

    /**
     * is the size used for the push constant command.
     */
    pushconstantSize?: number;

    /**
     * are the active states for the state flag command.
     */
    indirectStateFlags?: VkIndirectStateFlagBitsNV;

    /**
     *
     */
    indexTypeCount?: number;

    /**
     * and 'pIndexTypeValues' array pairings. If not zero, it allows to register a custom `uint32_t` value to be treated as specific 'VkIndexType'.
     */
    pIndexTypes?: Int32Array | null;

    /**
     *
     */
    pIndexTypeValues?: Uint32Array | null;
}

declare interface VkIndirectCommandsLayoutTokenNVConstructor {
  readonly prototype: VkIndirectCommandsLayoutTokenNV;
  new(param?: VkIndirectCommandsLayoutTokenNVInitializer | null): VkIndirectCommandsLayoutTokenNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkIndirectCommandsLayoutTokenNV: VkIndirectCommandsLayoutTokenNVConstructor;



  /**
   * Structure specifying input streams for generated command tokens
   */
interface VkIndirectCommandsStreamNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * where the arguments start.
     */
    buffer: VkBuffer | null;

    /**
     *
     */
    offset: bigint | number;

}

declare interface VkIndirectCommandsStreamNVInitializer {
  
    /**
     * where the arguments start.
     */
    buffer?: VkBuffer | null;

    /**
     *
     */
    offset?: bigint | number;
}

declare interface VkIndirectCommandsStreamNVConstructor {
  readonly prototype: VkIndirectCommandsStreamNV;
  new(param?: VkIndirectCommandsStreamNVInitializer | null): VkIndirectCommandsStreamNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkIndirectCommandsStreamNV: VkIndirectCommandsStreamNVConstructor;



  /**
   * Structure specifying input data for a single state flag command token
   */
interface VkSetStateFlagsIndirectCommandNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * encodes packed state that this command alters.
     */
    data: number;

}

declare interface VkSetStateFlagsIndirectCommandNVInitializer {
  
    /**
     * encodes packed state that this command alters.
     */
    data?: number;
}

declare interface VkSetStateFlagsIndirectCommandNVConstructor {
  readonly prototype: VkSetStateFlagsIndirectCommandNV;
  new(param?: VkSetStateFlagsIndirectCommandNVInitializer | null): VkSetStateFlagsIndirectCommandNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSetStateFlagsIndirectCommandNV: VkSetStateFlagsIndirectCommandNVConstructor;



  /**
   * Structure specifying input data for a single vertex buffer command token
   */
interface VkBindVertexBufferIndirectCommandNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * specifies a physical address of the 'VkBuffer' used as vertex input binding.
     */
    bufferAddress: bigint | number;

    /**
     * is the byte size range which is available for this operation from the provided address.
     */
    size: number;

    /**
     * is the byte size stride for this vertex input binding as in 'VkVertexInputBindingDescription'::'stride'. It is only used if 'VkIndirectCommandsLayoutTokenNV'::'vertexDynamicStride' was set, otherwise the stride is inherited from the current bound graphics pipeline.
     */
    stride: number;

}

declare interface VkBindVertexBufferIndirectCommandNVInitializer {
  
    /**
     * specifies a physical address of the 'VkBuffer' used as vertex input binding.
     */
    bufferAddress?: bigint | number;

    /**
     * is the byte size range which is available for this operation from the provided address.
     */
    size?: number;

    /**
     * is the byte size stride for this vertex input binding as in 'VkVertexInputBindingDescription'::'stride'. It is only used if 'VkIndirectCommandsLayoutTokenNV'::'vertexDynamicStride' was set, otherwise the stride is inherited from the current bound graphics pipeline.
     */
    stride?: number;
}

declare interface VkBindVertexBufferIndirectCommandNVConstructor {
  readonly prototype: VkBindVertexBufferIndirectCommandNV;
  new(param?: VkBindVertexBufferIndirectCommandNVInitializer | null): VkBindVertexBufferIndirectCommandNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindVertexBufferIndirectCommandNV: VkBindVertexBufferIndirectCommandNVConstructor;



  /**
   * Structure specifying input data for a single index buffer command token
   */
interface VkBindIndexBufferIndirectCommandNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * specifies a physical address of the 'VkBuffer' used as index buffer.
     */
    bufferAddress: bigint | number;

    /**
     * is the byte size range which is available for this operation from the provided address.
     */
    size: number;

    /**
     * is a 'VkIndexType' value specifying how indices are treated. Instead of the Vulkan enum values, a custom `uint32_t` value 'can' be mapped to an 'VkIndexType' by specifying the 'VkIndirectCommandsLayoutTokenNV'::'pIndexTypes' and 'VkIndirectCommandsLayoutTokenNV'::'pIndexTypeValues' arrays.
     */
    indexType: VkIndexType;

}

declare interface VkBindIndexBufferIndirectCommandNVInitializer {
  
    /**
     * specifies a physical address of the 'VkBuffer' used as index buffer.
     */
    bufferAddress?: bigint | number;

    /**
     * is the byte size range which is available for this operation from the provided address.
     */
    size?: number;

    /**
     * is a 'VkIndexType' value specifying how indices are treated. Instead of the Vulkan enum values, a custom `uint32_t` value 'can' be mapped to an 'VkIndexType' by specifying the 'VkIndirectCommandsLayoutTokenNV'::'pIndexTypes' and 'VkIndirectCommandsLayoutTokenNV'::'pIndexTypeValues' arrays.
     */
    indexType?: VkIndexType;
}

declare interface VkBindIndexBufferIndirectCommandNVConstructor {
  readonly prototype: VkBindIndexBufferIndirectCommandNV;
  new(param?: VkBindIndexBufferIndirectCommandNVInitializer | null): VkBindIndexBufferIndirectCommandNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindIndexBufferIndirectCommandNV: VkBindIndexBufferIndirectCommandNVConstructor;



  /**
   * Structure specifying input data for a single shader group command token
   */
interface VkBindShaderGroupIndirectCommandNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    groupIndex: number;

}

declare interface VkBindShaderGroupIndirectCommandNVInitializer {
  
    /**
     *
     */
    groupIndex?: number;
}

declare interface VkBindShaderGroupIndirectCommandNVConstructor {
  readonly prototype: VkBindShaderGroupIndirectCommandNV;
  new(param?: VkBindShaderGroupIndirectCommandNVInitializer | null): VkBindShaderGroupIndirectCommandNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindShaderGroupIndirectCommandNV: VkBindShaderGroupIndirectCommandNVConstructor;



  /**
   * Structure specifying parameters of a newly created multi shader group pipeline
   */
interface VkGraphicsPipelineShaderGroupsCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     *
     */
    groupCount: number;

    /**
     * is an array of 'VkGraphicsShaderGroupCreateInfoNV' values specifying which state of the original 'VkGraphicsPipelineCreateInfo' each shader group overrides.
     */
    pGroups: VkGraphicsShaderGroupCreateInfoNV[] | null;

    /**
     *
     */
    pipelineCount: number;

    /**
     * is an array of graphics 'VkPipeline', which are referenced within the created pipeline, including all their shader groups.
     */
    pPipelines: VkPipeline[] | null;

}

declare interface VkGraphicsPipelineShaderGroupsCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     *
     */
    groupCount?: number;

    /**
     * is an array of 'VkGraphicsShaderGroupCreateInfoNV' values specifying which state of the original 'VkGraphicsPipelineCreateInfo' each shader group overrides.
     */
    pGroups?: VkGraphicsShaderGroupCreateInfoNV[] | null;

    /**
     *
     */
    pipelineCount?: number;

    /**
     * is an array of graphics 'VkPipeline', which are referenced within the created pipeline, including all their shader groups.
     */
    pPipelines?: VkPipeline[] | null;
}

declare interface VkGraphicsPipelineShaderGroupsCreateInfoNVConstructor {
  readonly prototype: VkGraphicsPipelineShaderGroupsCreateInfoNV;
  new(param?: VkGraphicsPipelineShaderGroupsCreateInfoNVInitializer | null): VkGraphicsPipelineShaderGroupsCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkGraphicsPipelineShaderGroupsCreateInfoNV: VkGraphicsPipelineShaderGroupsCreateInfoNVConstructor;



  /**
   * Structure specifying override parameters for each shader group
   */
interface VkGraphicsShaderGroupCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * structures of type 'VkPipelineShaderStageCreateInfo' describing the set of the shader stages to be included in this shader group.
     */
    stageCount: number;

    /**
     * array.
     */
    pStages: VkPipelineShaderStageCreateInfo[] | null;

    /**
     * is a reference to an instance of the 'VkPipelineVertexInputStateCreateInfo' structure.
     */
    pVertexInputState: VkPipelineVertexInputStateCreateInfo | null;

    /**
     * is a reference to an instance of the 'VkPipelineTessellationStateCreateInfo' structure, and is ignored if the shader group does not include a tessellation control shader stage and tessellation evaluation shader stage.
     */
    pTessellationState: VkPipelineTessellationStateCreateInfo | null;

}

declare interface VkGraphicsShaderGroupCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * structures of type 'VkPipelineShaderStageCreateInfo' describing the set of the shader stages to be included in this shader group.
     */
    stageCount?: number;

    /**
     * array.
     */
    pStages?: VkPipelineShaderStageCreateInfo[] | null;

    /**
     * is a reference to an instance of the 'VkPipelineVertexInputStateCreateInfo' structure.
     */
    pVertexInputState?: VkPipelineVertexInputStateCreateInfo | null;

    /**
     * is a reference to an instance of the 'VkPipelineTessellationStateCreateInfo' structure, and is ignored if the shader group does not include a tessellation control shader stage and tessellation evaluation shader stage.
     */
    pTessellationState?: VkPipelineTessellationStateCreateInfo | null;
}

declare interface VkGraphicsShaderGroupCreateInfoNVConstructor {
  readonly prototype: VkGraphicsShaderGroupCreateInfoNV;
  new(param?: VkGraphicsShaderGroupCreateInfoNVInitializer | null): VkGraphicsShaderGroupCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkGraphicsShaderGroupCreateInfoNV: VkGraphicsShaderGroupCreateInfoNVConstructor;



  /**
   * Structure describing push descriptor limits that can be supported by an implementation
   */
interface VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    readonly sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext: null;

    /**
     * is the maximum number of shader groups in 'VkGraphicsPipelineShaderGroupsCreateInfoNV'.
     */
    readonly maxGraphicsShaderGroupCount: number;

    /**
     * is the maximum number of sequences in 'VkGeneratedCommandsInfoNV' and in 'VkGeneratedCommandsMemoryRequirementsInfoNV'.
     */
    readonly maxIndirectSequenceCount: number;

    /**
     *
     */
    readonly maxIndirectCommandsTokenCount: number;

    /**
     * is the maximum number of streams in 'VkIndirectCommandsLayoutCreateInfoNV'.
     */
    readonly maxIndirectCommandsStreamCount: number;

    /**
     * is the maximum offset in 'VkIndirectCommandsLayoutTokenNV'.
     */
    readonly maxIndirectCommandsTokenOffset: number;

    /**
     * is the maximum stream stride in 'VkIndirectCommandsLayoutCreateInfoNV'.
     */
    readonly maxIndirectCommandsStreamStride: number;

    /**
     *
     */
    readonly minSequencesCountBufferOffsetAlignment: number;

    /**
     *
     */
    readonly minSequencesIndexBufferOffsetAlignment: number;

    /**
     * is the minimum alignment for memory addresses used in 'VkIndirectCommandsStreamNV' and as preprocess buffer in 'VkGeneratedCommandsInfoNV'.
     */
    readonly minIndirectCommandsBufferOffsetAlignment: number;

}

declare interface VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVInitializer {
  
    /**
     * is the type of this structure.
     */
    readonly sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    readonly pNext?: null;

    /**
     * is the maximum number of shader groups in 'VkGraphicsPipelineShaderGroupsCreateInfoNV'.
     */
    readonly maxGraphicsShaderGroupCount?: number;

    /**
     * is the maximum number of sequences in 'VkGeneratedCommandsInfoNV' and in 'VkGeneratedCommandsMemoryRequirementsInfoNV'.
     */
    readonly maxIndirectSequenceCount?: number;

    /**
     *
     */
    readonly maxIndirectCommandsTokenCount?: number;

    /**
     * is the maximum number of streams in 'VkIndirectCommandsLayoutCreateInfoNV'.
     */
    readonly maxIndirectCommandsStreamCount?: number;

    /**
     * is the maximum offset in 'VkIndirectCommandsLayoutTokenNV'.
     */
    readonly maxIndirectCommandsTokenOffset?: number;

    /**
     * is the maximum stream stride in 'VkIndirectCommandsLayoutCreateInfoNV'.
     */
    readonly maxIndirectCommandsStreamStride?: number;

    /**
     *
     */
    readonly minSequencesCountBufferOffsetAlignment?: number;

    /**
     *
     */
    readonly minSequencesIndexBufferOffsetAlignment?: number;

    /**
     * is the minimum alignment for memory addresses used in 'VkIndirectCommandsStreamNV' and as preprocess buffer in 'VkGeneratedCommandsInfoNV'.
     */
    readonly minIndirectCommandsBufferOffsetAlignment?: number;
}

declare interface VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVConstructor {
  readonly prototype: VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV;
  new(param?: VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVInitializer | null): VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV: VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNVConstructor;



  /**
   * Structure specifying physical device support
   */
interface VkPhysicalDevicePrivateDataFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports private data. See <<private-data, Private Data>>.
     */
    privateData: boolean;

}

declare interface VkPhysicalDevicePrivateDataFeaturesEXTInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports private data. See <<private-data, Private Data>>.
     */
    privateData?: boolean;
}

declare interface VkPhysicalDevicePrivateDataFeaturesEXTConstructor {
  readonly prototype: VkPhysicalDevicePrivateDataFeaturesEXT;
  new(param?: VkPhysicalDevicePrivateDataFeaturesEXTInitializer | null): VkPhysicalDevicePrivateDataFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDevicePrivateDataFeaturesEXT: VkPhysicalDevicePrivateDataFeaturesEXTConstructor;



  /**
   * Structure specifying the parameters of private data slot construction
   */
interface VkPrivateDataSlotCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkPrivateDataSlotCreateFlagsEXT' specifying additional parameters of the new private data slot
     */
    flags: VkPrivateDataSlotCreateFlagBitsEXT;

}

declare interface VkPrivateDataSlotCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkPrivateDataSlotCreateFlagsEXT' specifying additional parameters of the new private data slot
     */
    flags?: VkPrivateDataSlotCreateFlagBitsEXT;
}

declare interface VkPrivateDataSlotCreateInfoEXTConstructor {
  readonly prototype: VkPrivateDataSlotCreateInfoEXT;
  new(param?: VkPrivateDataSlotCreateInfoEXTInitializer | null): VkPrivateDataSlotCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPrivateDataSlotCreateInfoEXT: VkPrivateDataSlotCreateInfoEXTConstructor;



  /**
   * Reserve private data slots
   */
interface VkDevicePrivateDataCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the amount of slots to reserve.
     */
    privateDataSlotRequestCount: number;

}

declare interface VkDevicePrivateDataCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the amount of slots to reserve.
     */
    privateDataSlotRequestCount?: number;
}

declare interface VkDevicePrivateDataCreateInfoEXTConstructor {
  readonly prototype: VkDevicePrivateDataCreateInfoEXT;
  new(param?: VkDevicePrivateDataCreateInfoEXTInitializer | null): VkDevicePrivateDataCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDevicePrivateDataCreateInfoEXT: VkDevicePrivateDataCreateInfoEXTConstructor;



  /**
   * Structure describing the device-generated commands features that can be supported by an implementation
   */
interface VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     * indicates whether the implementation supports functionality to generate commands on the device. See <<device-generated-commands,Device-Generated Commands>>.
     */
    deviceGeneratedCommands: boolean;

}

declare interface VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     * indicates whether the implementation supports functionality to generate commands on the device. See <<device-generated-commands,Device-Generated Commands>>.
     */
    deviceGeneratedCommands?: boolean;
}

declare interface VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVConstructor {
  readonly prototype: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
  new(param?: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVInitializer | null): VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNVConstructor;



  /**
   * use Windows keyex mutex mechanism to synchronize work
   */
interface VkWin32KeyedMutexAcquireReleaseInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    sType: VkStructureType;

    /**
     *
     */
    pNext: null;

    /**
     *
     */
    acquireCount: number;

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pAcquireSyncs: VkDeviceMemory[] | null;

    /**
     * is an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in 'pAcquireSyncs'.
     */
    pAcquireKeys: BigUint64Array | null;

    /**
     * is an array of timeout values, in millisecond units, for each acquire specified in 'pAcquireKeys'.
     */
    pAcquireTimeoutMilliseconds: Uint32Array | null;

    /**
     *
     */
    releaseCount: number;

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pReleaseSyncs: VkDeviceMemory[] | null;

    /**
     * is an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in 'pReleaseSyncs'.
     */
    pReleaseKeys: BigUint64Array | null;

}

declare interface VkWin32KeyedMutexAcquireReleaseInfoNVInitializer {
  
    /**
     *
     */
    sType?: VkStructureType;

    /**
     *
     */
    pNext?: null;

    /**
     *
     */
    acquireCount?: number;

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pAcquireSyncs?: VkDeviceMemory[] | null;

    /**
     * is an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in 'pAcquireSyncs'.
     */
    pAcquireKeys?: BigUint64Array | null;

    /**
     * is an array of timeout values, in millisecond units, for each acquire specified in 'pAcquireKeys'.
     */
    pAcquireTimeoutMilliseconds?: Uint32Array | null;

    /**
     *
     */
    releaseCount?: number;

    /**
     * is an array of 'VkDeviceMemory' objects which were imported from Direct3D 11 resources.
     */
    pReleaseSyncs?: VkDeviceMemory[] | null;

    /**
     * is an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in 'pReleaseSyncs'.
     */
    pReleaseKeys?: BigUint64Array | null;
}

declare interface VkWin32KeyedMutexAcquireReleaseInfoNVConstructor {
  readonly prototype: VkWin32KeyedMutexAcquireReleaseInfoNV;
  new(param?: VkWin32KeyedMutexAcquireReleaseInfoNVInitializer | null): VkWin32KeyedMutexAcquireReleaseInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkWin32KeyedMutexAcquireReleaseInfoNV: VkWin32KeyedMutexAcquireReleaseInfoNVConstructor;



  /**
   * specify security attributes and access rights for Win32 memory handles
   */
interface VkExportMemoryWin32HandleInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes: bigint | number;

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess: number;

}

declare interface VkExportMemoryWin32HandleInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a reference to a Windows 'SECURITY_ATTRIBUTES' structure specifying security attributes of the handle.
     */
    pAttributes?: bigint | number;

    /**
     * is a 'DWORD' specifying access rights of the handle.
     */
    dwAccess?: number;
}

declare interface VkExportMemoryWin32HandleInfoNVConstructor {
  readonly prototype: VkExportMemoryWin32HandleInfoNV;
  new(param?: VkExportMemoryWin32HandleInfoNVInitializer | null): VkExportMemoryWin32HandleInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportMemoryWin32HandleInfoNV: VkExportMemoryWin32HandleInfoNVConstructor;



  /**
   * import Win32 memory created on the same physical device
   */
interface VkImportMemoryWin32HandleInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is `0` or a 'VkExternalMemoryHandleTypeFlagBitsNV' value specifying the type of memory handle in 'handle'.
     */
    handleType: VkExternalMemoryHandleTypeFlagBitsNV;

    /**
     * is a Windows 'HANDLE' referring to the memory.
     */
    handle: bigint | number;

}

declare interface VkImportMemoryWin32HandleInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is `0` or a 'VkExternalMemoryHandleTypeFlagBitsNV' value specifying the type of memory handle in 'handle'.
     */
    handleType?: VkExternalMemoryHandleTypeFlagBitsNV;

    /**
     * is a Windows 'HANDLE' referring to the memory.
     */
    handle?: bigint | number;
}

declare interface VkImportMemoryWin32HandleInfoNVConstructor {
  readonly prototype: VkImportMemoryWin32HandleInfoNV;
  new(param?: VkImportMemoryWin32HandleInfoNVInitializer | null): VkImportMemoryWin32HandleInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImportMemoryWin32HandleInfoNV: VkImportMemoryWin32HandleInfoNVConstructor;



  /**
   * Specify memory handle types that may be exported
   */
interface VkExportMemoryAllocateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' specifying one or more memory handle types that 'may' be exported. Multiple handle types 'may' be requested for the same allocation as long as they are compatible, as reported by 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'.
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBitsNV;

}

declare interface VkExportMemoryAllocateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' specifying one or more memory handle types that 'may' be exported. Multiple handle types 'may' be requested for the same allocation as long as they are compatible, as reported by 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'.
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBitsNV;
}

declare interface VkExportMemoryAllocateInfoNVConstructor {
  readonly prototype: VkExportMemoryAllocateInfoNV;
  new(param?: VkExportMemoryAllocateInfoNVInitializer | null): VkExportMemoryAllocateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExportMemoryAllocateInfoNV: VkExportMemoryAllocateInfoNVConstructor;



  /**
   * Specify that an image may be backed by external memory
   */
interface VkExternalMemoryImageCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is zero, or a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' specifying one or more external memory handle types.
     */
    handleTypes: VkExternalMemoryHandleTypeFlagBitsNV;

}

declare interface VkExternalMemoryImageCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is zero, or a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' specifying one or more external memory handle types.
     */
    handleTypes?: VkExternalMemoryHandleTypeFlagBitsNV;
}

declare interface VkExternalMemoryImageCreateInfoNVConstructor {
  readonly prototype: VkExternalMemoryImageCreateInfoNV;
  new(param?: VkExternalMemoryImageCreateInfoNVInitializer | null): VkExternalMemoryImageCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalMemoryImageCreateInfoNV: VkExternalMemoryImageCreateInfoNVConstructor;



  /**
   * Structure specifying external image format properties
   */
interface VkExternalImageFormatPropertiesNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * will be filled in as when calling 'vkGetPhysicalDeviceImageFormatProperties', but the values returned 'may' vary depending on the external handle type requested.
     */
    readonly imageFormatProperties: VkImageFormatProperties | null;

    /**
     * is a bitmask of 'VkExternalMemoryFeatureFlagBitsNV', indicating properties of the external memory handle type ('vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType') being queried, or 0 if the external memory handle type is 0.
     */
    readonly externalMemoryFeatures: VkExternalMemoryFeatureFlagBitsNV;

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' containing a bit set for every external handle type that 'may' be used to create memory from which the handles of the type specified in 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType' 'can' be exported, or 0 if the external memory handle type is 0.
     */
    readonly exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagBitsNV;

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' containing a bit set for every external handle type that 'may' be specified simultaneously with the handle type specified by 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType' when calling 'vkAllocateMemory', or 0 if the external memory handle type is 0. 'compatibleHandleTypes' will always contain 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType'
     */
    readonly compatibleHandleTypes: VkExternalMemoryHandleTypeFlagBitsNV;

}

declare interface VkExternalImageFormatPropertiesNVInitializer {
  
    /**
     * will be filled in as when calling 'vkGetPhysicalDeviceImageFormatProperties', but the values returned 'may' vary depending on the external handle type requested.
     */
    readonly imageFormatProperties?: VkImageFormatProperties | null;

    /**
     * is a bitmask of 'VkExternalMemoryFeatureFlagBitsNV', indicating properties of the external memory handle type ('vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType') being queried, or 0 if the external memory handle type is 0.
     */
    readonly externalMemoryFeatures?: VkExternalMemoryFeatureFlagBitsNV;

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' containing a bit set for every external handle type that 'may' be used to create memory from which the handles of the type specified in 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType' 'can' be exported, or 0 if the external memory handle type is 0.
     */
    readonly exportFromImportedHandleTypes?: VkExternalMemoryHandleTypeFlagBitsNV;

    /**
     * is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' containing a bit set for every external handle type that 'may' be specified simultaneously with the handle type specified by 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType' when calling 'vkAllocateMemory', or 0 if the external memory handle type is 0. 'compatibleHandleTypes' will always contain 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV'::'externalHandleType'
     */
    readonly compatibleHandleTypes?: VkExternalMemoryHandleTypeFlagBitsNV;
}

declare interface VkExternalImageFormatPropertiesNVConstructor {
  readonly prototype: VkExternalImageFormatPropertiesNV;
  new(param?: VkExternalImageFormatPropertiesNVInitializer | null): VkExternalImageFormatPropertiesNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExternalImageFormatPropertiesNV: VkExternalImageFormatPropertiesNVConstructor;



  /**
   * Specify a dedicated memory allocation resource
   */
interface VkDedicatedAllocationMemoryAllocateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is 'VK_NULL_HANDLE' or a handle of an image which this memory will be bound to.
     */
    image: VkImage | null;

    /**
     * is 'VK_NULL_HANDLE' or a handle of a buffer which this memory will be bound to.
     */
    buffer: VkBuffer | null;

}

declare interface VkDedicatedAllocationMemoryAllocateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is 'VK_NULL_HANDLE' or a handle of an image which this memory will be bound to.
     */
    image?: VkImage | null;

    /**
     * is 'VK_NULL_HANDLE' or a handle of a buffer which this memory will be bound to.
     */
    buffer?: VkBuffer | null;
}

declare interface VkDedicatedAllocationMemoryAllocateInfoNVConstructor {
  readonly prototype: VkDedicatedAllocationMemoryAllocateInfoNV;
  new(param?: VkDedicatedAllocationMemoryAllocateInfoNVInitializer | null): VkDedicatedAllocationMemoryAllocateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDedicatedAllocationMemoryAllocateInfoNV: VkDedicatedAllocationMemoryAllocateInfoNVConstructor;



  /**
   * Specify that a buffer is bound to a dedicated memory resource
   */
interface VkDedicatedAllocationBufferCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies whether the buffer will have a dedicated allocation bound to it.
     */
    dedicatedAllocation: boolean;

}

declare interface VkDedicatedAllocationBufferCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies whether the buffer will have a dedicated allocation bound to it.
     */
    dedicatedAllocation?: boolean;
}

declare interface VkDedicatedAllocationBufferCreateInfoNVConstructor {
  readonly prototype: VkDedicatedAllocationBufferCreateInfoNV;
  new(param?: VkDedicatedAllocationBufferCreateInfoNVInitializer | null): VkDedicatedAllocationBufferCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDedicatedAllocationBufferCreateInfoNV: VkDedicatedAllocationBufferCreateInfoNVConstructor;



  /**
   * Specify that an image is bound to a dedicated memory resource
   */
interface VkDedicatedAllocationImageCreateInfoNV {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * specifies whether the image will have a dedicated allocation bound to it.
     */
    dedicatedAllocation: boolean;

}

declare interface VkDedicatedAllocationImageCreateInfoNVInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * specifies whether the image will have a dedicated allocation bound to it.
     */
    dedicatedAllocation?: boolean;
}

declare interface VkDedicatedAllocationImageCreateInfoNVConstructor {
  readonly prototype: VkDedicatedAllocationImageCreateInfoNV;
  new(param?: VkDedicatedAllocationImageCreateInfoNVInitializer | null): VkDedicatedAllocationImageCreateInfoNV;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDedicatedAllocationImageCreateInfoNV: VkDedicatedAllocationImageCreateInfoNVConstructor;



  /**
   * Specify parameters of a command buffer marker region
   */
interface VkDebugMarkerMarkerInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a reference to a string containing the name of the marker.
     */
    pMarkerName: string | null;

    /**
     * is an 'optional' RGBA color value that can be associated with the marker. A particular implementation 'may' choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in 'color' are set to 0.0 then it is ignored.
     */
    color: number[] | null;

}

declare interface VkDebugMarkerMarkerInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a reference to a string containing the name of the marker.
     */
    pMarkerName?: string | null;

    /**
     * is an 'optional' RGBA color value that can be associated with the marker. A particular implementation 'may' choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in 'color' are set to 0.0 then it is ignored.
     */
    color?: number[] | null;
}

declare interface VkDebugMarkerMarkerInfoEXTConstructor {
  readonly prototype: VkDebugMarkerMarkerInfoEXT;
  new(param?: VkDebugMarkerMarkerInfoEXTInitializer | null): VkDebugMarkerMarkerInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDebugMarkerMarkerInfoEXT: VkDebugMarkerMarkerInfoEXTConstructor;



  /**
   * Specify parameters of a tag to attach to an object
   */
interface VkDebugMarkerObjectTagInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkDebugReportObjectTypeEXT' specifying the type of the object to be named.
     */
    objectType: VkDebugReportObjectTypeEXT;

    /**
     * is the object to be tagged.
     */
    object: bigint | number;

    /**
     * is a numerical identifier of the tag.
     */
    tagName: bigint | number;

    /**
     * bytes containing the data to be associated with the object.
     */
    tagSize: bigint | number;

    /**
     *
     */
    pTag: ArrayBuffer | null;

}

declare interface VkDebugMarkerObjectTagInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkDebugReportObjectTypeEXT' specifying the type of the object to be named.
     */
    objectType?: VkDebugReportObjectTypeEXT;

    /**
     * is the object to be tagged.
     */
    object?: bigint | number;

    /**
     * is a numerical identifier of the tag.
     */
    tagName?: bigint | number;

    /**
     * bytes containing the data to be associated with the object.
     */
    tagSize?: bigint | number;

    /**
     *
     */
    pTag?: ArrayBuffer | null;
}

declare interface VkDebugMarkerObjectTagInfoEXTConstructor {
  readonly prototype: VkDebugMarkerObjectTagInfoEXT;
  new(param?: VkDebugMarkerObjectTagInfoEXTInitializer | null): VkDebugMarkerObjectTagInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDebugMarkerObjectTagInfoEXT: VkDebugMarkerObjectTagInfoEXTConstructor;



  /**
   * Specify parameters of a name to give to an object
   */
interface VkDebugMarkerObjectNameInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkDebugReportObjectTypeEXT' specifying the type of the object to be named.
     */
    objectType: VkDebugReportObjectTypeEXT;

    /**
     * is the object to be named.
     */
    object: bigint | number;

    /**
     * is a string specifying the name to apply to 'object'.
     */
    pObjectName: string | null;

}

declare interface VkDebugMarkerObjectNameInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkDebugReportObjectTypeEXT' specifying the type of the object to be named.
     */
    objectType?: VkDebugReportObjectTypeEXT;

    /**
     * is the object to be named.
     */
    object?: bigint | number;

    /**
     * is a string specifying the name to apply to 'object'.
     */
    pObjectName?: string | null;
}

declare interface VkDebugMarkerObjectNameInfoEXTConstructor {
  readonly prototype: VkDebugMarkerObjectNameInfoEXT;
  new(param?: VkDebugMarkerObjectNameInfoEXTInitializer | null): VkDebugMarkerObjectNameInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDebugMarkerObjectNameInfoEXT: VkDebugMarkerObjectNameInfoEXTConstructor;



  /**
   * Structure defining rasterization order for a graphics pipeline
   */
interface VkPipelineRasterizationStateRasterizationOrderAMD {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkRasterizationOrderAMD' value specifying the primitive rasterization order to use.
     */
    rasterizationOrder: VkRasterizationOrderAMD;

}

declare interface VkPipelineRasterizationStateRasterizationOrderAMDInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkRasterizationOrderAMD' value specifying the primitive rasterization order to use.
     */
    rasterizationOrder?: VkRasterizationOrderAMD;
}

declare interface VkPipelineRasterizationStateRasterizationOrderAMDConstructor {
  readonly prototype: VkPipelineRasterizationStateRasterizationOrderAMD;
  new(param?: VkPipelineRasterizationStateRasterizationOrderAMDInitializer | null): VkPipelineRasterizationStateRasterizationOrderAMD;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineRasterizationStateRasterizationOrderAMD: VkPipelineRasterizationStateRasterizationOrderAMDConstructor;



  /**
   * Specify validation features to enable or disable for a Vulkan instance
   */
interface VkValidationFeaturesEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of features to enable.
     */
    enabledValidationFeatureCount: number;

    /**
     * is an array of 'VkValidationFeatureEnableEXT' values specifying the validation features to be enabled.
     */
    pEnabledValidationFeatures: Int32Array | null;

    /**
     * is the number of features to disable.
     */
    disabledValidationFeatureCount: number;

    /**
     * is an array of 'VkValidationFeatureDisableEXT' values specifying the validation features to be disabled.
     */
    pDisabledValidationFeatures: Int32Array | null;

}

declare interface VkValidationFeaturesEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of features to enable.
     */
    enabledValidationFeatureCount?: number;

    /**
     * is an array of 'VkValidationFeatureEnableEXT' values specifying the validation features to be enabled.
     */
    pEnabledValidationFeatures?: Int32Array | null;

    /**
     * is the number of features to disable.
     */
    disabledValidationFeatureCount?: number;

    /**
     * is an array of 'VkValidationFeatureDisableEXT' values specifying the validation features to be disabled.
     */
    pDisabledValidationFeatures?: Int32Array | null;
}

declare interface VkValidationFeaturesEXTConstructor {
  readonly prototype: VkValidationFeaturesEXT;
  new(param?: VkValidationFeaturesEXTInitializer | null): VkValidationFeaturesEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkValidationFeaturesEXT: VkValidationFeaturesEXTConstructor;



  /**
   * Specify validation checks to disable for a Vulkan instance
   */
interface VkValidationFlagsEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of checks to disable.
     */
    disabledValidationCheckCount: number;

    /**
     * is an array of 'VkValidationCheckEXT' values specifying the validation checks to be disabled.
     */
    pDisabledValidationChecks: Int32Array | null;

}

declare interface VkValidationFlagsEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of checks to disable.
     */
    disabledValidationCheckCount?: number;

    /**
     * is an array of 'VkValidationCheckEXT' values specifying the validation checks to be disabled.
     */
    pDisabledValidationChecks?: Int32Array | null;
}

declare interface VkValidationFlagsEXTConstructor {
  readonly prototype: VkValidationFlagsEXT;
  new(param?: VkValidationFlagsEXTInitializer | null): VkValidationFlagsEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkValidationFlagsEXT: VkValidationFlagsEXTConstructor;



  /**
   * Structure specifying parameters of a newly created debug report callback
   */
interface VkDebugReportCallbackCreateInfoEXT {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkDebugReportFlagBitsEXT' specifying which event(s) will cause this callback to be called.
     */
    flags: VkDebugReportFlagBitsEXT;

    /**
     * is the application callback function to call.
     */
    pfnCallback: vkDebugReportCallbackEXT | null;

    /**
     * is user data to be passed to the callback.
     */
    pUserData: ArrayBuffer | null;

}

declare interface VkDebugReportCallbackCreateInfoEXTInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkDebugReportFlagBitsEXT' specifying which event(s) will cause this callback to be called.
     */
    flags?: VkDebugReportFlagBitsEXT;

    /**
     * is the application callback function to call.
     */
    pfnCallback?: vkDebugReportCallbackEXT | null;

    /**
     * is user data to be passed to the callback.
     */
    pUserData?: ArrayBuffer | null;
}

declare interface VkDebugReportCallbackCreateInfoEXTConstructor {
  readonly prototype: VkDebugReportCallbackCreateInfoEXT;
  new(param?: VkDebugReportCallbackCreateInfoEXTInitializer | null): VkDebugReportCallbackCreateInfoEXT;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDebugReportCallbackCreateInfoEXT: VkDebugReportCallbackCreateInfoEXTConstructor;



  /**
   * Structure describing parameters of a queue presentation
   */
interface VkPresentInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of semaphores to wait for before issuing the present request. The number 'may' be zero.
     */
    waitSemaphoreCount: number;

    /**
     * is <i>null</i> or a reference to an array of 'VkSemaphore' objects with 'waitSemaphoreCount' entries, and specifies the semaphores to wait for before issuing the present request.
     */
    pWaitSemaphores: VkSemaphore[] | null;

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount: number;

    /**
     * is an array of 'VkSwapchainKHR' objects with 'swapchainCount' entries. A given swapchain 'must' not appear in this list more than once.
     */
    pSwapchains: VkSwapchainKHR[] | null;

    /**
     * is an array of indices into the array of each swapchain's presentable images, with 'swapchainCount' entries. Each entry in this array identifies the image to present on the corresponding entry in the 'pSwapchains' array.
     */
    pImageIndices: Uint32Array | null;

    /**
     * is an array of 'VkResult' typed elements with 'swapchainCount' entries. Applications that do not need per-swapchain results 'can' use <i>null</i> for 'pResults'. If non-<i>null</i>, each entry in 'pResults' will be set to the 'VkResult' for presenting the swapchain corresponding to the same index in 'pSwapchains'.
     */
    pResults: Int32Array | null;

}

declare interface VkPresentInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of semaphores to wait for before issuing the present request. The number 'may' be zero.
     */
    waitSemaphoreCount?: number;

    /**
     * is <i>null</i> or a reference to an array of 'VkSemaphore' objects with 'waitSemaphoreCount' entries, and specifies the semaphores to wait for before issuing the present request.
     */
    pWaitSemaphores?: VkSemaphore[] | null;

    /**
     * is the number of swapchains being presented to by this command.
     */
    swapchainCount?: number;

    /**
     * is an array of 'VkSwapchainKHR' objects with 'swapchainCount' entries. A given swapchain 'must' not appear in this list more than once.
     */
    pSwapchains?: VkSwapchainKHR[] | null;

    /**
     * is an array of indices into the array of each swapchain's presentable images, with 'swapchainCount' entries. Each entry in this array identifies the image to present on the corresponding entry in the 'pSwapchains' array.
     */
    pImageIndices?: Uint32Array | null;

    /**
     * is an array of 'VkResult' typed elements with 'swapchainCount' entries. Applications that do not need per-swapchain results 'can' use <i>null</i> for 'pResults'. If non-<i>null</i>, each entry in 'pResults' will be set to the 'VkResult' for presenting the swapchain corresponding to the same index in 'pSwapchains'.
     */
    pResults?: Int32Array | null;
}

declare interface VkPresentInfoKHRConstructor {
  readonly prototype: VkPresentInfoKHR;
  new(param?: VkPresentInfoKHRInitializer | null): VkPresentInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPresentInfoKHR: VkPresentInfoKHRConstructor;



  /**
   * Structure specifying parameters of a newly created swapchain object
   */
interface VkSwapchainCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkSwapchainCreateFlagBitsKHR' indicating parameters of the swapchain creation.
     */
    flags: VkSwapchainCreateFlagBitsKHR;

    /**
     * is the surface onto which the swapchain will present images. If the creation succeeds, the swapchain becomes associated with 'surface'.
     */
    surface: VkSurfaceKHR | null;

    /**
     * is the minimum number of presentable images that the application needs. The implementation will either create the swapchain with at least that many images, or it will fail to create the swapchain.
     */
    minImageCount: number;

    /**
     * is a 'VkFormat' value specifying the format the swapchain image(s) will be created with.
     */
    imageFormat: VkFormat;

    /**
     * is a 'VkColorSpaceKHR' value specifying the way the swapchain interprets image data.
     */
    imageColorSpace: VkColorSpaceKHR;

    /**
     * is the size (in pixels) of the swapchain image(s). The behavior is platform-dependent if the image extent does not match the surface's 'currentExtent' as returned by 'vkGetPhysicalDeviceSurfaceCapabilitiesKHR'.
     */
    imageExtent: VkExtent2D | null;

    /**
     *
     */
    imageArrayLayers: number;

    /**
     *
     */
    imageUsage: VkImageUsageFlagBits;

    /**
     *
     */
    imageSharingMode: VkSharingMode;

    /**
     *
     */
    queueFamilyIndexCount: number;

    /**
     *
     */
    pQueueFamilyIndices: Uint32Array | null;

    /**
     *
     */
    preTransform: VkSurfaceTransformFlagBitsKHR;

    /**
     *
     */
    compositeAlpha: VkCompositeAlphaFlagBitsKHR;

    /**
     *
     */
    presentMode: VkPresentModeKHR;

    /**
     *
     */
    clipped: boolean;

    /**
     *
     */
    oldSwapchain: VkSwapchainKHR | null;

}

declare interface VkSwapchainCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkSwapchainCreateFlagBitsKHR' indicating parameters of the swapchain creation.
     */
    flags?: VkSwapchainCreateFlagBitsKHR;

    /**
     * is the surface onto which the swapchain will present images. If the creation succeeds, the swapchain becomes associated with 'surface'.
     */
    surface?: VkSurfaceKHR | null;

    /**
     * is the minimum number of presentable images that the application needs. The implementation will either create the swapchain with at least that many images, or it will fail to create the swapchain.
     */
    minImageCount?: number;

    /**
     * is a 'VkFormat' value specifying the format the swapchain image(s) will be created with.
     */
    imageFormat?: VkFormat;

    /**
     * is a 'VkColorSpaceKHR' value specifying the way the swapchain interprets image data.
     */
    imageColorSpace?: VkColorSpaceKHR;

    /**
     * is the size (in pixels) of the swapchain image(s). The behavior is platform-dependent if the image extent does not match the surface's 'currentExtent' as returned by 'vkGetPhysicalDeviceSurfaceCapabilitiesKHR'.
     */
    imageExtent?: VkExtent2D | null;

    /**
     *
     */
    imageArrayLayers?: number;

    /**
     *
     */
    imageUsage?: VkImageUsageFlagBits;

    /**
     *
     */
    imageSharingMode?: VkSharingMode;

    /**
     *
     */
    queueFamilyIndexCount?: number;

    /**
     *
     */
    pQueueFamilyIndices?: Uint32Array | null;

    /**
     *
     */
    preTransform?: VkSurfaceTransformFlagBitsKHR;

    /**
     *
     */
    compositeAlpha?: VkCompositeAlphaFlagBitsKHR;

    /**
     *
     */
    presentMode?: VkPresentModeKHR;

    /**
     *
     */
    clipped?: boolean;

    /**
     *
     */
    oldSwapchain?: VkSwapchainKHR | null;
}

declare interface VkSwapchainCreateInfoKHRConstructor {
  readonly prototype: VkSwapchainCreateInfoKHR;
  new(param?: VkSwapchainCreateInfoKHRInitializer | null): VkSwapchainCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSwapchainCreateInfoKHR: VkSwapchainCreateInfoKHRConstructor;



  /**
   * Structure describing a supported swapchain format-color space pair
   */
interface VkSurfaceFormatKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a 'VkFormat' that is compatible with the specified surface.
     */
    readonly format: VkFormat;

    /**
     * is a presentation 'VkColorSpaceKHR' that is compatible with the surface.
     */
    readonly colorSpace: VkColorSpaceKHR;

}

declare interface VkSurfaceFormatKHRInitializer {
  
    /**
     * is a 'VkFormat' that is compatible with the specified surface.
     */
    readonly format?: VkFormat;

    /**
     * is a presentation 'VkColorSpaceKHR' that is compatible with the surface.
     */
    readonly colorSpace?: VkColorSpaceKHR;
}

declare interface VkSurfaceFormatKHRConstructor {
  readonly prototype: VkSurfaceFormatKHR;
  new(param?: VkSurfaceFormatKHRInitializer | null): VkSurfaceFormatKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSurfaceFormatKHR: VkSurfaceFormatKHRConstructor;



  /**
   * Structure specifying parameters of a newly created Win32 surface object
   */
interface VkWin32SurfaceCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is the Win32 'HINSTANCE' for the window to associate the surface with.
     */
    hinstance: bigint | number;

    /**
     * is the Win32 'HWND' for the window to associate the surface with.
     */
    hwnd: bigint | number;

}

declare interface VkWin32SurfaceCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is the Win32 'HINSTANCE' for the window to associate the surface with.
     */
    hinstance?: bigint | number;

    /**
     * is the Win32 'HWND' for the window to associate the surface with.
     */
    hwnd?: bigint | number;
}

declare interface VkWin32SurfaceCreateInfoKHRConstructor {
  readonly prototype: VkWin32SurfaceCreateInfoKHR;
  new(param?: VkWin32SurfaceCreateInfoKHRInitializer | null): VkWin32SurfaceCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkWin32SurfaceCreateInfoKHR: VkWin32SurfaceCreateInfoKHRConstructor;



  /**
   * Structure describing capabilities of a surface
   */
interface VkSurfaceCapabilitiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the minimum number of images the specified device supports for a swapchain created for the surface, and will be at least one.
     */
    readonly minImageCount: number;

    /**
     * is the maximum number of images the specified device supports for a swapchain created for the surface, and will be either 0, or greater than or equal to 'minImageCount'. A value of 0 means that there is no limit on the number of images, though there 'may' be limits related to the total amount of memory used by presentable images.
     */
    readonly maxImageCount: number;

    /**
     * is the current width and height of the surface, or the special value [eq]#(0xFFFFFFFF, 0xFFFFFFFF)# indicating that the surface size will be determined by the extent of a swapchain targeting the surface.
     */
    readonly currentExtent: VkExtent2D | null;

    /**
     * contains the smallest valid swapchain extent for the surface on the specified device. The 'width' and 'height' of the extent will each be less than or equal to the corresponding 'width' and 'height' of 'currentExtent', unless 'currentExtent' has the special value described above.
     */
    readonly minImageExtent: VkExtent2D | null;

    /**
     * contains the largest valid swapchain extent for the surface on the specified device. The 'width' and 'height' of the extent will each be greater than or equal to the corresponding 'width' and 'height' of 'minImageExtent'. The 'width' and 'height' of the extent will each be greater than or equal to the corresponding 'width' and 'height' of 'currentExtent', unless 'currentExtent' has the special value described above.
     */
    readonly maxImageExtent: VkExtent2D | null;

    /**
     * is the maximum number of layers presentable images 'can' have for a swapchain created for this device and surface, and will be at least one.
     */
    readonly maxImageArrayLayers: number;

    /**
     * is a bitmask of 'VkSurfaceTransformFlagBitsKHR' indicating the presentation transforms supported for the surface on the specified device. At least one bit will be set.
     */
    readonly supportedTransforms: VkSurfaceTransformFlagBitsKHR;

    /**
     * is 'VkSurfaceTransformFlagBitsKHR' value indicating the surface's current transform relative to the presentation engine's natural orientation.
     */
    readonly currentTransform: VkSurfaceTransformFlagBitsKHR;

    /**
     * is a bitmask of 'VkCompositeAlphaFlagBitsKHR', representing the alpha compositing modes supported by the presentation engine for the surface on the specified device, and at least one bit will be set. Opaque composition 'can' be achieved in any alpha compositing mode by either using an image format that has no alpha component, or by ensuring that all pixels in the presentable images have an alpha value of 1.0.
     */
    readonly supportedCompositeAlpha: VkCompositeAlphaFlagBitsKHR;

    /**
     * is a bitmask of 'VkImageUsageFlagBits' representing the ways the application 'can' use the presentable images of a swapchain created with 'VkPresentModeKHR' set to 'VK_PRESENT_MODE_IMMEDIATE_KHR', 'VK_PRESENT_MODE_MAILBOX_KHR', 'VK_PRESENT_MODE_FIFO_KHR' or 'VK_PRESENT_MODE_FIFO_RELAXED_KHR'
     */
    readonly supportedUsageFlags: VkImageUsageFlagBits;

}

declare interface VkSurfaceCapabilitiesKHRInitializer {
  
    /**
     * is the minimum number of images the specified device supports for a swapchain created for the surface, and will be at least one.
     */
    readonly minImageCount?: number;

    /**
     * is the maximum number of images the specified device supports for a swapchain created for the surface, and will be either 0, or greater than or equal to 'minImageCount'. A value of 0 means that there is no limit on the number of images, though there 'may' be limits related to the total amount of memory used by presentable images.
     */
    readonly maxImageCount?: number;

    /**
     * is the current width and height of the surface, or the special value [eq]#(0xFFFFFFFF, 0xFFFFFFFF)# indicating that the surface size will be determined by the extent of a swapchain targeting the surface.
     */
    readonly currentExtent?: VkExtent2D | null;

    /**
     * contains the smallest valid swapchain extent for the surface on the specified device. The 'width' and 'height' of the extent will each be less than or equal to the corresponding 'width' and 'height' of 'currentExtent', unless 'currentExtent' has the special value described above.
     */
    readonly minImageExtent?: VkExtent2D | null;

    /**
     * contains the largest valid swapchain extent for the surface on the specified device. The 'width' and 'height' of the extent will each be greater than or equal to the corresponding 'width' and 'height' of 'minImageExtent'. The 'width' and 'height' of the extent will each be greater than or equal to the corresponding 'width' and 'height' of 'currentExtent', unless 'currentExtent' has the special value described above.
     */
    readonly maxImageExtent?: VkExtent2D | null;

    /**
     * is the maximum number of layers presentable images 'can' have for a swapchain created for this device and surface, and will be at least one.
     */
    readonly maxImageArrayLayers?: number;

    /**
     * is a bitmask of 'VkSurfaceTransformFlagBitsKHR' indicating the presentation transforms supported for the surface on the specified device. At least one bit will be set.
     */
    readonly supportedTransforms?: VkSurfaceTransformFlagBitsKHR;

    /**
     * is 'VkSurfaceTransformFlagBitsKHR' value indicating the surface's current transform relative to the presentation engine's natural orientation.
     */
    readonly currentTransform?: VkSurfaceTransformFlagBitsKHR;

    /**
     * is a bitmask of 'VkCompositeAlphaFlagBitsKHR', representing the alpha compositing modes supported by the presentation engine for the surface on the specified device, and at least one bit will be set. Opaque composition 'can' be achieved in any alpha compositing mode by either using an image format that has no alpha component, or by ensuring that all pixels in the presentable images have an alpha value of 1.0.
     */
    readonly supportedCompositeAlpha?: VkCompositeAlphaFlagBitsKHR;

    /**
     * is a bitmask of 'VkImageUsageFlagBits' representing the ways the application 'can' use the presentable images of a swapchain created with 'VkPresentModeKHR' set to 'VK_PRESENT_MODE_IMMEDIATE_KHR', 'VK_PRESENT_MODE_MAILBOX_KHR', 'VK_PRESENT_MODE_FIFO_KHR' or 'VK_PRESENT_MODE_FIFO_RELAXED_KHR'
     */
    readonly supportedUsageFlags?: VkImageUsageFlagBits;
}

declare interface VkSurfaceCapabilitiesKHRConstructor {
  readonly prototype: VkSurfaceCapabilitiesKHR;
  new(param?: VkSurfaceCapabilitiesKHRInitializer | null): VkSurfaceCapabilitiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSurfaceCapabilitiesKHR: VkSurfaceCapabilitiesKHRConstructor;



  /**
   * Structure describing parameters of a queue presentation to a swapchain
   */
interface VkDisplayPresentInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a rectangular region of pixels to present. It 'must' be a subset of the image being presented. If 'VkDisplayPresentInfoKHR' is not specified, this region will be assumed to be the entire presentable image.
     */
    srcRect: VkRect2D | null;

    /**
     * is a rectangular region within the visible region of the swapchain's display mode. If 'VkDisplayPresentInfoKHR' is not specified, this region will be assumed to be the entire visible region of the visible region of the swapchain's mode. If the specified rectangle is a subset of the display mode's visible region, content from display planes below the swapchain's plane will be visible outside the rectangle. If there are no planes below the swapchain's, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display's visible region, pixels mapping only to those portions of the rectangle will be discarded.
     */
    dstRect: VkRect2D | null;

    /**
     *
     */
    persistent: boolean;

}

declare interface VkDisplayPresentInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a rectangular region of pixels to present. It 'must' be a subset of the image being presented. If 'VkDisplayPresentInfoKHR' is not specified, this region will be assumed to be the entire presentable image.
     */
    srcRect?: VkRect2D | null;

    /**
     * is a rectangular region within the visible region of the swapchain's display mode. If 'VkDisplayPresentInfoKHR' is not specified, this region will be assumed to be the entire visible region of the visible region of the swapchain's mode. If the specified rectangle is a subset of the display mode's visible region, content from display planes below the swapchain's plane will be visible outside the rectangle. If there are no planes below the swapchain's, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display's visible region, pixels mapping only to those portions of the rectangle will be discarded.
     */
    dstRect?: VkRect2D | null;

    /**
     *
     */
    persistent?: boolean;
}

declare interface VkDisplayPresentInfoKHRConstructor {
  readonly prototype: VkDisplayPresentInfoKHR;
  new(param?: VkDisplayPresentInfoKHRInitializer | null): VkDisplayPresentInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayPresentInfoKHR: VkDisplayPresentInfoKHRConstructor;



  /**
   * Structure specifying parameters of a newly created display plane surface object
   */
interface VkDisplaySurfaceCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use, and 'must' be zero.
     */
    flags: number;

    /**
     * is a 'VkDisplayModeKHR' handle specifying the mode to use when displaying this surface.
     */
    displayMode: VkDisplayModeKHR | null;

    /**
     * is the plane on which this surface appears.
     */
    planeIndex: number;

    /**
     * is the z-order of the plane.
     */
    planeStackIndex: number;

    /**
     * is a 'VkSurfaceTransformFlagBitsKHR' value specifying the transformation to apply to images as part of the scanout operation.
     */
    transform: VkSurfaceTransformFlagBitsKHR;

    /**
     * is the global alpha value. This value is ignored if 'alphaMode' is not 'VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR'.
     */
    globalAlpha: number;

    /**
     * is a 'VkDisplayPlaneAlphaFlagBitsKHR' value specifying the type of alpha blending to use.
     */
    alphaMode: VkDisplayPlaneAlphaFlagBitsKHR;

    /**
     * The size of the presentable images to use with the surface.
     */
    imageExtent: VkExtent2D | null;

}

declare interface VkDisplaySurfaceCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use, and 'must' be zero.
     */
    flags?: number;

    /**
     * is a 'VkDisplayModeKHR' handle specifying the mode to use when displaying this surface.
     */
    displayMode?: VkDisplayModeKHR | null;

    /**
     * is the plane on which this surface appears.
     */
    planeIndex?: number;

    /**
     * is the z-order of the plane.
     */
    planeStackIndex?: number;

    /**
     * is a 'VkSurfaceTransformFlagBitsKHR' value specifying the transformation to apply to images as part of the scanout operation.
     */
    transform?: VkSurfaceTransformFlagBitsKHR;

    /**
     * is the global alpha value. This value is ignored if 'alphaMode' is not 'VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR'.
     */
    globalAlpha?: number;

    /**
     * is a 'VkDisplayPlaneAlphaFlagBitsKHR' value specifying the type of alpha blending to use.
     */
    alphaMode?: VkDisplayPlaneAlphaFlagBitsKHR;

    /**
     * The size of the presentable images to use with the surface.
     */
    imageExtent?: VkExtent2D | null;
}

declare interface VkDisplaySurfaceCreateInfoKHRConstructor {
  readonly prototype: VkDisplaySurfaceCreateInfoKHR;
  new(param?: VkDisplaySurfaceCreateInfoKHRInitializer | null): VkDisplaySurfaceCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplaySurfaceCreateInfoKHR: VkDisplaySurfaceCreateInfoKHRConstructor;



  /**
   * Structure describing capabilities of a mode and plane combination
   */
interface VkDisplayPlaneCapabilitiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a bitmask of 'VkDisplayPlaneAlphaFlagBitsKHR' describing the supported alpha blending modes.
     */
    readonly supportedAlpha: VkDisplayPlaneAlphaFlagBitsKHR;

    /**
     * is the minimum source rectangle offset supported by this plane using the specified mode.
     */
    readonly minSrcPosition: VkOffset2D | null;

    /**
     * is the maximum source rectangle offset supported by this plane using the specified mode. The 'x' and 'y' components of 'maxSrcPosition' 'must' each be greater than or equal to the 'x' and 'y' components of 'minSrcPosition', respectively.
     */
    readonly maxSrcPosition: VkOffset2D | null;

    /**
     * is the minimum source rectangle size supported by this plane using the specified mode.
     */
    readonly minSrcExtent: VkExtent2D | null;

    /**
     * is the maximum source rectangle size supported by this plane using the specified mode.
     */
    readonly maxSrcExtent: VkExtent2D | null;

    /**
     *
     */
    readonly minDstPosition: VkOffset2D | null;

    /**
     *
     */
    readonly maxDstPosition: VkOffset2D | null;

    /**
     *
     */
    readonly minDstExtent: VkExtent2D | null;

    /**
     *
     */
    readonly maxDstExtent: VkExtent2D | null;

}

declare interface VkDisplayPlaneCapabilitiesKHRInitializer {
  
    /**
     * is a bitmask of 'VkDisplayPlaneAlphaFlagBitsKHR' describing the supported alpha blending modes.
     */
    readonly supportedAlpha?: VkDisplayPlaneAlphaFlagBitsKHR;

    /**
     * is the minimum source rectangle offset supported by this plane using the specified mode.
     */
    readonly minSrcPosition?: VkOffset2D | null;

    /**
     * is the maximum source rectangle offset supported by this plane using the specified mode. The 'x' and 'y' components of 'maxSrcPosition' 'must' each be greater than or equal to the 'x' and 'y' components of 'minSrcPosition', respectively.
     */
    readonly maxSrcPosition?: VkOffset2D | null;

    /**
     * is the minimum source rectangle size supported by this plane using the specified mode.
     */
    readonly minSrcExtent?: VkExtent2D | null;

    /**
     * is the maximum source rectangle size supported by this plane using the specified mode.
     */
    readonly maxSrcExtent?: VkExtent2D | null;

    /**
     *
     */
    readonly minDstPosition?: VkOffset2D | null;

    /**
     *
     */
    readonly maxDstPosition?: VkOffset2D | null;

    /**
     *
     */
    readonly minDstExtent?: VkExtent2D | null;

    /**
     *
     */
    readonly maxDstExtent?: VkExtent2D | null;
}

declare interface VkDisplayPlaneCapabilitiesKHRConstructor {
  readonly prototype: VkDisplayPlaneCapabilitiesKHR;
  new(param?: VkDisplayPlaneCapabilitiesKHRInitializer | null): VkDisplayPlaneCapabilitiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayPlaneCapabilitiesKHR: VkDisplayPlaneCapabilitiesKHRConstructor;



  /**
   * Structure specifying parameters of a newly created display mode object
   */
interface VkDisplayModeCreateInfoKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use, and 'must' be zero.
     */
    flags: number;

    /**
     * is a 'VkDisplayModeParametersKHR' structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation 'must' return 'VK_ERROR_INITIALIZATION_FAILED'.
     */
    parameters: VkDisplayModeParametersKHR | null;

}

declare interface VkDisplayModeCreateInfoKHRInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use, and 'must' be zero.
     */
    flags?: number;

    /**
     * is a 'VkDisplayModeParametersKHR' structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation 'must' return 'VK_ERROR_INITIALIZATION_FAILED'.
     */
    parameters?: VkDisplayModeParametersKHR | null;
}

declare interface VkDisplayModeCreateInfoKHRConstructor {
  readonly prototype: VkDisplayModeCreateInfoKHR;
  new(param?: VkDisplayModeCreateInfoKHRInitializer | null): VkDisplayModeCreateInfoKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayModeCreateInfoKHR: VkDisplayModeCreateInfoKHRConstructor;



  /**
   * Structure describing display mode properties
   */
interface VkDisplayModePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a handle to the display mode described in this structure. This handle will be valid for the lifetime of the Vulkan instance.
     */
    readonly displayMode: VkDisplayModeKHR | null;

    /**
     * is a 'VkDisplayModeParametersKHR' structure describing the display parameters associated with 'displayMode'.
     */
    readonly parameters: VkDisplayModeParametersKHR | null;

}

declare interface VkDisplayModePropertiesKHRInitializer {
  
    /**
     * is a handle to the display mode described in this structure. This handle will be valid for the lifetime of the Vulkan instance.
     */
    readonly displayMode?: VkDisplayModeKHR | null;

    /**
     * is a 'VkDisplayModeParametersKHR' structure describing the display parameters associated with 'displayMode'.
     */
    readonly parameters?: VkDisplayModeParametersKHR | null;
}

declare interface VkDisplayModePropertiesKHRConstructor {
  readonly prototype: VkDisplayModePropertiesKHR;
  new(param?: VkDisplayModePropertiesKHRInitializer | null): VkDisplayModePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayModePropertiesKHR: VkDisplayModePropertiesKHRConstructor;



  /**
   * Structure describing display parameters associated with a display mode
   */
interface VkDisplayModeParametersKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the 2D extents of the visible region.
     */
    visibleRegion: VkExtent2D | null;

    /**
     * is a 'uint32_t' that is the number of times the display is refreshed each second multiplied by 1000.
     */
    refreshRate: number;

}

declare interface VkDisplayModeParametersKHRInitializer {
  
    /**
     * is the 2D extents of the visible region.
     */
    visibleRegion?: VkExtent2D | null;

    /**
     * is a 'uint32_t' that is the number of times the display is refreshed each second multiplied by 1000.
     */
    refreshRate?: number;
}

declare interface VkDisplayModeParametersKHRConstructor {
  readonly prototype: VkDisplayModeParametersKHR;
  new(param?: VkDisplayModeParametersKHRInitializer | null): VkDisplayModeParametersKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayModeParametersKHR: VkDisplayModeParametersKHRConstructor;



  /**
   * Structure describing display plane properties
   */
interface VkDisplayPlanePropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be 'VK_NULL_HANDLE'.
     */
    readonly currentDisplay: VkDisplayKHR | null;

    /**
     * is the current z-order of the plane. This will be between 0 and the value returned by 'vkGetPhysicalDeviceDisplayPlanePropertiesKHR' in 'pPropertyCount'.
     */
    readonly currentStackIndex: number;

}

declare interface VkDisplayPlanePropertiesKHRInitializer {
  
    /**
     * is the handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be 'VK_NULL_HANDLE'.
     */
    readonly currentDisplay?: VkDisplayKHR | null;

    /**
     * is the current z-order of the plane. This will be between 0 and the value returned by 'vkGetPhysicalDeviceDisplayPlanePropertiesKHR' in 'pPropertyCount'.
     */
    readonly currentStackIndex?: number;
}

declare interface VkDisplayPlanePropertiesKHRConstructor {
  readonly prototype: VkDisplayPlanePropertiesKHR;
  new(param?: VkDisplayPlanePropertiesKHRInitializer | null): VkDisplayPlanePropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayPlanePropertiesKHR: VkDisplayPlanePropertiesKHRConstructor;



  /**
   * Structure describing an available display device
   */
interface VkDisplayPropertiesKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.
     */
    readonly display: VkDisplayKHR | null;

    /**
     * is a reference to a string containing the name of the display. Generally, this will be the name provided by the display's EDID. It 'can' be <i>null</i> if no suitable name is available. If not <i>null</i>, the memory it reference to 'must' remain accessible as long as 'display' is valid.
     */
    readonly displayName: string | null;

    /**
     * describes the physical width and height of the visible portion of the display, in millimeters.
     */
    readonly physicalDimensions: VkExtent2D | null;

    /**
     * describes the physical, native, or preferred resolution of the display.
     */
    readonly physicalResolution: VkExtent2D | null;

    /**
     *
     */
    readonly supportedTransforms: VkSurfaceTransformFlagBitsKHR;

    /**
     *
     */
    readonly planeReorderPossible: boolean;

    /**
     *
     */
    readonly persistentContent: boolean;

}

declare interface VkDisplayPropertiesKHRInitializer {
  
    /**
     * is a handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.
     */
    readonly display?: VkDisplayKHR | null;

    /**
     * is a reference to a string containing the name of the display. Generally, this will be the name provided by the display's EDID. It 'can' be <i>null</i> if no suitable name is available. If not <i>null</i>, the memory it reference to 'must' remain accessible as long as 'display' is valid.
     */
    readonly displayName?: string | null;

    /**
     * describes the physical width and height of the visible portion of the display, in millimeters.
     */
    readonly physicalDimensions?: VkExtent2D | null;

    /**
     * describes the physical, native, or preferred resolution of the display.
     */
    readonly physicalResolution?: VkExtent2D | null;

    /**
     *
     */
    readonly supportedTransforms?: VkSurfaceTransformFlagBitsKHR;

    /**
     *
     */
    readonly planeReorderPossible?: boolean;

    /**
     *
     */
    readonly persistentContent?: boolean;
}

declare interface VkDisplayPropertiesKHRConstructor {
  readonly prototype: VkDisplayPropertiesKHR;
  new(param?: VkDisplayPropertiesKHRInitializer | null): VkDisplayPropertiesKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDisplayPropertiesKHR: VkDisplayPropertiesKHRConstructor;



  /**
   * Structure specifying a queue submit operation
   */
interface VkSubmitInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of semaphores upon which to wait before executing the command buffers for the batch.
     */
    waitSemaphoreCount: number;

    /**
     * is an array of 'VkSemaphore' handles upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a <<synchronization-semaphores-waiting, semaphore wait operation>>.
     */
    pWaitSemaphores: VkSemaphore[] | null;

    /**
     * is an array of pipeline stages at which each corresponding semaphore wait will occur.
     */
    pWaitDstStageMask: Int32Array | null;

    /**
     * is the number of command buffers to execute in the batch.
     */
    commandBufferCount: number;

    /**
     * is an array of 'VkCommandBuffer' handles to execute in the batch.
     */
    pCommandBuffers: VkCommandBuffer[] | null;

    /**
     * is the number of semaphores to be signaled once the commands specified in 'pCommandBuffers' have completed execution.
     */
    signalSemaphoreCount: number;

    /**
     * is an array of 'VkSemaphore' handles which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a <<synchronization-semaphores-signaling, semaphore signal operation>>.
     */
    pSignalSemaphores: VkSemaphore[] | null;

}

declare interface VkSubmitInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of semaphores upon which to wait before executing the command buffers for the batch.
     */
    waitSemaphoreCount?: number;

    /**
     * is an array of 'VkSemaphore' handles upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a <<synchronization-semaphores-waiting, semaphore wait operation>>.
     */
    pWaitSemaphores?: VkSemaphore[] | null;

    /**
     * is an array of pipeline stages at which each corresponding semaphore wait will occur.
     */
    pWaitDstStageMask?: Int32Array | null;

    /**
     * is the number of command buffers to execute in the batch.
     */
    commandBufferCount?: number;

    /**
     * is an array of 'VkCommandBuffer' handles to execute in the batch.
     */
    pCommandBuffers?: VkCommandBuffer[] | null;

    /**
     * is the number of semaphores to be signaled once the commands specified in 'pCommandBuffers' have completed execution.
     */
    signalSemaphoreCount?: number;

    /**
     * is an array of 'VkSemaphore' handles which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a <<synchronization-semaphores-signaling, semaphore signal operation>>.
     */
    pSignalSemaphores?: VkSemaphore[] | null;
}

declare interface VkSubmitInfoConstructor {
  readonly prototype: VkSubmitInfo;
  new(param?: VkSubmitInfoInitializer | null): VkSubmitInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubmitInfo: VkSubmitInfoConstructor;



  /**
   * Structure specifying a dispatch indirect command
   */
interface VkDispatchIndirectCommand {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the number of local workgroups to dispatch in the X dimension.
     */
    x: number;

    /**
     * is the number of local workgroups to dispatch in the Y dimension.
     */
    y: number;

    /**
     * is the number of local workgroups to dispatch in the Z dimension.
     */
    z: number;

}

declare interface VkDispatchIndirectCommandInitializer {
  
    /**
     * is the number of local workgroups to dispatch in the X dimension.
     */
    x?: number;

    /**
     * is the number of local workgroups to dispatch in the Y dimension.
     */
    y?: number;

    /**
     * is the number of local workgroups to dispatch in the Z dimension.
     */
    z?: number;
}

declare interface VkDispatchIndirectCommandConstructor {
  readonly prototype: VkDispatchIndirectCommand;
  new(param?: VkDispatchIndirectCommandInitializer | null): VkDispatchIndirectCommand;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDispatchIndirectCommand: VkDispatchIndirectCommandConstructor;



  /**
   * Structure specifying a draw indexed indirect command
   */
interface VkDrawIndexedIndirectCommand {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the number of vertices to draw.
     */
    indexCount: number;

    /**
     * is the number of instances to draw.
     */
    instanceCount: number;

    /**
     * is the base index within the index buffer.
     */
    firstIndex: number;

    /**
     * is the value added to the vertex index before indexing into the vertex buffer.
     */
    vertexOffset: number;

    /**
     * is the instance ID of the first instance to draw.
     */
    firstInstance: number;

}

declare interface VkDrawIndexedIndirectCommandInitializer {
  
    /**
     * is the number of vertices to draw.
     */
    indexCount?: number;

    /**
     * is the number of instances to draw.
     */
    instanceCount?: number;

    /**
     * is the base index within the index buffer.
     */
    firstIndex?: number;

    /**
     * is the value added to the vertex index before indexing into the vertex buffer.
     */
    vertexOffset?: number;

    /**
     * is the instance ID of the first instance to draw.
     */
    firstInstance?: number;
}

declare interface VkDrawIndexedIndirectCommandConstructor {
  readonly prototype: VkDrawIndexedIndirectCommand;
  new(param?: VkDrawIndexedIndirectCommandInitializer | null): VkDrawIndexedIndirectCommand;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDrawIndexedIndirectCommand: VkDrawIndexedIndirectCommandConstructor;



  /**
   * Structure specifying a draw indirect command
   */
interface VkDrawIndirectCommand {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the number of vertices to draw.
     */
    vertexCount: number;

    /**
     * is the number of instances to draw.
     */
    instanceCount: number;

    /**
     * is the index of the first vertex to draw.
     */
    firstVertex: number;

    /**
     * is the instance ID of the first instance to draw.
     */
    firstInstance: number;

}

declare interface VkDrawIndirectCommandInitializer {
  
    /**
     * is the number of vertices to draw.
     */
    vertexCount?: number;

    /**
     * is the number of instances to draw.
     */
    instanceCount?: number;

    /**
     * is the index of the first vertex to draw.
     */
    firstVertex?: number;

    /**
     * is the instance ID of the first instance to draw.
     */
    firstInstance?: number;
}

declare interface VkDrawIndirectCommandConstructor {
  readonly prototype: VkDrawIndirectCommand;
  new(param?: VkDrawIndirectCommandInitializer | null): VkDrawIndirectCommand;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDrawIndirectCommand: VkDrawIndirectCommandConstructor;



  /**
   * Structure specifying parameters of a newly created framebuffer
   */
interface VkFramebufferCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkFramebufferCreateFlagBits'
     */
    flags: VkFramebufferCreateFlagBits;

    /**
     * is a render pass defining what render passes the framebuffer will be compatible with. See <<renderpass-compatibility,Render Pass Compatibility>> for details.
     */
    renderPass: VkRenderPass | null;

    /**
     * is the number of attachments.
     */
    attachmentCount: number;

    /**
     * is an array of 'VkImageView' handles, each of which will be used as the corresponding attachment in a render pass instance. If 'flags' includes 'VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT', this parameter is ignored.
     */
    pAttachments: VkImageView[] | null;

    /**
     *
     */
    width: number;

    /**
     *
     */
    height: number;

    /**
     *
     */
    layers: number;

}

declare interface VkFramebufferCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkFramebufferCreateFlagBits'
     */
    flags?: VkFramebufferCreateFlagBits;

    /**
     * is a render pass defining what render passes the framebuffer will be compatible with. See <<renderpass-compatibility,Render Pass Compatibility>> for details.
     */
    renderPass?: VkRenderPass | null;

    /**
     * is the number of attachments.
     */
    attachmentCount?: number;

    /**
     * is an array of 'VkImageView' handles, each of which will be used as the corresponding attachment in a render pass instance. If 'flags' includes 'VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT', this parameter is ignored.
     */
    pAttachments?: VkImageView[] | null;

    /**
     *
     */
    width?: number;

    /**
     *
     */
    height?: number;

    /**
     *
     */
    layers?: number;
}

declare interface VkFramebufferCreateInfoConstructor {
  readonly prototype: VkFramebufferCreateInfo;
  new(param?: VkFramebufferCreateInfoInitializer | null): VkFramebufferCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFramebufferCreateInfo: VkFramebufferCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created query pool
   */
interface VkQueryPoolCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is a 'VkQueryType' value specifying the type of queries managed by the pool.
     */
    queryType: VkQueryType;

    /**
     * is the number of queries managed by the pool.
     */
    queryCount: number;

    /**
     * is a bitmask of 'VkQueryPipelineStatisticFlagBits' specifying which counters will be returned in queries on the new pool, as described below in <<queries-pipestats>>.
     */
    pipelineStatistics: VkQueryPipelineStatisticFlagBits;

}

declare interface VkQueryPoolCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is a 'VkQueryType' value specifying the type of queries managed by the pool.
     */
    queryType?: VkQueryType;

    /**
     * is the number of queries managed by the pool.
     */
    queryCount?: number;

    /**
     * is a bitmask of 'VkQueryPipelineStatisticFlagBits' specifying which counters will be returned in queries on the new pool, as described below in <<queries-pipestats>>.
     */
    pipelineStatistics?: VkQueryPipelineStatisticFlagBits;
}

declare interface VkQueryPoolCreateInfoConstructor {
  readonly prototype: VkQueryPoolCreateInfo;
  new(param?: VkQueryPoolCreateInfoInitializer | null): VkQueryPoolCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkQueryPoolCreateInfo: VkQueryPoolCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created semaphore
   */
interface VkSemaphoreCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

}

declare interface VkSemaphoreCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;
}

declare interface VkSemaphoreCreateInfoConstructor {
  readonly prototype: VkSemaphoreCreateInfo;
  new(param?: VkSemaphoreCreateInfoInitializer | null): VkSemaphoreCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSemaphoreCreateInfo: VkSemaphoreCreateInfoConstructor;



  /**
   * Structure reporting implementation-dependent physical device limits
   */
interface VkPhysicalDeviceLimits {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly maxImageDimension1D: number;

    /**
     *
     */
    readonly maxImageDimension2D: number;

    /**
     *
     */
    readonly maxImageDimension3D: number;

    /**
     *
     */
    readonly maxImageDimensionCube: number;

    /**
     *
     */
    readonly maxImageArrayLayers: number;

    /**
     *
     */
    readonly maxTexelBufferElements: number;

    /**
     *
     */
    readonly maxUniformBufferRange: number;

    /**
     *
     */
    readonly maxStorageBufferRange: number;

    /**
     *
     */
    readonly maxPushConstantsSize: number;

    /**
     * is the maximum number of device memory allocations, as created by 'vkAllocateMemory', which 'can' simultaneously exist.
     */
    readonly maxMemoryAllocationCount: number;

    /**
     * is the maximum number of sampler objects, as created by 'vkCreateSampler', which 'can' simultaneously exist on a device.
     */
    readonly maxSamplerAllocationCount: number;

    /**
     * is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources 'can' be bound to adjacent offsets in the same 'VkDeviceMemory' object without aliasing. See <<resources-bufferimagegranularity,Buffer-Image Granularity>> for more details.
     */
    readonly bufferImageGranularity: bigint | number;

    /**
     * is the total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them.
     */
    readonly sparseAddressSpaceSize: bigint | number;

    /**
     * is the maximum number of descriptor sets that 'can' be simultaneously used by a pipeline. All 'DescriptorSet' decorations in shader modules 'must' have a value less than 'maxBoundDescriptorSets'. See <<descriptorsets-sets>>.
     */
    readonly maxBoundDescriptorSets: number;

    /**
     * is the maximum number of samplers that 'can' be accessible to a single shader stage in a pipeline layout. Descriptors with a type of 'VK_DESCRIPTOR_TYPE_SAMPLER' or 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER' count against this limit. Only descriptors in descriptor set layouts created without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT' bit set count against this limit.
     */
    readonly maxPerStageDescriptorSamplers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUniformBuffers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorStorageBuffers: number;

    /**
     *
     */
    readonly maxPerStageDescriptorSampledImages: number;

    /**
     *
     */
    readonly maxPerStageDescriptorStorageImages: number;

    /**
     *
     */
    readonly maxPerStageDescriptorInputAttachments: number;

    /**
     *
     */
    readonly maxPerStageResources: number;

    /**
     *
     */
    readonly maxDescriptorSetSamplers: number;

    /**
     *
     */
    readonly maxDescriptorSetUniformBuffers: number;

    /**
     *
     */
    readonly maxDescriptorSetUniformBuffersDynamic: number;

    /**
     *
     */
    readonly maxDescriptorSetStorageBuffers: number;

    /**
     *
     */
    readonly maxDescriptorSetStorageBuffersDynamic: number;

    /**
     *
     */
    readonly maxDescriptorSetSampledImages: number;

    /**
     *
     */
    readonly maxDescriptorSetStorageImages: number;

    /**
     *
     */
    readonly maxDescriptorSetInputAttachments: number;

    /**
     *
     */
    readonly maxVertexInputAttributes: number;

    /**
     *
     */
    readonly maxVertexInputBindings: number;

    /**
     *
     */
    readonly maxVertexInputAttributeOffset: number;

    /**
     *
     */
    readonly maxVertexInputBindingStride: number;

    /**
     *
     */
    readonly maxVertexOutputComponents: number;

    /**
     *
     */
    readonly maxTessellationGenerationLevel: number;

    /**
     *
     */
    readonly maxTessellationPatchSize: number;

    /**
     *
     */
    readonly maxTessellationControlPerVertexInputComponents: number;

    /**
     *
     */
    readonly maxTessellationControlPerVertexOutputComponents: number;

    /**
     *
     */
    readonly maxTessellationControlPerPatchOutputComponents: number;

    /**
     *
     */
    readonly maxTessellationControlTotalOutputComponents: number;

    /**
     *
     */
    readonly maxTessellationEvaluationInputComponents: number;

    /**
     *
     */
    readonly maxTessellationEvaluationOutputComponents: number;

    /**
     *
     */
    readonly maxGeometryShaderInvocations: number;

    /**
     *
     */
    readonly maxGeometryInputComponents: number;

    /**
     *
     */
    readonly maxGeometryOutputComponents: number;

    /**
     *
     */
    readonly maxGeometryOutputVertices: number;

    /**
     *
     */
    readonly maxGeometryTotalOutputComponents: number;

    /**
     *
     */
    readonly maxFragmentInputComponents: number;

    /**
     *
     */
    readonly maxFragmentOutputAttachments: number;

    /**
     *
     */
    readonly maxFragmentDualSrcAttachments: number;

    /**
     *
     */
    readonly maxFragmentCombinedOutputResources: number;

    /**
     *
     */
    readonly maxComputeSharedMemorySize: number;

    /**
     *
     */
    readonly maxComputeWorkGroupCount: number[] | null;

    /**
     *
     */
    readonly maxComputeWorkGroupInvocations: number;

    /**
     *
     */
    readonly maxComputeWorkGroupSize: number[] | null;

    /**
     *
     */
    readonly subPixelPrecisionBits: number;

    /**
     *
     */
    readonly subTexelPrecisionBits: number;

    /**
     *
     */
    readonly mipmapPrecisionBits: number;

    /**
     *
     */
    readonly maxDrawIndexedIndexValue: number;

    /**
     *
     */
    readonly maxDrawIndirectCount: number;

    /**
     *
     */
    readonly maxSamplerLodBias: number;

    /**
     *
     */
    readonly maxSamplerAnisotropy: number;

    /**
     *
     */
    readonly maxViewports: number;

    /**
     *
     */
    readonly maxViewportDimensions: number[] | null;

    /**
     *
     */
    readonly viewportBoundsRange: number[] | null;

    /**
     *
     */
    readonly viewportSubPixelBits: number;

    /**
     *
     */
    readonly minMemoryMapAlignment: bigint | number;

    /**
     *
     */
    readonly minTexelBufferOffsetAlignment: bigint | number;

    /**
     *
     */
    readonly minUniformBufferOffsetAlignment: bigint | number;

    /**
     *
     */
    readonly minStorageBufferOffsetAlignment: bigint | number;

    /**
     *
     */
    readonly minTexelOffset: number;

    /**
     *
     */
    readonly maxTexelOffset: number;

    /**
     *
     */
    readonly minTexelGatherOffset: number;

    /**
     *
     */
    readonly maxTexelGatherOffset: number;

    /**
     *
     */
    readonly minInterpolationOffset: number;

    /**
     *
     */
    readonly maxInterpolationOffset: number;

    /**
     *
     */
    readonly subPixelInterpolationOffsetBits: number;

    /**
     *
     */
    readonly maxFramebufferWidth: number;

    /**
     *
     */
    readonly maxFramebufferHeight: number;

    /**
     *
     */
    readonly maxFramebufferLayers: number;

    /**
     *
     */
    readonly framebufferColorSampleCounts: VkSampleCountFlagBits;

    /**
     *
     */
    readonly framebufferDepthSampleCounts: VkSampleCountFlagBits;

    /**
     *
     */
    readonly framebufferStencilSampleCounts: VkSampleCountFlagBits;

    /**
     *
     */
    readonly framebufferNoAttachmentsSampleCounts: VkSampleCountFlagBits;

    /**
     *
     */
    readonly maxColorAttachments: number;

    /**
     *
     */
    readonly sampledImageColorSampleCounts: VkSampleCountFlagBits;

    /**
     *
     */
    readonly sampledImageIntegerSampleCounts: VkSampleCountFlagBits;

    /**
     *
     */
    readonly sampledImageDepthSampleCounts: VkSampleCountFlagBits;

    /**
     *
     */
    readonly sampledImageStencilSampleCounts: VkSampleCountFlagBits;

    /**
     *
     */
    readonly storageImageSampleCounts: VkSampleCountFlagBits;

    /**
     *
     */
    readonly maxSampleMaskWords: number;

    /**
     *
     */
    readonly timestampComputeAndGraphics: boolean;

    /**
     *
     */
    readonly timestampPeriod: number;

    /**
     *
     */
    readonly maxClipDistances: number;

    /**
     *
     */
    readonly maxCullDistances: number;

    /**
     *
     */
    readonly maxCombinedClipAndCullDistances: number;

    /**
     *
     */
    readonly discreteQueuePriorities: number;

    /**
     *
     */
    readonly pointSizeRange: number[] | null;

    /**
     *
     */
    readonly lineWidthRange: number[] | null;

    /**
     *
     */
    readonly pointSizeGranularity: number;

    /**
     *
     */
    readonly lineWidthGranularity: number;

    /**
     *
     */
    readonly strictLines: boolean;

    /**
     *
     */
    readonly standardSampleLocations: boolean;

    /**
     *
     */
    readonly optimalBufferCopyOffsetAlignment: bigint | number;

    /**
     *
     */
    readonly optimalBufferCopyRowPitchAlignment: bigint | number;

    /**
     *
     */
    readonly nonCoherentAtomSize: bigint | number;

}

declare interface VkPhysicalDeviceLimitsInitializer {
  
    /**
     *
     */
    readonly maxImageDimension1D?: number;

    /**
     *
     */
    readonly maxImageDimension2D?: number;

    /**
     *
     */
    readonly maxImageDimension3D?: number;

    /**
     *
     */
    readonly maxImageDimensionCube?: number;

    /**
     *
     */
    readonly maxImageArrayLayers?: number;

    /**
     *
     */
    readonly maxTexelBufferElements?: number;

    /**
     *
     */
    readonly maxUniformBufferRange?: number;

    /**
     *
     */
    readonly maxStorageBufferRange?: number;

    /**
     *
     */
    readonly maxPushConstantsSize?: number;

    /**
     * is the maximum number of device memory allocations, as created by 'vkAllocateMemory', which 'can' simultaneously exist.
     */
    readonly maxMemoryAllocationCount?: number;

    /**
     * is the maximum number of sampler objects, as created by 'vkCreateSampler', which 'can' simultaneously exist on a device.
     */
    readonly maxSamplerAllocationCount?: number;

    /**
     * is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources 'can' be bound to adjacent offsets in the same 'VkDeviceMemory' object without aliasing. See <<resources-bufferimagegranularity,Buffer-Image Granularity>> for more details.
     */
    readonly bufferImageGranularity?: bigint | number;

    /**
     * is the total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them.
     */
    readonly sparseAddressSpaceSize?: bigint | number;

    /**
     * is the maximum number of descriptor sets that 'can' be simultaneously used by a pipeline. All 'DescriptorSet' decorations in shader modules 'must' have a value less than 'maxBoundDescriptorSets'. See <<descriptorsets-sets>>.
     */
    readonly maxBoundDescriptorSets?: number;

    /**
     * is the maximum number of samplers that 'can' be accessible to a single shader stage in a pipeline layout. Descriptors with a type of 'VK_DESCRIPTOR_TYPE_SAMPLER' or 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER' count against this limit. Only descriptors in descriptor set layouts created without the 'VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT' bit set count against this limit.
     */
    readonly maxPerStageDescriptorSamplers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorUniformBuffers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorStorageBuffers?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorSampledImages?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorStorageImages?: number;

    /**
     *
     */
    readonly maxPerStageDescriptorInputAttachments?: number;

    /**
     *
     */
    readonly maxPerStageResources?: number;

    /**
     *
     */
    readonly maxDescriptorSetSamplers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUniformBuffers?: number;

    /**
     *
     */
    readonly maxDescriptorSetUniformBuffersDynamic?: number;

    /**
     *
     */
    readonly maxDescriptorSetStorageBuffers?: number;

    /**
     *
     */
    readonly maxDescriptorSetStorageBuffersDynamic?: number;

    /**
     *
     */
    readonly maxDescriptorSetSampledImages?: number;

    /**
     *
     */
    readonly maxDescriptorSetStorageImages?: number;

    /**
     *
     */
    readonly maxDescriptorSetInputAttachments?: number;

    /**
     *
     */
    readonly maxVertexInputAttributes?: number;

    /**
     *
     */
    readonly maxVertexInputBindings?: number;

    /**
     *
     */
    readonly maxVertexInputAttributeOffset?: number;

    /**
     *
     */
    readonly maxVertexInputBindingStride?: number;

    /**
     *
     */
    readonly maxVertexOutputComponents?: number;

    /**
     *
     */
    readonly maxTessellationGenerationLevel?: number;

    /**
     *
     */
    readonly maxTessellationPatchSize?: number;

    /**
     *
     */
    readonly maxTessellationControlPerVertexInputComponents?: number;

    /**
     *
     */
    readonly maxTessellationControlPerVertexOutputComponents?: number;

    /**
     *
     */
    readonly maxTessellationControlPerPatchOutputComponents?: number;

    /**
     *
     */
    readonly maxTessellationControlTotalOutputComponents?: number;

    /**
     *
     */
    readonly maxTessellationEvaluationInputComponents?: number;

    /**
     *
     */
    readonly maxTessellationEvaluationOutputComponents?: number;

    /**
     *
     */
    readonly maxGeometryShaderInvocations?: number;

    /**
     *
     */
    readonly maxGeometryInputComponents?: number;

    /**
     *
     */
    readonly maxGeometryOutputComponents?: number;

    /**
     *
     */
    readonly maxGeometryOutputVertices?: number;

    /**
     *
     */
    readonly maxGeometryTotalOutputComponents?: number;

    /**
     *
     */
    readonly maxFragmentInputComponents?: number;

    /**
     *
     */
    readonly maxFragmentOutputAttachments?: number;

    /**
     *
     */
    readonly maxFragmentDualSrcAttachments?: number;

    /**
     *
     */
    readonly maxFragmentCombinedOutputResources?: number;

    /**
     *
     */
    readonly maxComputeSharedMemorySize?: number;

    /**
     *
     */
    readonly maxComputeWorkGroupCount?: number[] | null;

    /**
     *
     */
    readonly maxComputeWorkGroupInvocations?: number;

    /**
     *
     */
    readonly maxComputeWorkGroupSize?: number[] | null;

    /**
     *
     */
    readonly subPixelPrecisionBits?: number;

    /**
     *
     */
    readonly subTexelPrecisionBits?: number;

    /**
     *
     */
    readonly mipmapPrecisionBits?: number;

    /**
     *
     */
    readonly maxDrawIndexedIndexValue?: number;

    /**
     *
     */
    readonly maxDrawIndirectCount?: number;

    /**
     *
     */
    readonly maxSamplerLodBias?: number;

    /**
     *
     */
    readonly maxSamplerAnisotropy?: number;

    /**
     *
     */
    readonly maxViewports?: number;

    /**
     *
     */
    readonly maxViewportDimensions?: number[] | null;

    /**
     *
     */
    readonly viewportBoundsRange?: number[] | null;

    /**
     *
     */
    readonly viewportSubPixelBits?: number;

    /**
     *
     */
    readonly minMemoryMapAlignment?: bigint | number;

    /**
     *
     */
    readonly minTexelBufferOffsetAlignment?: bigint | number;

    /**
     *
     */
    readonly minUniformBufferOffsetAlignment?: bigint | number;

    /**
     *
     */
    readonly minStorageBufferOffsetAlignment?: bigint | number;

    /**
     *
     */
    readonly minTexelOffset?: number;

    /**
     *
     */
    readonly maxTexelOffset?: number;

    /**
     *
     */
    readonly minTexelGatherOffset?: number;

    /**
     *
     */
    readonly maxTexelGatherOffset?: number;

    /**
     *
     */
    readonly minInterpolationOffset?: number;

    /**
     *
     */
    readonly maxInterpolationOffset?: number;

    /**
     *
     */
    readonly subPixelInterpolationOffsetBits?: number;

    /**
     *
     */
    readonly maxFramebufferWidth?: number;

    /**
     *
     */
    readonly maxFramebufferHeight?: number;

    /**
     *
     */
    readonly maxFramebufferLayers?: number;

    /**
     *
     */
    readonly framebufferColorSampleCounts?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly framebufferDepthSampleCounts?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly framebufferStencilSampleCounts?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly framebufferNoAttachmentsSampleCounts?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly maxColorAttachments?: number;

    /**
     *
     */
    readonly sampledImageColorSampleCounts?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly sampledImageIntegerSampleCounts?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly sampledImageDepthSampleCounts?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly sampledImageStencilSampleCounts?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly storageImageSampleCounts?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly maxSampleMaskWords?: number;

    /**
     *
     */
    readonly timestampComputeAndGraphics?: boolean;

    /**
     *
     */
    readonly timestampPeriod?: number;

    /**
     *
     */
    readonly maxClipDistances?: number;

    /**
     *
     */
    readonly maxCullDistances?: number;

    /**
     *
     */
    readonly maxCombinedClipAndCullDistances?: number;

    /**
     *
     */
    readonly discreteQueuePriorities?: number;

    /**
     *
     */
    readonly pointSizeRange?: number[] | null;

    /**
     *
     */
    readonly lineWidthRange?: number[] | null;

    /**
     *
     */
    readonly pointSizeGranularity?: number;

    /**
     *
     */
    readonly lineWidthGranularity?: number;

    /**
     *
     */
    readonly strictLines?: boolean;

    /**
     *
     */
    readonly standardSampleLocations?: boolean;

    /**
     *
     */
    readonly optimalBufferCopyOffsetAlignment?: bigint | number;

    /**
     *
     */
    readonly optimalBufferCopyRowPitchAlignment?: bigint | number;

    /**
     *
     */
    readonly nonCoherentAtomSize?: bigint | number;
}

declare interface VkPhysicalDeviceLimitsConstructor {
  readonly prototype: VkPhysicalDeviceLimits;
  new(param?: VkPhysicalDeviceLimitsInitializer | null): VkPhysicalDeviceLimits;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceLimits: VkPhysicalDeviceLimitsConstructor;



  /**
   * Structure specifying physical device sparse memory properties
   */
interface VkPhysicalDeviceSparseProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly residencyStandard2DBlockShape: boolean;

    /**
     *
     */
    readonly residencyStandard2DMultisampleBlockShape: boolean;

    /**
     *
     */
    readonly residencyStandard3DBlockShape: boolean;

    /**
     *
     */
    readonly residencyAlignedMipSize: boolean;

    /**
     * specifies whether the physical device 'can' consistently access non-resident regions of a resource. If this property is 'VK_TRUE', access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded.
     */
    readonly residencyNonResidentStrict: boolean;

}

declare interface VkPhysicalDeviceSparsePropertiesInitializer {
  
    /**
     *
     */
    readonly residencyStandard2DBlockShape?: boolean;

    /**
     *
     */
    readonly residencyStandard2DMultisampleBlockShape?: boolean;

    /**
     *
     */
    readonly residencyStandard3DBlockShape?: boolean;

    /**
     *
     */
    readonly residencyAlignedMipSize?: boolean;

    /**
     * specifies whether the physical device 'can' consistently access non-resident regions of a resource. If this property is 'VK_TRUE', access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded.
     */
    readonly residencyNonResidentStrict?: boolean;
}

declare interface VkPhysicalDeviceSparsePropertiesConstructor {
  readonly prototype: VkPhysicalDeviceSparseProperties;
  new(param?: VkPhysicalDeviceSparsePropertiesInitializer | null): VkPhysicalDeviceSparseProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceSparseProperties: VkPhysicalDeviceSparsePropertiesConstructor;



  /**
   * Structure describing the fine-grained features that can be supported by an implementation
   */
interface VkPhysicalDeviceFeatures {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * specifies that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by 'VkDescriptorBufferInfo'::'range', 'VkBufferViewCreateInfo'::'range', or the size of the buffer). Out of bounds accesses 'must' not cause application termination, and the effects of shader loads, stores, and atomics 'must' conform to an implementation-dependent behavior as described below.
     */
    robustBufferAccess: boolean;

    /**
     *
     */
    fullDrawIndexUint32: boolean;

    /**
     *
     */
    imageCubeArray: boolean;

    /**
     *
     */
    independentBlend: boolean;

    /**
     *
     */
    geometryShader: boolean;

    /**
     *
     */
    tessellationShader: boolean;

    /**
     *
     */
    sampleRateShading: boolean;

    /**
     *
     */
    dualSrcBlend: boolean;

    /**
     *
     */
    logicOp: boolean;

    /**
     *
     */
    multiDrawIndirect: boolean;

    /**
     *
     */
    drawIndirectFirstInstance: boolean;

    /**
     *
     */
    depthClamp: boolean;

    /**
     *
     */
    depthBiasClamp: boolean;

    /**
     *
     */
    fillModeNonSolid: boolean;

    /**
     *
     */
    depthBounds: boolean;

    /**
     *
     */
    wideLines: boolean;

    /**
     *
     */
    largePoints: boolean;

    /**
     *
     */
    alphaToOne: boolean;

    /**
     *
     */
    multiViewport: boolean;

    /**
     *
     */
    samplerAnisotropy: boolean;

    /**
     *
     */
    textureCompressionETC2: boolean;

    /**
     *
     */
    textureCompressionASTC_LDR: boolean;

    /**
     *
     */
    textureCompressionBC: boolean;

    /**
     *
     */
    occlusionQueryPrecise: boolean;

    /**
     *
     */
    pipelineStatisticsQuery: boolean;

    /**
     *
     */
    vertexPipelineStoresAndAtomics: boolean;

    /**
     *
     */
    fragmentStoresAndAtomics: boolean;

    /**
     *
     */
    shaderTessellationAndGeometryPointSize: boolean;

    /**
     *
     */
    shaderImageGatherExtended: boolean;

    /**
     *
     */
    shaderStorageImageExtendedFormats: boolean;

    /**
     *
     */
    shaderStorageImageMultisample: boolean;

    /**
     *
     */
    shaderStorageImageReadWithoutFormat: boolean;

    /**
     *
     */
    shaderStorageImageWriteWithoutFormat: boolean;

    /**
     *
     */
    shaderUniformBufferArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderSampledImageArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderStorageBufferArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderStorageImageArrayDynamicIndexing: boolean;

    /**
     *
     */
    shaderClipDistance: boolean;

    /**
     *
     */
    shaderCullDistance: boolean;

    /**
     *
     */
    shaderFloat64: boolean;

    /**
     *
     */
    shaderInt64: boolean;

    /**
     *
     */
    shaderInt16: boolean;

    /**
     *
     */
    shaderResourceResidency: boolean;

    /**
     *
     */
    shaderResourceMinLod: boolean;

    /**
     *
     */
    sparseBinding: boolean;

    /**
     *
     */
    sparseResidencyBuffer: boolean;

    /**
     *
     */
    sparseResidencyImage2D: boolean;

    /**
     *
     */
    sparseResidencyImage3D: boolean;

    /**
     *
     */
    sparseResidency2Samples: boolean;

    /**
     *
     */
    sparseResidency4Samples: boolean;

    /**
     *
     */
    sparseResidency8Samples: boolean;

    /**
     *
     */
    sparseResidency16Samples: boolean;

    /**
     *
     */
    sparseResidencyAliased: boolean;

    /**
     *
     */
    variableMultisampleRate: boolean;

    /**
     *
     */
    inheritedQueries: boolean;

}

declare interface VkPhysicalDeviceFeaturesInitializer {
  
    /**
     * specifies that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by 'VkDescriptorBufferInfo'::'range', 'VkBufferViewCreateInfo'::'range', or the size of the buffer). Out of bounds accesses 'must' not cause application termination, and the effects of shader loads, stores, and atomics 'must' conform to an implementation-dependent behavior as described below.
     */
    robustBufferAccess?: boolean;

    /**
     *
     */
    fullDrawIndexUint32?: boolean;

    /**
     *
     */
    imageCubeArray?: boolean;

    /**
     *
     */
    independentBlend?: boolean;

    /**
     *
     */
    geometryShader?: boolean;

    /**
     *
     */
    tessellationShader?: boolean;

    /**
     *
     */
    sampleRateShading?: boolean;

    /**
     *
     */
    dualSrcBlend?: boolean;

    /**
     *
     */
    logicOp?: boolean;

    /**
     *
     */
    multiDrawIndirect?: boolean;

    /**
     *
     */
    drawIndirectFirstInstance?: boolean;

    /**
     *
     */
    depthClamp?: boolean;

    /**
     *
     */
    depthBiasClamp?: boolean;

    /**
     *
     */
    fillModeNonSolid?: boolean;

    /**
     *
     */
    depthBounds?: boolean;

    /**
     *
     */
    wideLines?: boolean;

    /**
     *
     */
    largePoints?: boolean;

    /**
     *
     */
    alphaToOne?: boolean;

    /**
     *
     */
    multiViewport?: boolean;

    /**
     *
     */
    samplerAnisotropy?: boolean;

    /**
     *
     */
    textureCompressionETC2?: boolean;

    /**
     *
     */
    textureCompressionASTC_LDR?: boolean;

    /**
     *
     */
    textureCompressionBC?: boolean;

    /**
     *
     */
    occlusionQueryPrecise?: boolean;

    /**
     *
     */
    pipelineStatisticsQuery?: boolean;

    /**
     *
     */
    vertexPipelineStoresAndAtomics?: boolean;

    /**
     *
     */
    fragmentStoresAndAtomics?: boolean;

    /**
     *
     */
    shaderTessellationAndGeometryPointSize?: boolean;

    /**
     *
     */
    shaderImageGatherExtended?: boolean;

    /**
     *
     */
    shaderStorageImageExtendedFormats?: boolean;

    /**
     *
     */
    shaderStorageImageMultisample?: boolean;

    /**
     *
     */
    shaderStorageImageReadWithoutFormat?: boolean;

    /**
     *
     */
    shaderStorageImageWriteWithoutFormat?: boolean;

    /**
     *
     */
    shaderUniformBufferArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderSampledImageArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderStorageBufferArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderStorageImageArrayDynamicIndexing?: boolean;

    /**
     *
     */
    shaderClipDistance?: boolean;

    /**
     *
     */
    shaderCullDistance?: boolean;

    /**
     *
     */
    shaderFloat64?: boolean;

    /**
     *
     */
    shaderInt64?: boolean;

    /**
     *
     */
    shaderInt16?: boolean;

    /**
     *
     */
    shaderResourceResidency?: boolean;

    /**
     *
     */
    shaderResourceMinLod?: boolean;

    /**
     *
     */
    sparseBinding?: boolean;

    /**
     *
     */
    sparseResidencyBuffer?: boolean;

    /**
     *
     */
    sparseResidencyImage2D?: boolean;

    /**
     *
     */
    sparseResidencyImage3D?: boolean;

    /**
     *
     */
    sparseResidency2Samples?: boolean;

    /**
     *
     */
    sparseResidency4Samples?: boolean;

    /**
     *
     */
    sparseResidency8Samples?: boolean;

    /**
     *
     */
    sparseResidency16Samples?: boolean;

    /**
     *
     */
    sparseResidencyAliased?: boolean;

    /**
     *
     */
    variableMultisampleRate?: boolean;

    /**
     *
     */
    inheritedQueries?: boolean;
}

declare interface VkPhysicalDeviceFeaturesConstructor {
  readonly prototype: VkPhysicalDeviceFeatures;
  new(param?: VkPhysicalDeviceFeaturesInitializer | null): VkPhysicalDeviceFeatures;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceFeatures: VkPhysicalDeviceFeaturesConstructor;



  /**
   * Structure specifying parameters of a newly created fence
   */
interface VkFenceCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkFenceCreateFlagBits' specifying the initial state and behavior of the fence.
     */
    flags: VkFenceCreateFlagBits;

}

declare interface VkFenceCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkFenceCreateFlagBits' specifying the initial state and behavior of the fence.
     */
    flags?: VkFenceCreateFlagBits;
}

declare interface VkFenceCreateInfoConstructor {
  readonly prototype: VkFenceCreateInfo;
  new(param?: VkFenceCreateInfoInitializer | null): VkFenceCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFenceCreateInfo: VkFenceCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created event
   */
interface VkEventCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

}

declare interface VkEventCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;
}

declare interface VkEventCreateInfoConstructor {
  readonly prototype: VkEventCreateInfo;
  new(param?: VkEventCreateInfoInitializer | null): VkEventCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkEventCreateInfo: VkEventCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created render pass
   */
interface VkRenderPassCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.ifndef::VK_QCOM_render_pass_transform[]
     */
    pNext: null;

    /**
     * is a bitmask of 'VkRenderPassCreateFlagBits'
     */
    flags: VkRenderPassCreateFlagBits;

    /**
     *
     */
    attachmentCount: number;

    /**
     *
     */
    pAttachments: VkAttachmentDescription[] | null;

    /**
     *
     */
    subpassCount: number;

    /**
     *
     */
    pSubpasses: VkSubpassDescription[] | null;

    /**
     *
     */
    dependencyCount: number;

    /**
     *
     */
    pDependencies: VkSubpassDependency[] | null;

}

declare interface VkRenderPassCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.ifndef::VK_QCOM_render_pass_transform[]
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkRenderPassCreateFlagBits'
     */
    flags?: VkRenderPassCreateFlagBits;

    /**
     *
     */
    attachmentCount?: number;

    /**
     *
     */
    pAttachments?: VkAttachmentDescription[] | null;

    /**
     *
     */
    subpassCount?: number;

    /**
     *
     */
    pSubpasses?: VkSubpassDescription[] | null;

    /**
     *
     */
    dependencyCount?: number;

    /**
     *
     */
    pDependencies?: VkSubpassDependency[] | null;
}

declare interface VkRenderPassCreateInfoConstructor {
  readonly prototype: VkRenderPassCreateInfo;
  new(param?: VkRenderPassCreateInfoInitializer | null): VkRenderPassCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassCreateInfo: VkRenderPassCreateInfoConstructor;



  /**
   * Structure specifying a subpass dependency
   */
interface VkSubpassDependency {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the subpass index of the first subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    srcSubpass: number;

    /**
     * is the subpass index of the second subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    dstSubpass: number;

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, source stage mask>>.
     */
    srcStageMask: VkPipelineStageFlagBits;

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, destination stage mask>>
     */
    dstStageMask: VkPipelineStageFlagBits;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask: VkAccessFlagBits;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask: VkAccessFlagBits;

    /**
     * is a bitmask of 'VkDependencyFlagBits'.
     */
    dependencyFlags: VkDependencyFlagBits;

}

declare interface VkSubpassDependencyInitializer {
  
    /**
     * is the subpass index of the first subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    srcSubpass?: number;

    /**
     * is the subpass index of the second subpass in the dependency, or 'VK_SUBPASS_EXTERNAL'.
     */
    dstSubpass?: number;

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, source stage mask>>.
     */
    srcStageMask?: VkPipelineStageFlagBits;

    /**
     * is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, destination stage mask>>
     */
    dstStageMask?: VkPipelineStageFlagBits;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask?: VkAccessFlagBits;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask?: VkAccessFlagBits;

    /**
     * is a bitmask of 'VkDependencyFlagBits'.
     */
    dependencyFlags?: VkDependencyFlagBits;
}

declare interface VkSubpassDependencyConstructor {
  readonly prototype: VkSubpassDependency;
  new(param?: VkSubpassDependencyInitializer | null): VkSubpassDependency;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassDependency: VkSubpassDependencyConstructor;



  /**
   * Structure specifying a subpass description
   */
interface VkSubpassDescription {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a bitmask of 'VkSubpassDescriptionFlagBits' specifying usage of the subpass.
     */
    flags: VkSubpassDescriptionFlagBits;

    /**
     * is a 'VkPipelineBindPoint' value specifying the pipeline type supported for this subpass.
     */
    pipelineBindPoint: VkPipelineBindPoint;

    /**
     * is the number of input attachments.
     */
    inputAttachmentCount: number;

    /**
     * is an array of 'VkAttachmentReference' structures defining the input attachments for this subpass and their layouts.
     */
    pInputAttachments: VkAttachmentReference[] | null;

    /**
     * is the number of color attachments.
     */
    colorAttachmentCount: number;

    /**
     * is an array of 'VkAttachmentReference' structures defining the color attachments for this subpass and their layouts.
     */
    pColorAttachments: VkAttachmentReference[] | null;

    /**
     * is an optional array of 'colorAttachmentCount' 'VkAttachmentReference' structures defining the resolve attachments for this subpass and their layouts.
     */
    pResolveAttachments: VkAttachmentReference[] | null;

    /**
     * is a reference to a 'VkAttachmentReference' structure specifying the depth/stencil attachment for this subpass and its layout.
     */
    pDepthStencilAttachment: VkAttachmentReference | null;

    /**
     * is the number of preserved attachments.
     */
    preserveAttachmentCount: number;

    /**
     * is an array of 'preserveAttachmentCount' render pass attachment indices identifying attachments that are not used by this subpass, but whose contents 'must' be preserved throughout the subpass.
     */
    pPreserveAttachments: Uint32Array | null;

}

declare interface VkSubpassDescriptionInitializer {
  
    /**
     * is a bitmask of 'VkSubpassDescriptionFlagBits' specifying usage of the subpass.
     */
    flags?: VkSubpassDescriptionFlagBits;

    /**
     * is a 'VkPipelineBindPoint' value specifying the pipeline type supported for this subpass.
     */
    pipelineBindPoint?: VkPipelineBindPoint;

    /**
     * is the number of input attachments.
     */
    inputAttachmentCount?: number;

    /**
     * is an array of 'VkAttachmentReference' structures defining the input attachments for this subpass and their layouts.
     */
    pInputAttachments?: VkAttachmentReference[] | null;

    /**
     * is the number of color attachments.
     */
    colorAttachmentCount?: number;

    /**
     * is an array of 'VkAttachmentReference' structures defining the color attachments for this subpass and their layouts.
     */
    pColorAttachments?: VkAttachmentReference[] | null;

    /**
     * is an optional array of 'colorAttachmentCount' 'VkAttachmentReference' structures defining the resolve attachments for this subpass and their layouts.
     */
    pResolveAttachments?: VkAttachmentReference[] | null;

    /**
     * is a reference to a 'VkAttachmentReference' structure specifying the depth/stencil attachment for this subpass and its layout.
     */
    pDepthStencilAttachment?: VkAttachmentReference | null;

    /**
     * is the number of preserved attachments.
     */
    preserveAttachmentCount?: number;

    /**
     * is an array of 'preserveAttachmentCount' render pass attachment indices identifying attachments that are not used by this subpass, but whose contents 'must' be preserved throughout the subpass.
     */
    pPreserveAttachments?: Uint32Array | null;
}

declare interface VkSubpassDescriptionConstructor {
  readonly prototype: VkSubpassDescription;
  new(param?: VkSubpassDescriptionInitializer | null): VkSubpassDescription;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubpassDescription: VkSubpassDescriptionConstructor;



  /**
   * Structure specifying an attachment reference
   */
interface VkAttachmentReference {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is either a number value identifying an attachment at the corresponding index in 'VkRenderPassCreateInfo'::'pAttachments', or 'VK_ATTACHMENT_UNUSED' to signify that this attachment is not used.
     */
    attachment: number;

    /**
     * is a 'VkImageLayout' value specifying the layout the attachment uses during the subpass.
     */
    layout: VkImageLayout;

}

declare interface VkAttachmentReferenceInitializer {
  
    /**
     * is either a number value identifying an attachment at the corresponding index in 'VkRenderPassCreateInfo'::'pAttachments', or 'VK_ATTACHMENT_UNUSED' to signify that this attachment is not used.
     */
    attachment?: number;

    /**
     * is a 'VkImageLayout' value specifying the layout the attachment uses during the subpass.
     */
    layout?: VkImageLayout;
}

declare interface VkAttachmentReferenceConstructor {
  readonly prototype: VkAttachmentReference;
  new(param?: VkAttachmentReferenceInitializer | null): VkAttachmentReference;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentReference: VkAttachmentReferenceConstructor;



  /**
   * Structure specifying an attachment description
   */
interface VkAttachmentDescription {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a bitmask of 'VkAttachmentDescriptionFlagBits' specifying additional properties of the attachment.
     */
    flags: VkAttachmentDescriptionFlagBits;

    /**
     * is a 'VkFormat' value specifying the format of the image view that will be used for the attachment.
     */
    format: VkFormat;

    /**
     * is the number of samples of the image as defined in 'VkSampleCountFlagBits'.
     */
    samples: VkSampleCountFlagBits;

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of color and depth components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    loadOp: VkAttachmentLoadOp;

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of color and depth components of the attachment are treated at the end of the subpass where it is last used.
     */
    storeOp: VkAttachmentStoreOp;

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of stencil components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    stencilLoadOp: VkAttachmentLoadOp;

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of stencil components of the attachment are treated at the end of the last subpass where it is used.
     */
    stencilStoreOp: VkAttachmentStoreOp;

    /**
     * is the layout the attachment image subresource will be in when a render pass instance begins.
     */
    initialLayout: VkImageLayout;

    /**
     * is the layout the attachment image subresource will be transitioned to when a render pass instance ends.
     */
    finalLayout: VkImageLayout;

}

declare interface VkAttachmentDescriptionInitializer {
  
    /**
     * is a bitmask of 'VkAttachmentDescriptionFlagBits' specifying additional properties of the attachment.
     */
    flags?: VkAttachmentDescriptionFlagBits;

    /**
     * is a 'VkFormat' value specifying the format of the image view that will be used for the attachment.
     */
    format?: VkFormat;

    /**
     * is the number of samples of the image as defined in 'VkSampleCountFlagBits'.
     */
    samples?: VkSampleCountFlagBits;

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of color and depth components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    loadOp?: VkAttachmentLoadOp;

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of color and depth components of the attachment are treated at the end of the subpass where it is last used.
     */
    storeOp?: VkAttachmentStoreOp;

    /**
     * is a 'VkAttachmentLoadOp' value specifying how the contents of stencil components of the attachment are treated at the beginning of the subpass where it is first used.
     */
    stencilLoadOp?: VkAttachmentLoadOp;

    /**
     * is a 'VkAttachmentStoreOp' value specifying how the contents of stencil components of the attachment are treated at the end of the last subpass where it is used.
     */
    stencilStoreOp?: VkAttachmentStoreOp;

    /**
     * is the layout the attachment image subresource will be in when a render pass instance begins.
     */
    initialLayout?: VkImageLayout;

    /**
     * is the layout the attachment image subresource will be transitioned to when a render pass instance ends.
     */
    finalLayout?: VkImageLayout;
}

declare interface VkAttachmentDescriptionConstructor {
  readonly prototype: VkAttachmentDescription;
  new(param?: VkAttachmentDescriptionInitializer | null): VkAttachmentDescription;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAttachmentDescription: VkAttachmentDescriptionConstructor;



  /**
   * Structure specifying a clear attachment
   */
interface VkClearAttachment {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a mask selecting the color, depth and/or stencil aspects of the attachment to be cleared.
     */
    aspectMask: VkImageAspectFlagBits;

    /**
     * is only meaningful if 'VK_IMAGE_ASPECT_COLOR_BIT' is set in 'aspectMask', in which case it is an index to the 'pColorAttachments' array in the 'VkSubpassDescription' structure of the current subpass which selects the color attachment to clear.
     */
    colorAttachment: number;

    /**
     * is the color or depth/stencil value to clear the attachment to, as described in <<clears-values,Clear Values>> below.
     */
    clearValue: VkClearValue | null;

}

declare interface VkClearAttachmentInitializer {
  
    /**
     * is a mask selecting the color, depth and/or stencil aspects of the attachment to be cleared.
     */
    aspectMask?: VkImageAspectFlagBits;

    /**
     * is only meaningful if 'VK_IMAGE_ASPECT_COLOR_BIT' is set in 'aspectMask', in which case it is an index to the 'pColorAttachments' array in the 'VkSubpassDescription' structure of the current subpass which selects the color attachment to clear.
     */
    colorAttachment?: number;

    /**
     * is the color or depth/stencil value to clear the attachment to, as described in <<clears-values,Clear Values>> below.
     */
    clearValue?: VkClearValue | null;
}

declare interface VkClearAttachmentConstructor {
  readonly prototype: VkClearAttachment;
  new(param?: VkClearAttachmentInitializer | null): VkClearAttachment;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkClearAttachment: VkClearAttachmentConstructor;



  /**
   * Structure specifying a clear depth stencil value
   */
interface VkClearDepthStencilValue {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment's format.
     */
    depth: number;

    /**
     * is the clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment's format by taking the appropriate number of LSBs.
     */
    stencil: number;

}

declare interface VkClearDepthStencilValueInitializer {
  
    /**
     * is the clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment's format.
     */
    depth?: number;

    /**
     * is the clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment's format by taking the appropriate number of LSBs.
     */
    stencil?: number;
}

declare interface VkClearDepthStencilValueConstructor {
  readonly prototype: VkClearDepthStencilValue;
  new(param?: VkClearDepthStencilValueInitializer | null): VkClearDepthStencilValue;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkClearDepthStencilValue: VkClearDepthStencilValueConstructor;



  /**
   * Structure specifying render pass begin info
   */
interface VkRenderPassBeginInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the render pass to begin an instance of.
     */
    renderPass: VkRenderPass | null;

    /**
     * is the framebuffer containing the attachments that are used with the render pass.
     */
    framebuffer: VkFramebuffer | null;

    /**
     * is the render area that is affected by the render pass instance, and is described in more detail below.
     */
    renderArea: VkRect2D | null;

    /**
     * 'VkClearValue' structures that contains clear values for each attachment, if the attachment uses a 'loadOp' value of 'VK_ATTACHMENT_LOAD_OP_CLEAR' or if the attachment has a depth/stencil format and uses a 'stencilLoadOp' value of 'VK_ATTACHMENT_LOAD_OP_CLEAR'. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of 'pClearValues' are ignored.
     */
    clearValueCount: number;

    /**
     *
     */
    pClearValues: VkClearValue[] | null;

}

declare interface VkRenderPassBeginInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the render pass to begin an instance of.
     */
    renderPass?: VkRenderPass | null;

    /**
     * is the framebuffer containing the attachments that are used with the render pass.
     */
    framebuffer?: VkFramebuffer | null;

    /**
     * is the render area that is affected by the render pass instance, and is described in more detail below.
     */
    renderArea?: VkRect2D | null;

    /**
     * 'VkClearValue' structures that contains clear values for each attachment, if the attachment uses a 'loadOp' value of 'VK_ATTACHMENT_LOAD_OP_CLEAR' or if the attachment has a depth/stencil format and uses a 'stencilLoadOp' value of 'VK_ATTACHMENT_LOAD_OP_CLEAR'. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of 'pClearValues' are ignored.
     */
    clearValueCount?: number;

    /**
     *
     */
    pClearValues?: VkClearValue[] | null;
}

declare interface VkRenderPassBeginInfoConstructor {
  readonly prototype: VkRenderPassBeginInfo;
  new(param?: VkRenderPassBeginInfoInitializer | null): VkRenderPassBeginInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRenderPassBeginInfo: VkRenderPassBeginInfoConstructor;



  /**
   * Structure specifying a command buffer begin operation
   */
interface VkCommandBufferBeginInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkCommandBufferUsageFlagBits' specifying usage behavior for the command buffer.
     */
    flags: VkCommandBufferUsageFlagBits;

    /**
     * is a reference to a 'VkCommandBufferInheritanceInfo' structure, used if 'commandBuffer' is a secondary command buffer. If this is a primary command buffer, then this value is ignored.
     */
    pInheritanceInfo: VkCommandBufferInheritanceInfo | null;

}

declare interface VkCommandBufferBeginInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkCommandBufferUsageFlagBits' specifying usage behavior for the command buffer.
     */
    flags?: VkCommandBufferUsageFlagBits;

    /**
     * is a reference to a 'VkCommandBufferInheritanceInfo' structure, used if 'commandBuffer' is a secondary command buffer. If this is a primary command buffer, then this value is ignored.
     */
    pInheritanceInfo?: VkCommandBufferInheritanceInfo | null;
}

declare interface VkCommandBufferBeginInfoConstructor {
  readonly prototype: VkCommandBufferBeginInfo;
  new(param?: VkCommandBufferBeginInfoInitializer | null): VkCommandBufferBeginInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCommandBufferBeginInfo: VkCommandBufferBeginInfoConstructor;



  /**
   * Structure specifying command buffer inheritance info
   */
interface VkCommandBufferInheritanceInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a 'VkRenderPass' object defining which render passes the 'VkCommandBuffer' will be <<renderpass-compatibility, compatible>> with and 'can' be executed within. If the 'VkCommandBuffer' will not be executed within a render pass instance, 'renderPass' is ignored.
     */
    renderPass: VkRenderPass | null;

    /**
     * is the index of the subpass within the render pass instance that the 'VkCommandBuffer' will be executed within. If the 'VkCommandBuffer' will not be executed within a render pass instance, 'subpass' is ignored.
     */
    subpass: number;

    /**
     * optionally refers to the 'VkFramebuffer' object that the 'VkCommandBuffer' will be rendering to if it is executed within a render pass instance. It 'can' be 'VK_NULL_HANDLE' if the framebuffer is not known, or if the 'VkCommandBuffer' will not be executed within a render pass instance.+[NOTE].Note====Specifying the exact framebuffer that the secondary command buffer will beexecuted with 'may' result in better performance at command buffer executiontime.====
     */
    framebuffer: VkFramebuffer | null;

    /**
     * specifies whether the command buffer 'can' be executed while an occlusion query is active in the primary command buffer. If this is 'VK_TRUE', then this command buffer 'can' be executed whether the primary command buffer has an occlusion query active or not. If this is 'VK_FALSE', then the primary command buffer 'must' not have an occlusion query active.
     */
    occlusionQueryEnable: boolean;

    /**
     * specifies the query flags that 'can' be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the 'VK_QUERY_CONTROL_PRECISE_BIT' bit, then the active query 'can' return boolean results or actual sample counts. If this bit is not set, then the active query 'must' not use the 'VK_QUERY_CONTROL_PRECISE_BIT' bit.
     */
    queryFlags: VkQueryControlFlagBits;

    /**
     * is a bitmask of 'VkQueryPipelineStatisticFlagBits' specifying the set of pipeline statistics that 'can' be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer 'can' be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query 'must' not be from a query pool that counts that statistic.
     */
    pipelineStatistics: VkQueryPipelineStatisticFlagBits;

}

declare interface VkCommandBufferInheritanceInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a 'VkRenderPass' object defining which render passes the 'VkCommandBuffer' will be <<renderpass-compatibility, compatible>> with and 'can' be executed within. If the 'VkCommandBuffer' will not be executed within a render pass instance, 'renderPass' is ignored.
     */
    renderPass?: VkRenderPass | null;

    /**
     * is the index of the subpass within the render pass instance that the 'VkCommandBuffer' will be executed within. If the 'VkCommandBuffer' will not be executed within a render pass instance, 'subpass' is ignored.
     */
    subpass?: number;

    /**
     * optionally refers to the 'VkFramebuffer' object that the 'VkCommandBuffer' will be rendering to if it is executed within a render pass instance. It 'can' be 'VK_NULL_HANDLE' if the framebuffer is not known, or if the 'VkCommandBuffer' will not be executed within a render pass instance.+[NOTE].Note====Specifying the exact framebuffer that the secondary command buffer will beexecuted with 'may' result in better performance at command buffer executiontime.====
     */
    framebuffer?: VkFramebuffer | null;

    /**
     * specifies whether the command buffer 'can' be executed while an occlusion query is active in the primary command buffer. If this is 'VK_TRUE', then this command buffer 'can' be executed whether the primary command buffer has an occlusion query active or not. If this is 'VK_FALSE', then the primary command buffer 'must' not have an occlusion query active.
     */
    occlusionQueryEnable?: boolean;

    /**
     * specifies the query flags that 'can' be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the 'VK_QUERY_CONTROL_PRECISE_BIT' bit, then the active query 'can' return boolean results or actual sample counts. If this bit is not set, then the active query 'must' not use the 'VK_QUERY_CONTROL_PRECISE_BIT' bit.
     */
    queryFlags?: VkQueryControlFlagBits;

    /**
     * is a bitmask of 'VkQueryPipelineStatisticFlagBits' specifying the set of pipeline statistics that 'can' be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer 'can' be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query 'must' not be from a query pool that counts that statistic.
     */
    pipelineStatistics?: VkQueryPipelineStatisticFlagBits;
}

declare interface VkCommandBufferInheritanceInfoConstructor {
  readonly prototype: VkCommandBufferInheritanceInfo;
  new(param?: VkCommandBufferInheritanceInfoInitializer | null): VkCommandBufferInheritanceInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCommandBufferInheritanceInfo: VkCommandBufferInheritanceInfoConstructor;



  /**
   * Structure specifying the allocation parameters for command buffer object
   */
interface VkCommandBufferAllocateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the command pool from which the command buffers are allocated.
     */
    commandPool: VkCommandPool | null;

    /**
     * is a 'VkCommandBufferLevel' value specifying the command buffer level.
     */
    level: VkCommandBufferLevel;

    /**
     * is the number of command buffers to allocate from the pool.
     */
    commandBufferCount: number;

}

declare interface VkCommandBufferAllocateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the command pool from which the command buffers are allocated.
     */
    commandPool?: VkCommandPool | null;

    /**
     * is a 'VkCommandBufferLevel' value specifying the command buffer level.
     */
    level?: VkCommandBufferLevel;

    /**
     * is the number of command buffers to allocate from the pool.
     */
    commandBufferCount?: number;
}

declare interface VkCommandBufferAllocateInfoConstructor {
  readonly prototype: VkCommandBufferAllocateInfo;
  new(param?: VkCommandBufferAllocateInfoInitializer | null): VkCommandBufferAllocateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCommandBufferAllocateInfo: VkCommandBufferAllocateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created command pool
   */
interface VkCommandPoolCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkCommandPoolCreateFlagBits' indicating usage behavior for the pool and command buffers allocated from it.
     */
    flags: VkCommandPoolCreateFlagBits;

    /**
     * designates a queue family as described in section <<devsandqueues-queueprops,Queue Family Properties>>. All command buffers allocated from this command pool 'must' be submitted on queues from the same queue family.
     */
    queueFamilyIndex: number;

}

declare interface VkCommandPoolCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkCommandPoolCreateFlagBits' indicating usage behavior for the pool and command buffers allocated from it.
     */
    flags?: VkCommandPoolCreateFlagBits;

    /**
     * designates a queue family as described in section <<devsandqueues-queueprops,Queue Family Properties>>. All command buffers allocated from this command pool 'must' be submitted on queues from the same queue family.
     */
    queueFamilyIndex?: number;
}

declare interface VkCommandPoolCreateInfoConstructor {
  readonly prototype: VkCommandPoolCreateInfo;
  new(param?: VkCommandPoolCreateInfoInitializer | null): VkCommandPoolCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCommandPoolCreateInfo: VkCommandPoolCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created sampler
   */
interface VkSamplerCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkSamplerCreateFlagBits' describing additional parameters of the sampler.
     */
    flags: VkSamplerCreateFlagBits;

    /**
     * is a 'VkFilter' value specifying the magnification filter to apply to lookups.
     */
    magFilter: VkFilter;

    /**
     * is a 'VkFilter' value specifying the minification filter to apply to lookups.
     */
    minFilter: VkFilter;

    /**
     * is a 'VkSamplerMipmapMode' value specifying the mipmap filter to apply to lookups.
     */
    mipmapMode: VkSamplerMipmapMode;

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for U coordinate.
     */
    addressModeU: VkSamplerAddressMode;

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for V coordinate.
     */
    addressModeV: VkSamplerAddressMode;

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for W coordinate.
     */
    addressModeW: VkSamplerAddressMode;

    /**
     * is the bias to be added to mipmap LOD (level-of-detail) calculation and bias provided by image sampling functions in SPIR-V, as described in the <<textures-level-of-detail-operation, Level-of-Detail Operation>> section.
     */
    mipLodBias: number;

    /**
     *
     */
    anisotropyEnable: boolean;

    /**
     * is the anisotropy value clamp used by the sampler when 'anisotropyEnable' is 'VK_TRUE'. If 'anisotropyEnable' is 'VK_FALSE', 'maxAnisotropy' is ignored.
     */
    maxAnisotropy: number;

    /**
     *
     */
    compareEnable: boolean;

    /**
     * is a 'VkCompareOp' value specifying the comparison function to apply to fetched data before filtering as described in the <<textures-depth-compare-operation, Depth Compare Operation>> section.
     */
    compareOp: VkCompareOp;

    /**
     *
     */
    minLod: number;

    /**
     * are the values used to clamp the computed LOD value, as described in the <<textures-level-of-detail-operation, Level-of-Detail Operation>> section.
     */
    maxLod: number;

    /**
     * is a 'VkBorderColor' value specifying the predefined border color to use.
     */
    borderColor: VkBorderColor;

    /**
     * controls whether to use unnormalized or normalized texel coordinates to address texels of the image. When set to 'VK_TRUE', the range of the image coordinates used to lookup the texel is in the range of zero to the image dimensions for x, y and z. When set to 'VK_FALSE' the range of image coordinates is zero to one.+When 'unnormalizedCoordinates' is 'VK_TRUE', images the sampler isused with in the shader have the following requirements:+
     */
    unnormalizedCoordinates: boolean;

}

declare interface VkSamplerCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkSamplerCreateFlagBits' describing additional parameters of the sampler.
     */
    flags?: VkSamplerCreateFlagBits;

    /**
     * is a 'VkFilter' value specifying the magnification filter to apply to lookups.
     */
    magFilter?: VkFilter;

    /**
     * is a 'VkFilter' value specifying the minification filter to apply to lookups.
     */
    minFilter?: VkFilter;

    /**
     * is a 'VkSamplerMipmapMode' value specifying the mipmap filter to apply to lookups.
     */
    mipmapMode?: VkSamplerMipmapMode;

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for U coordinate.
     */
    addressModeU?: VkSamplerAddressMode;

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for V coordinate.
     */
    addressModeV?: VkSamplerAddressMode;

    /**
     * is a 'VkSamplerAddressMode' value specifying the addressing mode for outside [0..1] range for W coordinate.
     */
    addressModeW?: VkSamplerAddressMode;

    /**
     * is the bias to be added to mipmap LOD (level-of-detail) calculation and bias provided by image sampling functions in SPIR-V, as described in the <<textures-level-of-detail-operation, Level-of-Detail Operation>> section.
     */
    mipLodBias?: number;

    /**
     *
     */
    anisotropyEnable?: boolean;

    /**
     * is the anisotropy value clamp used by the sampler when 'anisotropyEnable' is 'VK_TRUE'. If 'anisotropyEnable' is 'VK_FALSE', 'maxAnisotropy' is ignored.
     */
    maxAnisotropy?: number;

    /**
     *
     */
    compareEnable?: boolean;

    /**
     * is a 'VkCompareOp' value specifying the comparison function to apply to fetched data before filtering as described in the <<textures-depth-compare-operation, Depth Compare Operation>> section.
     */
    compareOp?: VkCompareOp;

    /**
     *
     */
    minLod?: number;

    /**
     * are the values used to clamp the computed LOD value, as described in the <<textures-level-of-detail-operation, Level-of-Detail Operation>> section.
     */
    maxLod?: number;

    /**
     * is a 'VkBorderColor' value specifying the predefined border color to use.
     */
    borderColor?: VkBorderColor;

    /**
     * controls whether to use unnormalized or normalized texel coordinates to address texels of the image. When set to 'VK_TRUE', the range of the image coordinates used to lookup the texel is in the range of zero to the image dimensions for x, y and z. When set to 'VK_FALSE' the range of image coordinates is zero to one.+When 'unnormalizedCoordinates' is 'VK_TRUE', images the sampler isused with in the shader have the following requirements:+
     */
    unnormalizedCoordinates?: boolean;
}

declare interface VkSamplerCreateInfoConstructor {
  readonly prototype: VkSamplerCreateInfo;
  new(param?: VkSamplerCreateInfoInitializer | null): VkSamplerCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSamplerCreateInfo: VkSamplerCreateInfoConstructor;



  /**
   * Structure specifying the parameters of a newly created pipeline layout object
   */
interface VkPipelineLayoutCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is the number of descriptor sets included in the pipeline layout.
     */
    setLayoutCount: number;

    /**
     * is an array of 'VkDescriptorSetLayout' objects.
     */
    pSetLayouts: VkDescriptorSetLayout[] | null;

    /**
     * is the number of push constant ranges included in the pipeline layout.
     */
    pushConstantRangeCount: number;

    /**
     * is an array of 'VkPushConstantRange' structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants 'can' be accessed by each stage of the pipeline.+[NOTE].Note====Push constants represent a high speed path to modify constant data inpipelines that is expected to outperform memory-backed resource updates.====
     */
    pPushConstantRanges: VkPushConstantRange[] | null;

}

declare interface VkPipelineLayoutCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is the number of descriptor sets included in the pipeline layout.
     */
    setLayoutCount?: number;

    /**
     * is an array of 'VkDescriptorSetLayout' objects.
     */
    pSetLayouts?: VkDescriptorSetLayout[] | null;

    /**
     * is the number of push constant ranges included in the pipeline layout.
     */
    pushConstantRangeCount?: number;

    /**
     * is an array of 'VkPushConstantRange' structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants 'can' be accessed by each stage of the pipeline.+[NOTE].Note====Push constants represent a high speed path to modify constant data inpipelines that is expected to outperform memory-backed resource updates.====
     */
    pPushConstantRanges?: VkPushConstantRange[] | null;
}

declare interface VkPipelineLayoutCreateInfoConstructor {
  readonly prototype: VkPipelineLayoutCreateInfo;
  new(param?: VkPipelineLayoutCreateInfoInitializer | null): VkPipelineLayoutCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineLayoutCreateInfo: VkPipelineLayoutCreateInfoConstructor;



  /**
   * Structure specifying a push constant range
   */
interface VkPushConstantRange {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will return 'undefined' values.
     */
    stageFlags: VkShaderStageFlagBits;

    /**
     *
     */
    offset: number;

    /**
     * are the start offset and size, respectively, consumed by the range. Both 'offset' and 'size' are in units of bytes and 'must' be a multiple of 4. The layout of the push constant variables is specified in the shader.
     */
    size: number;

}

declare interface VkPushConstantRangeInitializer {
  
    /**
     * is a set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will return 'undefined' values.
     */
    stageFlags?: VkShaderStageFlagBits;

    /**
     *
     */
    offset?: number;

    /**
     * are the start offset and size, respectively, consumed by the range. Both 'offset' and 'size' are in units of bytes and 'must' be a multiple of 4. The layout of the push constant variables is specified in the shader.
     */
    size?: number;
}

declare interface VkPushConstantRangeConstructor {
  readonly prototype: VkPushConstantRange;
  new(param?: VkPushConstantRangeInitializer | null): VkPushConstantRange;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPushConstantRange: VkPushConstantRangeConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline cache
   */
interface VkPipelineCacheCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkPipelineCacheCreateFlagBits' specifying the behavior of the pipeline cache.
     */
    flags: VkPipelineCacheCreateFlagBits;

    /**
     *
     */
    initialDataSize: bigint | number;

    /**
     *
     */
    pInitialData: ArrayBuffer | null;

}

declare interface VkPipelineCacheCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkPipelineCacheCreateFlagBits' specifying the behavior of the pipeline cache.
     */
    flags?: VkPipelineCacheCreateFlagBits;

    /**
     *
     */
    initialDataSize?: bigint | number;

    /**
     *
     */
    pInitialData?: ArrayBuffer | null;
}

declare interface VkPipelineCacheCreateInfoConstructor {
  readonly prototype: VkPipelineCacheCreateInfo;
  new(param?: VkPipelineCacheCreateInfoInitializer | null): VkPipelineCacheCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineCacheCreateInfo: VkPipelineCacheCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created graphics pipeline
   */
interface VkGraphicsPipelineCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags: VkPipelineCreateFlagBits;

    /**
     * 'VkPipelineShaderStageCreateInfo' structures describing the set of the shader stages to be included in the graphics pipeline.
     */
    stageCount: number;

    /**
     * array.
     */
    pStages: VkPipelineShaderStageCreateInfo[] | null;

    /**
     * is a reference to a 'VkPipelineVertexInputStateCreateInfo' structure. It is ignored if the pipeline includes a mesh shader stage.
     */
    pVertexInputState: VkPipelineVertexInputStateCreateInfo | null;

    /**
     *
     */
    pInputAssemblyState: VkPipelineInputAssemblyStateCreateInfo | null;

    /**
     *
     */
    pTessellationState: VkPipelineTessellationStateCreateInfo | null;

    /**
     *
     */
    pViewportState: VkPipelineViewportStateCreateInfo | null;

    /**
     *
     */
    pRasterizationState: VkPipelineRasterizationStateCreateInfo | null;

    /**
     *
     */
    pMultisampleState: VkPipelineMultisampleStateCreateInfo | null;

    /**
     *
     */
    pDepthStencilState: VkPipelineDepthStencilStateCreateInfo | null;

    /**
     *
     */
    pColorBlendState: VkPipelineColorBlendStateCreateInfo | null;

    /**
     *
     */
    pDynamicState: VkPipelineDynamicStateCreateInfo | null;

    /**
     *
     */
    layout: VkPipelineLayout | null;

    /**
     *
     */
    renderPass: VkRenderPass | null;

    /**
     *
     */
    subpass: number;

    /**
     *
     */
    basePipelineHandle: VkPipeline | null;

    /**
     *
     */
    basePipelineIndex: number;

}

declare interface VkGraphicsPipelineCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags?: VkPipelineCreateFlagBits;

    /**
     * 'VkPipelineShaderStageCreateInfo' structures describing the set of the shader stages to be included in the graphics pipeline.
     */
    stageCount?: number;

    /**
     * array.
     */
    pStages?: VkPipelineShaderStageCreateInfo[] | null;

    /**
     * is a reference to a 'VkPipelineVertexInputStateCreateInfo' structure. It is ignored if the pipeline includes a mesh shader stage.
     */
    pVertexInputState?: VkPipelineVertexInputStateCreateInfo | null;

    /**
     *
     */
    pInputAssemblyState?: VkPipelineInputAssemblyStateCreateInfo | null;

    /**
     *
     */
    pTessellationState?: VkPipelineTessellationStateCreateInfo | null;

    /**
     *
     */
    pViewportState?: VkPipelineViewportStateCreateInfo | null;

    /**
     *
     */
    pRasterizationState?: VkPipelineRasterizationStateCreateInfo | null;

    /**
     *
     */
    pMultisampleState?: VkPipelineMultisampleStateCreateInfo | null;

    /**
     *
     */
    pDepthStencilState?: VkPipelineDepthStencilStateCreateInfo | null;

    /**
     *
     */
    pColorBlendState?: VkPipelineColorBlendStateCreateInfo | null;

    /**
     *
     */
    pDynamicState?: VkPipelineDynamicStateCreateInfo | null;

    /**
     *
     */
    layout?: VkPipelineLayout | null;

    /**
     *
     */
    renderPass?: VkRenderPass | null;

    /**
     *
     */
    subpass?: number;

    /**
     *
     */
    basePipelineHandle?: VkPipeline | null;

    /**
     *
     */
    basePipelineIndex?: number;
}

declare interface VkGraphicsPipelineCreateInfoConstructor {
  readonly prototype: VkGraphicsPipelineCreateInfo;
  new(param?: VkGraphicsPipelineCreateInfoInitializer | null): VkGraphicsPipelineCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkGraphicsPipelineCreateInfo: VkGraphicsPipelineCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline depth stencil state
   */
interface VkPipelineDepthStencilStateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * controls whether <<fragops-depth,depth testing>> is enabled.
     */
    depthTestEnable: boolean;

    /**
     * controls whether <<fragops-depth-write,depth writes>> are enabled when 'depthTestEnable' is 'VK_TRUE'. Depth writes are always disabled when 'depthTestEnable' is 'VK_FALSE'.
     */
    depthWriteEnable: boolean;

    /**
     * is the comparison operator used in the <<fragops-depth,depth test>>.
     */
    depthCompareOp: VkCompareOp;

    /**
     * controls whether <<fragops-dbt,depth bounds testing>> is enabled.
     */
    depthBoundsTestEnable: boolean;

    /**
     * controls whether <<fragops-stencil,stencil testing>> is enabled.
     */
    stencilTestEnable: boolean;

    /**
     *
     */
    front: VkStencilOpState | null;

    /**
     * control the parameters of the <<fragops-stencil,stencil test>>.
     */
    back: VkStencilOpState | null;

    /**
     * is the minimum depth bound used in the <<fragops-dbt, depth bounds test>>.
     */
    minDepthBounds: number;

    /**
     * is the maximum depth bound used in the <<fragops-dbt, depth bounds test>>.
     */
    maxDepthBounds: number;

}

declare interface VkPipelineDepthStencilStateCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * controls whether <<fragops-depth,depth testing>> is enabled.
     */
    depthTestEnable?: boolean;

    /**
     * controls whether <<fragops-depth-write,depth writes>> are enabled when 'depthTestEnable' is 'VK_TRUE'. Depth writes are always disabled when 'depthTestEnable' is 'VK_FALSE'.
     */
    depthWriteEnable?: boolean;

    /**
     * is the comparison operator used in the <<fragops-depth,depth test>>.
     */
    depthCompareOp?: VkCompareOp;

    /**
     * controls whether <<fragops-dbt,depth bounds testing>> is enabled.
     */
    depthBoundsTestEnable?: boolean;

    /**
     * controls whether <<fragops-stencil,stencil testing>> is enabled.
     */
    stencilTestEnable?: boolean;

    /**
     *
     */
    front?: VkStencilOpState | null;

    /**
     * control the parameters of the <<fragops-stencil,stencil test>>.
     */
    back?: VkStencilOpState | null;

    /**
     * is the minimum depth bound used in the <<fragops-dbt, depth bounds test>>.
     */
    minDepthBounds?: number;

    /**
     * is the maximum depth bound used in the <<fragops-dbt, depth bounds test>>.
     */
    maxDepthBounds?: number;
}

declare interface VkPipelineDepthStencilStateCreateInfoConstructor {
  readonly prototype: VkPipelineDepthStencilStateCreateInfo;
  new(param?: VkPipelineDepthStencilStateCreateInfoInitializer | null): VkPipelineDepthStencilStateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineDepthStencilStateCreateInfo: VkPipelineDepthStencilStateCreateInfoConstructor;



  /**
   * Structure specifying stencil operation state
   */
interface VkStencilOpState {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that fail the stencil test.
     */
    failOp: VkStencilOp;

    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that pass both the depth and stencil tests.
     */
    passOp: VkStencilOp;

    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that pass the stencil test and fail the depth test.
     */
    depthFailOp: VkStencilOp;

    /**
     * is a 'VkCompareOp' value specifying the comparison operator used in the stencil test.
     */
    compareOp: VkCompareOp;

    /**
     * selects the bits of the unsigned integer stencil values participating in the stencil test.
     */
    compareMask: number;

    /**
     * selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment.
     */
    writeMask: number;

    /**
     * is a number reference value that is used in the unsigned stencil comparison.
     */
    reference: number;

}

declare interface VkStencilOpStateInitializer {
  
    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that fail the stencil test.
     */
    failOp?: VkStencilOp;

    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that pass both the depth and stencil tests.
     */
    passOp?: VkStencilOp;

    /**
     * is a 'VkStencilOp' value specifying the action performed on samples that pass the stencil test and fail the depth test.
     */
    depthFailOp?: VkStencilOp;

    /**
     * is a 'VkCompareOp' value specifying the comparison operator used in the stencil test.
     */
    compareOp?: VkCompareOp;

    /**
     * selects the bits of the unsigned integer stencil values participating in the stencil test.
     */
    compareMask?: number;

    /**
     * selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment.
     */
    writeMask?: number;

    /**
     * is a number reference value that is used in the unsigned stencil comparison.
     */
    reference?: number;
}

declare interface VkStencilOpStateConstructor {
  readonly prototype: VkStencilOpState;
  new(param?: VkStencilOpStateInitializer | null): VkStencilOpState;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkStencilOpState: VkStencilOpStateConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline dynamic state
   */
interface VkPipelineDynamicStateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is the number of elements in the 'pDynamicStates' array.
     */
    dynamicStateCount: number;

    /**
     * is an array of 'VkDynamicState' values specifying which pieces of pipeline state will use the values from dynamic state commands rather than from pipeline state creation info.
     */
    pDynamicStates: Int32Array | null;

}

declare interface VkPipelineDynamicStateCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is the number of elements in the 'pDynamicStates' array.
     */
    dynamicStateCount?: number;

    /**
     * is an array of 'VkDynamicState' values specifying which pieces of pipeline state will use the values from dynamic state commands rather than from pipeline state creation info.
     */
    pDynamicStates?: Int32Array | null;
}

declare interface VkPipelineDynamicStateCreateInfoConstructor {
  readonly prototype: VkPipelineDynamicStateCreateInfo;
  new(param?: VkPipelineDynamicStateCreateInfoInitializer | null): VkPipelineDynamicStateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineDynamicStateCreateInfo: VkPipelineDynamicStateCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline color blend state
   */
interface VkPipelineColorBlendStateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * controls whether to apply <<framebuffer-logicop, Logical Operations>>.
     */
    logicOpEnable: boolean;

    /**
     * selects which logical operation to apply.
     */
    logicOp: VkLogicOp;

    /**
     * is the number of 'VkPipelineColorBlendAttachmentState' elements in 'pAttachments'.
     */
    attachmentCount: number;

    /**
     *
     */
    pAttachments: VkPipelineColorBlendAttachmentState[] | null;

    /**
     * is an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the <<framebuffer-blendfactors,blend factor>>.
     */
    blendConstants: number[] | null;

}

declare interface VkPipelineColorBlendStateCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * controls whether to apply <<framebuffer-logicop, Logical Operations>>.
     */
    logicOpEnable?: boolean;

    /**
     * selects which logical operation to apply.
     */
    logicOp?: VkLogicOp;

    /**
     * is the number of 'VkPipelineColorBlendAttachmentState' elements in 'pAttachments'.
     */
    attachmentCount?: number;

    /**
     *
     */
    pAttachments?: VkPipelineColorBlendAttachmentState[] | null;

    /**
     * is an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the <<framebuffer-blendfactors,blend factor>>.
     */
    blendConstants?: number[] | null;
}

declare interface VkPipelineColorBlendStateCreateInfoConstructor {
  readonly prototype: VkPipelineColorBlendStateCreateInfo;
  new(param?: VkPipelineColorBlendStateCreateInfoInitializer | null): VkPipelineColorBlendStateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineColorBlendStateCreateInfo: VkPipelineColorBlendStateCreateInfoConstructor;



  /**
   * Structure specifying a pipeline color blend attachment state
   */
interface VkPipelineColorBlendAttachmentState {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment's color for that attachment is passed through unmodified.
     */
    blendEnable: boolean;

    /**
     * selects which blend factor is used to determine the source factors [eq]#(S~r~,S~g~,S~b~)#.
     */
    srcColorBlendFactor: VkBlendFactor;

    /**
     * selects which blend factor is used to determine the destination factors [eq]#(D~r~,D~g~,D~b~)#.
     */
    dstColorBlendFactor: VkBlendFactor;

    /**
     * selects which blend operation is used to calculate the RGB values to write to the color attachment.
     */
    colorBlendOp: VkBlendOp;

    /**
     * selects which blend factor is used to determine the source factor [eq]#S~a~#.
     */
    srcAlphaBlendFactor: VkBlendFactor;

    /**
     * selects which blend factor is used to determine the destination factor [eq]#D~a~#.
     */
    dstAlphaBlendFactor: VkBlendFactor;

    /**
     * selects which blend operation is use to calculate the alpha values to write to the color attachment.
     */
    alphaBlendOp: VkBlendOp;

    /**
     * is a bitmask of 'VkColorComponentFlagBits' specifying which of the R, G, B, and/or A components are enabled for writing, as described for the <<framebuffer-color-write-mask,Color Write Mask>>.
     */
    colorWriteMask: VkColorComponentFlagBits;

}

declare interface VkPipelineColorBlendAttachmentStateInitializer {
  
    /**
     * controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment's color for that attachment is passed through unmodified.
     */
    blendEnable?: boolean;

    /**
     * selects which blend factor is used to determine the source factors [eq]#(S~r~,S~g~,S~b~)#.
     */
    srcColorBlendFactor?: VkBlendFactor;

    /**
     * selects which blend factor is used to determine the destination factors [eq]#(D~r~,D~g~,D~b~)#.
     */
    dstColorBlendFactor?: VkBlendFactor;

    /**
     * selects which blend operation is used to calculate the RGB values to write to the color attachment.
     */
    colorBlendOp?: VkBlendOp;

    /**
     * selects which blend factor is used to determine the source factor [eq]#S~a~#.
     */
    srcAlphaBlendFactor?: VkBlendFactor;

    /**
     * selects which blend factor is used to determine the destination factor [eq]#D~a~#.
     */
    dstAlphaBlendFactor?: VkBlendFactor;

    /**
     * selects which blend operation is use to calculate the alpha values to write to the color attachment.
     */
    alphaBlendOp?: VkBlendOp;

    /**
     * is a bitmask of 'VkColorComponentFlagBits' specifying which of the R, G, B, and/or A components are enabled for writing, as described for the <<framebuffer-color-write-mask,Color Write Mask>>.
     */
    colorWriteMask?: VkColorComponentFlagBits;
}

declare interface VkPipelineColorBlendAttachmentStateConstructor {
  readonly prototype: VkPipelineColorBlendAttachmentState;
  new(param?: VkPipelineColorBlendAttachmentStateInitializer | null): VkPipelineColorBlendAttachmentState;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineColorBlendAttachmentState: VkPipelineColorBlendAttachmentStateConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline multisample state
   */
interface VkPipelineMultisampleStateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of samples used in rasterization.
     */
    rasterizationSamples: VkSampleCountFlagBits;

    /**
     * 'can' be used to enable <<primsrast-sampleshading,Sample Shading>>.
     */
    sampleShadingEnable: boolean;

    /**
     * specifies a minimum fraction of sample shading if 'sampleShadingEnable' is set to 'VK_TRUE'.
     */
    minSampleShading: number;

    /**
     * is an array of 'VkSampleMask' values used in the <<fragops-samplemask,sample mask test>>.
     */
    pSampleMask: Uint32Array | null;

    /**
     * controls whether a temporary coverage value is generated based on the alpha component of the fragment's first color output as specified in the <<fragops-covg,Multisample Coverage>> section.
     */
    alphaToCoverageEnable: boolean;

    /**
     * controls whether the alpha component of the fragment's first color output is replaced with one as described in <<fragops-covg,Multisample Coverage>>.
     */
    alphaToOneEnable: boolean;

}

declare interface VkPipelineMultisampleStateCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of samples used in rasterization.
     */
    rasterizationSamples?: VkSampleCountFlagBits;

    /**
     * 'can' be used to enable <<primsrast-sampleshading,Sample Shading>>.
     */
    sampleShadingEnable?: boolean;

    /**
     * specifies a minimum fraction of sample shading if 'sampleShadingEnable' is set to 'VK_TRUE'.
     */
    minSampleShading?: number;

    /**
     * is an array of 'VkSampleMask' values used in the <<fragops-samplemask,sample mask test>>.
     */
    pSampleMask?: Uint32Array | null;

    /**
     * controls whether a temporary coverage value is generated based on the alpha component of the fragment's first color output as specified in the <<fragops-covg,Multisample Coverage>> section.
     */
    alphaToCoverageEnable?: boolean;

    /**
     * controls whether the alpha component of the fragment's first color output is replaced with one as described in <<fragops-covg,Multisample Coverage>>.
     */
    alphaToOneEnable?: boolean;
}

declare interface VkPipelineMultisampleStateCreateInfoConstructor {
  readonly prototype: VkPipelineMultisampleStateCreateInfo;
  new(param?: VkPipelineMultisampleStateCreateInfoInitializer | null): VkPipelineMultisampleStateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineMultisampleStateCreateInfo: VkPipelineMultisampleStateCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline rasterization state
   */
interface VkPipelineRasterizationStateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * controls whether to clamp the fragment's depth values as described in <<fragops-depth,Depth Test>>. If the pipeline is not created with 'VkPipelineRasterizationDepthClipStateCreateInfoEXT' present then enabling depth clamp will also disable clipping primitives to the z planes of the frustrum as described in <<vertexpostproc-clipping, Primitive Clipping>>. Otherwise depth clipping is controlled by the state set in 'VkPipelineRasterizationDepthClipStateCreateInfoEXT'.
     */
    depthClampEnable: boolean;

    /**
     *
     */
    rasterizerDiscardEnable: boolean;

    /**
     *
     */
    polygonMode: VkPolygonMode;

    /**
     *
     */
    cullMode: VkCullModeFlagBits;

    /**
     *
     */
    frontFace: VkFrontFace;

    /**
     *
     */
    depthBiasEnable: boolean;

    /**
     *
     */
    depthBiasConstantFactor: number;

    /**
     *
     */
    depthBiasClamp: number;

    /**
     *
     */
    depthBiasSlopeFactor: number;

    /**
     *
     */
    lineWidth: number;

}

declare interface VkPipelineRasterizationStateCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * controls whether to clamp the fragment's depth values as described in <<fragops-depth,Depth Test>>. If the pipeline is not created with 'VkPipelineRasterizationDepthClipStateCreateInfoEXT' present then enabling depth clamp will also disable clipping primitives to the z planes of the frustrum as described in <<vertexpostproc-clipping, Primitive Clipping>>. Otherwise depth clipping is controlled by the state set in 'VkPipelineRasterizationDepthClipStateCreateInfoEXT'.
     */
    depthClampEnable?: boolean;

    /**
     *
     */
    rasterizerDiscardEnable?: boolean;

    /**
     *
     */
    polygonMode?: VkPolygonMode;

    /**
     *
     */
    cullMode?: VkCullModeFlagBits;

    /**
     *
     */
    frontFace?: VkFrontFace;

    /**
     *
     */
    depthBiasEnable?: boolean;

    /**
     *
     */
    depthBiasConstantFactor?: number;

    /**
     *
     */
    depthBiasClamp?: number;

    /**
     *
     */
    depthBiasSlopeFactor?: number;

    /**
     *
     */
    lineWidth?: number;
}

declare interface VkPipelineRasterizationStateCreateInfoConstructor {
  readonly prototype: VkPipelineRasterizationStateCreateInfo;
  new(param?: VkPipelineRasterizationStateCreateInfoInitializer | null): VkPipelineRasterizationStateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineRasterizationStateCreateInfo: VkPipelineRasterizationStateCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline viewport state
   */
interface VkPipelineViewportStateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is the number of viewports used by the pipeline.
     */
    viewportCount: number;

    /**
     * is an array of 'VkViewport' structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored.
     */
    pViewports: VkViewport[] | null;

    /**
     * is the number of <<fragops-scissor,scissors>> and 'must' match the number of viewports.
     */
    scissorCount: number;

    /**
     * is an array of 'VkRect2D' structures defining the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored.
     */
    pScissors: VkRect2D[] | null;

}

declare interface VkPipelineViewportStateCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is the number of viewports used by the pipeline.
     */
    viewportCount?: number;

    /**
     * is an array of 'VkViewport' structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored.
     */
    pViewports?: VkViewport[] | null;

    /**
     * is the number of <<fragops-scissor,scissors>> and 'must' match the number of viewports.
     */
    scissorCount?: number;

    /**
     * is an array of 'VkRect2D' structures defining the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored.
     */
    pScissors?: VkRect2D[] | null;
}

declare interface VkPipelineViewportStateCreateInfoConstructor {
  readonly prototype: VkPipelineViewportStateCreateInfo;
  new(param?: VkPipelineViewportStateCreateInfoInitializer | null): VkPipelineViewportStateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineViewportStateCreateInfo: VkPipelineViewportStateCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline tessellation state
   */
interface VkPipelineTessellationStateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * number of control reference per patch.
     */
    patchControlPoints: number;

}

declare interface VkPipelineTessellationStateCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * number of control reference per patch.
     */
    patchControlPoints?: number;
}

declare interface VkPipelineTessellationStateCreateInfoConstructor {
  readonly prototype: VkPipelineTessellationStateCreateInfo;
  new(param?: VkPipelineTessellationStateCreateInfoInitializer | null): VkPipelineTessellationStateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineTessellationStateCreateInfo: VkPipelineTessellationStateCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline input assembly state
   */
interface VkPipelineInputAssemblyStateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is a 'VkPrimitiveTopology' defining the primitive topology, as described below.
     */
    topology: VkPrimitiveTopology;

    /**
     * controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws ('vkCmdDrawIndexed' and 'vkCmdDrawIndexedIndirect'), and the special index value is either 0xFFFFFFFF when the 'indexType' parameter of 'vkCmdBindIndexBuffer' is equal to 'VK_INDEX_TYPE_UINT32', 0xFF when 'indexType' is equal to 'VK_INDEX_TYPE_UINT8_EXT',
     */
    primitiveRestartEnable: boolean;

}

declare interface VkPipelineInputAssemblyStateCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is a 'VkPrimitiveTopology' defining the primitive topology, as described below.
     */
    topology?: VkPrimitiveTopology;

    /**
     * controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws ('vkCmdDrawIndexed' and 'vkCmdDrawIndexedIndirect'), and the special index value is either 0xFFFFFFFF when the 'indexType' parameter of 'vkCmdBindIndexBuffer' is equal to 'VK_INDEX_TYPE_UINT32', 0xFF when 'indexType' is equal to 'VK_INDEX_TYPE_UINT8_EXT',
     */
    primitiveRestartEnable?: boolean;
}

declare interface VkPipelineInputAssemblyStateCreateInfoConstructor {
  readonly prototype: VkPipelineInputAssemblyStateCreateInfo;
  new(param?: VkPipelineInputAssemblyStateCreateInfoInitializer | null): VkPipelineInputAssemblyStateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineInputAssemblyStateCreateInfo: VkPipelineInputAssemblyStateCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline vertex input state
   */
interface VkPipelineVertexInputStateCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is the number of vertex binding descriptions provided in 'pVertexBindingDescriptions'.
     */
    vertexBindingDescriptionCount: number;

    /**
     * is an array of 'VkVertexInputBindingDescription' structures.
     */
    pVertexBindingDescriptions: VkVertexInputBindingDescription[] | null;

    /**
     * is the number of vertex attribute descriptions provided in 'pVertexAttributeDescriptions'.
     */
    vertexAttributeDescriptionCount: number;

    /**
     * is an array of 'VkVertexInputAttributeDescription' structures.
     */
    pVertexAttributeDescriptions: VkVertexInputAttributeDescription[] | null;

}

declare interface VkPipelineVertexInputStateCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is the number of vertex binding descriptions provided in 'pVertexBindingDescriptions'.
     */
    vertexBindingDescriptionCount?: number;

    /**
     * is an array of 'VkVertexInputBindingDescription' structures.
     */
    pVertexBindingDescriptions?: VkVertexInputBindingDescription[] | null;

    /**
     * is the number of vertex attribute descriptions provided in 'pVertexAttributeDescriptions'.
     */
    vertexAttributeDescriptionCount?: number;

    /**
     * is an array of 'VkVertexInputAttributeDescription' structures.
     */
    pVertexAttributeDescriptions?: VkVertexInputAttributeDescription[] | null;
}

declare interface VkPipelineVertexInputStateCreateInfoConstructor {
  readonly prototype: VkPipelineVertexInputStateCreateInfo;
  new(param?: VkPipelineVertexInputStateCreateInfoInitializer | null): VkPipelineVertexInputStateCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineVertexInputStateCreateInfo: VkPipelineVertexInputStateCreateInfoConstructor;



  /**
   * Structure specifying vertex input attribute description
   */
interface VkVertexInputAttributeDescription {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the shader binding location number for this attribute.
     */
    location: number;

    /**
     * is the binding number which this attribute takes its data from.
     */
    binding: number;

    /**
     * is the size and type of the vertex attribute data.
     */
    format: VkFormat;

    /**
     * is a byte offset of this attribute relative to the start of an element in the vertex input binding.
     */
    offset: number;

}

declare interface VkVertexInputAttributeDescriptionInitializer {
  
    /**
     * is the shader binding location number for this attribute.
     */
    location?: number;

    /**
     * is the binding number which this attribute takes its data from.
     */
    binding?: number;

    /**
     * is the size and type of the vertex attribute data.
     */
    format?: VkFormat;

    /**
     * is a byte offset of this attribute relative to the start of an element in the vertex input binding.
     */
    offset?: number;
}

declare interface VkVertexInputAttributeDescriptionConstructor {
  readonly prototype: VkVertexInputAttributeDescription;
  new(param?: VkVertexInputAttributeDescriptionInitializer | null): VkVertexInputAttributeDescription;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkVertexInputAttributeDescription: VkVertexInputAttributeDescriptionConstructor;



  /**
   * Structure specifying vertex input binding description
   */
interface VkVertexInputBindingDescription {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the binding number that this structure describes.
     */
    binding: number;

    /**
     * is the distance in bytes between two consecutive elements within the buffer.
     */
    stride: number;

    /**
     * is a 'VkVertexInputRate' value specifying whether vertex attribute addressing is a function of the vertex index or of the instance index.
     */
    inputRate: VkVertexInputRate;

}

declare interface VkVertexInputBindingDescriptionInitializer {
  
    /**
     * is the binding number that this structure describes.
     */
    binding?: number;

    /**
     * is the distance in bytes between two consecutive elements within the buffer.
     */
    stride?: number;

    /**
     * is a 'VkVertexInputRate' value specifying whether vertex attribute addressing is a function of the vertex index or of the instance index.
     */
    inputRate?: VkVertexInputRate;
}

declare interface VkVertexInputBindingDescriptionConstructor {
  readonly prototype: VkVertexInputBindingDescription;
  new(param?: VkVertexInputBindingDescriptionInitializer | null): VkVertexInputBindingDescription;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkVertexInputBindingDescription: VkVertexInputBindingDescriptionConstructor;



  /**
   * Structure specifying parameters of a newly created compute pipeline
   */
interface VkComputePipelineCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags: VkPipelineCreateFlagBits;

    /**
     * is a 'VkPipelineShaderStageCreateInfo' structure describing the compute shader.
     */
    stage: VkPipelineShaderStageCreateInfo | null;

    /**
     * is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
     */
    layout: VkPipelineLayout | null;

    /**
     * is a pipeline to derive from
     */
    basePipelineHandle: VkPipeline | null;

    /**
     *
     */
    basePipelineIndex: number;

}

declare interface VkComputePipelineCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkPipelineCreateFlagBits' specifying how the pipeline will be generated.
     */
    flags?: VkPipelineCreateFlagBits;

    /**
     * is a 'VkPipelineShaderStageCreateInfo' structure describing the compute shader.
     */
    stage?: VkPipelineShaderStageCreateInfo | null;

    /**
     * is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
     */
    layout?: VkPipelineLayout | null;

    /**
     * is a pipeline to derive from
     */
    basePipelineHandle?: VkPipeline | null;

    /**
     *
     */
    basePipelineIndex?: number;
}

declare interface VkComputePipelineCreateInfoConstructor {
  readonly prototype: VkComputePipelineCreateInfo;
  new(param?: VkComputePipelineCreateInfoInitializer | null): VkComputePipelineCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkComputePipelineCreateInfo: VkComputePipelineCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created pipeline shader stage
   */
interface VkPipelineShaderStageCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkPipelineShaderStageCreateFlagBits' specifying how the pipeline shader stage will be generated.
     */
    flags: VkPipelineShaderStageCreateFlagBits;

    /**
     * is a 'VkShaderStageFlagBits' value specifying a single pipeline stage.
     */
    stage: VkShaderStageFlagBits;

    /**
     * is a 'VkShaderModule' object containing the shader for this stage.
     */
    module: VkShaderModule | null;

    /**
     * is a reference to a string specifying the entry point name of the shader for this stage.
     */
    pName: string | null;

    /**
     * is a reference to a 'VkSpecializationInfo' structure, as described in <<pipelines-specialization-constants,Specialization Constants>>, or <i>null</i>.
     */
    pSpecializationInfo: VkSpecializationInfo | null;

}

declare interface VkPipelineShaderStageCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkPipelineShaderStageCreateFlagBits' specifying how the pipeline shader stage will be generated.
     */
    flags?: VkPipelineShaderStageCreateFlagBits;

    /**
     * is a 'VkShaderStageFlagBits' value specifying a single pipeline stage.
     */
    stage?: VkShaderStageFlagBits;

    /**
     * is a 'VkShaderModule' object containing the shader for this stage.
     */
    module?: VkShaderModule | null;

    /**
     * is a reference to a string specifying the entry point name of the shader for this stage.
     */
    pName?: string | null;

    /**
     * is a reference to a 'VkSpecializationInfo' structure, as described in <<pipelines-specialization-constants,Specialization Constants>>, or <i>null</i>.
     */
    pSpecializationInfo?: VkSpecializationInfo | null;
}

declare interface VkPipelineShaderStageCreateInfoConstructor {
  readonly prototype: VkPipelineShaderStageCreateInfo;
  new(param?: VkPipelineShaderStageCreateInfoInitializer | null): VkPipelineShaderStageCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineShaderStageCreateInfo: VkPipelineShaderStageCreateInfoConstructor;



  /**
   * Structure specifying specialization info
   */
interface VkSpecializationInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    mapEntryCount: number;

    /**
     * is an array of 'VkSpecializationMapEntry' structures which map constant IDs to offsets in 'pData'.
     */
    pMapEntries: VkSpecializationMapEntry[] | null;

    /**
     *
     */
    dataSize: bigint | number;

    /**
     * contains the actual constant values to specialize with.
     */
    pData: ArrayBuffer | null;

}

declare interface VkSpecializationInfoInitializer {
  
    /**
     *
     */
    mapEntryCount?: number;

    /**
     * is an array of 'VkSpecializationMapEntry' structures which map constant IDs to offsets in 'pData'.
     */
    pMapEntries?: VkSpecializationMapEntry[] | null;

    /**
     *
     */
    dataSize?: bigint | number;

    /**
     * contains the actual constant values to specialize with.
     */
    pData?: ArrayBuffer | null;
}

declare interface VkSpecializationInfoConstructor {
  readonly prototype: VkSpecializationInfo;
  new(param?: VkSpecializationInfoInitializer | null): VkSpecializationInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSpecializationInfo: VkSpecializationInfoConstructor;



  /**
   * Structure specifying a specialization map entry
   */
interface VkSpecializationMapEntry {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the ID of the specialization constant in SPIR-V.
     */
    constantID: number;

    /**
     * is the byte offset of the specialization constant value within the supplied data buffer.
     */
    offset: number;

    /**
     * is the byte size of the specialization constant value within the supplied data buffer.
     */
    size: bigint | number;

}

declare interface VkSpecializationMapEntryInitializer {
  
    /**
     * is the ID of the specialization constant in SPIR-V.
     */
    constantID?: number;

    /**
     * is the byte offset of the specialization constant value within the supplied data buffer.
     */
    offset?: number;

    /**
     * is the byte size of the specialization constant value within the supplied data buffer.
     */
    size?: bigint | number;
}

declare interface VkSpecializationMapEntryConstructor {
  readonly prototype: VkSpecializationMapEntry;
  new(param?: VkSpecializationMapEntryInitializer | null): VkSpecializationMapEntry;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSpecializationMapEntry: VkSpecializationMapEntryConstructor;



  /**
   * Structure specifying the allocation parameters for descriptor sets
   */
interface VkDescriptorSetAllocateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the pool which the sets will be allocated from.
     */
    descriptorPool: VkDescriptorPool | null;

    /**
     * determines the number of descriptor sets to be allocated from the pool.
     */
    descriptorSetCount: number;

    /**
     * is an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.
     */
    pSetLayouts: VkDescriptorSetLayout[] | null;

}

declare interface VkDescriptorSetAllocateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the pool which the sets will be allocated from.
     */
    descriptorPool?: VkDescriptorPool | null;

    /**
     * determines the number of descriptor sets to be allocated from the pool.
     */
    descriptorSetCount?: number;

    /**
     * is an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.
     */
    pSetLayouts?: VkDescriptorSetLayout[] | null;
}

declare interface VkDescriptorSetAllocateInfoConstructor {
  readonly prototype: VkDescriptorSetAllocateInfo;
  new(param?: VkDescriptorSetAllocateInfoInitializer | null): VkDescriptorSetAllocateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetAllocateInfo: VkDescriptorSetAllocateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created descriptor pool
   */
interface VkDescriptorPoolCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkDescriptorPoolCreateFlagBits' specifying certain supported operations on the pool.
     */
    flags: VkDescriptorPoolCreateFlagBits;

    /**
     * is the maximum number of descriptor sets that 'can' be allocated from the pool.
     */
    maxSets: number;

    /**
     *
     */
    poolSizeCount: number;

    /**
     * is an array of 'VkDescriptorPoolSize' structures, each containing a descriptor type and number of descriptors of that type to be allocated in the pool.
     */
    pPoolSizes: VkDescriptorPoolSize[] | null;

}

declare interface VkDescriptorPoolCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkDescriptorPoolCreateFlagBits' specifying certain supported operations on the pool.
     */
    flags?: VkDescriptorPoolCreateFlagBits;

    /**
     * is the maximum number of descriptor sets that 'can' be allocated from the pool.
     */
    maxSets?: number;

    /**
     *
     */
    poolSizeCount?: number;

    /**
     * is an array of 'VkDescriptorPoolSize' structures, each containing a descriptor type and number of descriptors of that type to be allocated in the pool.
     */
    pPoolSizes?: VkDescriptorPoolSize[] | null;
}

declare interface VkDescriptorPoolCreateInfoConstructor {
  readonly prototype: VkDescriptorPoolCreateInfo;
  new(param?: VkDescriptorPoolCreateInfoInitializer | null): VkDescriptorPoolCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorPoolCreateInfo: VkDescriptorPoolCreateInfoConstructor;



  /**
   * Structure specifying descriptor pool size
   */
interface VkDescriptorPoolSize {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of descriptor.
     */
    type: VkDescriptorType;

    /**
     * is the number of descriptors of that type to allocate. If 'type' is 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'descriptorCount' is the number of bytes to allocate for descriptors of this type.
     */
    descriptorCount: number;

}

declare interface VkDescriptorPoolSizeInitializer {
  
    /**
     * is the type of descriptor.
     */
    type?: VkDescriptorType;

    /**
     * is the number of descriptors of that type to allocate. If 'type' is 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'descriptorCount' is the number of bytes to allocate for descriptors of this type.
     */
    descriptorCount?: number;
}

declare interface VkDescriptorPoolSizeConstructor {
  readonly prototype: VkDescriptorPoolSize;
  new(param?: VkDescriptorPoolSizeInitializer | null): VkDescriptorPoolSize;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorPoolSize: VkDescriptorPoolSizeConstructor;



  /**
   * Structure specifying parameters of a newly created descriptor set layout
   */
interface VkDescriptorSetLayoutCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkDescriptorSetLayoutCreateFlagBits'
     */
    flags: VkDescriptorSetLayoutCreateFlagBits;

    /**
     *
     */
    bindingCount: number;

    /**
     *
     */
    pBindings: VkDescriptorSetLayoutBinding[] | null;

}

declare interface VkDescriptorSetLayoutCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkDescriptorSetLayoutCreateFlagBits'
     */
    flags?: VkDescriptorSetLayoutCreateFlagBits;

    /**
     *
     */
    bindingCount?: number;

    /**
     *
     */
    pBindings?: VkDescriptorSetLayoutBinding[] | null;
}

declare interface VkDescriptorSetLayoutCreateInfoConstructor {
  readonly prototype: VkDescriptorSetLayoutCreateInfo;
  new(param?: VkDescriptorSetLayoutCreateInfoInitializer | null): VkDescriptorSetLayoutCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetLayoutCreateInfo: VkDescriptorSetLayoutCreateInfoConstructor;



  /**
   * Structure specifying a descriptor set layout binding
   */
interface VkDescriptorSetLayoutBinding {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.
     */
    binding: number;

    /**
     * is a 'VkDescriptorType' specifying which type of resource descriptors are used for this binding.
     */
    descriptorType: VkDescriptorType;

    /**
     * is the number of descriptors contained in the binding, accessed in a shader as an array , except if 'descriptorType' is 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' in which case 'descriptorCount' is the size in bytes of the inline uniform block
     */
    descriptorCount: number;

    /**
     *
     */
    stageFlags: VkShaderStageFlagBits;

    /**
     *
     */
    pImmutableSamplers: VkSampler[] | null;

}

declare interface VkDescriptorSetLayoutBindingInitializer {
  
    /**
     * is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.
     */
    binding?: number;

    /**
     * is a 'VkDescriptorType' specifying which type of resource descriptors are used for this binding.
     */
    descriptorType?: VkDescriptorType;

    /**
     * is the number of descriptors contained in the binding, accessed in a shader as an array , except if 'descriptorType' is 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' in which case 'descriptorCount' is the size in bytes of the inline uniform block
     */
    descriptorCount?: number;

    /**
     *
     */
    stageFlags?: VkShaderStageFlagBits;

    /**
     *
     */
    pImmutableSamplers?: VkSampler[] | null;
}

declare interface VkDescriptorSetLayoutBindingConstructor {
  readonly prototype: VkDescriptorSetLayoutBinding;
  new(param?: VkDescriptorSetLayoutBindingInitializer | null): VkDescriptorSetLayoutBinding;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorSetLayoutBinding: VkDescriptorSetLayoutBindingConstructor;



  /**
   * Structure specifying parameters of a newly created shader module
   */
interface VkShaderModuleCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: VkShaderModuleCreateFlagBits;

    /**
     * is the size, in bytes, of the code pointed to by 'pCode'.
     */
    codeSize: bigint | number;

    /**
     * is a reference to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by 'pCode'.
     */
    pCode: Uint8Array | null;

}

declare interface VkShaderModuleCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: VkShaderModuleCreateFlagBits;

    /**
     * is the size, in bytes, of the code pointed to by 'pCode'.
     */
    codeSize?: bigint | number;

    /**
     * is a reference to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by 'pCode'.
     */
    pCode?: Uint8Array | null;
}

declare interface VkShaderModuleCreateInfoConstructor {
  readonly prototype: VkShaderModuleCreateInfo;
  new(param?: VkShaderModuleCreateInfoInitializer | null): VkShaderModuleCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkShaderModuleCreateInfo: VkShaderModuleCreateInfoConstructor;



  /**
   * Structure specifying an image resolve operation
   */
interface VkImageResolve {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    srcSubresource: VkImageSubresourceLayers | null;

    /**
     *
     */
    srcOffset: VkOffset3D | null;

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.
     */
    dstSubresource: VkImageSubresourceLayers | null;

    /**
     *
     */
    dstOffset: VkOffset3D | null;

    /**
     * is the size in texels of the source image to resolve in 'width', 'height' and 'depth'.
     */
    extent: VkExtent3D | null;

}

declare interface VkImageResolveInitializer {
  
    /**
     *
     */
    srcSubresource?: VkImageSubresourceLayers | null;

    /**
     *
     */
    srcOffset?: VkOffset3D | null;

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.
     */
    dstSubresource?: VkImageSubresourceLayers | null;

    /**
     *
     */
    dstOffset?: VkOffset3D | null;

    /**
     * is the size in texels of the source image to resolve in 'width', 'height' and 'depth'.
     */
    extent?: VkExtent3D | null;
}

declare interface VkImageResolveConstructor {
  readonly prototype: VkImageResolve;
  new(param?: VkImageResolveInitializer | null): VkImageResolve;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageResolve: VkImageResolveConstructor;



  /**
   * Structure specifying a buffer image copy operation
   */
interface VkBufferImageCopy {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the offset in bytes from the start of the buffer object where the image data is copied from or to.
     */
    bufferOffset: bigint | number;

    /**
     *
     */
    bufferRowLength: number;

    /**
     * specify in texels a subregion of a larger two- or three-dimensional image in buffer memory, and control the addressing calculations. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the 'imageExtent'.
     */
    bufferImageHeight: number;

    /**
     * is a 'VkImageSubresourceLayers' used to specify the specific image subresources of the image used for the source or destination image data.
     */
    imageSubresource: VkImageSubresourceLayers | null;

    /**
     *
     */
    imageOffset: VkOffset3D | null;

    /**
     * is the size in texels of the image to copy in 'width', 'height' and 'depth'.
     */
    imageExtent: VkExtent3D | null;

}

declare interface VkBufferImageCopyInitializer {
  
    /**
     * is the offset in bytes from the start of the buffer object where the image data is copied from or to.
     */
    bufferOffset?: bigint | number;

    /**
     *
     */
    bufferRowLength?: number;

    /**
     * specify in texels a subregion of a larger two- or three-dimensional image in buffer memory, and control the addressing calculations. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the 'imageExtent'.
     */
    bufferImageHeight?: number;

    /**
     * is a 'VkImageSubresourceLayers' used to specify the specific image subresources of the image used for the source or destination image data.
     */
    imageSubresource?: VkImageSubresourceLayers | null;

    /**
     *
     */
    imageOffset?: VkOffset3D | null;

    /**
     * is the size in texels of the image to copy in 'width', 'height' and 'depth'.
     */
    imageExtent?: VkExtent3D | null;
}

declare interface VkBufferImageCopyConstructor {
  readonly prototype: VkBufferImageCopy;
  new(param?: VkBufferImageCopyInitializer | null): VkBufferImageCopy;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferImageCopy: VkBufferImageCopyConstructor;



  /**
   * Structure specifying an image blit operation
   */
interface VkImageBlit {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the subresource to blit from.
     */
    srcSubresource: VkImageSubresourceLayers | null;

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the source region within 'srcSubresource'.
     */
    srcOffsets: VkOffset3D[] | null;

    /**
     * is the subresource to blit into.
     */
    dstSubresource: VkImageSubresourceLayers | null;

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the destination region within 'dstSubresource'.
     */
    dstOffsets: VkOffset3D[] | null;

}

declare interface VkImageBlitInitializer {
  
    /**
     * is the subresource to blit from.
     */
    srcSubresource?: VkImageSubresourceLayers | null;

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the source region within 'srcSubresource'.
     */
    srcOffsets?: VkOffset3D[] | null;

    /**
     * is the subresource to blit into.
     */
    dstSubresource?: VkImageSubresourceLayers | null;

    /**
     * is an array of two 'VkOffset3D' structures specifying the bounds of the destination region within 'dstSubresource'.
     */
    dstOffsets?: VkOffset3D[] | null;
}

declare interface VkImageBlitConstructor {
  readonly prototype: VkImageBlit;
  new(param?: VkImageBlitInitializer | null): VkImageBlit;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageBlit: VkImageBlitConstructor;



  /**
   * Structure specifying an image copy operation
   */
interface VkImageCopy {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    srcSubresource: VkImageSubresourceLayers | null;

    /**
     *
     */
    srcOffset: VkOffset3D | null;

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively.
     */
    dstSubresource: VkImageSubresourceLayers | null;

    /**
     *
     */
    dstOffset: VkOffset3D | null;

    /**
     *
     */
    extent: VkExtent3D | null;

}

declare interface VkImageCopyInitializer {
  
    /**
     *
     */
    srcSubresource?: VkImageSubresourceLayers | null;

    /**
     *
     */
    srcOffset?: VkOffset3D | null;

    /**
     * are 'VkImageSubresourceLayers' structures specifying the image subresources of the images used for the source and destination image data, respectively.
     */
    dstSubresource?: VkImageSubresourceLayers | null;

    /**
     *
     */
    dstOffset?: VkOffset3D | null;

    /**
     *
     */
    extent?: VkExtent3D | null;
}

declare interface VkImageCopyConstructor {
  readonly prototype: VkImageCopy;
  new(param?: VkImageCopyInitializer | null): VkImageCopy;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageCopy: VkImageCopyConstructor;



  /**
   * Structure specifying a sparse binding operation
   */
interface VkBindSparseInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the number of semaphores upon which to wait before executing the sparse binding operations for the batch.
     */
    waitSemaphoreCount: number;

    /**
     * is an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a <<synchronization-semaphores-waiting, semaphore wait operation>>.
     */
    pWaitSemaphores: VkSemaphore[] | null;

    /**
     * is the number of sparse buffer bindings to perform in the batch.
     */
    bufferBindCount: number;

    /**
     * is an array of 'VkSparseBufferMemoryBindInfo' structures.
     */
    pBufferBinds: VkSparseBufferMemoryBindInfo[] | null;

    /**
     * is the number of opaque sparse image bindings to perform.
     */
    imageOpaqueBindCount: number;

    /**
     * is an array of 'VkSparseImageOpaqueMemoryBindInfo' structures, indicating opaque sparse image bindings to perform.
     */
    pImageOpaqueBinds: VkSparseImageOpaqueMemoryBindInfo[] | null;

    /**
     * is the number of sparse image bindings to perform.
     */
    imageBindCount: number;

    /**
     * is an array of 'VkSparseImageMemoryBindInfo' structures, indicating sparse image bindings to perform.
     */
    pImageBinds: VkSparseImageMemoryBindInfo[] | null;

    /**
     * is the number of semaphores to be signaled once the sparse binding operations specified by the structure have completed execution.
     */
    signalSemaphoreCount: number;

    /**
     * is an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a <<synchronization-semaphores-signaling, semaphore signal operation>>.
     */
    pSignalSemaphores: VkSemaphore[] | null;

}

declare interface VkBindSparseInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the number of semaphores upon which to wait before executing the sparse binding operations for the batch.
     */
    waitSemaphoreCount?: number;

    /**
     * is an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a <<synchronization-semaphores-waiting, semaphore wait operation>>.
     */
    pWaitSemaphores?: VkSemaphore[] | null;

    /**
     * is the number of sparse buffer bindings to perform in the batch.
     */
    bufferBindCount?: number;

    /**
     * is an array of 'VkSparseBufferMemoryBindInfo' structures.
     */
    pBufferBinds?: VkSparseBufferMemoryBindInfo[] | null;

    /**
     * is the number of opaque sparse image bindings to perform.
     */
    imageOpaqueBindCount?: number;

    /**
     * is an array of 'VkSparseImageOpaqueMemoryBindInfo' structures, indicating opaque sparse image bindings to perform.
     */
    pImageOpaqueBinds?: VkSparseImageOpaqueMemoryBindInfo[] | null;

    /**
     * is the number of sparse image bindings to perform.
     */
    imageBindCount?: number;

    /**
     * is an array of 'VkSparseImageMemoryBindInfo' structures, indicating sparse image bindings to perform.
     */
    pImageBinds?: VkSparseImageMemoryBindInfo[] | null;

    /**
     * is the number of semaphores to be signaled once the sparse binding operations specified by the structure have completed execution.
     */
    signalSemaphoreCount?: number;

    /**
     * is an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a <<synchronization-semaphores-signaling, semaphore signal operation>>.
     */
    pSignalSemaphores?: VkSemaphore[] | null;
}

declare interface VkBindSparseInfoConstructor {
  readonly prototype: VkBindSparseInfo;
  new(param?: VkBindSparseInfoInitializer | null): VkBindSparseInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBindSparseInfo: VkBindSparseInfoConstructor;



  /**
   * Structure specifying sparse image memory bind info
   */
interface VkSparseImageMemoryBindInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the 'VkImage' object to be bound
     */
    image: VkImage | null;

    /**
     * is the number of 'VkSparseImageMemoryBind' structures in 'pBinds' array
     */
    bindCount: number;

    /**
     * is an array of 'VkSparseImageMemoryBind' structures
     */
    pBinds: VkSparseImageMemoryBind[] | null;

}

declare interface VkSparseImageMemoryBindInfoInitializer {
  
    /**
     * is the 'VkImage' object to be bound
     */
    image?: VkImage | null;

    /**
     * is the number of 'VkSparseImageMemoryBind' structures in 'pBinds' array
     */
    bindCount?: number;

    /**
     * is an array of 'VkSparseImageMemoryBind' structures
     */
    pBinds?: VkSparseImageMemoryBind[] | null;
}

declare interface VkSparseImageMemoryBindInfoConstructor {
  readonly prototype: VkSparseImageMemoryBindInfo;
  new(param?: VkSparseImageMemoryBindInfoInitializer | null): VkSparseImageMemoryBindInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseImageMemoryBindInfo: VkSparseImageMemoryBindInfoConstructor;



  /**
   * Structure specifying sparse image opaque memory bind info
   */
interface VkSparseImageOpaqueMemoryBindInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the 'VkImage' object to be bound.
     */
    image: VkImage | null;

    /**
     * is the number of 'VkSparseMemoryBind' structures in the 'pBinds' array.
     */
    bindCount: number;

    /**
     * is an array of 'VkSparseMemoryBind' structures.
     */
    pBinds: VkSparseMemoryBind[] | null;

}

declare interface VkSparseImageOpaqueMemoryBindInfoInitializer {
  
    /**
     * is the 'VkImage' object to be bound.
     */
    image?: VkImage | null;

    /**
     * is the number of 'VkSparseMemoryBind' structures in the 'pBinds' array.
     */
    bindCount?: number;

    /**
     * is an array of 'VkSparseMemoryBind' structures.
     */
    pBinds?: VkSparseMemoryBind[] | null;
}

declare interface VkSparseImageOpaqueMemoryBindInfoConstructor {
  readonly prototype: VkSparseImageOpaqueMemoryBindInfo;
  new(param?: VkSparseImageOpaqueMemoryBindInfoInitializer | null): VkSparseImageOpaqueMemoryBindInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseImageOpaqueMemoryBindInfo: VkSparseImageOpaqueMemoryBindInfoConstructor;



  /**
   * Structure specifying a sparse buffer memory bind operation
   */
interface VkSparseBufferMemoryBindInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the 'VkBuffer' object to be bound.
     */
    buffer: VkBuffer | null;

    /**
     * is the number of 'VkSparseMemoryBind' structures in the 'pBinds' array.
     */
    bindCount: number;

    /**
     * is a reference to array of 'VkSparseMemoryBind' structures.
     */
    pBinds: VkSparseMemoryBind[] | null;

}

declare interface VkSparseBufferMemoryBindInfoInitializer {
  
    /**
     * is the 'VkBuffer' object to be bound.
     */
    buffer?: VkBuffer | null;

    /**
     * is the number of 'VkSparseMemoryBind' structures in the 'pBinds' array.
     */
    bindCount?: number;

    /**
     * is a reference to array of 'VkSparseMemoryBind' structures.
     */
    pBinds?: VkSparseMemoryBind[] | null;
}

declare interface VkSparseBufferMemoryBindInfoConstructor {
  readonly prototype: VkSparseBufferMemoryBindInfo;
  new(param?: VkSparseBufferMemoryBindInfoInitializer | null): VkSparseBufferMemoryBindInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseBufferMemoryBindInfo: VkSparseBufferMemoryBindInfoConstructor;



  /**
   * Structure specifying sparse image memory bind
   */
interface VkSparseImageMemoryBind {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    subresource: VkImageSubresource | null;

    /**
     *
     */
    offset: VkOffset3D | null;

    /**
     *
     */
    extent: VkExtent3D | null;

    /**
     * is the 'VkDeviceMemory' object that the sparse image blocks of the image are bound to. If 'memory' is 'VK_NULL_HANDLE', the sparse image blocks are unbound.
     */
    memory: VkDeviceMemory | null;

    /**
     * is an offset into 'VkDeviceMemory' object. If 'memory' is 'VK_NULL_HANDLE', this value is ignored.
     */
    memoryOffset: bigint | number;

    /**
     * are sparse memory binding flags.
     */
    flags: VkSparseMemoryBindFlagBits;

}

declare interface VkSparseImageMemoryBindInitializer {
  
    /**
     *
     */
    subresource?: VkImageSubresource | null;

    /**
     *
     */
    offset?: VkOffset3D | null;

    /**
     *
     */
    extent?: VkExtent3D | null;

    /**
     * is the 'VkDeviceMemory' object that the sparse image blocks of the image are bound to. If 'memory' is 'VK_NULL_HANDLE', the sparse image blocks are unbound.
     */
    memory?: VkDeviceMemory | null;

    /**
     * is an offset into 'VkDeviceMemory' object. If 'memory' is 'VK_NULL_HANDLE', this value is ignored.
     */
    memoryOffset?: bigint | number;

    /**
     * are sparse memory binding flags.
     */
    flags?: VkSparseMemoryBindFlagBits;
}

declare interface VkSparseImageMemoryBindConstructor {
  readonly prototype: VkSparseImageMemoryBind;
  new(param?: VkSparseImageMemoryBindInitializer | null): VkSparseImageMemoryBind;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseImageMemoryBind: VkSparseImageMemoryBindConstructor;



  /**
   * Structure specifying a sparse memory bind operation
   */
interface VkSparseMemoryBind {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the offset into the resource.
     */
    resourceOffset: bigint | number;

    /**
     * is the size of the memory region to be bound.
     */
    size: bigint | number;

    /**
     * is the 'VkDeviceMemory' object that the range of the resource is bound to. If 'memory' is 'VK_NULL_HANDLE', the range is unbound.
     */
    memory: VkDeviceMemory | null;

    /**
     * is the offset into the 'VkDeviceMemory' object to bind the resource range to. If 'memory' is 'VK_NULL_HANDLE', this value is ignored.
     */
    memoryOffset: bigint | number;

    /**
     * is a bitmask of 'VkSparseMemoryBindFlagBits' specifying usage of the binding operation.
     */
    flags: VkSparseMemoryBindFlagBits;

}

declare interface VkSparseMemoryBindInitializer {
  
    /**
     * is the offset into the resource.
     */
    resourceOffset?: bigint | number;

    /**
     * is the size of the memory region to be bound.
     */
    size?: bigint | number;

    /**
     * is the 'VkDeviceMemory' object that the range of the resource is bound to. If 'memory' is 'VK_NULL_HANDLE', the range is unbound.
     */
    memory?: VkDeviceMemory | null;

    /**
     * is the offset into the 'VkDeviceMemory' object to bind the resource range to. If 'memory' is 'VK_NULL_HANDLE', this value is ignored.
     */
    memoryOffset?: bigint | number;

    /**
     * is a bitmask of 'VkSparseMemoryBindFlagBits' specifying usage of the binding operation.
     */
    flags?: VkSparseMemoryBindFlagBits;
}

declare interface VkSparseMemoryBindConstructor {
  readonly prototype: VkSparseMemoryBind;
  new(param?: VkSparseMemoryBindInitializer | null): VkSparseMemoryBind;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseMemoryBind: VkSparseMemoryBindConstructor;



  /**
   * Structure specifying a buffer copy operation
   */
interface VkBufferCopy {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the starting offset in bytes from the start of 'srcBuffer'.
     */
    srcOffset: bigint | number;

    /**
     * is the starting offset in bytes from the start of 'dstBuffer'.
     */
    dstOffset: bigint | number;

    /**
     * is the number of bytes to copy.
     */
    size: bigint | number;

}

declare interface VkBufferCopyInitializer {
  
    /**
     * is the starting offset in bytes from the start of 'srcBuffer'.
     */
    srcOffset?: bigint | number;

    /**
     * is the starting offset in bytes from the start of 'dstBuffer'.
     */
    dstOffset?: bigint | number;

    /**
     * is the number of bytes to copy.
     */
    size?: bigint | number;
}

declare interface VkBufferCopyConstructor {
  readonly prototype: VkBufferCopy;
  new(param?: VkBufferCopyInitializer | null): VkBufferCopy;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferCopy: VkBufferCopyConstructor;



  /**
   * Structure specifying parameters of a newly created image view
   */
interface VkImageViewCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkImageViewCreateFlagBits' describing additional parameters of the image view.
     */
    flags: VkImageViewCreateFlagBits;

    /**
     * is a 'VkImage' on which the view will be created.
     */
    image: VkImage | null;

    /**
     * is a 'VkImageViewType' value specifying the type of the image view.
     */
    viewType: VkImageViewType;

    /**
     * is a 'VkFormat' describing the format and type used to interpret texel blocks in the image.
     */
    format: VkFormat;

    /**
     * is a 'VkComponentMapping' specifies a remapping of color components (or of depth or stencil components after they have been converted into color components).
     */
    components: VkComponentMapping | null;

    /**
     * is a 'VkImageSubresourceRange' selecting the set of mipmap levels and array layers to be accessible to the view.
     */
    subresourceRange: VkImageSubresourceRange | null;

}

declare interface VkImageViewCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkImageViewCreateFlagBits' describing additional parameters of the image view.
     */
    flags?: VkImageViewCreateFlagBits;

    /**
     * is a 'VkImage' on which the view will be created.
     */
    image?: VkImage | null;

    /**
     * is a 'VkImageViewType' value specifying the type of the image view.
     */
    viewType?: VkImageViewType;

    /**
     * is a 'VkFormat' describing the format and type used to interpret texel blocks in the image.
     */
    format?: VkFormat;

    /**
     * is a 'VkComponentMapping' specifies a remapping of color components (or of depth or stencil components after they have been converted into color components).
     */
    components?: VkComponentMapping | null;

    /**
     * is a 'VkImageSubresourceRange' selecting the set of mipmap levels and array layers to be accessible to the view.
     */
    subresourceRange?: VkImageSubresourceRange | null;
}

declare interface VkImageViewCreateInfoConstructor {
  readonly prototype: VkImageViewCreateInfo;
  new(param?: VkImageViewCreateInfoInitializer | null): VkImageViewCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageViewCreateInfo: VkImageViewCreateInfoConstructor;



  /**
   * Structure specifying subresource layout
   */
interface VkSubresourceLayout {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the byte offset from the start of the image or the plane
     */
    readonly offset: bigint | number;

    /**
     *
     */
    readonly size: bigint | number;

    /**
     *
     */
    readonly rowPitch: bigint | number;

    /**
     *
     */
    readonly arrayPitch: bigint | number;

    /**
     *
     */
    readonly depthPitch: bigint | number;

}

declare interface VkSubresourceLayoutInitializer {
  
    /**
     * is the byte offset from the start of the image or the plane
     */
    readonly offset?: bigint | number;

    /**
     *
     */
    readonly size?: bigint | number;

    /**
     *
     */
    readonly rowPitch?: bigint | number;

    /**
     *
     */
    readonly arrayPitch?: bigint | number;

    /**
     *
     */
    readonly depthPitch?: bigint | number;
}

declare interface VkSubresourceLayoutConstructor {
  readonly prototype: VkSubresourceLayout;
  new(param?: VkSubresourceLayoutInitializer | null): VkSubresourceLayout;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSubresourceLayout: VkSubresourceLayoutConstructor;



  /**
   * Structure specifying the parameters of a newly created image object
   */
interface VkImageCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkImageCreateFlagBits' describing additional parameters of the image.
     */
    flags: VkImageCreateFlagBits;

    /**
     * is a 'VkImageType' value specifying the basic dimensionality of the image. Layers in array textures do not count as a dimension for the purposes of the image type.
     */
    imageType: VkImageType;

    /**
     * is a 'VkFormat' describing the format and type of the texel blocks that will be contained in the image.
     */
    format: VkFormat;

    /**
     * is a 'VkExtent3D' describing the number of data elements in each dimension of the base level.
     */
    extent: VkExtent3D | null;

    /**
     * describes the number of levels of detail available for minified sampling of the image.
     */
    mipLevels: number;

    /**
     * is the number of layers in the image.
     */
    arrayLayers: number;

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of <<primsrast-multisampling,samples per texel>>.
     */
    samples: VkSampleCountFlagBits;

    /**
     * is a 'VkImageTiling' value specifying the tiling arrangement of the texel blocks in memory.
     */
    tiling: VkImageTiling;

    /**
     * is a bitmask of 'VkImageUsageFlagBits' describing the intended usage of the image.
     */
    usage: VkImageUsageFlagBits;

    /**
     * is a 'VkSharingMode' value specifying the sharing mode of the image when it will be accessed by multiple queue families.
     */
    sharingMode: VkSharingMode;

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount: number;

    /**
     * is a list of queue families that will access this image (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices: Uint32Array | null;

    /**
     * is a 'VkImageLayout' value specifying the initial 'VkImageLayout' of all image subresources of the image. See <<resources-image-layouts,Image Layouts>>.
     */
    initialLayout: VkImageLayout;

}

declare interface VkImageCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkImageCreateFlagBits' describing additional parameters of the image.
     */
    flags?: VkImageCreateFlagBits;

    /**
     * is a 'VkImageType' value specifying the basic dimensionality of the image. Layers in array textures do not count as a dimension for the purposes of the image type.
     */
    imageType?: VkImageType;

    /**
     * is a 'VkFormat' describing the format and type of the texel blocks that will be contained in the image.
     */
    format?: VkFormat;

    /**
     * is a 'VkExtent3D' describing the number of data elements in each dimension of the base level.
     */
    extent?: VkExtent3D | null;

    /**
     * describes the number of levels of detail available for minified sampling of the image.
     */
    mipLevels?: number;

    /**
     * is the number of layers in the image.
     */
    arrayLayers?: number;

    /**
     * is a 'VkSampleCountFlagBits' specifying the number of <<primsrast-multisampling,samples per texel>>.
     */
    samples?: VkSampleCountFlagBits;

    /**
     * is a 'VkImageTiling' value specifying the tiling arrangement of the texel blocks in memory.
     */
    tiling?: VkImageTiling;

    /**
     * is a bitmask of 'VkImageUsageFlagBits' describing the intended usage of the image.
     */
    usage?: VkImageUsageFlagBits;

    /**
     * is a 'VkSharingMode' value specifying the sharing mode of the image when it will be accessed by multiple queue families.
     */
    sharingMode?: VkSharingMode;

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount?: number;

    /**
     * is a list of queue families that will access this image (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices?: Uint32Array | null;

    /**
     * is a 'VkImageLayout' value specifying the initial 'VkImageLayout' of all image subresources of the image. See <<resources-image-layouts,Image Layouts>>.
     */
    initialLayout?: VkImageLayout;
}

declare interface VkImageCreateInfoConstructor {
  readonly prototype: VkImageCreateInfo;
  new(param?: VkImageCreateInfoInitializer | null): VkImageCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageCreateInfo: VkImageCreateInfoConstructor;



  /**
   * Structure specifying the parameters of an image memory barrier
   */
interface VkImageMemoryBarrier {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask: VkAccessFlagBits;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask: VkAccessFlagBits;

    /**
     * is the old layout in an <<synchronization-image-layout-transitions, image layout transition>>.
     */
    oldLayout: VkImageLayout;

    /**
     * is the new layout in an <<synchronization-image-layout-transitions, image layout transition>>.
     */
    newLayout: VkImageLayout;

    /**
     * is the source queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    srcQueueFamilyIndex: number;

    /**
     * is the destination queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    dstQueueFamilyIndex: number;

    /**
     * is a handle to the image affected by this barrier.
     */
    image: VkImage | null;

    /**
     * describes the <<resources-image-views, image subresource range>> within 'image' that is affected by this barrier.
     */
    subresourceRange: VkImageSubresourceRange | null;

}

declare interface VkImageMemoryBarrierInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask?: VkAccessFlagBits;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask?: VkAccessFlagBits;

    /**
     * is the old layout in an <<synchronization-image-layout-transitions, image layout transition>>.
     */
    oldLayout?: VkImageLayout;

    /**
     * is the new layout in an <<synchronization-image-layout-transitions, image layout transition>>.
     */
    newLayout?: VkImageLayout;

    /**
     * is the source queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    srcQueueFamilyIndex?: number;

    /**
     * is the destination queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    dstQueueFamilyIndex?: number;

    /**
     * is a handle to the image affected by this barrier.
     */
    image?: VkImage | null;

    /**
     * describes the <<resources-image-views, image subresource range>> within 'image' that is affected by this barrier.
     */
    subresourceRange?: VkImageSubresourceRange | null;
}

declare interface VkImageMemoryBarrierConstructor {
  readonly prototype: VkImageMemoryBarrier;
  new(param?: VkImageMemoryBarrierInitializer | null): VkImageMemoryBarrier;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageMemoryBarrier: VkImageMemoryBarrierConstructor;



  /**
   * Structure specifying a buffer memory barrier
   */
interface VkBufferMemoryBarrier {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask: VkAccessFlagBits;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask: VkAccessFlagBits;

    /**
     * is the source queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    srcQueueFamilyIndex: number;

    /**
     * is the destination queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    dstQueueFamilyIndex: number;

    /**
     * is a handle to the buffer whose backing memory is affected by the barrier.
     */
    buffer: VkBuffer | null;

    /**
     * is an offset in bytes into the backing memory for 'buffer'; this is relative to the base offset as bound to the buffer (see 'vkBindBufferMemory').
     */
    offset: bigint | number;

    /**
     * is a size in bytes of the affected area of backing memory for 'buffer', or 'VK_WHOLE_SIZE' to use the range from 'offset' to the end of the buffer.
     */
    size: bigint | number;

}

declare interface VkBufferMemoryBarrierInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask?: VkAccessFlagBits;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask?: VkAccessFlagBits;

    /**
     * is the source queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    srcQueueFamilyIndex?: number;

    /**
     * is the destination queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.
     */
    dstQueueFamilyIndex?: number;

    /**
     * is a handle to the buffer whose backing memory is affected by the barrier.
     */
    buffer?: VkBuffer | null;

    /**
     * is an offset in bytes into the backing memory for 'buffer'; this is relative to the base offset as bound to the buffer (see 'vkBindBufferMemory').
     */
    offset?: bigint | number;

    /**
     * is a size in bytes of the affected area of backing memory for 'buffer', or 'VK_WHOLE_SIZE' to use the range from 'offset' to the end of the buffer.
     */
    size?: bigint | number;
}

declare interface VkBufferMemoryBarrierConstructor {
  readonly prototype: VkBufferMemoryBarrier;
  new(param?: VkBufferMemoryBarrierInitializer | null): VkBufferMemoryBarrier;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferMemoryBarrier: VkBufferMemoryBarrierConstructor;



  /**
   * Structure specifying a global memory barrier
   */
interface VkMemoryBarrier {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask: VkAccessFlagBits;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask: VkAccessFlagBits;

}

declare interface VkMemoryBarrierInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, source access mask>>.
     */
    srcAccessMask?: VkAccessFlagBits;

    /**
     * is a bitmask of 'VkAccessFlagBits' specifying a <<synchronization-access-masks, destination access mask>>.
     */
    dstAccessMask?: VkAccessFlagBits;
}

declare interface VkMemoryBarrierConstructor {
  readonly prototype: VkMemoryBarrier;
  new(param?: VkMemoryBarrierInitializer | null): VkMemoryBarrier;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryBarrier: VkMemoryBarrierConstructor;



  /**
   * Structure specifying an image subresource range
   */
interface VkImageSubresourceRange {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a bitmask of 'VkImageAspectFlagBits' specifying which aspect(s) of the image are included in the view.
     */
    aspectMask: VkImageAspectFlagBits;

    /**
     * is the first mipmap level accessible to the view.
     */
    baseMipLevel: number;

    /**
     * is the number of mipmap levels (starting from 'baseMipLevel') accessible to the view.
     */
    levelCount: number;

    /**
     * is the first array layer accessible to the view.
     */
    baseArrayLayer: number;

    /**
     * is the number of array layers (starting from 'baseArrayLayer') accessible to the view.
     */
    layerCount: number;

}

declare interface VkImageSubresourceRangeInitializer {
  
    /**
     * is a bitmask of 'VkImageAspectFlagBits' specifying which aspect(s) of the image are included in the view.
     */
    aspectMask?: VkImageAspectFlagBits;

    /**
     * is the first mipmap level accessible to the view.
     */
    baseMipLevel?: number;

    /**
     * is the number of mipmap levels (starting from 'baseMipLevel') accessible to the view.
     */
    levelCount?: number;

    /**
     * is the first array layer accessible to the view.
     */
    baseArrayLayer?: number;

    /**
     * is the number of array layers (starting from 'baseArrayLayer') accessible to the view.
     */
    layerCount?: number;
}

declare interface VkImageSubresourceRangeConstructor {
  readonly prototype: VkImageSubresourceRange;
  new(param?: VkImageSubresourceRangeInitializer | null): VkImageSubresourceRange;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageSubresourceRange: VkImageSubresourceRangeConstructor;



  /**
   * Structure specifying an image subresource layers
   */
interface VkImageSubresourceLayers {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a combination of 'VkImageAspectFlagBits', selecting the color, depth and/or stencil aspects to be copied.
     */
    aspectMask: VkImageAspectFlagBits;

    /**
     * is the mipmap level to copy from.
     */
    mipLevel: number;

    /**
     *
     */
    baseArrayLayer: number;

    /**
     * are the starting layer and number of layers to copy.
     */
    layerCount: number;

}

declare interface VkImageSubresourceLayersInitializer {
  
    /**
     * is a combination of 'VkImageAspectFlagBits', selecting the color, depth and/or stencil aspects to be copied.
     */
    aspectMask?: VkImageAspectFlagBits;

    /**
     * is the mipmap level to copy from.
     */
    mipLevel?: number;

    /**
     *
     */
    baseArrayLayer?: number;

    /**
     * are the starting layer and number of layers to copy.
     */
    layerCount?: number;
}

declare interface VkImageSubresourceLayersConstructor {
  readonly prototype: VkImageSubresourceLayers;
  new(param?: VkImageSubresourceLayersInitializer | null): VkImageSubresourceLayers;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageSubresourceLayers: VkImageSubresourceLayersConstructor;



  /**
   * Structure specifying an image subresource
   */
interface VkImageSubresource {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a 'VkImageAspectFlags' selecting the image _aspect_.
     */
    aspectMask: VkImageAspectFlagBits;

    /**
     * selects the mipmap level.
     */
    mipLevel: number;

    /**
     * selects the array layer.
     */
    arrayLayer: number;

}

declare interface VkImageSubresourceInitializer {
  
    /**
     * is a 'VkImageAspectFlags' selecting the image _aspect_.
     */
    aspectMask?: VkImageAspectFlagBits;

    /**
     * selects the mipmap level.
     */
    mipLevel?: number;

    /**
     * selects the array layer.
     */
    arrayLayer?: number;
}

declare interface VkImageSubresourceConstructor {
  readonly prototype: VkImageSubresource;
  new(param?: VkImageSubresourceInitializer | null): VkImageSubresource;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageSubresource: VkImageSubresourceConstructor;



  /**
   * Structure specifying parameters of a newly created buffer view
   */
interface VkBufferViewCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is a 'VkBuffer' on which the view will be created.
     */
    buffer: VkBuffer | null;

    /**
     * is a 'VkFormat' describing the format of the data elements in the buffer.
     */
    format: VkFormat;

    /**
     * is an offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset.
     */
    offset: bigint | number;

    /**
     * is a size in bytes of the buffer view. If 'range' is equal to 'VK_WHOLE_SIZE', the range from 'offset' to the end of the buffer is used. If 'VK_WHOLE_SIZE' is used and the remaining size of the buffer is not a multiple of the <<texel-block-size, texel block size>> of 'format', the nearest smaller multiple is used.
     */
    range: bigint | number;

}

declare interface VkBufferViewCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is a 'VkBuffer' on which the view will be created.
     */
    buffer?: VkBuffer | null;

    /**
     * is a 'VkFormat' describing the format of the data elements in the buffer.
     */
    format?: VkFormat;

    /**
     * is an offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset.
     */
    offset?: bigint | number;

    /**
     * is a size in bytes of the buffer view. If 'range' is equal to 'VK_WHOLE_SIZE', the range from 'offset' to the end of the buffer is used. If 'VK_WHOLE_SIZE' is used and the remaining size of the buffer is not a multiple of the <<texel-block-size, texel block size>> of 'format', the nearest smaller multiple is used.
     */
    range?: bigint | number;
}

declare interface VkBufferViewCreateInfoConstructor {
  readonly prototype: VkBufferViewCreateInfo;
  new(param?: VkBufferViewCreateInfoInitializer | null): VkBufferViewCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferViewCreateInfo: VkBufferViewCreateInfoConstructor;



  /**
   * Structure specifying the parameters of a newly created buffer object
   */
interface VkBufferCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is a bitmask of 'VkBufferCreateFlagBits' specifying additional parameters of the buffer.
     */
    flags: VkBufferCreateFlagBits;

    /**
     * is the size in bytes of the buffer to be created.
     */
    size: bigint | number;

    /**
     * is a bitmask of 'VkBufferUsageFlagBits' specifying allowed usages of the buffer.
     */
    usage: VkBufferUsageFlagBits;

    /**
     * is a 'VkSharingMode' value specifying the sharing mode of the buffer when it will be accessed by multiple queue families.
     */
    sharingMode: VkSharingMode;

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount: number;

    /**
     * is a list of queue families that will access this buffer (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices: Uint32Array | null;

}

declare interface VkBufferCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is a bitmask of 'VkBufferCreateFlagBits' specifying additional parameters of the buffer.
     */
    flags?: VkBufferCreateFlagBits;

    /**
     * is the size in bytes of the buffer to be created.
     */
    size?: bigint | number;

    /**
     * is a bitmask of 'VkBufferUsageFlagBits' specifying allowed usages of the buffer.
     */
    usage?: VkBufferUsageFlagBits;

    /**
     * is a 'VkSharingMode' value specifying the sharing mode of the buffer when it will be accessed by multiple queue families.
     */
    sharingMode?: VkSharingMode;

    /**
     * is the number of entries in the 'pQueueFamilyIndices' array.
     */
    queueFamilyIndexCount?: number;

    /**
     * is a list of queue families that will access this buffer (ignored if 'sharingMode' is not 'VK_SHARING_MODE_CONCURRENT').
     */
    pQueueFamilyIndices?: Uint32Array | null;
}

declare interface VkBufferCreateInfoConstructor {
  readonly prototype: VkBufferCreateInfo;
  new(param?: VkBufferCreateInfoInitializer | null): VkBufferCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBufferCreateInfo: VkBufferCreateInfoConstructor;



  /**
   * Structure specifying a copy descriptor set operation
   */
interface VkCopyDescriptorSet {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     *
     */
    srcSet: VkDescriptorSet | null;

    /**
     *
     */
    srcBinding: number;

    /**
     * are the source set, binding, and array element, respectively. If the descriptor binding identified by 'srcSet' and 'srcBinding' has a descriptor type of 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'srcArrayElement' specifies the starting byte offset within the binding to copy from.
     */
    srcArrayElement: number;

    /**
     *
     */
    dstSet: VkDescriptorSet | null;

    /**
     *
     */
    dstBinding: number;

    /**
     *
     */
    dstArrayElement: number;

    /**
     *
     */
    descriptorCount: number;

}

declare interface VkCopyDescriptorSetInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     *
     */
    srcSet?: VkDescriptorSet | null;

    /**
     *
     */
    srcBinding?: number;

    /**
     * are the source set, binding, and array element, respectively. If the descriptor binding identified by 'srcSet' and 'srcBinding' has a descriptor type of 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'srcArrayElement' specifies the starting byte offset within the binding to copy from.
     */
    srcArrayElement?: number;

    /**
     *
     */
    dstSet?: VkDescriptorSet | null;

    /**
     *
     */
    dstBinding?: number;

    /**
     *
     */
    dstArrayElement?: number;

    /**
     *
     */
    descriptorCount?: number;
}

declare interface VkCopyDescriptorSetConstructor {
  readonly prototype: VkCopyDescriptorSet;
  new(param?: VkCopyDescriptorSetInitializer | null): VkCopyDescriptorSet;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkCopyDescriptorSet: VkCopyDescriptorSetConstructor;



  /**
   * Structure specifying the parameters of a descriptor set write operation
   */
interface VkWriteDescriptorSet {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the destination descriptor set to update.
     */
    dstSet: VkDescriptorSet | null;

    /**
     * is the descriptor binding within that set.
     */
    dstBinding: number;

    /**
     * is the starting element in that array. If the descriptor binding identified by 'dstSet' and 'dstBinding' has a descriptor type of 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'dstArrayElement' specifies the starting byte offset within the binding.
     */
    dstArrayElement: number;

    /**
     *
     */
    descriptorCount: number;

    /**
     *
     */
    descriptorType: VkDescriptorType;

    /**
     *
     */
    pImageInfo: VkDescriptorImageInfo[] | null;

    /**
     *
     */
    pBufferInfo: VkDescriptorBufferInfo[] | null;

    /**
     *
     */
    pTexelBufferView: VkBufferView[] | null;

}

declare interface VkWriteDescriptorSetInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the destination descriptor set to update.
     */
    dstSet?: VkDescriptorSet | null;

    /**
     * is the descriptor binding within that set.
     */
    dstBinding?: number;

    /**
     * is the starting element in that array. If the descriptor binding identified by 'dstSet' and 'dstBinding' has a descriptor type of 'VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT' then 'dstArrayElement' specifies the starting byte offset within the binding.
     */
    dstArrayElement?: number;

    /**
     *
     */
    descriptorCount?: number;

    /**
     *
     */
    descriptorType?: VkDescriptorType;

    /**
     *
     */
    pImageInfo?: VkDescriptorImageInfo[] | null;

    /**
     *
     */
    pBufferInfo?: VkDescriptorBufferInfo[] | null;

    /**
     *
     */
    pTexelBufferView?: VkBufferView[] | null;
}

declare interface VkWriteDescriptorSetConstructor {
  readonly prototype: VkWriteDescriptorSet;
  new(param?: VkWriteDescriptorSetInitializer | null): VkWriteDescriptorSet;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkWriteDescriptorSet: VkWriteDescriptorSetConstructor;



  /**
   * Structure specifying descriptor image info
   */
interface VkDescriptorImageInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a sampler handle, and is used in descriptor updates for types 'VK_DESCRIPTOR_TYPE_SAMPLER' and 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER' if the binding being updated does not use immutable samplers.
     */
    sampler: VkSampler | null;

    /**
     * is 'VK_NULL_HANDLE' or
     */
    imageView: VkImageView | null;

    /**
     *
     */
    imageLayout: VkImageLayout;

}

declare interface VkDescriptorImageInfoInitializer {
  
    /**
     * is a sampler handle, and is used in descriptor updates for types 'VK_DESCRIPTOR_TYPE_SAMPLER' and 'VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER' if the binding being updated does not use immutable samplers.
     */
    sampler?: VkSampler | null;

    /**
     * is 'VK_NULL_HANDLE' or
     */
    imageView?: VkImageView | null;

    /**
     *
     */
    imageLayout?: VkImageLayout;
}

declare interface VkDescriptorImageInfoConstructor {
  readonly prototype: VkDescriptorImageInfo;
  new(param?: VkDescriptorImageInfoInitializer | null): VkDescriptorImageInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorImageInfo: VkDescriptorImageInfoConstructor;



  /**
   * Structure specifying descriptor buffer info
   */
interface VkDescriptorBufferInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is'VK_NULL_HANDLE' or
     */
    buffer: VkBuffer | null;

    /**
     *
     */
    offset: bigint | number;

    /**
     *
     */
    range: bigint | number;

}

declare interface VkDescriptorBufferInfoInitializer {
  
    /**
     * is'VK_NULL_HANDLE' or
     */
    buffer?: VkBuffer | null;

    /**
     *
     */
    offset?: bigint | number;

    /**
     *
     */
    range?: bigint | number;
}

declare interface VkDescriptorBufferInfoConstructor {
  readonly prototype: VkDescriptorBufferInfo;
  new(param?: VkDescriptorBufferInfoInitializer | null): VkDescriptorBufferInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDescriptorBufferInfo: VkDescriptorBufferInfoConstructor;



  /**
   * Structure specifying an image format properties
   */
interface VkImageFormatProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * are the maximum image dimensions. See the <<features-extentperimagetype,Allowed Extent Values>> section below for how these values are constrained by 'type'.
     */
    readonly maxExtent: VkExtent3D | null;

    /**
     * is the maximum number of mipmap levels. 'maxMipLevels' 'must' be equal to the number of levels in the complete mipmap chain based on the [eq]#'maxExtent.width'#, [eq]#'maxExtent.height'#, and [eq]#'maxExtent.depth'#, except when one of the following conditions is true, in which case it 'may' instead be `1`:
     */
    readonly maxMipLevels: number;

    /**
     *
     */
    readonly maxArrayLayers: number;

    /**
     *
     */
    readonly sampleCounts: VkSampleCountFlagBits;

    /**
     *
     */
    readonly maxResourceSize: bigint | number;

}

declare interface VkImageFormatPropertiesInitializer {
  
    /**
     * are the maximum image dimensions. See the <<features-extentperimagetype,Allowed Extent Values>> section below for how these values are constrained by 'type'.
     */
    readonly maxExtent?: VkExtent3D | null;

    /**
     * is the maximum number of mipmap levels. 'maxMipLevels' 'must' be equal to the number of levels in the complete mipmap chain based on the [eq]#'maxExtent.width'#, [eq]#'maxExtent.height'#, and [eq]#'maxExtent.depth'#, except when one of the following conditions is true, in which case it 'may' instead be `1`:
     */
    readonly maxMipLevels?: number;

    /**
     *
     */
    readonly maxArrayLayers?: number;

    /**
     *
     */
    readonly sampleCounts?: VkSampleCountFlagBits;

    /**
     *
     */
    readonly maxResourceSize?: bigint | number;
}

declare interface VkImageFormatPropertiesConstructor {
  readonly prototype: VkImageFormatProperties;
  new(param?: VkImageFormatPropertiesInitializer | null): VkImageFormatProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkImageFormatProperties: VkImageFormatPropertiesConstructor;



  /**
   * Structure specifying image format properties
   */
interface VkFormatProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by images created with a 'tiling' parameter of 'VK_IMAGE_TILING_LINEAR'.
     */
    readonly linearTilingFeatures: VkFormatFeatureFlagBits;

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by images created with a 'tiling' parameter of 'VK_IMAGE_TILING_OPTIMAL'.
     */
    readonly optimalTilingFeatures: VkFormatFeatureFlagBits;

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by buffers.
     */
    readonly bufferFeatures: VkFormatFeatureFlagBits;

}

declare interface VkFormatPropertiesInitializer {
  
    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by images created with a 'tiling' parameter of 'VK_IMAGE_TILING_LINEAR'.
     */
    readonly linearTilingFeatures?: VkFormatFeatureFlagBits;

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by images created with a 'tiling' parameter of 'VK_IMAGE_TILING_OPTIMAL'.
     */
    readonly optimalTilingFeatures?: VkFormatFeatureFlagBits;

    /**
     * is a bitmask of 'VkFormatFeatureFlagBits' specifying features supported by buffers.
     */
    readonly bufferFeatures?: VkFormatFeatureFlagBits;
}

declare interface VkFormatPropertiesConstructor {
  readonly prototype: VkFormatProperties;
  new(param?: VkFormatPropertiesInitializer | null): VkFormatProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkFormatProperties: VkFormatPropertiesConstructor;



  /**
   * Structure specifying a mapped memory range
   */
interface VkMappedMemoryRange {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the memory object to which this range belongs.
     */
    memory: VkDeviceMemory | null;

    /**
     * is the zero-based byte offset from the beginning of the memory object.
     */
    offset: bigint | number;

    /**
     *
     */
    size: bigint | number;

}

declare interface VkMappedMemoryRangeInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the memory object to which this range belongs.
     */
    memory?: VkDeviceMemory | null;

    /**
     * is the zero-based byte offset from the beginning of the memory object.
     */
    offset?: bigint | number;

    /**
     *
     */
    size?: bigint | number;
}

declare interface VkMappedMemoryRangeConstructor {
  readonly prototype: VkMappedMemoryRange;
  new(param?: VkMappedMemoryRangeInitializer | null): VkMappedMemoryRange;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMappedMemoryRange: VkMappedMemoryRangeConstructor;



  /**
   * Structure specifying a memory heap
   */
interface VkMemoryHeap {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the total memory size in bytes in the heap.
     */
    readonly size: bigint | number;

    /**
     * is a bitmask of 'VkMemoryHeapFlagBits' specifying attribute flags for the heap.
     */
    readonly flags: VkMemoryHeapFlagBits;

}

declare interface VkMemoryHeapInitializer {
  
    /**
     * is the total memory size in bytes in the heap.
     */
    readonly size?: bigint | number;

    /**
     * is a bitmask of 'VkMemoryHeapFlagBits' specifying attribute flags for the heap.
     */
    readonly flags?: VkMemoryHeapFlagBits;
}

declare interface VkMemoryHeapConstructor {
  readonly prototype: VkMemoryHeap;
  new(param?: VkMemoryHeapInitializer | null): VkMemoryHeap;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryHeap: VkMemoryHeapConstructor;



  /**
   * Structure specifying memory type
   */
interface VkMemoryType {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a bitmask of 'VkMemoryPropertyFlagBits' of properties for this memory type.
     */
    readonly propertyFlags: VkMemoryPropertyFlagBits;

    /**
     * describes which memory heap this memory type corresponds to, and 'must' be less than 'memoryHeapCount' from the 'VkPhysicalDeviceMemoryProperties' structure.
     */
    readonly heapIndex: number;

}

declare interface VkMemoryTypeInitializer {
  
    /**
     * is a bitmask of 'VkMemoryPropertyFlagBits' of properties for this memory type.
     */
    readonly propertyFlags?: VkMemoryPropertyFlagBits;

    /**
     * describes which memory heap this memory type corresponds to, and 'must' be less than 'memoryHeapCount' from the 'VkPhysicalDeviceMemoryProperties' structure.
     */
    readonly heapIndex?: number;
}

declare interface VkMemoryTypeConstructor {
  readonly prototype: VkMemoryType;
  new(param?: VkMemoryTypeInitializer | null): VkMemoryType;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryType: VkMemoryTypeConstructor;



  /**
   * Structure specifying sparse image memory requirements
   */
interface VkSparseImageMemoryRequirements {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly formatProperties: VkSparseImageFormatProperties | null;

    /**
     * is the first mip level at which image subresources are included in the mip tail region.
     */
    readonly imageMipTailFirstLod: number;

    /**
     * is the memory size (in bytes) of the mip tail region. If 'formatProperties.flags' contains 'VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT', this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes.
     */
    readonly imageMipTailSize: bigint | number;

    /**
     * is the opaque memory offset used with 'VkSparseImageOpaqueMemoryBindInfo' to bind the mip tail region(s).
     */
    readonly imageMipTailOffset: bigint | number;

    /**
     * is the offset stride between each array-layer's mip tail, if 'formatProperties.flags' does not contain 'VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT' (otherwise the value is 'undefined').
     */
    readonly imageMipTailStride: bigint | number;

}

declare interface VkSparseImageMemoryRequirementsInitializer {
  
    /**
     *
     */
    readonly formatProperties?: VkSparseImageFormatProperties | null;

    /**
     * is the first mip level at which image subresources are included in the mip tail region.
     */
    readonly imageMipTailFirstLod?: number;

    /**
     * is the memory size (in bytes) of the mip tail region. If 'formatProperties.flags' contains 'VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT', this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes.
     */
    readonly imageMipTailSize?: bigint | number;

    /**
     * is the opaque memory offset used with 'VkSparseImageOpaqueMemoryBindInfo' to bind the mip tail region(s).
     */
    readonly imageMipTailOffset?: bigint | number;

    /**
     * is the offset stride between each array-layer's mip tail, if 'formatProperties.flags' does not contain 'VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT' (otherwise the value is 'undefined').
     */
    readonly imageMipTailStride?: bigint | number;
}

declare interface VkSparseImageMemoryRequirementsConstructor {
  readonly prototype: VkSparseImageMemoryRequirements;
  new(param?: VkSparseImageMemoryRequirementsInitializer | null): VkSparseImageMemoryRequirements;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseImageMemoryRequirements: VkSparseImageMemoryRequirementsConstructor;



  /**
   * Structure specifying sparse image format properties
   */
interface VkSparseImageFormatProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a bitmask 'VkImageAspectFlagBits' specifying which aspects of the image the properties apply to.
     */
    readonly aspectMask: VkImageAspectFlagBits;

    /**
     * is the width, height, and depth of the sparse image block in texels or compressed texel blocks.
     */
    readonly imageGranularity: VkExtent3D | null;

    /**
     * is a bitmask of 'VkSparseImageFormatFlagBits' specifying additional information about the sparse resource.
     */
    readonly flags: VkSparseImageFormatFlagBits;

}

declare interface VkSparseImageFormatPropertiesInitializer {
  
    /**
     * is a bitmask 'VkImageAspectFlagBits' specifying which aspects of the image the properties apply to.
     */
    readonly aspectMask?: VkImageAspectFlagBits;

    /**
     * is the width, height, and depth of the sparse image block in texels or compressed texel blocks.
     */
    readonly imageGranularity?: VkExtent3D | null;

    /**
     * is a bitmask of 'VkSparseImageFormatFlagBits' specifying additional information about the sparse resource.
     */
    readonly flags?: VkSparseImageFormatFlagBits;
}

declare interface VkSparseImageFormatPropertiesConstructor {
  readonly prototype: VkSparseImageFormatProperties;
  new(param?: VkSparseImageFormatPropertiesInitializer | null): VkSparseImageFormatProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkSparseImageFormatProperties: VkSparseImageFormatPropertiesConstructor;



  /**
   * Structure specifying memory requirements
   */
interface VkMemoryRequirements {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the size, in bytes, of the memory allocation 'required' for the resource.
     */
    readonly size: bigint | number;

    /**
     * is the alignment, in bytes, of the offset within the allocation 'required' for the resource.
     */
    readonly alignment: bigint | number;

    /**
     * is a bitmask and contains one bit set for every supported memory type for the resource. Bit `i` is set if and only if the memory type `i` in the 'VkPhysicalDeviceMemoryProperties' structure for the physical device is supported for the resource.
     */
    readonly memoryTypeBits: number;

}

declare interface VkMemoryRequirementsInitializer {
  
    /**
     * is the size, in bytes, of the memory allocation 'required' for the resource.
     */
    readonly size?: bigint | number;

    /**
     * is the alignment, in bytes, of the offset within the allocation 'required' for the resource.
     */
    readonly alignment?: bigint | number;

    /**
     * is a bitmask and contains one bit set for every supported memory type for the resource. Bit `i` is set if and only if the memory type `i` in the 'VkPhysicalDeviceMemoryProperties' structure for the physical device is supported for the resource.
     */
    readonly memoryTypeBits?: number;
}

declare interface VkMemoryRequirementsConstructor {
  readonly prototype: VkMemoryRequirements;
  new(param?: VkMemoryRequirementsInitializer | null): VkMemoryRequirements;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryRequirements: VkMemoryRequirementsConstructor;



  /**
   * Structure containing parameters of a memory allocation
   */
interface VkMemoryAllocateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is the size of the allocation in bytes
     */
    allocationSize: bigint | number;

    /**
     * is an index identifying a memory type from the 'memoryTypes' array of the 'VkPhysicalDeviceMemoryProperties' structure
     */
    memoryTypeIndex: number;

}

declare interface VkMemoryAllocateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is the size of the allocation in bytes
     */
    allocationSize?: bigint | number;

    /**
     * is an index identifying a memory type from the 'memoryTypes' array of the 'VkPhysicalDeviceMemoryProperties' structure
     */
    memoryTypeIndex?: number;
}

declare interface VkMemoryAllocateInfoConstructor {
  readonly prototype: VkMemoryAllocateInfo;
  new(param?: VkMemoryAllocateInfoInitializer | null): VkMemoryAllocateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkMemoryAllocateInfo: VkMemoryAllocateInfoConstructor;



  /**
   * Structure specifying physical device memory properties
   */
interface VkPhysicalDeviceMemoryProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the number of valid elements in the 'memoryTypes' array.
     */
    readonly memoryTypeCount: number;

    /**
     *
     */
    readonly memoryTypes: VkMemoryType[] | null;

    /**
     * is the number of valid elements in the 'memoryHeaps' array.
     */
    readonly memoryHeapCount: number;

    /**
     *
     */
    readonly memoryHeaps: VkMemoryHeap[] | null;

}

declare interface VkPhysicalDeviceMemoryPropertiesInitializer {
  
    /**
     * is the number of valid elements in the 'memoryTypes' array.
     */
    readonly memoryTypeCount?: number;

    /**
     *
     */
    readonly memoryTypes?: VkMemoryType[] | null;

    /**
     * is the number of valid elements in the 'memoryHeaps' array.
     */
    readonly memoryHeapCount?: number;

    /**
     *
     */
    readonly memoryHeaps?: VkMemoryHeap[] | null;
}

declare interface VkPhysicalDeviceMemoryPropertiesConstructor {
  readonly prototype: VkPhysicalDeviceMemoryProperties;
  new(param?: VkPhysicalDeviceMemoryPropertiesInitializer | null): VkPhysicalDeviceMemoryProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceMemoryProperties: VkPhysicalDeviceMemoryPropertiesConstructor;



  /**
   * Structure providing information about a queue family
   */
interface VkQueueFamilyProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a bitmask of 'VkQueueFlagBits' indicating capabilities of the queues in this queue family.
     */
    readonly queueFlags: VkQueueFlagBits;

    /**
     * is the unsigned integer count of queues in this queue family. Each queue family 'must' support at least one queue.
     */
    readonly queueCount: number;

    /**
     * is the unsigned integer count of meaningful bits in the timestamps written via 'vkCmdWriteTimestamp'. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros.
     */
    readonly timestampValidBits: number;

    /**
     * is the minimum granularity supported for image transfer operations on the queues in this queue family.
     */
    readonly minImageTransferGranularity: VkExtent3D | null;

}

declare interface VkQueueFamilyPropertiesInitializer {
  
    /**
     * is a bitmask of 'VkQueueFlagBits' indicating capabilities of the queues in this queue family.
     */
    readonly queueFlags?: VkQueueFlagBits;

    /**
     * is the unsigned integer count of queues in this queue family. Each queue family 'must' support at least one queue.
     */
    readonly queueCount?: number;

    /**
     * is the unsigned integer count of meaningful bits in the timestamps written via 'vkCmdWriteTimestamp'. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros.
     */
    readonly timestampValidBits?: number;

    /**
     * is the minimum granularity supported for image transfer operations on the queues in this queue family.
     */
    readonly minImageTransferGranularity?: VkExtent3D | null;
}

declare interface VkQueueFamilyPropertiesConstructor {
  readonly prototype: VkQueueFamilyProperties;
  new(param?: VkQueueFamilyPropertiesInitializer | null): VkQueueFamilyProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkQueueFamilyProperties: VkQueueFamilyPropertiesConstructor;



  /**
   * Structure specifying parameters of a newly created instance
   */
interface VkInstanceCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is <i>null</i> or a reference to a 'VkApplicationInfo' structure. If not <i>null</i>, this information helps implementations recognize behavior inherent to classes of applications. 'VkApplicationInfo' is defined in detail below.
     */
    pApplicationInfo: VkApplicationInfo | null;

    /**
     * is the number of global layers to enable.
     */
    enabledLayerCount: number;

    /**
     * is an array of 'enabledLayerCount' strings containing the names of layers to enable for the created instance. The layers are loaded in the order they are listed in this array, with the first array element being the closest to the application, and the last array element being the closest to the driver. See the <<extendingvulkan-layers>> section for further details.
     */
    ppEnabledLayerNames: string[] | null;

    /**
     * is the number of global extensions to enable.
     */
    enabledExtensionCount: number;

    /**
     * is an array of 'enabledExtensionCount' strings containing the names of extensions to enable.
     */
    ppEnabledExtensionNames: string[] | null;

}

declare interface VkInstanceCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is <i>null</i> or a reference to a 'VkApplicationInfo' structure. If not <i>null</i>, this information helps implementations recognize behavior inherent to classes of applications. 'VkApplicationInfo' is defined in detail below.
     */
    pApplicationInfo?: VkApplicationInfo | null;

    /**
     * is the number of global layers to enable.
     */
    enabledLayerCount?: number;

    /**
     * is an array of 'enabledLayerCount' strings containing the names of layers to enable for the created instance. The layers are loaded in the order they are listed in this array, with the first array element being the closest to the application, and the last array element being the closest to the driver. See the <<extendingvulkan-layers>> section for further details.
     */
    ppEnabledLayerNames?: string[] | null;

    /**
     * is the number of global extensions to enable.
     */
    enabledExtensionCount?: number;

    /**
     * is an array of 'enabledExtensionCount' strings containing the names of extensions to enable.
     */
    ppEnabledExtensionNames?: string[] | null;
}

declare interface VkInstanceCreateInfoConstructor {
  readonly prototype: VkInstanceCreateInfo;
  new(param?: VkInstanceCreateInfoInitializer | null): VkInstanceCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkInstanceCreateInfo: VkInstanceCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created device
   */
interface VkDeviceCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is reserved for future use.
     */
    flags: number;

    /**
     * is the size of the 'pQueueCreateInfos' array. Refer to the <<devsandqueues-queue-creation,Queue Creation>> section below for further details.
     */
    queueCreateInfoCount: number;

    /**
     * is an array of 'VkDeviceQueueCreateInfo' structures describing the queues that are requested to be created along with the logical device. Refer to the <<devsandqueues-queue-creation,Queue Creation>> section below for further details.
     */
    pQueueCreateInfos: VkDeviceQueueCreateInfo[] | null;

    /**
     * is deprecated and ignored.
     */
    enabledLayerCount: number;

    /**
     * is deprecated and ignored. See <<extendingvulkan-layers-devicelayerdeprecation>>.
     */
    ppEnabledLayerNames: string[] | null;

    /**
     * is the number of device extensions to enable.
     */
    enabledExtensionCount: number;

    /**
     * is an array of 'enabledExtensionCount' strings containing the names of extensions to enable for the created device. See the <<extendingvulkan-extensions>> section for further details.
     */
    ppEnabledExtensionNames: string[] | null;

    /**
     * is <i>null</i> or a reference to a 'VkPhysicalDeviceFeatures' structure containing boolean indicators of all the features to be enabled. Refer to the <<features,Features>> section for further details.
     */
    pEnabledFeatures: VkPhysicalDeviceFeatures | null;

}

declare interface VkDeviceCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is reserved for future use.
     */
    flags?: number;

    /**
     * is the size of the 'pQueueCreateInfos' array. Refer to the <<devsandqueues-queue-creation,Queue Creation>> section below for further details.
     */
    queueCreateInfoCount?: number;

    /**
     * is an array of 'VkDeviceQueueCreateInfo' structures describing the queues that are requested to be created along with the logical device. Refer to the <<devsandqueues-queue-creation,Queue Creation>> section below for further details.
     */
    pQueueCreateInfos?: VkDeviceQueueCreateInfo[] | null;

    /**
     * is deprecated and ignored.
     */
    enabledLayerCount?: number;

    /**
     * is deprecated and ignored. See <<extendingvulkan-layers-devicelayerdeprecation>>.
     */
    ppEnabledLayerNames?: string[] | null;

    /**
     * is the number of device extensions to enable.
     */
    enabledExtensionCount?: number;

    /**
     * is an array of 'enabledExtensionCount' strings containing the names of extensions to enable for the created device. See the <<extendingvulkan-extensions>> section for further details.
     */
    ppEnabledExtensionNames?: string[] | null;

    /**
     * is <i>null</i> or a reference to a 'VkPhysicalDeviceFeatures' structure containing boolean indicators of all the features to be enabled. Refer to the <<features,Features>> section for further details.
     */
    pEnabledFeatures?: VkPhysicalDeviceFeatures | null;
}

declare interface VkDeviceCreateInfoConstructor {
  readonly prototype: VkDeviceCreateInfo;
  new(param?: VkDeviceCreateInfoInitializer | null): VkDeviceCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceCreateInfo: VkDeviceCreateInfoConstructor;



  /**
   * Structure specifying parameters of a newly created device queue
   */
interface VkDeviceQueueCreateInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.ifndef::VK_VERSION_1_1[]
     */
    pNext: null;

    /**
     * is a bitmask indicating behavior of the queue.
     */
    flags: VkDeviceQueueCreateFlagBits;

    /**
     *
     */
    queueFamilyIndex: number;

    /**
     *
     */
    queueCount: number;

    /**
     *
     */
    pQueuePriorities: Float32Array | null;

}

declare interface VkDeviceQueueCreateInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.ifndef::VK_VERSION_1_1[]
     */
    pNext?: null;

    /**
     * is a bitmask indicating behavior of the queue.
     */
    flags?: VkDeviceQueueCreateFlagBits;

    /**
     *
     */
    queueFamilyIndex?: number;

    /**
     *
     */
    queueCount?: number;

    /**
     *
     */
    pQueuePriorities?: Float32Array | null;
}

declare interface VkDeviceQueueCreateInfoConstructor {
  readonly prototype: VkDeviceQueueCreateInfo;
  new(param?: VkDeviceQueueCreateInfoInitializer | null): VkDeviceQueueCreateInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceQueueCreateInfo: VkDeviceQueueCreateInfoConstructor;



  /**
   * Structure containing callback function references for memory allocation
   */
interface VkAllocationCallbacks {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in 'VkAllocationCallbacks' are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value 'can' vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands.
     */
    pUserData: ArrayBuffer | null;

    /**
     * is a 'PFN_vkAllocationFunction' reference to an application-defined memory allocation function.
     */
    pfnAllocation: vkAllocationFunction | null;

    /**
     * is a 'PFN_vkReallocationFunction' reference to an application-defined memory reallocation function.
     */
    pfnReallocation: vkReallocationFunction | null;

    /**
     * is a 'PFN_vkFreeFunction' reference to an application-defined memory free function.
     */
    pfnFree: vkFreeFunction | null;

    /**
     * is a 'PFN_vkInternalAllocationNotification' reference to an application-defined function that is called by the implementation when the implementation makes internal allocations.
     */
    pfnInternalAllocation: vkInternalAllocationNotification | null;

    /**
     * is a 'PFN_vkInternalFreeNotification' reference to an application-defined function that is called by the implementation when the implementation frees internal allocations.
     */
    pfnInternalFree: vkInternalFreeNotification | null;

}

declare interface VkAllocationCallbacksInitializer {
  
    /**
     * is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in 'VkAllocationCallbacks' are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value 'can' vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands.
     */
    pUserData?: ArrayBuffer | null;

    /**
     * is a 'PFN_vkAllocationFunction' reference to an application-defined memory allocation function.
     */
    pfnAllocation?: vkAllocationFunction | null;

    /**
     * is a 'PFN_vkReallocationFunction' reference to an application-defined memory reallocation function.
     */
    pfnReallocation?: vkReallocationFunction | null;

    /**
     * is a 'PFN_vkFreeFunction' reference to an application-defined memory free function.
     */
    pfnFree?: vkFreeFunction | null;

    /**
     * is a 'PFN_vkInternalAllocationNotification' reference to an application-defined function that is called by the implementation when the implementation makes internal allocations.
     */
    pfnInternalAllocation?: vkInternalAllocationNotification | null;

    /**
     * is a 'PFN_vkInternalFreeNotification' reference to an application-defined function that is called by the implementation when the implementation frees internal allocations.
     */
    pfnInternalFree?: vkInternalFreeNotification | null;
}

declare interface VkAllocationCallbacksConstructor {
  readonly prototype: VkAllocationCallbacks;
  new(param?: VkAllocationCallbacksInitializer | null): VkAllocationCallbacks;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAllocationCallbacks: VkAllocationCallbacksConstructor;



  /**
   * Structure specifying application info
   */
interface VkApplicationInfo {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the type of this structure.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext: null;

    /**
     * is <i>null</i> or is a reference to a string containing the name of the application.
     */
    pApplicationName: string | null;

    /**
     * is a number variable containing the developer-supplied version number of the application.
     */
    applicationVersion: number;

    /**
     * is <i>null</i> or is a reference to a string containing the name of the engine (if any) used to create the application.
     */
    pEngineName: string | null;

    /**
     * is a number variable containing the developer-supplied version number of the engine used to create the application.ifndef::VK_VERSION_1_1[]
     */
    engineVersion: number;

    /**
     * 'must' be the highest version of Vulkan that the application is designed to use, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    apiVersion: number;

}

declare interface VkApplicationInfoInitializer {
  
    /**
     * is the type of this structure.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to a structure extending this structure.
     */
    pNext?: null;

    /**
     * is <i>null</i> or is a reference to a string containing the name of the application.
     */
    pApplicationName?: string | null;

    /**
     * is a number variable containing the developer-supplied version number of the application.
     */
    applicationVersion?: number;

    /**
     * is <i>null</i> or is a reference to a string containing the name of the engine (if any) used to create the application.
     */
    pEngineName?: string | null;

    /**
     * is a number variable containing the developer-supplied version number of the engine used to create the application.ifndef::VK_VERSION_1_1[]
     */
    engineVersion?: number;

    /**
     * 'must' be the highest version of Vulkan that the application is designed to use, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    apiVersion?: number;
}

declare interface VkApplicationInfoConstructor {
  readonly prototype: VkApplicationInfo;
  new(param?: VkApplicationInfoInitializer | null): VkApplicationInfo;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkApplicationInfo: VkApplicationInfoConstructor;



  /**
   * Structure specifying layer properties
   */
interface VkLayerProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly layerName: string | null;

    /**
     * is the Vulkan version the layer was written to, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    readonly specVersion: number;

    /**
     * is the version of this layer. It is a number, increasing with backward compatible changes.
     */
    readonly implementationVersion: number;

    /**
     *
     */
    readonly description: string | null;

}

declare interface VkLayerPropertiesInitializer {
  
    /**
     *
     */
    readonly layerName?: string | null;

    /**
     * is the Vulkan version the layer was written to, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    readonly specVersion?: number;

    /**
     * is the version of this layer. It is a number, increasing with backward compatible changes.
     */
    readonly implementationVersion?: number;

    /**
     *
     */
    readonly description?: string | null;
}

declare interface VkLayerPropertiesConstructor {
  readonly prototype: VkLayerProperties;
  new(param?: VkLayerPropertiesInitializer | null): VkLayerProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkLayerProperties: VkLayerPropertiesConstructor;



  /**
   * Structure specifying an extension properties
   */
interface VkExtensionProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    readonly extensionName: string | null;

    /**
     * is the version of this extension. It is a number, incremented with backward compatible changes.
     */
    readonly specVersion: number;

}

declare interface VkExtensionPropertiesInitializer {
  
    /**
     *
     */
    readonly extensionName?: string | null;

    /**
     * is the version of this extension. It is a number, incremented with backward compatible changes.
     */
    readonly specVersion?: number;
}

declare interface VkExtensionPropertiesConstructor {
  readonly prototype: VkExtensionProperties;
  new(param?: VkExtensionPropertiesInitializer | null): VkExtensionProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExtensionProperties: VkExtensionPropertiesConstructor;



  /**
   * Structure specifying physical device properties
   */
interface VkPhysicalDeviceProperties {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the version of Vulkan supported by the device, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    readonly apiVersion: number;

    /**
     * is the vendor-specified version of the driver.
     */
    readonly driverVersion: number;

    /**
     * is a unique identifier for the _vendor_ (see below) of the physical device.
     */
    readonly vendorID: number;

    /**
     * is a unique identifier for the physical device among devices available from the vendor.
     */
    readonly deviceID: number;

    /**
     * is a 'VkPhysicalDeviceType' specifying the type of device.
     */
    readonly deviceType: VkPhysicalDeviceType;

    /**
     *
     */
    readonly deviceName: string | null;

    /**
     *
     */
    readonly pipelineCacheUUID: number[] | null;

    /**
     * is the 'VkPhysicalDeviceLimits' structure specifying device-specific limits of the physical device. See <<limits,Limits>> for details.
     */
    readonly limits: VkPhysicalDeviceLimits | null;

    /**
     * is the 'VkPhysicalDeviceSparseProperties' structure specifying various sparse related properties of the physical device. See <<sparsememory-physicalprops,Sparse Properties>> for details.
     */
    readonly sparseProperties: VkPhysicalDeviceSparseProperties | null;

}

declare interface VkPhysicalDevicePropertiesInitializer {
  
    /**
     * is the version of Vulkan supported by the device, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
     */
    readonly apiVersion?: number;

    /**
     * is the vendor-specified version of the driver.
     */
    readonly driverVersion?: number;

    /**
     * is a unique identifier for the _vendor_ (see below) of the physical device.
     */
    readonly vendorID?: number;

    /**
     * is a unique identifier for the physical device among devices available from the vendor.
     */
    readonly deviceID?: number;

    /**
     * is a 'VkPhysicalDeviceType' specifying the type of device.
     */
    readonly deviceType?: VkPhysicalDeviceType;

    /**
     *
     */
    readonly deviceName?: string | null;

    /**
     *
     */
    readonly pipelineCacheUUID?: number[] | null;

    /**
     * is the 'VkPhysicalDeviceLimits' structure specifying device-specific limits of the physical device. See <<limits,Limits>> for details.
     */
    readonly limits?: VkPhysicalDeviceLimits | null;

    /**
     * is the 'VkPhysicalDeviceSparseProperties' structure specifying various sparse related properties of the physical device. See <<sparsememory-physicalprops,Sparse Properties>> for details.
     */
    readonly sparseProperties?: VkPhysicalDeviceSparseProperties | null;
}

declare interface VkPhysicalDevicePropertiesConstructor {
  readonly prototype: VkPhysicalDeviceProperties;
  new(param?: VkPhysicalDevicePropertiesInitializer | null): VkPhysicalDeviceProperties;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPhysicalDeviceProperties: VkPhysicalDevicePropertiesConstructor;



  /**
   * Structure specifying a color component mapping
   */
interface VkComponentMapping {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the R component of the output vector.
     */
    r: VkComponentSwizzle;

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the G component of the output vector.
     */
    g: VkComponentSwizzle;

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the B component of the output vector.
     */
    b: VkComponentSwizzle;

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the A component of the output vector.
     */
    a: VkComponentSwizzle;

}

declare interface VkComponentMappingInitializer {
  
    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the R component of the output vector.
     */
    r?: VkComponentSwizzle;

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the G component of the output vector.
     */
    g?: VkComponentSwizzle;

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the B component of the output vector.
     */
    b?: VkComponentSwizzle;

    /**
     * is a 'VkComponentSwizzle' specifying the component value placed in the A component of the output vector.
     */
    a?: VkComponentSwizzle;
}

declare interface VkComponentMappingConstructor {
  readonly prototype: VkComponentMapping;
  new(param?: VkComponentMappingInitializer | null): VkComponentMapping;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkComponentMapping: VkComponentMappingConstructor;



  /**
   * Structure specifying a clear rectangle
   */
interface VkClearRect {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the two-dimensional region to be cleared.
     */
    rect: VkRect2D | null;

    /**
     * is the first layer to be cleared.
     */
    baseArrayLayer: number;

    /**
     * is the number of layers to clear.
     */
    layerCount: number;

}

declare interface VkClearRectInitializer {
  
    /**
     * is the two-dimensional region to be cleared.
     */
    rect?: VkRect2D | null;

    /**
     * is the first layer to be cleared.
     */
    baseArrayLayer?: number;

    /**
     * is the number of layers to clear.
     */
    layerCount?: number;
}

declare interface VkClearRectConstructor {
  readonly prototype: VkClearRect;
  new(param?: VkClearRectInitializer | null): VkClearRect;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkClearRect: VkClearRectConstructor;



  /**
   * Structure specifying a two-dimensional subregion
   */
interface VkRect2D {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a 'VkOffset2D' specifying the rectangle offset.
     */
    offset: VkOffset2D | null;

    /**
     * is a 'VkExtent2D' specifying the rectangle extent.
     */
    extent: VkExtent2D | null;

}

declare interface VkRect2DInitializer {
  
    /**
     * is a 'VkOffset2D' specifying the rectangle offset.
     */
    offset?: VkOffset2D | null;

    /**
     * is a 'VkExtent2D' specifying the rectangle extent.
     */
    extent?: VkExtent2D | null;
}

declare interface VkRect2DConstructor {
  readonly prototype: VkRect2D;
  new(param?: VkRect2DInitializer | null): VkRect2D;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkRect2D: VkRect2DConstructor;



  /**
   * Structure specifying a viewport
   */
interface VkViewport {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    x: number;

    /**
     * are the viewport's upper left corner [eq]#(x,y)#.
     */
    y: number;

    /**
     *
     */
    width: number;

    /**
     * are the viewport's width and height, respectively.
     */
    height: number;

    /**
     *
     */
    minDepth: number;

    /**
     * are the depth range for the viewport. It is valid for 'minDepth' to be greater than or equal to 'maxDepth'.
     */
    maxDepth: number;

}

declare interface VkViewportInitializer {
  
    /**
     *
     */
    x?: number;

    /**
     * are the viewport's upper left corner [eq]#(x,y)#.
     */
    y?: number;

    /**
     *
     */
    width?: number;

    /**
     * are the viewport's width and height, respectively.
     */
    height?: number;

    /**
     *
     */
    minDepth?: number;

    /**
     * are the depth range for the viewport. It is valid for 'minDepth' to be greater than or equal to 'maxDepth'.
     */
    maxDepth?: number;
}

declare interface VkViewportConstructor {
  readonly prototype: VkViewport;
  new(param?: VkViewportInitializer | null): VkViewport;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkViewport: VkViewportConstructor;



  /**
   * Structure specifying a three-dimensional extent
   */
interface VkExtent3D {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the width of the extent.
     */
    width: number;

    /**
     * is the height of the extent.
     */
    height: number;

    /**
     * is the depth of the extent.
     */
    depth: number;

}

declare interface VkExtent3DInitializer {
  
    /**
     * is the width of the extent.
     */
    width?: number;

    /**
     * is the height of the extent.
     */
    height?: number;

    /**
     * is the depth of the extent.
     */
    depth?: number;
}

declare interface VkExtent3DConstructor {
  readonly prototype: VkExtent3D;
  new(param?: VkExtent3DInitializer | null): VkExtent3D;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExtent3D: VkExtent3DConstructor;



  /**
   * Structure specifying a two-dimensional extent
   */
interface VkExtent2D {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the width of the extent.
     */
    width: number;

    /**
     * is the height of the extent.
     */
    height: number;

}

declare interface VkExtent2DInitializer {
  
    /**
     * is the width of the extent.
     */
    width?: number;

    /**
     * is the height of the extent.
     */
    height?: number;
}

declare interface VkExtent2DConstructor {
  readonly prototype: VkExtent2D;
  new(param?: VkExtent2DInitializer | null): VkExtent2D;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkExtent2D: VkExtent2DConstructor;



  /**
   * Structure specifying a three-dimensional offset
   */
interface VkOffset3D {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the x offset.
     */
    x: number;

    /**
     * is the y offset.
     */
    y: number;

    /**
     * is the z offset.
     */
    z: number;

}

declare interface VkOffset3DInitializer {
  
    /**
     * is the x offset.
     */
    x?: number;

    /**
     * is the y offset.
     */
    y?: number;

    /**
     * is the z offset.
     */
    z?: number;
}

declare interface VkOffset3DConstructor {
  readonly prototype: VkOffset3D;
  new(param?: VkOffset3DInitializer | null): VkOffset3D;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkOffset3D: VkOffset3DConstructor;



  /**
   * Structure specifying a two-dimensional offset
   */
interface VkOffset2D {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the x offset.
     */
    x: number;

    /**
     * is the y offset.
     */
    y: number;

}

declare interface VkOffset2DInitializer {
  
    /**
     * is the x offset.
     */
    x?: number;

    /**
     * is the y offset.
     */
    y?: number;
}

declare interface VkOffset2DConstructor {
  readonly prototype: VkOffset2D;
  new(param?: VkOffset2DInitializer | null): VkOffset2D;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkOffset2D: VkOffset2DConstructor;



  /**
   * Base structure for a read-only reference chain
   */
interface VkBaseInStructure {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the structure type of the structure being iterated through.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to the next structure in a structure chain.
     */
    pNext: VkBaseInStructure | null;

}

declare interface VkBaseInStructureInitializer {
  
    /**
     * is the structure type of the structure being iterated through.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to the next structure in a structure chain.
     */
    pNext?: VkBaseInStructure | null;
}

declare interface VkBaseInStructureConstructor {
  readonly prototype: VkBaseInStructure;
  new(param?: VkBaseInStructureInitializer | null): VkBaseInStructure;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBaseInStructure: VkBaseInStructureConstructor;



  /**
   * Base structure for a read-only reference chain
   */
interface VkBaseOutStructure {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the structure type of the structure being iterated through.
     */
    sType: VkStructureType;

    /**
     * is <i>null</i> or a reference to the next structure in a structure chain.
     */
    pNext: VkBaseOutStructure | null;

}

declare interface VkBaseOutStructureInitializer {
  
    /**
     * is the structure type of the structure being iterated through.
     */
    sType?: VkStructureType;

    /**
     * is <i>null</i> or a reference to the next structure in a structure chain.
     */
    pNext?: VkBaseOutStructure | null;
}

declare interface VkBaseOutStructureConstructor {
  readonly prototype: VkBaseOutStructure;
  new(param?: VkBaseOutStructureInitializer | null): VkBaseOutStructure;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkBaseOutStructure: VkBaseOutStructureConstructor;



  /**
   * Union specifying acceleration structure geometry data
   */
interface VkAccelerationStructureGeometryDataKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a 'VkAccelerationStructureGeometryTrianglesDataKHR' structure.
     */
    triangles: VkAccelerationStructureGeometryTrianglesDataKHR | null;

    /**
     * is a 'VkAccelerationStructureGeometryAabbsDataKHR' struture.
     */
    aabbs: VkAccelerationStructureGeometryAabbsDataKHR | null;

    /**
     * is a 'VkAccelerationStructureGeometryInstancesDataKHR' structure.
     */
    instances: VkAccelerationStructureGeometryInstancesDataKHR | null;

}

declare interface VkAccelerationStructureGeometryDataKHRInitializer {
  
    /**
     * is a 'VkAccelerationStructureGeometryTrianglesDataKHR' structure.
     */
    triangles?: VkAccelerationStructureGeometryTrianglesDataKHR | null;

    /**
     * is a 'VkAccelerationStructureGeometryAabbsDataKHR' struture.
     */
    aabbs?: VkAccelerationStructureGeometryAabbsDataKHR | null;

    /**
     * is a 'VkAccelerationStructureGeometryInstancesDataKHR' structure.
     */
    instances?: VkAccelerationStructureGeometryInstancesDataKHR | null;
}

declare interface VkAccelerationStructureGeometryDataKHRConstructor {
  readonly prototype: VkAccelerationStructureGeometryDataKHR;
  new(param?: VkAccelerationStructureGeometryDataKHRInitializer | null): VkAccelerationStructureGeometryDataKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkAccelerationStructureGeometryDataKHR: VkAccelerationStructureGeometryDataKHRConstructor;



  /**
   * Union specifying a const device or host address
   */
interface VkDeviceOrHostAddressConstKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a buffer device address as returned by the 'vkGetBufferDeviceAddressKHR' command.
     */
    deviceAddress: bigint | number;

    /**
     * is a const host memory address.
     */
    hostAddress: ArrayBuffer | null;

}

declare interface VkDeviceOrHostAddressConstKHRInitializer {
  
    /**
     * is a buffer device address as returned by the 'vkGetBufferDeviceAddressKHR' command.
     */
    deviceAddress?: bigint | number;

    /**
     * is a const host memory address.
     */
    hostAddress?: ArrayBuffer | null;
}

declare interface VkDeviceOrHostAddressConstKHRConstructor {
  readonly prototype: VkDeviceOrHostAddressConstKHR;
  new(param?: VkDeviceOrHostAddressConstKHRInitializer | null): VkDeviceOrHostAddressConstKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceOrHostAddressConstKHR: VkDeviceOrHostAddressConstKHRConstructor;



  /**
   * Union specifying a device or host address
   */
interface VkDeviceOrHostAddressKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is a buffer device address as returned by the 'vkGetBufferDeviceAddressKHR' command.
     */
    deviceAddress: bigint | number;

    /**
     * is a host memory address.
     */
    hostAddress: ArrayBuffer | null;

}

declare interface VkDeviceOrHostAddressKHRInitializer {
  
    /**
     * is a buffer device address as returned by the 'vkGetBufferDeviceAddressKHR' command.
     */
    deviceAddress?: bigint | number;

    /**
     * is a host memory address.
     */
    hostAddress?: ArrayBuffer | null;
}

declare interface VkDeviceOrHostAddressKHRConstructor {
  readonly prototype: VkDeviceOrHostAddressKHR;
  new(param?: VkDeviceOrHostAddressKHRInitializer | null): VkDeviceOrHostAddressKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkDeviceOrHostAddressKHR: VkDeviceOrHostAddressKHRConstructor;



  /**
   * A union describing a pipeline executable statistic
   */
interface VkPipelineExecutableStatisticValueKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * is the 32-bit boolean value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR'.
     */
    readonly b32: boolean;

    /**
     * is the signed 64-bit integer value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR'.
     */
    readonly i64: bigint | number;

    /**
     * is the unsigned 64-bit integer value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR'.
     */
    readonly u64: bigint | number;

    /**
     * is the 64-bit floating-point value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR'.
     */
    readonly f64: bigint | number;

}

declare interface VkPipelineExecutableStatisticValueKHRInitializer {
  
    /**
     * is the 32-bit boolean value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR'.
     */
    readonly b32?: boolean;

    /**
     * is the signed 64-bit integer value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR'.
     */
    readonly i64?: bigint | number;

    /**
     * is the unsigned 64-bit integer value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR'.
     */
    readonly u64?: bigint | number;

    /**
     * is the 64-bit floating-point value if the 'VkPipelineExecutableStatisticFormatKHR' is 'VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR'.
     */
    readonly f64?: bigint | number;
}

declare interface VkPipelineExecutableStatisticValueKHRConstructor {
  readonly prototype: VkPipelineExecutableStatisticValueKHR;
  new(param?: VkPipelineExecutableStatisticValueKHRInitializer | null): VkPipelineExecutableStatisticValueKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPipelineExecutableStatisticValueKHR: VkPipelineExecutableStatisticValueKHRConstructor;



  /**
   * Values returned for the parameters
   */
interface VkPerformanceValueDataINTEL {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    value32: number;

    /**
     *
     */
    value64: bigint | number;

    /**
     *
     */
    valueFloat: number;

    /**
     *
     */
    valueBool: boolean;

    /**
     *
     */
    valueString: string | null;

}

declare interface VkPerformanceValueDataINTELInitializer {
  
    /**
     *
     */
    value32?: number;

    /**
     *
     */
    value64?: bigint | number;

    /**
     *
     */
    valueFloat?: number;

    /**
     *
     */
    valueBool?: boolean;

    /**
     *
     */
    valueString?: string | null;
}

declare interface VkPerformanceValueDataINTELConstructor {
  readonly prototype: VkPerformanceValueDataINTEL;
  new(param?: VkPerformanceValueDataINTELInitializer | null): VkPerformanceValueDataINTEL;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPerformanceValueDataINTEL: VkPerformanceValueDataINTELConstructor;



  /**
   * Union containing a performance counter result
   */
interface VkPerformanceCounterResultKHR {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     *
     */
    int32: number;

    /**
     *
     */
    int64: bigint | number;

    /**
     *
     */
    uint32: number;

    /**
     *
     */
    uint64: bigint | number;

    /**
     *
     */
    float32: number;

    /**
     *
     */
    float64: bigint | number;

}

declare interface VkPerformanceCounterResultKHRInitializer {
  
    /**
     *
     */
    int32?: number;

    /**
     *
     */
    int64?: bigint | number;

    /**
     *
     */
    uint32?: number;

    /**
     *
     */
    uint64?: bigint | number;

    /**
     *
     */
    float32?: number;

    /**
     *
     */
    float64?: bigint | number;
}

declare interface VkPerformanceCounterResultKHRConstructor {
  readonly prototype: VkPerformanceCounterResultKHR;
  new(param?: VkPerformanceCounterResultKHRInitializer | null): VkPerformanceCounterResultKHR;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkPerformanceCounterResultKHR: VkPerformanceCounterResultKHRConstructor;



  /**
   * Structure specifying a clear value
   */
interface VkClearValue {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * specifies the color image clear values to use when clearing a color image or attachment.
     */
    color: VkClearColorValue | null;

    /**
     * specifies the depth and stencil clear values to use when clearing a depth/stencil image or attachment.
     */
    depthStencil: VkClearDepthStencilValue | null;

}

declare interface VkClearValueInitializer {
  
    /**
     * specifies the color image clear values to use when clearing a color image or attachment.
     */
    color?: VkClearColorValue | null;

    /**
     * specifies the depth and stencil clear values to use when clearing a depth/stencil image or attachment.
     */
    depthStencil?: VkClearDepthStencilValue | null;
}

declare interface VkClearValueConstructor {
  readonly prototype: VkClearValue;
  new(param?: VkClearValueInitializer | null): VkClearValue;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkClearValue: VkClearValueConstructor;



  /**
   * Structure specifying a clear color value
   */
interface VkClearColorValue {
  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

  /**
    * Memory representation of the original vulkan structure instance.
    */
  memoryBuffer: ArrayBuffer;
  
    /**
     * are the color clear values when the format of the image or attachment is one of the formats in the <<formats-numericformat>> table other than signed integer ('SINT') or unsigned integer ('UINT'). Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB.
     */
    float32: number[] | null;

    /**
     * are the color clear values when the format of the image or attachment is signed integer ('SINT'). Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is 'undefined'.
     */
    int32: number[] | null;

    /**
     * are the color clear values when the format of the image or attachment is unsigned integer ('UINT'). Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits.
     */
    uint32: number[] | null;

}

declare interface VkClearColorValueInitializer {
  
    /**
     * are the color clear values when the format of the image or attachment is one of the formats in the <<formats-numericformat>> table other than signed integer ('SINT') or unsigned integer ('UINT'). Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB.
     */
    float32?: number[] | null;

    /**
     * are the color clear values when the format of the image or attachment is signed integer ('SINT'). Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is 'undefined'.
     */
    int32?: number[] | null;

    /**
     * are the color clear values when the format of the image or attachment is unsigned integer ('UINT'). Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits.
     */
    uint32?: number[] | null;
}

declare interface VkClearColorValueConstructor {
  readonly prototype: VkClearColorValue;
  new(param?: VkClearColorValueInitializer | null): VkClearColorValue;

  /**
    * Object describing the memory layout for this structure.
    */
  readonly memoryLayout: object;

}

declare var VkClearColorValue: VkClearColorValueConstructor;





  /**
   * Create a new Vulkan instance
   * @param pCreateInfo is a reference to a 'VkInstanceCreateInfo' structure controlling creation of the instance.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pInstance references a 'VkInstance' handle in which the resulting instance is returned.
   */
  export function vkCreateInstance(pCreateInfo: VkInstanceCreateInfo | null, pAllocator: null, pInstance: VkInstance | null): VkResult;

  /**
   * Destroy an instance of Vulkan
   * @param instance is the handle of the instance to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyInstance(instance: VkInstance | null, pAllocator: null): void;

  /**
   * Enumerates the physical devices accessible to a Vulkan instance
   * @param instance is a handle to a Vulkan instance previously created with 'vkCreateInstance'.
   * @param pPhysicalDeviceCount is a reference to a number related to the number of physical devices available or queried, as described below.
   * @param pPhysicalDevices is either <i>null</i> or a reference to an array of 'VkPhysicalDevice' handles.
   */
  export function vkEnumeratePhysicalDevices(instance: VkInstance | null, pPhysicalDeviceCount: VkInout | null, pPhysicalDevices: VkPhysicalDevice[] | null): VkResult;

  /**
   * Return a function reference for a command
   * @param device
   * @param pName
   */
  export function vkGetDeviceProcAddr(device: VkDevice | null, pName: string | null): void;

  /**
   * Return a function reference for a command
   * @param instance is the instance that the function reference will be compatible with, or <i>null</i> for commands not dependent on any instance.
   * @param pName is the name of the command to obtain.
   */
  export function vkGetInstanceProcAddr(instance: VkInstance | null, pName: string | null): void;

  /**
   * Returns properties of a physical device
   * @param physicalDevice is the handle to the physical device whose properties will be queried.
   * @param pProperties is a reference to a 'VkPhysicalDeviceProperties' structure in which properties are returned.
   */
  export function vkGetPhysicalDeviceProperties(physicalDevice: VkPhysicalDevice | null, pProperties: VkPhysicalDeviceProperties | null): void;

  /**
   * Reports properties of the queues of the specified physical device
   * @param physicalDevice is the handle to the physical device whose properties will be queried.
   * @param pQueueFamilyPropertyCount is a reference to a number related to the number of queue families available or queried, as described below.
   * @param pQueueFamilyProperties is either <i>null</i> or a reference to an array of 'VkQueueFamilyProperties' structures.
   */
  export function vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice: VkPhysicalDevice | null, pQueueFamilyPropertyCount: VkInout | null, pQueueFamilyProperties: VkQueueFamilyProperties[] | null): void;

  /**
   * Reports memory information for the specified physical device
   * @param physicalDevice is the handle to the device to query.
   * @param pMemoryProperties is a reference to a 'VkPhysicalDeviceMemoryProperties' structure in which the properties are returned.
   */
  export function vkGetPhysicalDeviceMemoryProperties(physicalDevice: VkPhysicalDevice | null, pMemoryProperties: VkPhysicalDeviceMemoryProperties | null): void;

  /**
   * Reports capabilities of a physical device
   * @param physicalDevice is the physical device from which to query the supported features.
   * @param pFeatures is a reference to a 'VkPhysicalDeviceFeatures' structure in which the physical device features are returned. For each feature, a value of 'VK_TRUE' specifies that the feature is supported on this physical device, and 'VK_FALSE' specifies that the feature is not supported.
   */
  export function vkGetPhysicalDeviceFeatures(physicalDevice: VkPhysicalDevice | null, pFeatures: VkPhysicalDeviceFeatures | null): void;

  /**
   * Lists physical device\
   * @param physicalDevice is the physical device from which to query the format properties.
   * @param format is the format whose properties are queried.
   * @param pFormatProperties is a reference to a 'VkFormatProperties' structure in which physical device properties for 'format' are returned.
   */
  export function vkGetPhysicalDeviceFormatProperties(physicalDevice: VkPhysicalDevice | null, format: VkFormat, pFormatProperties: VkFormatProperties | null): void;

  /**
   * Lists physical device\
   * @param physicalDevice is the physical device from which to query the image capabilities.
   * @param format is a 'VkFormat' value specifying the image format, corresponding to 'VkImageCreateInfo'::'format'.
   * @param type is a 'VkImageType' value specifying the image type, corresponding to 'VkImageCreateInfo'::'imageType'.
   * @param tiling is a 'VkImageTiling' value specifying the image tiling, corresponding to 'VkImageCreateInfo'::'tiling'.
   * @param usage is a bitmask of 'VkImageUsageFlagBits' specifying the intended usage of the image, corresponding to 'VkImageCreateInfo'::'usage'.
   * @param flags is a bitmask of 'VkImageCreateFlagBits' specifying additional parameters of the image, corresponding to 'VkImageCreateInfo'::'flags'.
   * @param pImageFormatProperties is a reference to a 'VkImageFormatProperties' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceImageFormatProperties(physicalDevice: VkPhysicalDevice | null, format: VkFormat, type: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlagBits, flags: VkImageCreateFlagBits, pImageFormatProperties: VkImageFormatProperties | null): VkResult;

  /**
   * Create a new device instance
   * @param physicalDevice 'must' be one of the device handles returned from a call to 'vkEnumeratePhysicalDevices' (see <<devsandqueues-physical-device-enumeration, Physical Device Enumeration>>).
   * @param pCreateInfo is a reference to a 'VkDeviceCreateInfo' structure containing information about how to create the device.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pDevice is a reference to a handle in which the created 'VkDevice' is returned.
   */
  export function vkCreateDevice(physicalDevice: VkPhysicalDevice | null, pCreateInfo: VkDeviceCreateInfo | null, pAllocator: null, pDevice: VkDevice | null): VkResult;

  /**
   * Destroy a logical device
   * @param device is the logical device to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDevice(device: VkDevice | null, pAllocator: null): void;

  /**
   * Query instance-level version before instance creation
   * @param pApiVersion is a reference to a 'uint32_t', which is the version of Vulkan supported by instance-level functionality, encoded as described in <<extendingvulkan-coreversions-versionnumbers>>.
   */
  export function vkEnumerateInstanceVersion(pApiVersion: VkInout | null): VkResult;

  /**
   * Returns up to requested number of global layer properties
   * @param pPropertyCount is a reference to a number related to the number of layer properties available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkLayerProperties' structures.
   */
  export function vkEnumerateInstanceLayerProperties(pPropertyCount: VkInout | null, pProperties: VkLayerProperties[] | null): VkResult;

  /**
   * Returns up to requested number of global extension properties
   * @param pLayerName is either <i>null</i> or a reference to a string naming the layer to retrieve extensions from.
   * @param pPropertyCount is a reference to a number related to the number of extension properties available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkExtensionProperties' structures.
   */
  export function vkEnumerateInstanceExtensionProperties(pLayerName: string | null, pPropertyCount: VkInout | null, pProperties: VkExtensionProperties[] | null): VkResult;

  /**
   * Returns properties of available physical device layers
   * @param physicalDevice
   * @param pPropertyCount is a reference to a number related to the number of layer properties available or queried.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkLayerProperties' structures.
   */
  export function vkEnumerateDeviceLayerProperties(physicalDevice: VkPhysicalDevice | null, pPropertyCount: VkInout | null, pProperties: VkLayerProperties[] | null): VkResult;

  /**
   * Returns properties of available physical device extensions
   * @param physicalDevice is the physical device that will be queried.
   * @param pLayerName is either <i>null</i> or a reference to a string naming the layer to retrieve extensions from.
   * @param pPropertyCount is a reference to a number related to the number of extension properties available or queried, and is treated in the same fashion as the 'vkEnumerateInstanceExtensionProperties'::'pPropertyCount' parameter.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkExtensionProperties' structures.
   */
  export function vkEnumerateDeviceExtensionProperties(physicalDevice: VkPhysicalDevice | null, pLayerName: string | null, pPropertyCount: VkInout | null, pProperties: VkExtensionProperties[] | null): VkResult;

  /**
   * Get a queue handle from a device
   * @param device is the logical device that owns the queue.
   * @param queueFamilyIndex is the index of the queue family to which the queue belongs.
   * @param queueIndex is the index within this queue family of the queue to retrieve.
   * @param pQueue is a reference to a 'VkQueue' object that will be filled with the handle for the requested queue.
   */
  export function vkGetDeviceQueue(device: VkDevice | null, queueFamilyIndex: number, queueIndex: number, pQueue: VkQueue | null): void;

  /**
   * Submits a sequence of semaphores or command buffers to a queue
   * @param queue is the queue that the command buffers will be submitted to.
   * @param submitCount
   * @param pSubmits is an array of 'VkSubmitInfo' structures, each specifying a command buffer submission batch.
   * @param fence is an 'optional' handle to a fence to be signaled once all submitted command buffers have completed execution. If 'fence' is not 'VK_NULL_HANDLE', it defines a <<synchronization-fences-signaling, fence signal operation>>.
   */
  export function vkQueueSubmit(queue: VkQueue | null, submitCount: number, pSubmits: VkSubmitInfo[] | null, fence: VkFence | null): VkResult;

  /**
   * Wait for a queue to become idle
   * @param queue is the queue on which to wait.
   */
  export function vkQueueWaitIdle(queue: VkQueue | null): VkResult;

  /**
   * Wait for a device to become idle
   * @param device is the logical device to idle.
   */
  export function vkDeviceWaitIdle(device: VkDevice | null): VkResult;

  /**
   * Allocate device memory
   * @param device
   * @param pAllocateInfo
   * @param pAllocator
   * @param pMemory
   */
  export function vkAllocateMemory(device: VkDevice | null, pAllocateInfo: VkMemoryAllocateInfo | null, pAllocator: null, pMemory: VkDeviceMemory | null): VkResult;

  /**
   * Free device memory
   * @param device is the logical device that owns the memory.
   * @param memory is the 'VkDeviceMemory' object to be freed.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkFreeMemory(device: VkDevice | null, memory: VkDeviceMemory | null, pAllocator: null): void;

  /**
   * Map a memory object into application address space
   * @param device is the logical device that owns the memory.
   * @param memory is the 'VkDeviceMemory' object to be mapped.
   * @param offset is a zero-based byte offset from the beginning of the memory object.
   * @param size is the size of the memory range to map, or 'VK_WHOLE_SIZE' to map from 'offset' to the end of the allocation.
   * @param flags is reserved for future use.
   * @param ppData is a reference to a `void 
   */
  export function vkMapMemory(device: VkDevice | null, memory: VkDeviceMemory | null, offset: bigint | number, size: bigint | number, flags: number, ppData: VkInoutAddress | null): VkResult;

  /**
   * Unmap a previously mapped memory object
   * @param device is the logical device that owns the memory.
   * @param memory is the memory object to be unmapped.
   */
  export function vkUnmapMemory(device: VkDevice | null, memory: VkDeviceMemory | null): void;

  /**
   * Flush mapped memory ranges
   * @param device is the logical device that owns the memory ranges.
   * @param memoryRangeCount
   * @param pMemoryRanges is an array of 'VkMappedMemoryRange' structures describing the memory ranges to flush.
   */
  export function vkFlushMappedMemoryRanges(device: VkDevice | null, memoryRangeCount: number, pMemoryRanges: VkMappedMemoryRange[] | null): VkResult;

  /**
   * Invalidate ranges of mapped memory objects
   * @param device is the logical device that owns the memory ranges.
   * @param memoryRangeCount
   * @param pMemoryRanges is an array of 'VkMappedMemoryRange' structures describing the memory ranges to invalidate.
   */
  export function vkInvalidateMappedMemoryRanges(device: VkDevice | null, memoryRangeCount: number, pMemoryRanges: VkMappedMemoryRange[] | null): VkResult;

  /**
   * Query the current commitment for a VkDeviceMemory
   * @param device is the logical device that owns the memory.
   * @param memory is the memory object being queried.
   * @param pCommittedMemoryInBytes is a reference to a 'VkDeviceSize' value in which the number of bytes currently committed is returned, on success.
   */
  export function vkGetDeviceMemoryCommitment(device: VkDevice | null, memory: VkDeviceMemory | null, pCommittedMemoryInBytes: VkInoutAddress | null): void;

  /**
   * Returns the memory requirements for specified Vulkan object
   * @param device is the logical device that owns the buffer.
   * @param buffer is the buffer to query.
   * @param pMemoryRequirements is a reference to a 'VkMemoryRequirements' structure in which the memory requirements of the buffer object are returned.
   */
  export function vkGetBufferMemoryRequirements(device: VkDevice | null, buffer: VkBuffer | null, pMemoryRequirements: VkMemoryRequirements | null): void;

  /**
   * Bind device memory to a buffer object
   * @param device is the logical device that owns the buffer and memory.
   * @param buffer is the buffer to be attached to memory.
   * @param memory which is to be bound to the buffer. The number of bytes returned in the 'VkMemoryRequirements'::'size' member in 'memory', starting from 'memoryOffset' bytes, will be bound to the specified buffer.
   * @param memoryOffset
   */
  export function vkBindBufferMemory(device: VkDevice | null, buffer: VkBuffer | null, memory: VkDeviceMemory | null, memoryOffset: bigint | number): VkResult;

  /**
   * Returns the memory requirements for specified Vulkan object
   * @param device is the logical device that owns the image.
   * @param image is the image to query.
   * @param pMemoryRequirements is a reference to a 'VkMemoryRequirements' structure in which the memory requirements of the image object are returned.
   */
  export function vkGetImageMemoryRequirements(device: VkDevice | null, image: VkImage | null, pMemoryRequirements: VkMemoryRequirements | null): void;

  /**
   * Bind device memory to an image object
   * @param device is the logical device that owns the image and memory.
   * @param image is the image.
   * @param memory which is to be bound to the image. The number of bytes returned in the 'VkMemoryRequirements'::'size' member in 'memory', starting from 'memoryOffset' bytes, will be bound to the specified image.
   * @param memoryOffset
   */
  export function vkBindImageMemory(device: VkDevice | null, image: VkImage | null, memory: VkDeviceMemory | null, memoryOffset: bigint | number): VkResult;

  /**
   * Query the memory requirements for a sparse image
   * @param device is the logical device that owns the image.
   * @param image is the 'VkImage' object to get the memory requirements for.
   * @param pSparseMemoryRequirementCount is a reference to a number related to the number of sparse memory requirements available or queried, as described below.
   * @param pSparseMemoryRequirements is either <i>null</i> or a reference to an array of 'VkSparseImageMemoryRequirements' structures.
   */
  export function vkGetImageSparseMemoryRequirements(device: VkDevice | null, image: VkImage | null, pSparseMemoryRequirementCount: VkInout | null, pSparseMemoryRequirements: VkSparseImageMemoryRequirements[] | null): void;

  /**
   * Retrieve properties of an image format applied to sparse images
   * @param physicalDevice is the physical device from which to query the sparse image capabilities.
   * @param format is the image format.
   * @param type is the dimensionality of image.
   * @param samples is the number of samples per texel as defined in 'VkSampleCountFlagBits'.
   * @param usage is a bitmask describing the intended usage of the image.
   * @param tiling is the tiling arrangement of the texel blocks in memory.
   * @param pPropertyCount is a reference to a number related to the number of sparse format properties available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkSparseImageFormatProperties' structures.
   */
  export function vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice: VkPhysicalDevice | null, format: VkFormat, type: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlagBits, tiling: VkImageTiling, pPropertyCount: VkInout | null, pProperties: VkSparseImageFormatProperties[] | null): void;

  /**
   * Bind device memory to a sparse resource object
   * @param queue is the queue that the sparse binding operations will be submitted to.
   * @param bindInfoCount
   * @param pBindInfo is an array of 'VkBindSparseInfo' structures, each specifying a sparse binding submission batch.
   * @param fence is an 'optional' handle to a fence to be signaled. If 'fence' is not 'VK_NULL_HANDLE', it defines a <<synchronization-fences-signaling, fence signal operation>>.
   */
  export function vkQueueBindSparse(queue: VkQueue | null, bindInfoCount: number, pBindInfo: VkBindSparseInfo[] | null, fence: VkFence | null): VkResult;

  /**
   * Create a new fence object
   * @param device is the logical device that creates the fence.
   * @param pCreateInfo is a reference to a 'VkFenceCreateInfo' structure containing information about how the fence is to be created.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pFence is a reference to a handle in which the resulting fence object is returned.
   */
  export function vkCreateFence(device: VkDevice | null, pCreateInfo: VkFenceCreateInfo | null, pAllocator: null, pFence: VkFence | null): VkResult;

  /**
   * Destroy a fence object
   * @param device is the logical device that destroys the fence.
   * @param fence is the handle of the fence to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyFence(device: VkDevice | null, fence: VkFence | null, pAllocator: null): void;

  /**
   * Resets one or more fence objects
   * @param device is the logical device that owns the fences.
   * @param fenceCount is the number of fences to reset.
   * @param pFences is an array of fence handles to reset.
   */
  export function vkResetFences(device: VkDevice | null, fenceCount: number, pFences: VkFence[] | null): VkResult;

  /**
   * Return the status of a fence
   * @param device is the logical device that owns the fence.
   * @param fence is the handle of the fence to query.
   */
  export function vkGetFenceStatus(device: VkDevice | null, fence: VkFence | null): VkResult;

  /**
   * Wait for one or more fences to become signaled
   * @param device is the logical device that owns the fences.
   * @param fenceCount fence handles.
   * @param pFences
   * @param waitAll is the condition that 'must' be satisfied to successfully unblock the wait. If 'waitAll' is 'VK_TRUE', then the condition is that all fences in 'pFences' are signaled. Otherwise, the condition is that at least one fence in 'pFences' is signaled.
   * @param timeout is the timeout period in units of nanoseconds. 'timeout' is adjusted to the closest value allowed by the implementation-dependent timeout accuracy, which 'may' be substantially longer than one nanosecond, and 'may' be longer than the requested period.
   */
  export function vkWaitForFences(device: VkDevice | null, fenceCount: number, pFences: VkFence[] | null, waitAll: boolean, timeout: bigint | number): VkResult;

  /**
   * Create a new queue semaphore object
   * @param device is the logical device that creates the semaphore.
   * @param pCreateInfo is a reference to a 'VkSemaphoreCreateInfo' structure containing information about how the semaphore is to be created.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pSemaphore is a reference to a handle in which the resulting semaphore object is returned.
   */
  export function vkCreateSemaphore(device: VkDevice | null, pCreateInfo: VkSemaphoreCreateInfo | null, pAllocator: null, pSemaphore: VkSemaphore | null): VkResult;

  /**
   * Destroy a semaphore object
   * @param device is the logical device that destroys the semaphore.
   * @param semaphore is the handle of the semaphore to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroySemaphore(device: VkDevice | null, semaphore: VkSemaphore | null, pAllocator: null): void;

  /**
   * Create a new event object
   * @param device is the logical device that creates the event.
   * @param pCreateInfo is a reference to a 'VkEventCreateInfo' structure containing information about how the event is to be created.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pEvent is a reference to a handle in which the resulting event object is returned.
   */
  export function vkCreateEvent(device: VkDevice | null, pCreateInfo: VkEventCreateInfo | null, pAllocator: null, pEvent: VkEvent | null): VkResult;

  /**
   * Destroy an event object
   * @param device is the logical device that destroys the event.
   * @param event is the handle of the event to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyEvent(device: VkDevice | null, event: VkEvent | null, pAllocator: null): void;

  /**
   * Retrieve the status of an event object
   * @param device is the logical device that owns the event.
   * @param event is the handle of the event to query.
   */
  export function vkGetEventStatus(device: VkDevice | null, event: VkEvent | null): VkResult;

  /**
   * Set an event to signaled state
   * @param device is the logical device that owns the event.
   * @param event is the event to set.
   */
  export function vkSetEvent(device: VkDevice | null, event: VkEvent | null): VkResult;

  /**
   * Reset an event to non-signaled state
   * @param device is the logical device that owns the event.
   * @param event is the event to reset.
   */
  export function vkResetEvent(device: VkDevice | null, event: VkEvent | null): VkResult;

  /**
   * Create a new query pool object
   * @param device is the logical device that creates the query pool.
   * @param pCreateInfo is a reference to a 'VkQueryPoolCreateInfo' structure containing the number and type of queries to be managed by the pool.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pQueryPool is a reference to a 'VkQueryPool' handle in which the resulting query pool object is returned.
   */
  export function vkCreateQueryPool(device: VkDevice | null, pCreateInfo: VkQueryPoolCreateInfo | null, pAllocator: null, pQueryPool: VkQueryPool | null): VkResult;

  /**
   * Destroy a query pool object
   * @param device is the logical device that destroys the query pool.
   * @param queryPool is the query pool to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyQueryPool(device: VkDevice | null, queryPool: VkQueryPool | null, pAllocator: null): void;

  /**
   * Copy results of queries in a query pool to a host memory region
   * @param device is the logical device that owns the query pool.
   * @param queryPool is the query pool managing the queries containing the desired results.
   * @param firstQuery is the initial query index.
   * @param queryCount is the number of queries to read.
   * @param dataSize is the size in bytes of the buffer pointed to by 'pData'.
   * @param pData is a reference to a user-allocated buffer where the results will be written
   * @param stride is the stride in bytes between results for individual queries within 'pData'.
   * @param flags is a bitmask of 'VkQueryResultFlagBits' specifying how and when results are returned.
   */
  export function vkGetQueryPoolResults(device: VkDevice | null, queryPool: VkQueryPool | null, firstQuery: number, queryCount: number, dataSize: bigint | number, pData: ArrayBuffer | null, stride: bigint | number, flags: VkQueryResultFlagBits): VkResult;

  /**
   * Reset queries in a query pool
   * @param device is the logical device that owns the query pool.
   * @param queryPool is the handle of the query pool managing the queries being reset.
   * @param firstQuery is the initial query index to reset.
   * @param queryCount is the number of queries to reset.
   */
  export function vkResetQueryPool(device: VkDevice | null, queryPool: VkQueryPool | null, firstQuery: number, queryCount: number): void;

  /**
   * Create a new buffer object
   * @param device is the logical device that creates the buffer object.
   * @param pCreateInfo is a reference to a 'VkBufferCreateInfo' structure containing parameters affecting creation of the buffer.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pBuffer is a reference to a 'VkBuffer' handle in which the resulting buffer object is returned.
   */
  export function vkCreateBuffer(device: VkDevice | null, pCreateInfo: VkBufferCreateInfo | null, pAllocator: null, pBuffer: VkBuffer | null): VkResult;

  /**
   * Destroy a buffer object
   * @param device is the logical device that destroys the buffer.
   * @param buffer is the buffer to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyBuffer(device: VkDevice | null, buffer: VkBuffer | null, pAllocator: null): void;

  /**
   * Create a new buffer view object
   * @param device is the logical device that creates the buffer view.
   * @param pCreateInfo is a reference to a 'VkBufferViewCreateInfo' structure containing parameters to be used to create the buffer.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pView is a reference to a 'VkBufferView' handle in which the resulting buffer view object is returned.
   */
  export function vkCreateBufferView(device: VkDevice | null, pCreateInfo: VkBufferViewCreateInfo | null, pAllocator: null, pView: VkBufferView | null): VkResult;

  /**
   * Destroy a buffer view object
   * @param device is the logical device that destroys the buffer view.
   * @param bufferView is the buffer view to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyBufferView(device: VkDevice | null, bufferView: VkBufferView | null, pAllocator: null): void;

  /**
   * Create a new image object
   * @param device is the logical device that creates the image.
   * @param pCreateInfo is a reference to a 'VkImageCreateInfo' structure containing parameters to be used to create the image.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pImage is a reference to a 'VkImage' handle in which the resulting image object is returned.
   */
  export function vkCreateImage(device: VkDevice | null, pCreateInfo: VkImageCreateInfo | null, pAllocator: null, pImage: VkImage | null): VkResult;

  /**
   * Destroy an image object
   * @param device is the logical device that destroys the image.
   * @param image is the image to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyImage(device: VkDevice | null, image: VkImage | null, pAllocator: null): void;

  /**
   * Retrieve information about an image subresource
   * @param device is the logical device that owns the image.
   * @param image is the image whose layout is being queried.
   * @param pSubresource is a reference to a 'VkImageSubresource' structure selecting a specific image for the image subresource.
   * @param pLayout is a reference to a 'VkSubresourceLayout' structure in which the layout is returned.
   */
  export function vkGetImageSubresourceLayout(device: VkDevice | null, image: VkImage | null, pSubresource: VkImageSubresource | null, pLayout: VkSubresourceLayout | null): void;

  /**
   * Create an image view from an existing image
   * @param device is the logical device that creates the image view.
   * @param pCreateInfo is a reference to a 'VkImageViewCreateInfo' structure containing parameters to be used to create the image view.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pView is a reference to a 'VkImageView' handle in which the resulting image view object is returned.
   */
  export function vkCreateImageView(device: VkDevice | null, pCreateInfo: VkImageViewCreateInfo | null, pAllocator: null, pView: VkImageView | null): VkResult;

  /**
   * Destroy an image view object
   * @param device is the logical device that destroys the image view.
   * @param imageView is the image view to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyImageView(device: VkDevice | null, imageView: VkImageView | null, pAllocator: null): void;

  /**
   * Creates a new shader module object
   * @param device is the logical device that creates the shader module.
   * @param pCreateInfo is a reference to a 'VkShaderModuleCreateInfo' structure.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pShaderModule is a reference to a 'VkShaderModule' handle in which the resulting shader module object is returned.
   */
  export function vkCreateShaderModule(device: VkDevice | null, pCreateInfo: VkShaderModuleCreateInfo | null, pAllocator: null, pShaderModule: VkShaderModule | null): VkResult;

  /**
   * Destroy a shader module
   * @param device is the logical device that destroys the shader module.
   * @param shaderModule is the handle of the shader module to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyShaderModule(device: VkDevice | null, shaderModule: VkShaderModule | null, pAllocator: null): void;

  /**
   * Creates a new pipeline cache
   * @param device is the logical device that creates the pipeline cache object.
   * @param pCreateInfo is a reference to a 'VkPipelineCacheCreateInfo' structure containing initial parameters for the pipeline cache object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelineCache is a reference to a 'VkPipelineCache' handle in which the resulting pipeline cache object is returned.
   */
  export function vkCreatePipelineCache(device: VkDevice | null, pCreateInfo: VkPipelineCacheCreateInfo | null, pAllocator: null, pPipelineCache: VkPipelineCache | null): VkResult;

  /**
   * Destroy a pipeline cache object
   * @param device is the logical device that destroys the pipeline cache object.
   * @param pipelineCache is the handle of the pipeline cache to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyPipelineCache(device: VkDevice | null, pipelineCache: VkPipelineCache | null, pAllocator: null): void;

  /**
   * Get the data store from a pipeline cache
   * @param device is the logical device that owns the pipeline cache.
   * @param pipelineCache is the pipeline cache to retrieve data from.
   * @param pDataSize is a reference to a 'size_t' value related to the amount of data in the pipeline cache, as described below.
   * @param pData is either <i>null</i> or a reference to a buffer.
   */
  export function vkGetPipelineCacheData(device: VkDevice | null, pipelineCache: VkPipelineCache | null, pDataSize: VkInoutAddress | null, pData: ArrayBuffer | null): VkResult;

  /**
   * Combine the data stores of pipeline caches
   * @param device is the logical device that owns the pipeline cache objects.
   * @param dstCache is the handle of the pipeline cache to merge results into.
   * @param srcCacheCount
   * @param pSrcCaches is an array of pipeline cache handles, which will be merged into 'dstCache'. The previous contents of 'dstCache' are included after the merge.
   */
  export function vkMergePipelineCaches(device: VkDevice | null, dstCache: VkPipelineCache | null, srcCacheCount: number, pSrcCaches: VkPipelineCache[] | null): VkResult;

  /**
   * Create graphics pipelines
   * @param device is the logical device that creates the graphics pipelines.
   * @param pipelineCache is either 'VK_NULL_HANDLE', indicating that pipeline caching is disabled; or the handle of a valid <<pipelines-cache,pipeline cache>> object, in which case use of that cache is enabled for the duration of the command.
   * @param createInfoCount
   * @param pCreateInfos is an array of 'VkGraphicsPipelineCreateInfo' structures.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelines is an array of 'VkPipeline' handles in which the resulting graphics pipeline objects are returned.
   */
  export function vkCreateGraphicsPipelines(device: VkDevice | null, pipelineCache: VkPipelineCache | null, createInfoCount: number, pCreateInfos: VkGraphicsPipelineCreateInfo[] | null, pAllocator: null, pPipelines: VkPipeline[] | null): VkResult;

  /**
   * Creates a new compute pipeline object
   * @param device is the logical device that creates the compute pipelines.
   * @param pipelineCache is either 'VK_NULL_HANDLE', indicating that pipeline caching is disabled; or the handle of a valid <<pipelines-cache,pipeline cache>> object, in which case use of that cache is enabled for the duration of the command.
   * @param createInfoCount
   * @param pCreateInfos is an array of 'VkComputePipelineCreateInfo' structures.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelines is an array of 'VkPipeline' handles in which the resulting compute pipeline objects are returned.+[NOTE].editing-note====TODO (Jon) - Should we say something like "`the i'th element of the'pPipelines' array is created based on the corresponding element of the'pCreateInfos' array`"? Also for 'vkCreateGraphicsPipelines' below.====
   */
  export function vkCreateComputePipelines(device: VkDevice | null, pipelineCache: VkPipelineCache | null, createInfoCount: number, pCreateInfos: VkComputePipelineCreateInfo[] | null, pAllocator: null, pPipelines: VkPipeline[] | null): VkResult;

  /**
   * Destroy a pipeline object
   * @param device is the logical device that destroys the pipeline.
   * @param pipeline is the handle of the pipeline to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyPipeline(device: VkDevice | null, pipeline: VkPipeline | null, pAllocator: null): void;

  /**
   * Creates a new pipeline layout object
   * @param device is the logical device that creates the pipeline layout.
   * @param pCreateInfo is a reference to a 'VkPipelineLayoutCreateInfo' structure specifying the state of the pipeline layout object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelineLayout is a reference to a 'VkPipelineLayout' handle in which the resulting pipeline layout object is returned.
   */
  export function vkCreatePipelineLayout(device: VkDevice | null, pCreateInfo: VkPipelineLayoutCreateInfo | null, pAllocator: null, pPipelineLayout: VkPipelineLayout | null): VkResult;

  /**
   * Destroy a pipeline layout object
   * @param device is the logical device that destroys the pipeline layout.
   * @param pipelineLayout is the pipeline layout to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyPipelineLayout(device: VkDevice | null, pipelineLayout: VkPipelineLayout | null, pAllocator: null): void;

  /**
   * Create a new sampler object
   * @param device is the logical device that creates the sampler.
   * @param pCreateInfo is a reference to a 'VkSamplerCreateInfo' structure specifying the state of the sampler object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pSampler is a reference to a 'VkSampler' handle in which the resulting sampler object is returned.
   */
  export function vkCreateSampler(device: VkDevice | null, pCreateInfo: VkSamplerCreateInfo | null, pAllocator: null, pSampler: VkSampler | null): VkResult;

  /**
   * Destroy a sampler object
   * @param device is the logical device that destroys the sampler.
   * @param sampler is the sampler to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroySampler(device: VkDevice | null, sampler: VkSampler | null, pAllocator: null): void;

  /**
   * Create a new descriptor set layout
   * @param device is the logical device that creates the descriptor set layout.
   * @param pCreateInfo is a reference to a 'VkDescriptorSetLayoutCreateInfo' structure specifying the state of the descriptor set layout object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pSetLayout is a reference to a 'VkDescriptorSetLayout' handle in which the resulting descriptor set layout object is returned.
   */
  export function vkCreateDescriptorSetLayout(device: VkDevice | null, pCreateInfo: VkDescriptorSetLayoutCreateInfo | null, pAllocator: null, pSetLayout: VkDescriptorSetLayout | null): VkResult;

  /**
   * Destroy a descriptor set layout object
   * @param device is the logical device that destroys the descriptor set layout.
   * @param descriptorSetLayout is the descriptor set layout to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDescriptorSetLayout(device: VkDevice | null, descriptorSetLayout: VkDescriptorSetLayout | null, pAllocator: null): void;

  /**
   * Creates a descriptor pool object
   * @param device is the logical device that creates the descriptor pool.
   * @param pCreateInfo is a reference to a 'VkDescriptorPoolCreateInfo' structure specifying the state of the descriptor pool object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pDescriptorPool is a reference to a 'VkDescriptorPool' handle in which the resulting descriptor pool object is returned.
   */
  export function vkCreateDescriptorPool(device: VkDevice | null, pCreateInfo: VkDescriptorPoolCreateInfo | null, pAllocator: null, pDescriptorPool: VkDescriptorPool | null): VkResult;

  /**
   * Destroy a descriptor pool object
   * @param device is the logical device that destroys the descriptor pool.
   * @param descriptorPool is the descriptor pool to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDescriptorPool(device: VkDevice | null, descriptorPool: VkDescriptorPool | null, pAllocator: null): void;

  /**
   * Resets a descriptor pool object
   * @param device is the logical device that owns the descriptor pool.
   * @param descriptorPool is the descriptor pool to be reset.
   * @param flags is reserved for future use.
   */
  export function vkResetDescriptorPool(device: VkDevice | null, descriptorPool: VkDescriptorPool | null, flags: number): VkResult;

  /**
   * Allocate one or more descriptor sets
   * @param device is the logical device that owns the descriptor pool.
   * @param pAllocateInfo is a reference to a 'VkDescriptorSetAllocateInfo' structure describing parameters of the allocation.
   * @param pDescriptorSets is an array of 'VkDescriptorSet' handles in which the resulting descriptor set objects are returned.
   */
  export function vkAllocateDescriptorSets(device: VkDevice | null, pAllocateInfo: VkDescriptorSetAllocateInfo | null, pDescriptorSets: VkDescriptorSet[] | null): VkResult;

  /**
   * Free one or more descriptor sets
   * @param device is the logical device that owns the descriptor pool.
   * @param descriptorPool is the descriptor pool from which the descriptor sets were allocated.
   * @param descriptorSetCount is the number of elements in the 'pDescriptorSets' array.
   * @param pDescriptorSets is an array of handles to 'VkDescriptorSet' objects.
   */
  export function vkFreeDescriptorSets(device: VkDevice | null, descriptorPool: VkDescriptorPool | null, descriptorSetCount: number, pDescriptorSets: VkDescriptorSet[] | null): VkResult;

  /**
   * Update the contents of a descriptor set object
   * @param device is the logical device that updates the descriptor sets.
   * @param descriptorWriteCount is the number of elements in the 'pDescriptorWrites' array.
   * @param pDescriptorWrites is an array of 'VkWriteDescriptorSet' structures describing the descriptor sets to write to.
   * @param descriptorCopyCount is the number of elements in the 'pDescriptorCopies' array.
   * @param pDescriptorCopies is an array of 'VkCopyDescriptorSet' structures describing the descriptor sets to copy between.
   */
  export function vkUpdateDescriptorSets(device: VkDevice | null, descriptorWriteCount: number, pDescriptorWrites: VkWriteDescriptorSet[] | null, descriptorCopyCount: number, pDescriptorCopies: VkCopyDescriptorSet[] | null): void;

  /**
   * Create a new framebuffer object
   * @param device is the logical device that creates the framebuffer.
   * @param pCreateInfo is a reference to a 'VkFramebufferCreateInfo' structure describing additional information about framebuffer creation.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pFramebuffer is a reference to a 'VkFramebuffer' handle in which the resulting framebuffer object is returned.
   */
  export function vkCreateFramebuffer(device: VkDevice | null, pCreateInfo: VkFramebufferCreateInfo | null, pAllocator: null, pFramebuffer: VkFramebuffer | null): VkResult;

  /**
   * Destroy a framebuffer object
   * @param device is the logical device that destroys the framebuffer.
   * @param framebuffer is the handle of the framebuffer to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyFramebuffer(device: VkDevice | null, framebuffer: VkFramebuffer | null, pAllocator: null): void;

  /**
   * Create a new render pass object
   * @param device is the logical device that creates the render pass.
   * @param pCreateInfo is a reference to a 'VkRenderPassCreateInfo' structure describing the parameters of the render pass.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pRenderPass is a reference to a 'VkRenderPass' handle in which the resulting render pass object is returned.
   */
  export function vkCreateRenderPass(device: VkDevice | null, pCreateInfo: VkRenderPassCreateInfo | null, pAllocator: null, pRenderPass: VkRenderPass | null): VkResult;

  /**
   * Destroy a render pass object
   * @param device is the logical device that destroys the render pass.
   * @param renderPass is the handle of the render pass to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyRenderPass(device: VkDevice | null, renderPass: VkRenderPass | null, pAllocator: null): void;

  /**
   * Returns the granularity for optimal render area
   * @param device is the logical device that owns the render pass.
   * @param renderPass is a handle to a render pass.
   * @param pGranularity is a reference to a 'VkExtent2D' structure in which the granularity is returned.
   */
  export function vkGetRenderAreaGranularity(device: VkDevice | null, renderPass: VkRenderPass | null, pGranularity: VkExtent2D | null): void;

  /**
   * Create a new command pool object
   * @param device is the logical device that creates the command pool.
   * @param pCreateInfo is a reference to a 'VkCommandPoolCreateInfo' structure specifying the state of the command pool object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pCommandPool is a reference to a 'VkCommandPool' handle in which the created pool is returned.
   */
  export function vkCreateCommandPool(device: VkDevice | null, pCreateInfo: VkCommandPoolCreateInfo | null, pAllocator: null, pCommandPool: VkCommandPool | null): VkResult;

  /**
   * Destroy a command pool object
   * @param device is the logical device that destroys the command pool.
   * @param commandPool is the handle of the command pool to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyCommandPool(device: VkDevice | null, commandPool: VkCommandPool | null, pAllocator: null): void;

  /**
   * Reset a command pool
   * @param device is the logical device that owns the command pool.
   * @param commandPool is the command pool to reset.
   * @param flags is a bitmask of 'VkCommandPoolResetFlagBits' controlling the reset operation.
   */
  export function vkResetCommandPool(device: VkDevice | null, commandPool: VkCommandPool | null, flags: VkCommandPoolResetFlagBits): VkResult;

  /**
   * Allocate command buffers from an existing command pool
   * @param device is the logical device that owns the command pool.
   * @param pAllocateInfo is a reference to a 'VkCommandBufferAllocateInfo' structure describing parameters of the allocation.
   * @param pCommandBuffers is an array of 'VkCommandBuffer' handles in which the resulting command buffer objects are returned. The array 'must' be at least the length specified by the 'commandBufferCount' member of 'pAllocateInfo'. Each allocated command buffer begins in the initial state.
   */
  export function vkAllocateCommandBuffers(device: VkDevice | null, pAllocateInfo: VkCommandBufferAllocateInfo | null, pCommandBuffers: VkCommandBuffer[] | null): VkResult;

  /**
   * Free command buffers
   * @param device is the logical device that owns the command pool.
   * @param commandPool is the command pool from which the command buffers were allocated.
   * @param commandBufferCount
   * @param pCommandBuffers is an array of handles of command buffers to free.
   */
  export function vkFreeCommandBuffers(device: VkDevice | null, commandPool: VkCommandPool | null, commandBufferCount: number, pCommandBuffers: VkCommandBuffer[] | null): void;

  /**
   * Start recording a command buffer
   * @param commandBuffer is the handle of the command buffer which is to be put in the recording state.
   * @param pBeginInfo reference to a 'VkCommandBufferBeginInfo' structure defining additional information about how the command buffer begins recording.
   */
  export function vkBeginCommandBuffer(commandBuffer: VkCommandBuffer | null, pBeginInfo: VkCommandBufferBeginInfo | null): VkResult;

  /**
   * Finish recording a command buffer
   * @param commandBuffer is the command buffer to complete recording.
   */
  export function vkEndCommandBuffer(commandBuffer: VkCommandBuffer | null): VkResult;

  /**
   * Reset a command buffer to the initial state
   * @param commandBuffer is the command buffer to reset. The command buffer 'can' be in any state other than <<commandbuffers-lifecycle, pending>>, and is moved into the <<commandbuffers-lifecycle, initial state>>.
   * @param flags is a bitmask of 'VkCommandBufferResetFlagBits' controlling the reset operation.
   */
  export function vkResetCommandBuffer(commandBuffer: VkCommandBuffer | null, flags: VkCommandBufferResetFlagBits): VkResult;

  /**
   * Bind a pipeline object to a command buffer
   * @param commandBuffer is the command buffer that the pipeline will be bound to.
   * @param pipelineBindPoint is a 'VkPipelineBindPoint' value specifying to which bind point the pipeline is bound. Binding one does not disturb the others.
   * @param pipeline is the pipeline to be bound.
   */
  export function vkCmdBindPipeline(commandBuffer: VkCommandBuffer | null, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline | null): void;

  /**
   * Set the viewport on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstViewport is the index of the first viewport whose parameters are updated by the command.
   * @param viewportCount is the number of viewports whose parameters are updated by the command.
   * @param pViewports is an array of 'VkViewport' structures specifying viewport parameters.
   */
  export function vkCmdSetViewport(commandBuffer: VkCommandBuffer | null, firstViewport: number, viewportCount: number, pViewports: VkViewport[] | null): void;

  /**
   * Set the dynamic scissor rectangles on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstScissor is the index of the first scissor whose state is updated by the command.
   * @param scissorCount is the number of scissors whose rectangles are updated by the command.
   * @param pScissors is an array of 'VkRect2D' structures defining scissor rectangles.
   */
  export function vkCmdSetScissor(commandBuffer: VkCommandBuffer | null, firstScissor: number, scissorCount: number, pScissors: VkRect2D[] | null): void;

  /**
   * Set the dynamic line width state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param lineWidth is the width of rasterized line segments.
   */
  export function vkCmdSetLineWidth(commandBuffer: VkCommandBuffer | null, lineWidth: number): void;

  /**
   * Set the depth bias dynamic state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param depthBiasConstantFactor is a scalar factor controlling the constant depth value added to each fragment.
   * @param depthBiasClamp is the maximum (or minimum) depth bias of a fragment.
   * @param depthBiasSlopeFactor is a scalar factor applied to a fragment's slope in depth bias calculations.
   */
  export function vkCmdSetDepthBias(commandBuffer: VkCommandBuffer | null, depthBiasConstantFactor: number, depthBiasClamp: number, depthBiasSlopeFactor: number): void;

  /**
   * Set the values of blend constants
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param blendConstants is an array of four values specifying the R, G, B, and A components of the blend constant color used in blending, depending on the <<framebuffer-blendfactors,blend factor>>.
   */
  export function vkCmdSetBlendConstants(commandBuffer: VkCommandBuffer | null, blendConstants: number[] | null): void;

  /**
   * Set the depth bounds test values for a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param minDepthBounds is the minimum depth bound.
   * @param maxDepthBounds is the maximum depth bound.
   */
  export function vkCmdSetDepthBounds(commandBuffer: VkCommandBuffer | null, minDepthBounds: number, maxDepthBounds: number): void;

  /**
   * Set the stencil compare mask dynamic state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param faceMask is a bitmask of 'VkStencilFaceFlagBits' specifying the set of stencil state for which to update the compare mask.
   * @param compareMask is the new value to use as the stencil compare mask.
   */
  export function vkCmdSetStencilCompareMask(commandBuffer: VkCommandBuffer | null, faceMask: VkStencilFaceFlagBits, compareMask: number): void;

  /**
   * Set the stencil write mask dynamic state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param faceMask is a bitmask of 'VkStencilFaceFlagBits' specifying the set of stencil state for which to update the write mask, as described above for 'vkCmdSetStencilCompareMask'.
   * @param writeMask is the new value to use as the stencil write mask.
   */
  export function vkCmdSetStencilWriteMask(commandBuffer: VkCommandBuffer | null, faceMask: VkStencilFaceFlagBits, writeMask: number): void;

  /**
   * Set the stencil reference dynamic state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param faceMask is a bitmask of 'VkStencilFaceFlagBits' specifying the set of stencil state for which to update the reference value, as described above for 'vkCmdSetStencilCompareMask'.
   * @param reference is the new value to use as the stencil reference value.
   */
  export function vkCmdSetStencilReference(commandBuffer: VkCommandBuffer | null, faceMask: VkStencilFaceFlagBits, reference: number): void;

  /**
   * Binds descriptor sets to a command buffer
   * @param commandBuffer is the command buffer that the descriptor sets will be bound to.
   * @param pipelineBindPoint is a 'VkPipelineBindPoint' indicating the type of the pipeline that will use the descriptors. There is a separate set of bind reference for each pipeline type, so binding one does not disturb the others.
   * @param layout is a 'VkPipelineLayout' object used to program the bindings.
   * @param firstSet is the set number of the first descriptor set to be bound.
   * @param descriptorSetCount is the number of elements in the 'pDescriptorSets' array.
   * @param pDescriptorSets is an array of handles to 'VkDescriptorSet' objects describing the descriptor sets to write to.
   * @param dynamicOffsetCount is the number of dynamic offsets in the 'pDynamicOffsets' array.
   * @param pDynamicOffsets is an array of 'uint32_t' values specifying dynamic offsets.
   */
  export function vkCmdBindDescriptorSets(commandBuffer: VkCommandBuffer | null, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout | null, firstSet: number, descriptorSetCount: number, pDescriptorSets: VkDescriptorSet[] | null, dynamicOffsetCount: number, pDynamicOffsets: Uint32Array | null): void;

  /**
   * Bind an index buffer to a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer used in index buffer address calculations.
   * @param offset
   * @param indexType is a 'VkIndexType' value specifying whether indices are treated as 16 bits or 32 bits.
   */
  export function vkCmdBindIndexBuffer(commandBuffer: VkCommandBuffer | null, buffer: VkBuffer | null, offset: bigint | number, indexType: VkIndexType): void;

  /**
   * Bind vertex buffers to a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param firstBinding is the index of the first vertex input binding whose state is updated by the command.
   * @param bindingCount is the number of vertex input bindings whose state is updated by the command.
   * @param pBuffers is an array of buffer handles.
   * @param pOffsets is an array of buffer offsets.
   */
  export function vkCmdBindVertexBuffers(commandBuffer: VkCommandBuffer | null, firstBinding: number, bindingCount: number, pBuffers: VkBuffer[] | null, pOffsets: BigUint64Array | null): void;

  /**
   * Draw primitives
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param vertexCount is the number of vertices to draw.
   * @param instanceCount is the number of instances to draw.
   * @param firstVertex is the index of the first vertex to draw.
   * @param firstInstance is the instance ID of the first instance to draw.
   */
  export function vkCmdDraw(commandBuffer: VkCommandBuffer | null, vertexCount: number, instanceCount: number, firstVertex: number, firstInstance: number): void;

  /**
   * Issue an indexed draw into a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param indexCount is the number of vertices to draw.
   * @param instanceCount is the number of instances to draw.
   * @param firstIndex is the base index within the index buffer.
   * @param vertexOffset is the value added to the vertex index before indexing into the vertex buffer.
   * @param firstInstance is the instance ID of the first instance to draw.
   */
  export function vkCmdDrawIndexed(commandBuffer: VkCommandBuffer | null, indexCount: number, instanceCount: number, firstIndex: number, vertexOffset: number, firstInstance: number): void;

  /**
   * Issue an indirect draw into a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param drawCount is the number of draws to execute, and 'can' be zero.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawIndirect(commandBuffer: VkCommandBuffer | null, buffer: VkBuffer | null, offset: bigint | number, drawCount: number, stride: number): void;

  /**
   * Perform an indexed indirect draw
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param drawCount is the number of draws to execute, and 'can' be zero.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawIndexedIndirect(commandBuffer: VkCommandBuffer | null, buffer: VkBuffer | null, offset: bigint | number, drawCount: number, stride: number): void;

  /**
   * Dispatch compute work items
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param groupCountX is the number of local workgroups to dispatch in the X dimension.
   * @param groupCountY is the number of local workgroups to dispatch in the Y dimension.
   * @param groupCountZ is the number of local workgroups to dispatch in the Z dimension.
   */
  export function vkCmdDispatch(commandBuffer: VkCommandBuffer | null, groupCountX: number, groupCountY: number, groupCountZ: number): void;

  /**
   * Dispatch compute work items using indirect parameters
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param buffer where parameters begin.
   * @param offset
   */
  export function vkCmdDispatchIndirect(commandBuffer: VkCommandBuffer | null, buffer: VkBuffer | null, offset: bigint | number): void;

  /**
   * Copy data between buffer regions
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcBuffer is the source buffer.
   * @param dstBuffer is the destination buffer.
   * @param regionCount is the number of regions to copy.
   * @param pRegions is an array of 'VkBufferCopy' structures specifying the regions to copy.
   */
  export function vkCmdCopyBuffer(commandBuffer: VkCommandBuffer | null, srcBuffer: VkBuffer | null, dstBuffer: VkBuffer | null, regionCount: number, pRegions: VkBufferCopy[] | null): void;

  /**
   * Copy data between images
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcImage is the source image.
   * @param srcImageLayout is the current layout of the source image subresource.
   * @param dstImage is the destination image.
   * @param dstImageLayout is the current layout of the destination image subresource.
   * @param regionCount is the number of regions to copy.
   * @param pRegions is an array of 'VkImageCopy' structures specifying the regions to copy.
   */
  export function vkCmdCopyImage(commandBuffer: VkCommandBuffer | null, srcImage: VkImage | null, srcImageLayout: VkImageLayout, dstImage: VkImage | null, dstImageLayout: VkImageLayout, regionCount: number, pRegions: VkImageCopy[] | null): void;

  /**
   * Copy regions of an image, potentially performing format conversion,
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcImage is the source image.
   * @param srcImageLayout is the layout of the source image subresources for the blit.
   * @param dstImage is the destination image.
   * @param dstImageLayout is the layout of the destination image subresources for the blit.
   * @param regionCount is the number of regions to blit.
   * @param pRegions is an array of 'VkImageBlit' structures specifying the regions to blit.
   * @param filter is a 'VkFilter' specifying the filter to apply if the blits require scaling.
   */
  export function vkCmdBlitImage(commandBuffer: VkCommandBuffer | null, srcImage: VkImage | null, srcImageLayout: VkImageLayout, dstImage: VkImage | null, dstImageLayout: VkImageLayout, regionCount: number, pRegions: VkImageBlit[] | null, filter: VkFilter): void;

  /**
   * Copy data from a buffer into an image
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcBuffer is the source buffer.
   * @param dstImage is the destination image.
   * @param dstImageLayout is the layout of the destination image subresources for the copy.
   * @param regionCount is the number of regions to copy.
   * @param pRegions is an array of 'VkBufferImageCopy' structures specifying the regions to copy.
   */
  export function vkCmdCopyBufferToImage(commandBuffer: VkCommandBuffer | null, srcBuffer: VkBuffer | null, dstImage: VkImage | null, dstImageLayout: VkImageLayout, regionCount: number, pRegions: VkBufferImageCopy[] | null): void;

  /**
   * Copy image data into a buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcImage is the source image.
   * @param srcImageLayout is the layout of the source image subresources for the copy.
   * @param dstBuffer is the destination buffer.
   * @param regionCount is the number of regions to copy.
   * @param pRegions is an array of 'VkBufferImageCopy' structures specifying the regions to copy.
   */
  export function vkCmdCopyImageToBuffer(commandBuffer: VkCommandBuffer | null, srcImage: VkImage | null, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer | null, regionCount: number, pRegions: VkBufferImageCopy[] | null): void;

  /**
   * Update a buffer\
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param dstBuffer is a handle to the buffer to be updated.
   * @param dstOffset is the byte offset into the buffer to start updating, and 'must' be a multiple of 4.
   * @param dataSize is the number of bytes to update, and 'must' be a multiple of 4.
   * @param pData is a reference to the source data for the buffer update, and 'must' be at least 'dataSize' bytes in size.
   */
  export function vkCmdUpdateBuffer(commandBuffer: VkCommandBuffer | null, dstBuffer: VkBuffer | null, dstOffset: bigint | number, dataSize: bigint | number, pData: ArrayBuffer | null): void;

  /**
   * Fill a region of a buffer with a fixed value
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param dstBuffer is the buffer to be filled.
   * @param dstOffset is the byte offset into the buffer at which to start filling, and 'must' be a multiple of 4.
   * @param size is the number of bytes to fill, and 'must' be either a multiple of 4, or 'VK_WHOLE_SIZE' to fill the range from 'offset' to the end of the buffer. If 'VK_WHOLE_SIZE' is used and the remaining size of the buffer is not a multiple of 4, then the nearest smaller multiple is used.
   * @param data is the 4-byte word written repeatedly to the buffer to fill 'size' bytes of data. The data word is written to memory according to the host endianness.
   */
  export function vkCmdFillBuffer(commandBuffer: VkCommandBuffer | null, dstBuffer: VkBuffer | null, dstOffset: bigint | number, size: bigint | number, data: number): void;

  /**
   * Clear regions of a color image
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param image is the image to be cleared.
   * @param imageLayout specifies the current layout of the image subresource ranges to be cleared, and 'must' be 'VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR',
   * @param pColor
   * @param rangeCount
   * @param pRanges
   */
  export function vkCmdClearColorImage(commandBuffer: VkCommandBuffer | null, image: VkImage | null, imageLayout: VkImageLayout, pColor: VkClearColorValue | null, rangeCount: number, pRanges: VkImageSubresourceRange[] | null): void;

  /**
   * Fill regions of a combined depth/stencil image
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param image is the image to be cleared.
   * @param imageLayout specifies the current layout of the image subresource ranges to be cleared, and 'must' be 'VK_IMAGE_LAYOUT_GENERAL' or 'VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL'.
   * @param pDepthStencil is a reference to a 'VkClearDepthStencilValue' structure containing the values that the depth and stencil image subresource ranges will be cleared to (see <<clears-values>> below).
   * @param rangeCount is the number of image subresource range structures in 'pRanges'.
   * @param pRanges is an array of 'VkImageSubresourceRange' structures describing a range of mipmap levels, array layers, and aspects to be cleared, as described in <<resources-image-views,Image Views>>.
   */
  export function vkCmdClearDepthStencilImage(commandBuffer: VkCommandBuffer | null, image: VkImage | null, imageLayout: VkImageLayout, pDepthStencil: VkClearDepthStencilValue | null, rangeCount: number, pRanges: VkImageSubresourceRange[] | null): void;

  /**
   * Clear regions within bound framebuffer attachments
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param attachmentCount
   * @param pAttachments is an array of 'VkClearAttachment' structures defining the attachments to clear and the clear values to use. If any attachment to be cleared in the current subpass is 'VK_ATTACHMENT_UNUSED', then the clear has no effect on that attachment.
   * @param rectCount
   * @param pRects is an array of 'VkClearRect' structures defining regions within each selected attachment to clear.
   */
  export function vkCmdClearAttachments(commandBuffer: VkCommandBuffer | null, attachmentCount: number, pAttachments: VkClearAttachment[] | null, rectCount: number, pRects: VkClearRect[] | null): void;

  /**
   * Resolve regions of an image
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param srcImage is the source image.
   * @param srcImageLayout is the layout of the source image subresources for the resolve.
   * @param dstImage is the destination image.
   * @param dstImageLayout is the layout of the destination image subresources for the resolve.
   * @param regionCount is the number of regions to resolve.
   * @param pRegions is an array of 'VkImageResolve' structures specifying the regions to resolve.
   */
  export function vkCmdResolveImage(commandBuffer: VkCommandBuffer | null, srcImage: VkImage | null, srcImageLayout: VkImageLayout, dstImage: VkImage | null, dstImageLayout: VkImageLayout, regionCount: number, pRegions: VkImageResolve[] | null): void;

  /**
   * Set an event object to signaled state
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param event is the event that will be signaled.
   * @param stageMask specifies the <<synchronization-pipeline-stages,source stage mask>> used to determine the first <<synchronization-dependencies-scopes, synchronization scope>>.
   */
  export function vkCmdSetEvent(commandBuffer: VkCommandBuffer | null, event: VkEvent | null, stageMask: VkPipelineStageFlagBits): void;

  /**
   * Reset an event object to non-signaled state
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param event is the event that will be unsignaled.
   * @param stageMask is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages, source stage mask>> used to determine when the 'event' is unsignaled.
   */
  export function vkCmdResetEvent(commandBuffer: VkCommandBuffer | null, event: VkEvent | null, stageMask: VkPipelineStageFlagBits): void;

  /**
   * Wait for one or more events and insert a set of memory
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param eventCount
   * @param pEvents is an array of event object handles to wait on.
   * @param srcStageMask is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages, source stage mask>>.
   * @param dstStageMask is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages, destination stage mask>>.
   * @param memoryBarrierCount
   * @param pMemoryBarriers is an array of 'VkMemoryBarrier' structures.
   * @param bufferMemoryBarrierCount is the length of the 'pBufferMemoryBarriers' array.
   * @param pBufferMemoryBarriers is an array of 'VkBufferMemoryBarrier' structures.
   * @param imageMemoryBarrierCount is the length of the 'pImageMemoryBarriers' array.
   * @param pImageMemoryBarriers is an array of 'VkImageMemoryBarrier' structures.
   */
  export function vkCmdWaitEvents(commandBuffer: VkCommandBuffer | null, eventCount: number, pEvents: VkEvent[] | null, srcStageMask: VkPipelineStageFlagBits, dstStageMask: VkPipelineStageFlagBits, memoryBarrierCount: number, pMemoryBarriers: VkMemoryBarrier[] | null, bufferMemoryBarrierCount: number, pBufferMemoryBarriers: VkBufferMemoryBarrier[] | null, imageMemoryBarrierCount: number, pImageMemoryBarriers: VkImageMemoryBarrier[] | null): void;

  /**
   * Insert a memory dependency
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param srcStageMask is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, source stage mask>>.
   * @param dstStageMask is a bitmask of 'VkPipelineStageFlagBits' specifying the <<synchronization-pipeline-stages-masks, destination stage mask>>.
   * @param dependencyFlags is a bitmask of 'VkDependencyFlagBits' specifying how execution and memory dependencies are formed.
   * @param memoryBarrierCount
   * @param pMemoryBarriers is an array of 'VkMemoryBarrier' structures.
   * @param bufferMemoryBarrierCount is the length of the 'pBufferMemoryBarriers' array.
   * @param pBufferMemoryBarriers is an array of 'VkBufferMemoryBarrier' structures.
   * @param imageMemoryBarrierCount is the length of the 'pImageMemoryBarriers' array.
   * @param pImageMemoryBarriers is an array of 'VkImageMemoryBarrier' structures.
   */
  export function vkCmdPipelineBarrier(commandBuffer: VkCommandBuffer | null, srcStageMask: VkPipelineStageFlagBits, dstStageMask: VkPipelineStageFlagBits, dependencyFlags: VkDependencyFlagBits, memoryBarrierCount: number, pMemoryBarriers: VkMemoryBarrier[] | null, bufferMemoryBarrierCount: number, pBufferMemoryBarriers: VkBufferMemoryBarrier[] | null, imageMemoryBarrierCount: number, pImageMemoryBarriers: VkImageMemoryBarrier[] | null): void;

  /**
   * Begin a query
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the query pool that will manage the results of the query.
   * @param query is the query index within the query pool that will contain the results.
   * @param flags is a bitmask of 'VkQueryControlFlagBits' specifying constraints on the types of queries that 'can' be performed.
   */
  export function vkCmdBeginQuery(commandBuffer: VkCommandBuffer | null, queryPool: VkQueryPool | null, query: number, flags: VkQueryControlFlagBits): void;

  /**
   * Ends a query
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the query pool that is managing the results of the query.
   * @param query is the query index within the query pool where the result is stored.
   */
  export function vkCmdEndQuery(commandBuffer: VkCommandBuffer | null, queryPool: VkQueryPool | null, query: number): void;

  /**
   * Define the beginning of a conditional rendering block
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param pConditionalRenderingBegin is a reference to a 'VkConditionalRenderingBeginInfoEXT' structure specifying parameters of conditional rendering.
   */
  export function vkCmdBeginConditionalRenderingEXT(commandBuffer: VkCommandBuffer | null, pConditionalRenderingBegin: VkConditionalRenderingBeginInfoEXT | null): void;

  /**
   * Define the end of a conditional rendering block
   * @param commandBuffer is the command buffer into which this command will be recorded.
   */
  export function vkCmdEndConditionalRenderingEXT(commandBuffer: VkCommandBuffer | null): void;

  /**
   * Reset queries in a query pool
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the handle of the query pool managing the queries being reset.
   * @param firstQuery is the initial query index to reset.
   * @param queryCount is the number of queries to reset.
   */
  export function vkCmdResetQueryPool(commandBuffer: VkCommandBuffer | null, queryPool: VkQueryPool | null, firstQuery: number, queryCount: number): void;

  /**
   * Write a device timestamp into a query object
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pipelineStage is one of the 'VkPipelineStageFlagBits', specifying a stage of the pipeline.
   * @param queryPool is the query pool that will manage the timestamp.
   * @param query is the query within the query pool that will contain the timestamp.
   */
  export function vkCmdWriteTimestamp(commandBuffer: VkCommandBuffer | null, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool | null, query: number): void;

  /**
   * Copy the results of queries in a query pool to a buffer object
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the query pool managing the queries containing the desired results.
   * @param firstQuery is the initial query index.
   * @param queryCount is the number of queries. 'firstQuery' and 'queryCount' together define a range of queries.
   * @param dstBuffer is a 'VkBuffer' object that will receive the results of the copy command.
   * @param dstOffset
   * @param stride is the stride in bytes between results for individual queries within 'dstBuffer'. The required size of the backing memory for 'dstBuffer' is determined as described above for 'vkGetQueryPoolResults'.
   * @param flags is a bitmask of 'VkQueryResultFlagBits' specifying how and when results are returned.
   */
  export function vkCmdCopyQueryPoolResults(commandBuffer: VkCommandBuffer | null, queryPool: VkQueryPool | null, firstQuery: number, queryCount: number, dstBuffer: VkBuffer | null, dstOffset: bigint | number, stride: bigint | number, flags: VkQueryResultFlagBits): void;

  /**
   * Update the values of push constants
   * @param commandBuffer is the command buffer in which the push constant update will be recorded.
   * @param layout is the pipeline layout used to program the push constant updates.
   * @param stageFlags is a bitmask of 'VkShaderStageFlagBits' specifying the shader stages that will use the push constants in the updated range.
   * @param offset is the start offset of the push constant range to update, in units of bytes.
   * @param size bytes containing the new push constant values.
   * @param pValues
   */
  export function vkCmdPushConstants(commandBuffer: VkCommandBuffer | null, layout: VkPipelineLayout | null, stageFlags: VkShaderStageFlagBits, offset: number, size: number, pValues: ArrayBuffer | null): void;

  /**
   * Begin a new render pass
   * @param commandBuffer is the command buffer in which to record the command.
   * @param pRenderPassBegin is a reference to a 'VkRenderPassBeginInfo' structure specifying the render pass to begin an instance of, and the framebuffer the instance uses.
   * @param contents is a 'VkSubpassContents' value specifying how the commands in the first subpass will be provided.
   */
  export function vkCmdBeginRenderPass(commandBuffer: VkCommandBuffer | null, pRenderPassBegin: VkRenderPassBeginInfo | null, contents: VkSubpassContents): void;

  /**
   * Transition to the next subpass of a render pass
   * @param commandBuffer is the command buffer in which to record the command.
   * @param contents specifies how the commands in the next subpass will be provided, in the same fashion as the corresponding parameter of 'vkCmdBeginRenderPass'.
   */
  export function vkCmdNextSubpass(commandBuffer: VkCommandBuffer | null, contents: VkSubpassContents): void;

  /**
   * End the current render pass
   * @param commandBuffer is the command buffer in which to end the current render pass instance.
   */
  export function vkCmdEndRenderPass(commandBuffer: VkCommandBuffer | null): void;

  /**
   * Execute a secondary command buffer from a primary command buffer
   * @param commandBuffer is a handle to a primary command buffer that the secondary command buffers are executed in.
   * @param commandBufferCount
   * @param pCommandBuffers is an array of 'commandBufferCount' secondary command buffer handles, which are recorded to execute in the primary command buffer in the order they are listed in the array.
   */
  export function vkCmdExecuteCommands(commandBuffer: VkCommandBuffer | null, commandBufferCount: number, pCommandBuffers: VkCommandBuffer[] | null): void;

  /**
   * Query information about the available displays
   * @param physicalDevice is a physical device.
   * @param pPropertyCount is a reference to a number related to the number of display devices available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayPropertiesKHR' structures.
   */
  export function vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice: VkPhysicalDevice | null, pPropertyCount: VkInout | null, pProperties: VkDisplayPropertiesKHR[] | null): VkResult;

  /**
   * Query the plane properties
   * @param physicalDevice is a physical device.
   * @param pPropertyCount is a reference to a number related to the number of display planes available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayPlanePropertiesKHR' structures.
   */
  export function vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice: VkPhysicalDevice | null, pPropertyCount: VkInout | null, pProperties: VkDisplayPlanePropertiesKHR[] | null): VkResult;

  /**
   * Query the list of displays a plane supports
   * @param physicalDevice is a physical device.
   * @param planeIndex is the plane which the application wishes to use, and 'must' be in the range [eq]#[0, physical device plane count - 1]#.
   * @param pDisplayCount is a reference to a number related to the number of displays available or queried, as described below.
   * @param pDisplays is either <i>null</i> or a reference to an array of 'VkDisplayKHR' handles.
   */
  export function vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice: VkPhysicalDevice | null, planeIndex: number, pDisplayCount: VkInout | null, pDisplays: VkDisplayKHR[] | null): VkResult;

  /**
   * Query the set of mode properties supported by the display
   * @param physicalDevice is the physical device associated with 'display'.
   * @param display is the display to query.
   * @param pPropertyCount is a reference to a number related to the number of display modes available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayModePropertiesKHR' structures.
   */
  export function vkGetDisplayModePropertiesKHR(physicalDevice: VkPhysicalDevice | null, display: VkDisplayKHR | null, pPropertyCount: VkInout | null, pProperties: VkDisplayModePropertiesKHR[] | null): VkResult;

  /**
   * Create a display mode
   * @param physicalDevice is the physical device associated with 'display'.
   * @param display is the display to create an additional mode for.
   * @param pCreateInfo is a 'VkDisplayModeCreateInfoKHR' structure describing the new mode to create.
   * @param pAllocator is the allocator used for host memory allocated for the display mode object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pMode returns the handle of the mode created.
   */
  export function vkCreateDisplayModeKHR(physicalDevice: VkPhysicalDevice | null, display: VkDisplayKHR | null, pCreateInfo: VkDisplayModeCreateInfoKHR | null, pAllocator: null, pMode: VkDisplayModeKHR | null): VkResult;

  /**
   * Query capabilities of a mode and plane combination
   * @param physicalDevice is the physical device associated with 'display'
   * @param mode is the display mode the application intends to program when using the specified plane. Note this parameter also implicitly specifies a display.
   * @param planeIndex is the plane which the application intends to use with the display, and is less than the number of display planes supported by the device.
   * @param pCapabilities is a reference to a 'VkDisplayPlaneCapabilitiesKHR' structure in which the capabilities are returned.
   */
  export function vkGetDisplayPlaneCapabilitiesKHR(physicalDevice: VkPhysicalDevice | null, mode: VkDisplayModeKHR | null, planeIndex: number, pCapabilities: VkDisplayPlaneCapabilitiesKHR | null): VkResult;

  /**
   * Create a {#0#} structure representing a display plane and mode
   * @param instance is the instance corresponding to the physical device the targeted display is on.
   * @param pCreateInfo is a reference to a 'VkDisplaySurfaceCreateInfoKHR' structure specifying which mode, plane, and other parameters to use, as described below.
   * @param pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pSurface is a reference to a 'VkSurfaceKHR' handle in which the created surface is returned.
   */
  export function vkCreateDisplayPlaneSurfaceKHR(instance: VkInstance | null, pCreateInfo: VkDisplaySurfaceCreateInfoKHR | null, pAllocator: null, pSurface: VkSurfaceKHR | null): VkResult;

  /**
   * Create multiple swapchains that share presentable images
   * @param device is the device to create the swapchains for.
   * @param swapchainCount is the number of swapchains to create.
   * @param pCreateInfos is an array of 'VkSwapchainCreateInfoKHR' structures specifying the parameters of the created swapchains.
   * @param pAllocator is the allocator used for host memory allocated for the swapchain objects when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pSwapchains is an array of 'VkSwapchainKHR' handles in which the created swapchain objects will be returned.
   */
  export function vkCreateSharedSwapchainsKHR(device: VkDevice | null, swapchainCount: number, pCreateInfos: VkSwapchainCreateInfoKHR[] | null, pAllocator: null, pSwapchains: VkSwapchainKHR[] | null): VkResult;

  /**
   * Destroy a VkSurfaceKHR object
   * @param instance is the instance used to create the surface.
   * @param surface is the surface to destroy.
   * @param pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   */
  export function vkDestroySurfaceKHR(instance: VkInstance | null, surface: VkSurfaceKHR | null, pAllocator: null): void;

  /**
   * Query if presentation is supported
   * @param physicalDevice is the physical device.
   * @param queueFamilyIndex is the queue family.
   * @param surface is the surface.
   * @param pSupported is a reference to a 'VkInout', which is set to 'VK_TRUE' to indicate support, and 'VK_FALSE' otherwise.
   */
  export function vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice: VkPhysicalDevice | null, queueFamilyIndex: number, surface: VkSurfaceKHR | null, pSupported: VkInout | null): VkResult;

  /**
   * Query surface capabilities
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param surface is the surface that will be associated with the swapchain.
   * @param pSurfaceCapabilities is a reference to a 'VkSurfaceCapabilitiesKHR' structure in which the capabilities are returned.
   */
  export function vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice: VkPhysicalDevice | null, surface: VkSurfaceKHR | null, pSurfaceCapabilities: VkSurfaceCapabilitiesKHR | null): VkResult;

  /**
   * Query color formats supported by surface
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param surface is the surface that will be associated with the swapchain.
   * @param pSurfaceFormatCount is a reference to a number related to the number of format pairs available or queried, as described below.
   * @param pSurfaceFormats is either <i>null</i> or a reference to an array of 'VkSurfaceFormatKHR' structures.
   */
  export function vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice: VkPhysicalDevice | null, surface: VkSurfaceKHR | null, pSurfaceFormatCount: VkInout | null, pSurfaceFormats: VkSurfaceFormatKHR[] | null): VkResult;

  /**
   * Query supported presentation modes
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param surface is the surface that will be associated with the swapchain.
   * @param pPresentModeCount is a reference to a number related to the number of presentation modes available or queried, as described below.
   * @param pPresentModes is either <i>null</i> or a reference to an array of 'VkPresentModeKHR' values, indicating the supported presentation modes.
   */
  export function vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice: VkPhysicalDevice | null, surface: VkSurfaceKHR | null, pPresentModeCount: VkInout | null, pPresentModes: Int32Array | null): VkResult;

  /**
   * Create a swapchain
   * @param device is the device to create the swapchain for.
   * @param pCreateInfo is a reference to a 'VkSwapchainCreateInfoKHR' structure specifying the parameters of the created swapchain.
   * @param pAllocator is the allocator used for host memory allocated for the swapchain object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pSwapchain is a reference to a 'VkSwapchainKHR' handle in which the created swapchain object will be returned.
   */
  export function vkCreateSwapchainKHR(device: VkDevice | null, pCreateInfo: VkSwapchainCreateInfoKHR | null, pAllocator: null, pSwapchain: VkSwapchainKHR | null): VkResult;

  /**
   * Destroy a swapchain object
   * @param device
   * @param swapchain is the swapchain to destroy.
   * @param pAllocator is the allocator used for host memory allocated for the swapchain object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   */
  export function vkDestroySwapchainKHR(device: VkDevice | null, swapchain: VkSwapchainKHR | null, pAllocator: null): void;

  /**
   * Obtain the array of presentable images associated with a swapchain
   * @param device
   * @param swapchain is the swapchain to query.
   * @param pSwapchainImageCount is a reference to a number related to the number of presentable images available or queried, as described below.
   * @param pSwapchainImages is either <i>null</i> or a reference to an array of 'VkImage' handles.
   */
  export function vkGetSwapchainImagesKHR(device: VkDevice | null, swapchain: VkSwapchainKHR | null, pSwapchainImageCount: VkInout | null, pSwapchainImages: VkImage[] | null): VkResult;

  /**
   * Retrieve the index of the next available presentable image
   * @param device
   * @param swapchain is the non-retired swapchain from which an image is being acquired.
   * @param timeout specifies how long the function waits, in nanoseconds, if no image is available.
   * @param semaphore is 'VK_NULL_HANDLE' or a semaphore to signal.
   * @param fence is 'VK_NULL_HANDLE' or a fence to signal.
   * @param pImageIndex is a reference to a 'uint32_t' in which the index of the next image to use (i.e. an index into the array of images returned by 'vkGetSwapchainImagesKHR') is returned.
   */
  export function vkAcquireNextImageKHR(device: VkDevice | null, swapchain: VkSwapchainKHR | null, timeout: bigint | number, semaphore: VkSemaphore | null, fence: VkFence | null, pImageIndex: VkInout | null): VkResult;

  /**
   * Queue an image for presentation
   * @param queue is a queue that is capable of presentation to the target surface's platform on the same device as the image's swapchain.
   * @param pPresentInfo is a reference to a 'VkPresentInfoKHR' structure specifying parameters of the presentation.
   */
  export function vkQueuePresentKHR(queue: VkQueue | null, pPresentInfo: VkPresentInfoKHR | null): VkResult;

  /**
   * Create a {#0#} object for an Win32 native window
   * @param instance is the instance to associate the surface with.
   * @param pCreateInfo is a reference to a 'VkWin32SurfaceCreateInfoKHR' structure containing parameters affecting the creation of the surface object.
   * @param pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pSurface is a reference to a 'VkSurfaceKHR' handle in which the created surface object is returned.
   */
  export function vkCreateWin32SurfaceKHR(instance: VkInstance | null, pCreateInfo: VkWin32SurfaceCreateInfoKHR | null, pAllocator: null, pSurface: VkSurfaceKHR | null): VkResult;

  /**
   * query queue family support for presentation on a Win32 display
   * @param physicalDevice is the physical device.
   * @param queueFamilyIndex is the queue family index.
   */
  export function vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice: VkPhysicalDevice | null, queueFamilyIndex: number): number;

  /**
   * Create a debug report callback object
   * @param instance is the instance the callback will be logged on.
   * @param pCreateInfo is a reference to a 'VkDebugReportCallbackCreateInfoEXT' structure defining the conditions under which this callback will be called.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pCallback is a reference to a 'VkDebugReportCallbackEXT' handle in which the created object is returned.
   */
  export function vkCreateDebugReportCallbackEXT(instance: VkInstance | null, pCreateInfo: VkDebugReportCallbackCreateInfoEXT | null, pAllocator: null, pCallback: VkDebugReportCallbackEXT | null): VkResult;

  /**
   * Destroy a debug report callback object
   * @param instance is the instance where the callback was created.
   * @param callback is the 'VkDebugReportCallbackEXT' object to destroy. 'callback' is an externally synchronized object and 'must' not be used on more than one thread at a time. This means that 'vkDestroyDebugReportCallbackEXT' 'must' not be called when a callback is active.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDebugReportCallbackEXT(instance: VkInstance | null, callback: VkDebugReportCallbackEXT | null, pAllocator: null): void;

  /**
   * Inject a message into a debug stream
   * @param instance is the debug stream's 'VkInstance'.
   * @param flags specifies the 'VkDebugReportFlagBitsEXT' classification of this event/message.
   * @param objectType is a 'VkDebugReportObjectTypeEXT' specifying the type of object being used or created at the time the event was triggered.
   * @param object is the object where the issue was detected. 'object' 'can' be 'VK_NULL_HANDLE' if there is no object associated with the event.
   * @param location is an application defined value.
   * @param messageCode is an application defined value.
   * @param pLayerPrefix is the abbreviation of the component making this event/message.
   * @param pMessage is a string detailing the trigger conditions.
   */
  export function vkDebugReportMessageEXT(instance: VkInstance | null, flags: VkDebugReportFlagBitsEXT, objectType: VkDebugReportObjectTypeEXT, object: bigint | number, location: bigint | number, messageCode: number, pLayerPrefix: string | null, pMessage: string | null): void;

  /**
   * Give a user-friendly name to an object
   * @param device is the device that created the object.
   * @param pNameInfo is a reference to a 'VkDebugMarkerObjectNameInfoEXT' structure specifying the parameters of the name to set on the object.
   */
  export function vkDebugMarkerSetObjectNameEXT(device: VkDevice | null, pNameInfo: VkDebugMarkerObjectNameInfoEXT | null): VkResult;

  /**
   * Attach arbitrary data to an object
   * @param device is the device that created the object.
   * @param pTagInfo is a reference to a 'VkDebugMarkerObjectTagInfoEXT' structure specifying the parameters of the tag to attach to the object.
   */
  export function vkDebugMarkerSetObjectTagEXT(device: VkDevice | null, pTagInfo: VkDebugMarkerObjectTagInfoEXT | null): VkResult;

  /**
   * Open a command buffer marker region
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param pMarkerInfo is a reference to a 'VkDebugMarkerMarkerInfoEXT' structure specifying the parameters of the marker region to open.
   */
  export function vkCmdDebugMarkerBeginEXT(commandBuffer: VkCommandBuffer | null, pMarkerInfo: VkDebugMarkerMarkerInfoEXT | null): void;

  /**
   * Close a command buffer marker region
   * @param commandBuffer is the command buffer into which the command is recorded.
   */
  export function vkCmdDebugMarkerEndEXT(commandBuffer: VkCommandBuffer | null): void;

  /**
   * Insert a marker label into a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param pMarkerInfo is a reference to a 'VkDebugMarkerMarkerInfoEXT' structure specifying the parameters of the marker to insert.
   */
  export function vkCmdDebugMarkerInsertEXT(commandBuffer: VkCommandBuffer | null, pMarkerInfo: VkDebugMarkerMarkerInfoEXT | null): void;

  /**
   * determine image capabilities compatible with external memory handle types
   * @param physicalDevice is the physical device from which to query the image capabilities
   * @param format is the image format, corresponding to 'VkImageCreateInfo'::'format'.
   * @param type is the image type, corresponding to 'VkImageCreateInfo'::'imageType'.
   * @param tiling is the image tiling, corresponding to 'VkImageCreateInfo'::'tiling'.
   * @param usage is the intended usage of the image, corresponding to 'VkImageCreateInfo'::'usage'.
   * @param flags is a bitmask describing additional parameters of the image, corresponding to 'VkImageCreateInfo'::'flags'.
   * @param externalHandleType is either one of the bits from 'VkExternalMemoryHandleTypeFlagBitsNV', or 0.
   * @param pExternalImageFormatProperties is a reference to a 'VkExternalImageFormatPropertiesNV' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice: VkPhysicalDevice | null, format: VkFormat, type: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlagBits, flags: VkImageCreateFlagBits, externalHandleType: VkExternalMemoryHandleTypeFlagBitsNV, pExternalImageFormatProperties: VkExternalImageFormatPropertiesNV | null): VkResult;

  /**
   * retrieve Win32 handle to a device memory object
   * @param device is the logical device that owns the memory.
   * @param memory is the 'VkDeviceMemory' object.
   * @param handleType is a bitmask of 'VkExternalMemoryHandleTypeFlagBitsNV' containing a single bit specifying the type of handle requested.
   * @param pHandle
   */
  export function vkGetMemoryWin32HandleNV(device: VkDevice | null, memory: VkDeviceMemory | null, handleType: VkExternalMemoryHandleTypeFlagBitsNV, pHandle: VkInoutAddress | null): VkResult;

  /**
   * Performs the generation and execution of commands on the device
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param isPreprocessed represents whether the input data has already been preprocessed on the device. If it is 'VK_FALSE' this command will implicitly trigger the preprocessing step, otherwise not.
   * @param pGeneratedCommandsInfo is a reference to an instance of the 'VkGeneratedCommandsInfoNV' structure containing parameters affecting the generation of commands.
   */
  export function vkCmdExecuteGeneratedCommandsNV(commandBuffer: VkCommandBuffer | null, isPreprocessed: boolean, pGeneratedCommandsInfo: VkGeneratedCommandsInfoNV | null): void;

  /**
   * Performs preprocessing for generated commands
   * @param commandBuffer is the command buffer which does the preprocessing.
   * @param pGeneratedCommandsInfo is a reference to an instance of the 'VkGeneratedCommandsInfoNV' structure containing parameters affecting the preprocessing step.
   */
  export function vkCmdPreprocessGeneratedCommandsNV(commandBuffer: VkCommandBuffer | null, pGeneratedCommandsInfo: VkGeneratedCommandsInfoNV | null): void;

  /**
   * Bind a pipeline object
   * @param commandBuffer is the command buffer that the pipeline will be bound to.
   * @param pipelineBindPoint is a 'VkPipelineBindPoint' value specifying the bind point to which the pipeline will be bound.
   * @param pipeline is the pipeline to be bound.
   * @param groupIndex is the shader group to be bound.
   */
  export function vkCmdBindPipelineShaderGroupNV(commandBuffer: VkCommandBuffer | null, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline | null, groupIndex: number): void;

  /**
   * Retrieve the buffer allocation requirements for generated commands
   * @param device is the logical device that owns the buffer.
   * @param pInfo is a reference to an instance of the 'VkGeneratedCommandsMemoryRequirementsInfoNV' structure containing parameters required for the memory requirements query.
   * @param pMemoryRequirements reference to an instance of the 'VkMemoryRequirements2' structure in which the memory requirements of the buffer object are returned.
   */
  export function vkGetGeneratedCommandsMemoryRequirementsNV(device: VkDevice | null, pInfo: VkGeneratedCommandsMemoryRequirementsInfoNV | null, pMemoryRequirements: VkMemoryRequirements2 | null): void;

  /**
   * Create an indirect command layout object
   * @param device is the logical device that creates the indirect command layout.
   * @param pCreateInfo is a reference to an instance of the 'VkIndirectCommandsLayoutCreateInfoNV' structure containing parameters affecting creation of the indirect command layout.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pIndirectCommandsLayout reference to a 'VkIndirectCommandsLayoutNV' handle in which the resulting indirect command layout is returned.
   */
  export function vkCreateIndirectCommandsLayoutNV(device: VkDevice | null, pCreateInfo: VkIndirectCommandsLayoutCreateInfoNV | null, pAllocator: null, pIndirectCommandsLayout: VkIndirectCommandsLayoutNV | null): VkResult;

  /**
   * Destroy an indirect commands layout
   * @param device is the logical device that destroys the layout.
   * @param indirectCommandsLayout is the layout to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyIndirectCommandsLayoutNV(device: VkDevice | null, indirectCommandsLayout: VkIndirectCommandsLayoutNV | null, pAllocator: null): void;

  /**
   * Reports capabilities of a physical device
   * @param physicalDevice is the physical device from which to query the supported features.
   * @param pFeatures is a reference to a 'VkPhysicalDeviceFeatures2' structure in which the physical device features are returned.
   */
  export function vkGetPhysicalDeviceFeatures2(physicalDevice: VkPhysicalDevice | null, pFeatures: VkPhysicalDeviceFeatures2 | null): void;

  /**
   * Returns properties of a physical device
   * @param physicalDevice is the handle to the physical device whose properties will be queried.
   * @param pProperties is a reference to a 'VkPhysicalDeviceProperties2' structure in which properties are returned.
   */
  export function vkGetPhysicalDeviceProperties2(physicalDevice: VkPhysicalDevice | null, pProperties: VkPhysicalDeviceProperties2 | null): void;

  /**
   * Lists physical device\
   * @param physicalDevice is the physical device from which to query the format properties.
   * @param format is the format whose properties are queried.
   * @param pFormatProperties is a reference to a 'VkFormatProperties2' structure in which physical device properties for 'format' are returned.
   */
  export function vkGetPhysicalDeviceFormatProperties2(physicalDevice: VkPhysicalDevice | null, format: VkFormat, pFormatProperties: VkFormatProperties2 | null): void;

  /**
   * Lists physical device\
   * @param physicalDevice is the physical device from which to query the image capabilities.
   * @param pImageFormatInfo is a reference to a 'VkPhysicalDeviceImageFormatInfo2' structure describing the parameters that would be consumed by 'vkCreateImage'.
   * @param pImageFormatProperties is a reference to a 'VkImageFormatProperties2' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceImageFormatProperties2(physicalDevice: VkPhysicalDevice | null, pImageFormatInfo: VkPhysicalDeviceImageFormatInfo2 | null, pImageFormatProperties: VkImageFormatProperties2 | null): VkResult;

  /**
   * Reports properties of the queues of the specified physical device
   * @param physicalDevice is the handle to the physical device whose properties will be queried.
   * @param pQueueFamilyPropertyCount is a reference to a number related to the number of queue families available or queried, as described in 'vkGetPhysicalDeviceQueueFamilyProperties'.
   * @param pQueueFamilyProperties is either <i>null</i> or a reference to an array of 'VkQueueFamilyProperties2' structures.
   */
  export function vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice: VkPhysicalDevice | null, pQueueFamilyPropertyCount: VkInout | null, pQueueFamilyProperties: VkQueueFamilyProperties2[] | null): void;

  /**
   * Reports memory information for the specified physical device
   * @param physicalDevice is the handle to the device to query.
   * @param pMemoryProperties is a reference to a 'VkPhysicalDeviceMemoryProperties2' structure in which the properties are returned.
   */
  export function vkGetPhysicalDeviceMemoryProperties2(physicalDevice: VkPhysicalDevice | null, pMemoryProperties: VkPhysicalDeviceMemoryProperties2 | null): void;

  /**
   * Retrieve properties of an image format applied to sparse images
   * @param physicalDevice is the physical device from which to query the sparse image capabilities.
   * @param pFormatInfo is a reference to a 'VkPhysicalDeviceSparseImageFormatInfo2' structure containing input parameters to the command.
   * @param pPropertyCount is a reference to a number related to the number of sparse format properties available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkSparseImageFormatProperties2' structures.
   */
  export function vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice: VkPhysicalDevice | null, pFormatInfo: VkPhysicalDeviceSparseImageFormatInfo2 | null, pPropertyCount: VkInout | null, pProperties: VkSparseImageFormatProperties2[] | null): void;

  /**
   * Pushes descriptor updates into a command buffer
   * @param commandBuffer is the command buffer that the descriptors will be recorded in.
   * @param pipelineBindPoint is a 'VkPipelineBindPoint' indicating the type of the pipeline that will use the descriptors. There is a separate set of push descriptor bindings for each pipeline type, so binding one does not disturb the others.
   * @param layout is a 'VkPipelineLayout' object used to program the bindings.
   * @param set is the set number of the descriptor set in the pipeline layout that will be updated.
   * @param descriptorWriteCount is the number of elements in the 'pDescriptorWrites' array.
   * @param pDescriptorWrites is an array of 'VkWriteDescriptorSet' structures describing the descriptors to be updated.
   */
  export function vkCmdPushDescriptorSetKHR(commandBuffer: VkCommandBuffer | null, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout | null, set: number, descriptorWriteCount: number, pDescriptorWrites: VkWriteDescriptorSet[] | null): void;

  /**
   * Trim a command pool
   * @param device is the logical device that owns the command pool.
   * @param commandPool is the command pool to trim.
   * @param flags is reserved for future use.
   */
  export function vkTrimCommandPool(device: VkDevice | null, commandPool: VkCommandPool | null, flags: number): void;

  /**
   * Query external handle types supported by buffers
   * @param physicalDevice is the physical device from which to query the buffer capabilities.
   * @param pExternalBufferInfo is a reference to a 'VkPhysicalDeviceExternalBufferInfo' structure describing the parameters that would be consumed by 'vkCreateBuffer'.
   * @param pExternalBufferProperties is a reference to a 'VkExternalBufferProperties' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceExternalBufferProperties(physicalDevice: VkPhysicalDevice | null, pExternalBufferInfo: VkPhysicalDeviceExternalBufferInfo | null, pExternalBufferProperties: VkExternalBufferProperties | null): void;

  /**
   * Get a Windows HANDLE for a memory object
   * @param device is the logical device that created the device memory being exported.
   * @param pGetWin32HandleInfo is a reference to a 'VkMemoryGetWin32HandleInfoKHR' structure containing parameters of the export operation.
   * @param pHandle will return the Windows handle representing the payload of the device memory object.
   */
  export function vkGetMemoryWin32HandleKHR(device: VkDevice | null, pGetWin32HandleInfo: VkMemoryGetWin32HandleInfoKHR | null, pHandle: VkInoutAddress | null): VkResult;

  /**
   * Get Properties of External Memory Win32 Handles
   * @param device
   * @param handleType
   * @param handle is the handle which will be imported.
   * @param pMemoryWin32HandleProperties will return properties of 'handle'.
   */
  export function vkGetMemoryWin32HandlePropertiesKHR(device: VkDevice | null, handleType: VkExternalMemoryHandleTypeFlagBits, handle: bigint | number, pMemoryWin32HandleProperties: VkMemoryWin32HandlePropertiesKHR | null): VkResult;

  /**
   * Get a POSIX file descriptor for a memory object
   * @param device is the logical device that created the device memory being exported.
   * @param pGetFdInfo is a reference to a 'VkMemoryGetFdInfoKHR' structure containing parameters of the export operation.
   * @param pFd will return a file descriptor referencing the payload of the device memory object.
   */
  export function vkGetMemoryFdKHR(device: VkDevice | null, pGetFdInfo: VkMemoryGetFdInfoKHR | null, pFd: VkInout | null): VkResult;

  /**
   * Get Properties of External Memory File Descriptors
   * @param device
   * @param handleType
   * @param fd is the handle which will be imported.
   * @param pMemoryFdProperties is a reference to a 'VkMemoryFdPropertiesKHR' structure in which the properties of the handle 'fd' are returned.
   */
  export function vkGetMemoryFdPropertiesKHR(device: VkDevice | null, handleType: VkExternalMemoryHandleTypeFlagBits, fd: number, pMemoryFdProperties: VkMemoryFdPropertiesKHR | null): VkResult;

  /**
   * Function for querying external semaphore handle capabilities.
   * @param physicalDevice is the physical device from which to query the semaphore capabilities.
   * @param pExternalSemaphoreInfo is a reference to a 'VkPhysicalDeviceExternalSemaphoreInfo' structure describing the parameters that would be consumed by 'vkCreateSemaphore'.
   * @param pExternalSemaphoreProperties is a reference to a 'VkExternalSemaphoreProperties' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice: VkPhysicalDevice | null, pExternalSemaphoreInfo: VkPhysicalDeviceExternalSemaphoreInfo | null, pExternalSemaphoreProperties: VkExternalSemaphoreProperties | null): void;

  /**
   * Get a Windows HANDLE for a semaphore
   * @param device is the logical device that created the semaphore being exported.
   * @param pGetWin32HandleInfo is a reference to a 'VkSemaphoreGetWin32HandleInfoKHR' structure containing parameters of the export operation.
   * @param pHandle will return the Windows handle representing the semaphore state.
   */
  export function vkGetSemaphoreWin32HandleKHR(device: VkDevice | null, pGetWin32HandleInfo: VkSemaphoreGetWin32HandleInfoKHR | null, pHandle: VkInoutAddress | null): VkResult;

  /**
   * Import a semaphore from a Windows HANDLE
   * @param device is the logical device that created the semaphore.
   * @param pImportSemaphoreWin32HandleInfo is a reference to a 'VkImportSemaphoreWin32HandleInfoKHR' structure specifying the semaphore and import parameters.
   */
  export function vkImportSemaphoreWin32HandleKHR(device: VkDevice | null, pImportSemaphoreWin32HandleInfo: VkImportSemaphoreWin32HandleInfoKHR | null): VkResult;

  /**
   * Get a POSIX file descriptor handle for a semaphore
   * @param device is the logical device that created the semaphore being exported.
   * @param pGetFdInfo is a reference to a 'VkSemaphoreGetFdInfoKHR' structure containing parameters of the export operation.
   * @param pFd will return the file descriptor representing the semaphore payload.
   */
  export function vkGetSemaphoreFdKHR(device: VkDevice | null, pGetFdInfo: VkSemaphoreGetFdInfoKHR | null, pFd: VkInout | null): VkResult;

  /**
   * Import a semaphore from a POSIX file descriptor
   * @param device is the logical device that created the semaphore.
   * @param pImportSemaphoreFdInfo is a reference to a 'VkImportSemaphoreFdInfoKHR' structure specifying the semaphore and import parameters.
   */
  export function vkImportSemaphoreFdKHR(device: VkDevice | null, pImportSemaphoreFdInfo: VkImportSemaphoreFdInfoKHR | null): VkResult;

  /**
   * Function for querying external fence handle capabilities.
   * @param physicalDevice is the physical device from which to query the fence capabilities.
   * @param pExternalFenceInfo is a reference to a 'VkPhysicalDeviceExternalFenceInfo' structure describing the parameters that would be consumed by 'vkCreateFence'.
   * @param pExternalFenceProperties is a reference to a 'VkExternalFenceProperties' structure in which capabilities are returned.
   */
  export function vkGetPhysicalDeviceExternalFenceProperties(physicalDevice: VkPhysicalDevice | null, pExternalFenceInfo: VkPhysicalDeviceExternalFenceInfo | null, pExternalFenceProperties: VkExternalFenceProperties | null): void;

  /**
   * Get a Windows HANDLE for a fence
   * @param device is the logical device that created the fence being exported.
   * @param pGetWin32HandleInfo is a reference to a 'VkFenceGetWin32HandleInfoKHR' structure containing parameters of the export operation.
   * @param pHandle will return the Windows handle representing the fence state.
   */
  export function vkGetFenceWin32HandleKHR(device: VkDevice | null, pGetWin32HandleInfo: VkFenceGetWin32HandleInfoKHR | null, pHandle: VkInoutAddress | null): VkResult;

  /**
   * Import a fence from a Windows HANDLE
   * @param device is the logical device that created the fence.
   * @param pImportFenceWin32HandleInfo is a reference to a 'VkImportFenceWin32HandleInfoKHR' structure specifying the fence and import parameters.
   */
  export function vkImportFenceWin32HandleKHR(device: VkDevice | null, pImportFenceWin32HandleInfo: VkImportFenceWin32HandleInfoKHR | null): VkResult;

  /**
   * Get a POSIX file descriptor handle for a fence
   * @param device is the logical device that created the fence being exported.
   * @param pGetFdInfo is a reference to a 'VkFenceGetFdInfoKHR' structure containing parameters of the export operation.
   * @param pFd will return the file descriptor representing the fence payload.
   */
  export function vkGetFenceFdKHR(device: VkDevice | null, pGetFdInfo: VkFenceGetFdInfoKHR | null, pFd: VkInout | null): VkResult;

  /**
   * Import a fence from a POSIX file descriptor
   * @param device is the logical device that created the fence.
   * @param pImportFenceFdInfo is a reference to a 'VkImportFenceFdInfoKHR' structure specifying the fence and import parameters.
   */
  export function vkImportFenceFdKHR(device: VkDevice | null, pImportFenceFdInfo: VkImportFenceFdInfoKHR | null): VkResult;

  /**
   * Release access to an acquired VkDisplayKHR
   * @param physicalDevice The physical device the display is on.
   * @param display The display to release control of.
   */
  export function vkReleaseDisplayEXT(physicalDevice: VkPhysicalDevice | null, display: VkDisplayKHR | null): VkResult;

  /**
   * Set the power state of a display
   * @param device
   * @param display is the display whose power state is modified.
   * @param pDisplayPowerInfo is a 'VkDisplayPowerInfoEXT' structure specifying the new power state of 'display'.
   */
  export function vkDisplayPowerControlEXT(device: VkDevice | null, display: VkDisplayKHR | null, pDisplayPowerInfo: VkDisplayPowerInfoEXT | null): VkResult;

  /**
   * Signal a fence when a device event occurs
   * @param device is a logical device on which the event 'may' occur.
   * @param pDeviceEventInfo is a reference to a 'VkDeviceEventInfoEXT' structure describing the event of interest to the application.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pFence is a reference to a handle in which the resulting fence object is returned.
   */
  export function vkRegisterDeviceEventEXT(device: VkDevice | null, pDeviceEventInfo: VkDeviceEventInfoEXT | null, pAllocator: null, pFence: VkFence | null): VkResult;

  /**
   * Signal a fence when a display event occurs
   * @param device
   * @param display is the display on which the event 'may' occur.
   * @param pDisplayEventInfo is a reference to a 'VkDisplayEventInfoEXT' structure describing the event of interest to the application.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pFence is a reference to a handle in which the resulting fence object is returned.
   */
  export function vkRegisterDisplayEventEXT(device: VkDevice | null, display: VkDisplayKHR | null, pDisplayEventInfo: VkDisplayEventInfoEXT | null, pAllocator: null, pFence: VkFence | null): VkResult;

  /**
   * Query the current value of a surface counter
   * @param device
   * @param swapchain is the swapchain from which to query the counter value.
   * @param counter is the counter to query.
   * @param pCounterValue will return the current value of the counter.
   */
  export function vkGetSwapchainCounterEXT(device: VkDevice | null, swapchain: VkSwapchainKHR | null, counter: VkSurfaceCounterFlagBitsEXT, pCounterValue: VkInoutAddress | null): VkResult;

  /**
   * Query surface capabilities
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param surface is the surface that will be associated with the swapchain.
   * @param pSurfaceCapabilities is a reference to a 'VkSurfaceCapabilities2EXT' structure in which the capabilities are returned.
   */
  export function vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice: VkPhysicalDevice | null, surface: VkSurfaceKHR | null, pSurfaceCapabilities: VkSurfaceCapabilities2EXT | null): VkResult;

  /**
   * Enumerates groups of physical devices that can be used to create a single logical device
   * @param instance is a handle to a Vulkan instance previously created with 'vkCreateInstance'.
   * @param pPhysicalDeviceGroupCount is a reference to a number related to the number of device groups available or queried, as described below.
   * @param pPhysicalDeviceGroupProperties is either <i>null</i> or a reference to an array of 'VkPhysicalDeviceGroupProperties' structures.
   */
  export function vkEnumeratePhysicalDeviceGroups(instance: VkInstance | null, pPhysicalDeviceGroupCount: VkInout | null, pPhysicalDeviceGroupProperties: VkPhysicalDeviceGroupProperties[] | null): VkResult;

  /**
   * Query supported peer memory features of a device
   * @param device is the logical device that owns the memory.
   * @param heapIndex is the index of the memory heap from which the memory is allocated.
   * @param localDeviceIndex is the device index of the physical device that performs the memory access.
   * @param remoteDeviceIndex is the device index of the physical device that the memory is allocated for.
   * @param pPeerMemoryFeatures is a reference to a 'VkPeerMemoryFeatureFlags' bitmask indicating which types of memory accesses are supported for the combination of heap, local, and remote devices.
   */
  export function vkGetDeviceGroupPeerMemoryFeatures(device: VkDevice | null, heapIndex: number, localDeviceIndex: number, remoteDeviceIndex: number, pPeerMemoryFeatures: VkInout | null): void;

  /**
   * Bind device memory to buffer objects
   * @param device is the logical device that owns the buffers and memory.
   * @param bindInfoCount 'VkBindBufferMemoryInfo' structures describing buffers and memory to bind.
   * @param pBindInfos
   */
  export function vkBindBufferMemory2(device: VkDevice | null, bindInfoCount: number, pBindInfos: VkBindBufferMemoryInfo[] | null): VkResult;

  /**
   * Bind device memory to image objects
   * @param device is the logical device that owns the images and memory.
   * @param bindInfoCount
   * @param pBindInfos is an array of 'VkBindImageMemoryInfo' structures, describing images and memory to bind.
   */
  export function vkBindImageMemory2(device: VkDevice | null, bindInfoCount: number, pBindInfos: VkBindImageMemoryInfo[] | null): VkResult;

  /**
   * Modify device mask of a command buffer
   * @param commandBuffer is command buffer whose current device mask is modified.
   * @param deviceMask is the new value of the current device mask.
   */
  export function vkCmdSetDeviceMask(commandBuffer: VkCommandBuffer | null, deviceMask: number): void;

  /**
   * Query present capabilities from other physical devices
   * @param device is the logical device.
   * @param pDeviceGroupPresentCapabilities is a reference to a 'VkDeviceGroupPresentCapabilitiesKHR' structure in which the device's capabilities are returned.
   */
  export function vkGetDeviceGroupPresentCapabilitiesKHR(device: VkDevice | null, pDeviceGroupPresentCapabilities: VkDeviceGroupPresentCapabilitiesKHR | null): VkResult;

  /**
   * Query present capabilities for a surface
   * @param device is the logical device.
   * @param surface is the surface.
   * @param pModes is a reference to a 'VkDeviceGroupPresentModeFlagsKHR' in which the supported device group present modes for the surface are returned.
   */
  export function vkGetDeviceGroupSurfacePresentModesKHR(device: VkDevice | null, surface: VkSurfaceKHR | null, pModes: VkInout | null): VkResult;

  /**
   * Retrieve the index of the next available presentable image
   * @param device
   * @param pAcquireInfo is a reference to a 'VkAcquireNextImageInfoKHR' structure containing parameters of the acquire.
   * @param pImageIndex is a reference to a 'uint32_t' that is set to the index of the next image to use.
   */
  export function vkAcquireNextImage2KHR(device: VkDevice | null, pAcquireInfo: VkAcquireNextImageInfoKHR | null, pImageIndex: VkInout | null): VkResult;

  /**
   * Dispatch compute work items
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param baseGroupX is the start value for the X component of 'WorkgroupId'.
   * @param baseGroupY is the start value for the Y component of 'WorkgroupId'.
   * @param baseGroupZ is the start value for the Z component of 'WorkgroupId'.
   * @param groupCountX is the number of local workgroups to dispatch in the X dimension.
   * @param groupCountY is the number of local workgroups to dispatch in the Y dimension.
   * @param groupCountZ is the number of local workgroups to dispatch in the Z dimension.
   */
  export function vkCmdDispatchBase(commandBuffer: VkCommandBuffer | null, baseGroupX: number, baseGroupY: number, baseGroupZ: number, groupCountX: number, groupCountY: number, groupCountZ: number): void;

  /**
   * Query present rectangles for a surface on a physical device
   * @param physicalDevice is the physical device.
   * @param surface is the surface.
   * @param pRectCount is a reference to a number related to the number of rectangles available or queried, as described below.
   * @param pRects is either <i>null</i> or a reference to an array of 'VkRect2D' structures.
   */
  export function vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice: VkPhysicalDevice | null, surface: VkSurfaceKHR | null, pRectCount: VkInout | null, pRects: VkRect2D[] | null): VkResult;

  /**
   * Create a new descriptor update template
   * @param device is the logical device that creates the descriptor update template.
   * @param pCreateInfo is a reference to a 'VkDescriptorUpdateTemplateCreateInfo' structure specifying the set of descriptors to update with a single call to 'vkCmdPushDescriptorSetWithTemplateKHR' or
   * @param pAllocator
   * @param pDescriptorUpdateTemplate
   */
  export function vkCreateDescriptorUpdateTemplate(device: VkDevice | null, pCreateInfo: VkDescriptorUpdateTemplateCreateInfo | null, pAllocator: null, pDescriptorUpdateTemplate: VkDescriptorUpdateTemplate | null): VkResult;

  /**
   * Destroy a descriptor update template object
   * @param device is the logical device that has been used to create the descriptor update template
   * @param descriptorUpdateTemplate is the descriptor update template to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDescriptorUpdateTemplate(device: VkDevice | null, descriptorUpdateTemplate: VkDescriptorUpdateTemplate | null, pAllocator: null): void;

  /**
   * Update the contents of a descriptor set object using an update template
   * @param device is the logical device that updates the descriptor sets.
   * @param descriptorSet is the descriptor set to update
   * @param descriptorUpdateTemplate is a 'VkDescriptorUpdateTemplate' object specifying the update mapping between 'pData' and the descriptor set to update.
   * @param pData is a reference to memory containing one or more 'VkDescriptorImageInfo', 'VkDescriptorBufferInfo', or 'VkBufferView' structuresifdef::VK_KHR_acceleration_structure[or 'VkAccelerationStructureKHR']ifdef::VK_NV_ray_tracing[or 'VkAccelerationStructureNV']ifdef::VK_NV_ray_tracing,VK_KHR_acceleration_structure[handles] used to write the descriptors.
   */
  export function vkUpdateDescriptorSetWithTemplate(device: VkDevice | null, descriptorSet: VkDescriptorSet | null, descriptorUpdateTemplate: VkDescriptorUpdateTemplate | null, pData: ArrayBuffer | null): void;

  /**
   * Pushes descriptor updates into a command buffer using a descriptor update template
   * @param commandBuffer is the command buffer that the descriptors will be recorded in.
   * @param descriptorUpdateTemplate is a descriptor update template defining how to interpret the descriptor information in 'pData'.
   * @param layout is a 'VkPipelineLayout' object used to program the bindings. It 'must' be compatible with the layout used to create the 'descriptorUpdateTemplate' handle.
   * @param set is the set number of the descriptor set in the pipeline layout that will be updated. This 'must' be the same number used to create the 'descriptorUpdateTemplate' handle.
   * @param pData is a reference to memory containing descriptors for the templated update.
   */
  export function vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer: VkCommandBuffer | null, descriptorUpdateTemplate: VkDescriptorUpdateTemplate | null, layout: VkPipelineLayout | null, set: number, pData: ArrayBuffer | null): void;

  /**
   * function to set Hdr metadata
   * @param device is the logical device where the swapchain(s) were created.
   * @param swapchainCount 'VkHdrMetadataEXT' structures.
   * @param pSwapchains
   * @param pMetadata
   */
  export function vkSetHdrMetadataEXT(device: VkDevice | null, swapchainCount: number, pSwapchains: VkSwapchainKHR[] | null, pMetadata: VkHdrMetadataEXT[] | null): void;

  /**
   * Get a swapchain\
   * @param device
   * @param swapchain is the swapchain to query.
   */
  export function vkGetSwapchainStatusKHR(device: VkDevice | null, swapchain: VkSwapchainKHR | null): VkResult;

  /**
   * Obtain the RC duration of the PE\
   * @param device
   * @param swapchain is the swapchain to obtain the refresh duration for.
   * @param pDisplayTimingProperties is a reference to a 'VkRefreshCycleDurationGOOGLE' structure.
   */
  export function vkGetRefreshCycleDurationGOOGLE(device: VkDevice | null, swapchain: VkSwapchainKHR | null, pDisplayTimingProperties: VkRefreshCycleDurationGOOGLE | null): VkResult;

  /**
   * Obtain timing of a previously-presented image
   * @param device
   * @param swapchain is the swapchain to obtain presentation timing information duration for.
   * @param pPresentationTimingCount is a reference to a number related to the number of 'VkPastPresentationTimingGOOGLE' structures to query, as described below.
   * @param pPresentationTimings is either <i>null</i> or a reference to an array of 'VkPastPresentationTimingGOOGLE' structures.
   */
  export function vkGetPastPresentationTimingGOOGLE(device: VkDevice | null, swapchain: VkSwapchainKHR | null, pPresentationTimingCount: VkInout | null, pPresentationTimings: VkPastPresentationTimingGOOGLE[] | null): VkResult;

  /**
   * Set the viewport W scaling on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstViewport is the index of the first viewport whose parameters are updated by the command.
   * @param viewportCount is the number of viewports whose parameters are updated by the command.
   * @param pViewportWScalings is an array of 'VkViewportWScalingNV' structures specifying viewport parameters.
   */
  export function vkCmdSetViewportWScalingNV(commandBuffer: VkCommandBuffer | null, firstViewport: number, viewportCount: number, pViewportWScalings: VkViewportWScalingNV[] | null): void;

  /**
   * Set discard rectangles dynamically
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstDiscardRectangle is the index of the first discard rectangle whose state is updated by the command.
   * @param discardRectangleCount is the number of discard rectangles whose state are updated by the command.
   * @param pDiscardRectangles is an array of 'VkRect2D' structures specifying discard rectangles.
   */
  export function vkCmdSetDiscardRectangleEXT(commandBuffer: VkCommandBuffer | null, firstDiscardRectangle: number, discardRectangleCount: number, pDiscardRectangles: VkRect2D[] | null): void;

  /**
   * Set the dynamic sample locations state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pSampleLocationsInfo is the sample locations state to set.
   */
  export function vkCmdSetSampleLocationsEXT(commandBuffer: VkCommandBuffer | null, pSampleLocationsInfo: VkSampleLocationsInfoEXT | null): void;

  /**
   * Report sample count specific multisampling capabilities of a physical device
   * @param physicalDevice is the physical device from which to query the additional multisampling capabilities.
   * @param samples is the sample count to query the capabilities for.
   * @param pMultisampleProperties is a reference to a 'VkMultisamplePropertiesEXT' structure in which information about the additional multisampling capabilities specific to the sample count is returned.
   */
  export function vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice: VkPhysicalDevice | null, samples: VkSampleCountFlagBits, pMultisampleProperties: VkMultisamplePropertiesEXT | null): void;

  /**
   * Reports capabilities of a surface on a physical device
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param pSurfaceInfo is a reference to a 'VkPhysicalDeviceSurfaceInfo2KHR' structure describing the surface and other fixed parameters that would be consumed by 'vkCreateSwapchainKHR'.
   * @param pSurfaceCapabilities is a reference to a 'VkSurfaceCapabilities2KHR' structure in which the capabilities are returned.
   */
  export function vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice: VkPhysicalDevice | null, pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR | null, pSurfaceCapabilities: VkSurfaceCapabilities2KHR | null): VkResult;

  /**
   * Query color formats supported by surface
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param pSurfaceInfo is a reference to a 'VkPhysicalDeviceSurfaceInfo2KHR' structure describing the surface and other fixed parameters that would be consumed by 'vkCreateSwapchainKHR'.
   * @param pSurfaceFormatCount is a reference to a number related to the number of format tuples available or queried, as described below.
   * @param pSurfaceFormats is either <i>null</i> or a reference to an array of 'VkSurfaceFormat2KHR' structures.
   */
  export function vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice: VkPhysicalDevice | null, pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR | null, pSurfaceFormatCount: VkInout | null, pSurfaceFormats: VkSurfaceFormat2KHR[] | null): VkResult;

  /**
   * Query information about the available displays
   * @param physicalDevice is a physical device.
   * @param pPropertyCount is a reference to a number related to the number of display devices available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayProperties2KHR' structures.
   */
  export function vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice: VkPhysicalDevice | null, pPropertyCount: VkInout | null, pProperties: VkDisplayProperties2KHR[] | null): VkResult;

  /**
   * Query information about the available display planes.
   * @param physicalDevice is a physical device.
   * @param pPropertyCount is a reference to a number related to the number of display planes available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayPlaneProperties2KHR' structures.
   */
  export function vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice: VkPhysicalDevice | null, pPropertyCount: VkInout | null, pProperties: VkDisplayPlaneProperties2KHR[] | null): VkResult;

  /**
   * Query information about the available display modes.
   * @param physicalDevice is the physical device associated with 'display'.
   * @param display is the display to query.
   * @param pPropertyCount is a reference to a number related to the number of display modes available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkDisplayModeProperties2KHR' structures.
   */
  export function vkGetDisplayModeProperties2KHR(physicalDevice: VkPhysicalDevice | null, display: VkDisplayKHR | null, pPropertyCount: VkInout | null, pProperties: VkDisplayModeProperties2KHR[] | null): VkResult;

  /**
   * Query capabilities of a mode and plane combination
   * @param physicalDevice is the physical device associated with 'pDisplayPlaneInfo'.
   * @param pDisplayPlaneInfo is a reference to a 'VkDisplayPlaneInfo2KHR' structure describing the plane and mode.
   * @param pCapabilities is a reference to a 'VkDisplayPlaneCapabilities2KHR' structure in which the capabilities are returned.
   */
  export function vkGetDisplayPlaneCapabilities2KHR(physicalDevice: VkPhysicalDevice | null, pDisplayPlaneInfo: VkDisplayPlaneInfo2KHR | null, pCapabilities: VkDisplayPlaneCapabilities2KHR | null): VkResult;

  /**
   * Returns the memory requirements for specified Vulkan object
   * @param device is the logical device that owns the buffer.
   * @param pInfo is a reference to a 'VkBufferMemoryRequirementsInfo2' structure containing parameters required for the memory requirements query.
   * @param pMemoryRequirements is a reference to a 'VkMemoryRequirements2' structure in which the memory requirements of the buffer object are returned.
   */
  export function vkGetBufferMemoryRequirements2(device: VkDevice | null, pInfo: VkBufferMemoryRequirementsInfo2 | null, pMemoryRequirements: VkMemoryRequirements2 | null): void;

  /**
   * Returns the memory requirements for specified Vulkan object
   * @param device is the logical device that owns the image.
   * @param pInfo is a reference to a 'VkImageMemoryRequirementsInfo2' structure containing parameters required for the memory requirements query.
   * @param pMemoryRequirements is a reference to a 'VkMemoryRequirements2' structure in which the memory requirements of the image object are returned.
   */
  export function vkGetImageMemoryRequirements2(device: VkDevice | null, pInfo: VkImageMemoryRequirementsInfo2 | null, pMemoryRequirements: VkMemoryRequirements2 | null): void;

  /**
   * Query the memory requirements for a sparse image
   * @param device is the logical device that owns the image.
   * @param pInfo is a reference to a 'VkImageSparseMemoryRequirementsInfo2' structure containing parameters required for the memory requirements query.
   * @param pSparseMemoryRequirementCount is a reference to a number related to the number of sparse memory requirements available or queried, as described below.
   * @param pSparseMemoryRequirements is either <i>null</i> or a reference to an array of 'VkSparseImageMemoryRequirements2' structures.
   */
  export function vkGetImageSparseMemoryRequirements2(device: VkDevice | null, pInfo: VkImageSparseMemoryRequirementsInfo2 | null, pSparseMemoryRequirementCount: VkInout | null, pSparseMemoryRequirements: VkSparseImageMemoryRequirements2[] | null): void;

  /**
   * 
   * @param device
   * @param pCreateInfo
   * @param pAllocator
   * @param pYcbcrConversion
   */
  export function vkCreateSamplerYcbcrConversion(device: VkDevice | null, pCreateInfo: VkSamplerYcbcrConversionCreateInfo | null, pAllocator: null, pYcbcrConversion: VkSamplerYcbcrConversion | null): VkResult;

  /**
   * 
   * @param device
   * @param ycbcrConversion
   * @param pAllocator
   */
  export function vkDestroySamplerYcbcrConversion(device: VkDevice | null, ycbcrConversion: VkSamplerYcbcrConversion | null, pAllocator: null): void;

  /**
   * Get a queue handle from a device
   * @param device is the logical device that owns the queue.
   * @param pQueueInfo is a reference to a 'VkDeviceQueueInfo2' structure, describing the parameters used to create the device queue.
   * @param pQueue is a reference to a 'VkQueue' object that will be filled with the handle for the requested queue.
   */
  export function vkGetDeviceQueue2(device: VkDevice | null, pQueueInfo: VkDeviceQueueInfo2 | null, pQueue: VkQueue | null): void;

  /**
   * Creates a new validation cache
   * @param device is the logical device that creates the validation cache object.
   * @param pCreateInfo is a reference to a 'VkValidationCacheCreateInfoEXT' structure containing the initial parameters for the validation cache object.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pValidationCache is a reference to a 'VkValidationCacheEXT' handle in which the resulting validation cache object is returned.
   */
  export function vkCreateValidationCacheEXT(device: VkDevice | null, pCreateInfo: VkValidationCacheCreateInfoEXT | null, pAllocator: null, pValidationCache: VkValidationCacheEXT | null): VkResult;

  /**
   * Destroy a validation cache object
   * @param device is the logical device that destroys the validation cache object.
   * @param validationCache is the handle of the validation cache to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyValidationCacheEXT(device: VkDevice | null, validationCache: VkValidationCacheEXT | null, pAllocator: null): void;

  /**
   * Get the data store from a validation cache
   * @param device is the logical device that owns the validation cache.
   * @param validationCache is the validation cache to retrieve data from.
   * @param pDataSize is a reference to a value related to the amount of data in the validation cache, as described below.
   * @param pData is either <i>null</i> or a reference to a buffer.
   */
  export function vkGetValidationCacheDataEXT(device: VkDevice | null, validationCache: VkValidationCacheEXT | null, pDataSize: VkInoutAddress | null, pData: ArrayBuffer | null): VkResult;

  /**
   * Combine the data stores of validation caches
   * @param device is the logical device that owns the validation cache objects.
   * @param dstCache is the handle of the validation cache to merge results into.
   * @param srcCacheCount
   * @param pSrcCaches is an array of validation cache handles, which will be merged into 'dstCache'. The previous contents of 'dstCache' are included after the merge.
   */
  export function vkMergeValidationCachesEXT(device: VkDevice | null, dstCache: VkValidationCacheEXT | null, srcCacheCount: number, pSrcCaches: VkValidationCacheEXT[] | null): VkResult;

  /**
   * Query whether a descriptor set layout can be created
   * @param device is the logical device that would create the descriptor set layout.
   * @param pCreateInfo is a reference to a 'VkDescriptorSetLayoutCreateInfo' structure specifying the state of the descriptor set layout object.
   * @param pSupport is a reference to a 'VkDescriptorSetLayoutSupport' structure, in which information about support for the descriptor set layout object is returned.
   */
  export function vkGetDescriptorSetLayoutSupport(device: VkDevice | null, pCreateInfo: VkDescriptorSetLayoutCreateInfo | null, pSupport: VkDescriptorSetLayoutSupport | null): void;

  /**
   * Get information about a shader in a pipeline
   * @param device
   * @param pipeline is the target of the query.
   * @param shaderStage identifies the particular shader within the pipeline about which information is being queried.
   * @param infoType describes what kind of information is being queried.
   * @param pInfoSize is a reference to a value related to the amount of data the query returns, as described below.
   * @param pInfo is either <i>null</i> or a reference to a buffer.
   */
  export function vkGetShaderInfoAMD(device: VkDevice | null, pipeline: VkPipeline | null, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: VkInoutAddress | null, pInfo: ArrayBuffer | null): VkResult;

  /**
   * Set Local Dimming
   * @param device
   * @param swapChain handle to enable local dimming.
   * @param localDimmingEnable specifies whether local dimming is enabled for the swapchain.
   */
  export function vkSetLocalDimmingAMD(device: VkDevice | null, swapChain: VkSwapchainKHR | null, localDimmingEnable: boolean): void;

  /**
   * Query calibrateable time domains
   * @param physicalDevice is the physical device from which to query the set of calibrateable time domains.
   * @param pTimeDomainCount is a reference to a number related to the number of calibrateable time domains available or queried, as described below.
   * @param pTimeDomains is either <i>null</i> or a reference to an array of 'VkTimeDomainEXT' values, indicating the supported calibrateable time domains.
   */
  export function vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice: VkPhysicalDevice | null, pTimeDomainCount: VkInout | null, pTimeDomains: Int32Array | null): VkResult;

  /**
   * Query calibrated timestamps
   * @param device is the logical device used to perform the query.
   * @param timestampCount 64-bit unsigned integer values in which the requested calibrated timestamp values are returned.
   * @param pTimestampInfos
   * @param pTimestamps
   * @param pMaxDeviation is a reference to a 64-bit unsigned integer value in which the strictly positive maximum deviation, in nanoseconds, of the calibrated timestamp values is returned.
   */
  export function vkGetCalibratedTimestampsEXT(device: VkDevice | null, timestampCount: number, pTimestampInfos: VkCalibratedTimestampInfoEXT[] | null, pTimestamps: BigUint64Array | null, pMaxDeviation: VkInoutAddress | null): VkResult;

  /**
   * Give a user-friendly name to an object
   * @param device is the device that created the object.
   * @param pNameInfo is a reference to a 'VkDebugUtilsObjectNameInfoEXT' structure specifying parameters of the name to set on the object.
   */
  export function vkSetDebugUtilsObjectNameEXT(device: VkDevice | null, pNameInfo: VkDebugUtilsObjectNameInfoEXT | null): VkResult;

  /**
   * Attach arbitrary data to an object
   * @param device is the device that created the object.
   * @param pTagInfo is a reference to a 'VkDebugUtilsObjectTagInfoEXT' structure specifying parameters of the tag to attach to the object.
   */
  export function vkSetDebugUtilsObjectTagEXT(device: VkDevice | null, pTagInfo: VkDebugUtilsObjectTagInfoEXT | null): VkResult;

  /**
   * Open a queue debug label region
   * @param queue is the queue in which to start a debug label region.
   * @param pLabelInfo is a reference to a 'VkDebugUtilsLabelEXT' structure specifying parameters of the label region to open.
   */
  export function vkQueueBeginDebugUtilsLabelEXT(queue: VkQueue | null, pLabelInfo: VkDebugUtilsLabelEXT | null): void;

  /**
   * Close a queue debug label region
   * @param queue is the queue in which a debug label region should be closed.
   */
  export function vkQueueEndDebugUtilsLabelEXT(queue: VkQueue | null): void;

  /**
   * Insert a label into a queue
   * @param queue is the queue into which a debug label will be inserted.
   * @param pLabelInfo is a reference to a 'VkDebugUtilsLabelEXT' structure specifying parameters of the label to insert.
   */
  export function vkQueueInsertDebugUtilsLabelEXT(queue: VkQueue | null, pLabelInfo: VkDebugUtilsLabelEXT | null): void;

  /**
   * Open a command buffer debug label region
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param pLabelInfo is a reference to a 'VkDebugUtilsLabelEXT' structure specifying parameters of the label region to open.
   */
  export function vkCmdBeginDebugUtilsLabelEXT(commandBuffer: VkCommandBuffer | null, pLabelInfo: VkDebugUtilsLabelEXT | null): void;

  /**
   * Close a command buffer label region
   * @param commandBuffer is the command buffer into which the command is recorded.
   */
  export function vkCmdEndDebugUtilsLabelEXT(commandBuffer: VkCommandBuffer | null): void;

  /**
   * Insert a label into a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param pLabelInfo
   */
  export function vkCmdInsertDebugUtilsLabelEXT(commandBuffer: VkCommandBuffer | null, pLabelInfo: VkDebugUtilsLabelEXT | null): void;

  /**
   * Create a debug messenger object
   * @param instance is the instance the messenger will be used with.
   * @param pCreateInfo is a reference to a 'VkDebugUtilsMessengerCreateInfoEXT' structure containing the callback reference, as well as defining conditions under which this messenger will trigger the callback.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pMessenger is a reference to a 'VkDebugUtilsMessengerEXT' handle in which the created object is returned.
   */
  export function vkCreateDebugUtilsMessengerEXT(instance: VkInstance | null, pCreateInfo: VkDebugUtilsMessengerCreateInfoEXT | null, pAllocator: null, pMessenger: VkDebugUtilsMessengerEXT | null): VkResult;

  /**
   * Destroy a debug messenger object
   * @param instance is the instance where the callback was created.
   * @param messenger is the 'VkDebugUtilsMessengerEXT' object to destroy. 'messenger' is an externally synchronized object and 'must' not be used on more than one thread at a time. This means that 'vkDestroyDebugUtilsMessengerEXT' 'must' not be called when a callback is active.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyDebugUtilsMessengerEXT(instance: VkInstance | null, messenger: VkDebugUtilsMessengerEXT | null, pAllocator: null): void;

  /**
   * Inject a message into a debug stream
   * @param instance is the debug stream's 'VkInstance'.
   * @param messageSeverity is the 'VkDebugUtilsMessageSeverityFlagBitsEXT' severity of this event/message.
   * @param messageTypes is a bitmask of 'VkDebugUtilsMessageTypeFlagBitsEXT' specifying which type of event(s) to identify with this message.
   * @param pCallbackData contains all the callback related data in the 'VkDebugUtilsMessengerCallbackDataEXT' structure.
   */
  export function vkSubmitDebugUtilsMessageEXT(instance: VkInstance | null, messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagBitsEXT, pCallbackData: VkDebugUtilsMessengerCallbackDataEXT | null): void;

  /**
   * Get properties of external memory host reference
   * @param device is the logical device that will be importing 'pHostPointer'.
   * @param handleType
   * @param pHostPointer is the host reference to import from.
   * @param pMemoryHostPointerProperties is a reference to a 'VkMemoryHostPointerPropertiesEXT' structure in which the host reference properties are returned.
   */
  export function vkGetMemoryHostPointerPropertiesEXT(device: VkDevice | null, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: ArrayBuffer | null, pMemoryHostPointerProperties: VkMemoryHostPointerPropertiesEXT | null): VkResult;

  /**
   * Execute a pipelined write of a marker value into a buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pipelineStage is one of the 'VkPipelineStageFlagBits' values, specifying the pipeline stage whose completion triggers the marker write.
   * @param dstBuffer is the buffer where the marker will be written to.
   * @param dstOffset is the byte offset into the buffer where the marker will be written to.
   * @param marker is the 32-bit value of the marker.
   */
  export function vkCmdWriteBufferMarkerAMD(commandBuffer: VkCommandBuffer | null, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer | null, dstOffset: bigint | number, marker: number): void;

  /**
   * Create a new render pass object
   * @param device is the logical device that creates the render pass.
   * @param pCreateInfo is a reference to a 'VkRenderPassCreateInfo2' structure describing the parameters of the render pass.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pRenderPass is a reference to a 'VkRenderPass' handle in which the resulting render pass object is returned.
   */
  export function vkCreateRenderPass2(device: VkDevice | null, pCreateInfo: VkRenderPassCreateInfo2 | null, pAllocator: null, pRenderPass: VkRenderPass | null): VkResult;

  /**
   * Begin a new render pass
   * @param commandBuffer is the command buffer in which to record the command.
   * @param pRenderPassBegin is a reference to a 'VkRenderPassBeginInfo' structure specifying the render pass to begin an instance of, and the framebuffer the instance uses.
   * @param pSubpassBeginInfo is a reference to a 'VkSubpassBeginInfo' structure containing information about the subpass which is about to begin rendering.
   */
  export function vkCmdBeginRenderPass2(commandBuffer: VkCommandBuffer | null, pRenderPassBegin: VkRenderPassBeginInfo | null, pSubpassBeginInfo: VkSubpassBeginInfo | null): void;

  /**
   * Transition to the next subpass of a render pass
   * @param commandBuffer is the command buffer in which to record the command.
   * @param pSubpassBeginInfo is a reference to a 'VkSubpassBeginInfo' structure containing information about the subpass which is about to begin rendering.
   * @param pSubpassEndInfo is a reference to a 'VkSubpassEndInfo' structure containing information about how the previous subpass will be ended.
   */
  export function vkCmdNextSubpass2(commandBuffer: VkCommandBuffer | null, pSubpassBeginInfo: VkSubpassBeginInfo | null, pSubpassEndInfo: VkSubpassEndInfo | null): void;

  /**
   * End the current render pass
   * @param commandBuffer is the command buffer in which to end the current render pass instance.
   * @param pSubpassEndInfo is a reference to a 'VkSubpassEndInfo' structure containing information about how the previous subpass will be ended.
   */
  export function vkCmdEndRenderPass2(commandBuffer: VkCommandBuffer | null, pSubpassEndInfo: VkSubpassEndInfo | null): void;

  /**
   * Query the current state of a timeline semaphore
   * @param device is the logical device that owns the semaphore.
   * @param semaphore is the handle of the semaphore to query.
   * @param pValue is a reference to a 64-bit integer value in which the current counter value of the semaphore is returned.
   */
  export function vkGetSemaphoreCounterValue(device: VkDevice | null, semaphore: VkSemaphore | null, pValue: VkInoutAddress | null): VkResult;

  /**
   * Wait for timeline semaphores on the host
   * @param device is the logical device that owns the semaphore.
   * @param pWaitInfo is a reference to a 'VkSemaphoreWaitInfo' structure containing information about the wait condition.
   * @param timeout is the timeout period in units of nanoseconds. 'timeout' is adjusted to the closest value allowed by the implementation-dependent timeout accuracy, which 'may' be substantially longer than one nanosecond, and 'may' be longer than the requested period.
   */
  export function vkWaitSemaphores(device: VkDevice | null, pWaitInfo: VkSemaphoreWaitInfo | null, timeout: bigint | number): VkResult;

  /**
   * Signal a timeline semaphore on the host
   * @param device is the logical device that owns the semaphore.
   * @param pSignalInfo is a reference to a 'VkSemaphoreSignalInfo' structure containing information about the signal operation.
   */
  export function vkSignalSemaphore(device: VkDevice | null, pSignalInfo: VkSemaphoreSignalInfo | null): VkResult;

  /**
   * Perform an indirect draw with the draw count sourced from a buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param countBuffer where the draw count begins.
   * @param countBufferOffset
   * @param maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in 'countBuffer' and 'maxDrawCount'.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawIndirectCount(commandBuffer: VkCommandBuffer | null, buffer: VkBuffer | null, offset: bigint | number, countBuffer: VkBuffer | null, countBufferOffset: bigint | number, maxDrawCount: number, stride: number): void;

  /**
   * Perform an indexed indirect draw with the draw count sourced from a buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param countBuffer where the draw count begins.
   * @param countBufferOffset
   * @param maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in 'countBuffer' and 'maxDrawCount'.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawIndexedIndirectCount(commandBuffer: VkCommandBuffer | null, buffer: VkBuffer | null, offset: bigint | number, countBuffer: VkBuffer | null, countBufferOffset: bigint | number, maxDrawCount: number, stride: number): void;

  /**
   * insert diagnostic checkpoint in command stream
   * @param commandBuffer is the command buffer that will receive the marker
   * @param pCheckpointMarker is an opaque application-provided value that will be associated with the checkpoint.
   */
  export function vkCmdSetCheckpointNV(commandBuffer: VkCommandBuffer | null, pCheckpointMarker: ArrayBuffer | null): void;

  /**
   * retrieve diagnostic checkpoint data
   * @param queue is the 'VkQueue' object the caller would like to retrieve checkpoint data for
   * @param pCheckpointDataCount is a reference to a number related to the number of checkpoint markers available or queried, as described below.
   * @param pCheckpointData is either <i>null</i> or a reference to an array of 'VkCheckpointDataNV' structures.
   */
  export function vkGetQueueCheckpointDataNV(queue: VkQueue | null, pCheckpointDataCount: VkInout | null, pCheckpointData: VkCheckpointDataNV[] | null): void;

  /**
   * Bind transform feedback buffers to a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param firstBinding is the index of the first transform feedback binding whose state is updated by the command.
   * @param bindingCount is the number of transform feedback bindings whose state is updated by the command.
   * @param pBuffers is an array of buffer handles.
   * @param pOffsets is an array of buffer offsets.
   * @param pSizes is an optional array of buffer sizes, specifying the maximum number of bytes to capture to the corresponding transform feedback buffer. If 'pSizes' is <i>null</i>, or the value of the 'pSizes' array element is 'VK_WHOLE_SIZE', then the maximum bytes captured will be the size of the corresponding buffer minus the buffer offset.
   */
  export function vkCmdBindTransformFeedbackBuffersEXT(commandBuffer: VkCommandBuffer | null, firstBinding: number, bindingCount: number, pBuffers: VkBuffer[] | null, pOffsets: BigUint64Array | null, pSizes: BigUint64Array | null): void;

  /**
   * Make transform feedback active in the command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param firstCounterBuffer is the index of the first transform feedback buffer corresponding to 'pCounterBuffers'[0] and 'pCounterBufferOffsets'[0].
   * @param counterBufferCount
   * @param pCounterBuffers is an optional array of buffer handles to the counter buffers which contain a 4 byte integer value representing the byte offset from the start of the corresponding transform feedback buffer from where to start capturing vertex data. If the byte offset stored to the counter buffer location was done using 'vkCmdEndTransformFeedbackEXT' it can be used to resume transform feedback from the previous location. If 'pCounterBuffers' is <i>null</i>, then transform feedback will start capturing vertex data to byte offset zero in all bound transform feedback buffers. For each element of 'pCounterBuffers' that is 'VK_NULL_HANDLE', transform feedback will start capturing vertex data to byte zero in the corresponding bound transform feedback buffer.
   * @param pCounterBufferOffsets is an optional array of offsets within each of the 'pCounterBuffers' where the counter values were previously written. The location in each counter buffer at these offsets 'must' be large enough to contain 4 bytes of data. This data is the number of bytes captured by the previous transform feedback to this buffer. If 'pCounterBufferOffsets' is <i>null</i>, then it is assumed the offsets are zero.
   */
  export function vkCmdBeginTransformFeedbackEXT(commandBuffer: VkCommandBuffer | null, firstCounterBuffer: number, counterBufferCount: number, pCounterBuffers: VkBuffer[] | null, pCounterBufferOffsets: BigUint64Array | null): void;

  /**
   * Make transform feedback inactive in the command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param firstCounterBuffer is the index of the first transform feedback buffer corresponding to 'pCounterBuffers'[0] and 'pCounterBufferOffsets'[0].
   * @param counterBufferCount
   * @param pCounterBuffers is an optional array of buffer handles to the counter buffers used to record the current byte positions of each transform feedback buffer where the next vertex output data would be captured. This 'can' be used by a subsequent 'vkCmdBeginTransformFeedbackEXT' call to resume transform feedback capture from this position. It can also be used by 'vkCmdDrawIndirectByteCountEXT' to determine the vertex count of the draw call.
   * @param pCounterBufferOffsets is an optional array of offsets within each of the 'pCounterBuffers' where the counter values can be written. The location in each counter buffer at these offsets 'must' be large enough to contain 4 bytes of data. The data stored at this location is the byte offset from the start of the transform feedback buffer binding where the next vertex data would be written. If 'pCounterBufferOffsets' is <i>null</i>, then it is assumed the offsets are zero.
   */
  export function vkCmdEndTransformFeedbackEXT(commandBuffer: VkCommandBuffer | null, firstCounterBuffer: number, counterBufferCount: number, pCounterBuffers: VkBuffer[] | null, pCounterBufferOffsets: BigUint64Array | null): void;

  /**
   * Begin an indexed query
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the query pool that will manage the results of the query.
   * @param query is the query index within the query pool that will contain the results.
   * @param flags is a bitmask of 'VkQueryControlFlagBits' specifying constraints on the types of queries that 'can' be performed.
   * @param index is the query type specific index. When the query type is 'VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT' the index represents the vertex stream.
   */
  export function vkCmdBeginQueryIndexedEXT(commandBuffer: VkCommandBuffer | null, queryPool: VkQueryPool | null, query: number, flags: VkQueryControlFlagBits, index: number): void;

  /**
   * Ends a query
   * @param commandBuffer is the command buffer into which this command will be recorded.
   * @param queryPool is the query pool that is managing the results of the query.
   * @param query is the query index within the query pool where the result is stored.
   * @param index is the query type specific index.
   */
  export function vkCmdEndQueryIndexedEXT(commandBuffer: VkCommandBuffer | null, queryPool: VkQueryPool | null, query: number, index: number): void;

  /**
   * Draw primitives where the vertex count is derived from the counter byte value in the counter buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param instanceCount is the number of instances to draw.
   * @param firstInstance is the instance ID of the first instance to draw.
   * @param counterBuffer is the buffer handle from where the byte count is read.
   * @param counterBufferOffset is the offset into the buffer used to read the byte count, which is used to calculate the vertex count for this draw call.
   * @param counterOffset is subtracted from the byte count read from the 'counterBuffer' at the 'counterBufferOffset'
   * @param vertexStride is the stride in bytes between each element of the vertex data that is used to calculate the vertex count from the counter value. This value is typically the same value that was used in the graphics pipeline state when the transform feedback was captured as the 'XfbStride'.
   */
  export function vkCmdDrawIndirectByteCountEXT(commandBuffer: VkCommandBuffer | null, instanceCount: number, firstInstance: number, counterBuffer: VkBuffer | null, counterBufferOffset: bigint | number, counterOffset: number, vertexStride: number): void;

  /**
   * Set the dynamic exclusive scissor rectangles on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstExclusiveScissor is the index of the first exclusive scissor rectangle whose state is updated by the command.
   * @param exclusiveScissorCount is the number of exclusive scissor rectangles updated by the command.
   * @param pExclusiveScissors is an array of 'VkRect2D' structures defining exclusive scissor rectangles.
   */
  export function vkCmdSetExclusiveScissorNV(commandBuffer: VkCommandBuffer | null, firstExclusiveScissor: number, exclusiveScissorCount: number, pExclusiveScissors: VkRect2D[] | null): void;

  /**
   * Bind a shading rate image on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param imageView is an image view handle specifying the shading rate image. 'imageView' 'may' be set to 'VK_NULL_HANDLE', which is equivalent to specifying a view of an image filled with zero values.
   * @param imageLayout is the layout that the image subresources accessible from 'imageView' will be in when the shading rate image is accessed.
   */
  export function vkCmdBindShadingRateImageNV(commandBuffer: VkCommandBuffer | null, imageView: VkImageView | null, imageLayout: VkImageLayout): void;

  /**
   * Set shading rate image palettes on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param firstViewport is the index of the first viewport whose shading rate palette is updated by the command.
   * @param viewportCount is the number of viewports whose shading rate palettes are updated by the command.
   * @param pShadingRatePalettes is an array of 'VkShadingRatePaletteNV' structures defining the palette for each viewport.
   */
  export function vkCmdSetViewportShadingRatePaletteNV(commandBuffer: VkCommandBuffer | null, firstViewport: number, viewportCount: number, pShadingRatePalettes: VkShadingRatePaletteNV[] | null): void;

  /**
   * Set sample order for coarse fragments on a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param sampleOrderType specifies the mechanism used to order coverage samples in fragments larger than one pixel.
   * @param customSampleOrderCount specifies the number of custom sample orderings to use when ordering coverage samples.
   * @param pCustomSampleOrders is an array of 'VkCoarseSampleOrderCustomNV' structures, each of which specifies the coverage sample order for a single combination of fragment area and coverage sample count.
   */
  export function vkCmdSetCoarseSampleOrderNV(commandBuffer: VkCommandBuffer | null, sampleOrderType: VkCoarseSampleOrderTypeNV, customSampleOrderCount: number, pCustomSampleOrders: VkCoarseSampleOrderCustomNV[] | null): void;

  /**
   * Draw mesh task work items
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param taskCount is the number of local workgroups to dispatch in the X dimension. Y and Z dimension are implicitly set to one.
   * @param firstTask is the X component of the first workgroup ID.
   */
  export function vkCmdDrawMeshTasksNV(commandBuffer: VkCommandBuffer | null, taskCount: number, firstTask: number): void;

  /**
   * Issue an indirect mesh tasks draw into a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param drawCount is the number of draws to execute, and 'can' be zero.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawMeshTasksIndirectNV(commandBuffer: VkCommandBuffer | null, buffer: VkBuffer | null, offset: bigint | number, drawCount: number, stride: number): void;

  /**
   * Perform an indirect mesh tasks draw with the draw count sourced from a buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param buffer where parameters begin.
   * @param offset
   * @param countBuffer where the draw count begins.
   * @param countBufferOffset
   * @param maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in 'countBuffer' and 'maxDrawCount'.
   * @param stride is the byte stride between successive sets of draw parameters.
   */
  export function vkCmdDrawMeshTasksIndirectCountNV(commandBuffer: VkCommandBuffer | null, buffer: VkBuffer | null, offset: bigint | number, countBuffer: VkBuffer | null, countBufferOffset: bigint | number, maxDrawCount: number, stride: number): void;

  /**
   * Deferred compilation of shaders
   * @param device is the logical device containing the ray tracing pipeline.
   * @param pipeline is the ray tracing pipeline object containing the shaders.
   * @param shader is the index of the shader to compile.
   */
  export function vkCompileDeferredNV(device: VkDevice | null, pipeline: VkPipeline | null, shader: number): VkResult;

  /**
   * Create a new acceleration structure object
   * @param device is the logical device that creates the buffer object.
   * @param pCreateInfo is a reference to a 'VkAccelerationStructureCreateInfoNV' structure containing parameters affecting creation of the acceleration structure.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pAccelerationStructure is a reference to a 'VkAccelerationStructureNV' handle in which the resulting acceleration structure object is returned.
   */
  export function vkCreateAccelerationStructureNV(device: VkDevice | null, pCreateInfo: VkAccelerationStructureCreateInfoNV | null, pAllocator: null, pAccelerationStructure: VkAccelerationStructureNV | null): VkResult;

  /**
   * Destroy an acceleration structure object
   * @param device is the logical device that destroys the buffer.
   * @param accelerationStructure is the acceleration structure to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyAccelerationStructureKHR(device: VkDevice | null, accelerationStructure: VkAccelerationStructureKHR | null, pAllocator: null): void;

  /**
   * Destroy an acceleration structure object
   * @param device is the logical device that destroys the buffer.
   * @param accelerationStructure is the acceleration structure to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyAccelerationStructureNV(device: VkDevice | null, accelerationStructure: VkAccelerationStructureNV | null, pAllocator: null): void;

  /**
   * Get acceleration structure memory requirements
   * @param device is the logical device on which the acceleration structure was created.
   * @param pInfo specifies the acceleration structure to get memory requirements for.
   * @param pMemoryRequirements returns the requested acceleration structure memory requirements.
   */
  export function vkGetAccelerationStructureMemoryRequirementsNV(device: VkDevice | null, pInfo: VkAccelerationStructureMemoryRequirementsInfoNV | null, pMemoryRequirements: VkMemoryRequirements2KHR | null): void;

  /**
   * Bind acceleration structure memory
   * @param device is the logical device that owns the acceleration structures and memory.
   * @param bindInfoCount
   * @param pBindInfos is an array of 'VkBindAccelerationStructureMemoryInfoNV' structures describing acceleration structures and memory to bind.
   */
  export function vkBindAccelerationStructureMemoryNV(device: VkDevice | null, bindInfoCount: number, pBindInfos: VkBindAccelerationStructureMemoryInfoNV[] | null): VkResult;

  /**
   * Copy an acceleration structure
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param dst is the target acceleration structure for the copy.
   * @param src is the source acceleration structure for the copy.
   * @param mode is a 'VkCopyAccelerationStructureModeKHR' value specifying additional operations to perform during the copy.
   */
  export function vkCmdCopyAccelerationStructureNV(commandBuffer: VkCommandBuffer | null, dst: VkAccelerationStructureNV | null, src: VkAccelerationStructureNV | null, mode: VkCopyAccelerationStructureModeKHR): void;

  /**
   * Copy an acceleration structure
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pInfo is a reference to a 'VkCopyAccelerationStructureInfoKHR' structure defining the copy operation.
   */
  export function vkCmdCopyAccelerationStructureKHR(commandBuffer: VkCommandBuffer | null, pInfo: VkCopyAccelerationStructureInfoKHR | null): void;

  /**
   * Copy an acceleration structure on the host
   * @param device is the device which owns the acceleration structures.
   * @param deferredOperation is an optional 'VkDeferredOperationKHR' to <<deferred-host-operations-requesting, request deferral>> for this command.
   * @param pInfo is a reference to a 'VkCopyAccelerationStructureInfoKHR' structure defining the copy operation.
   */
  export function vkCopyAccelerationStructureKHR(device: VkDevice | null, deferredOperation: VkDeferredOperationKHR | null, pInfo: VkCopyAccelerationStructureInfoKHR | null): VkResult;

  /**
   * Copy an acceleration structure to device memory
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pInfo is an a reference to a 'VkCopyAccelerationStructureToMemoryInfoKHR' structure defining the copy operation.
   */
  export function vkCmdCopyAccelerationStructureToMemoryKHR(commandBuffer: VkCommandBuffer | null, pInfo: VkCopyAccelerationStructureToMemoryInfoKHR | null): void;

  /**
   * Serialize an acceleration structure on the host
   * @param device
   * @param deferredOperation is an optional 'VkDeferredOperationKHR' to <<deferred-host-operations-requesting, request deferral>> for this command.
   * @param pInfo is a reference to a 'VkCopyAccelerationStructureToMemoryInfoKHR' structure defining the copy operation.
   */
  export function vkCopyAccelerationStructureToMemoryKHR(device: VkDevice | null, deferredOperation: VkDeferredOperationKHR | null, pInfo: VkCopyAccelerationStructureToMemoryInfoKHR | null): VkResult;

  /**
   * Copy device memory to an acceleration structure
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pInfo is a reference to a 'VkCopyMemoryToAccelerationStructureInfoKHR' structure defining the copy operation.
   */
  export function vkCmdCopyMemoryToAccelerationStructureKHR(commandBuffer: VkCommandBuffer | null, pInfo: VkCopyMemoryToAccelerationStructureInfoKHR | null): void;

  /**
   * Deserialize an acceleration structure on the host
   * @param device
   * @param deferredOperation is an optional 'VkDeferredOperationKHR' to <<deferred-host-operations-requesting, request deferral>> for this command.
   * @param pInfo is a reference to a 'VkCopyMemoryToAccelerationStructureInfoKHR' structure defining the copy operation.
   */
  export function vkCopyMemoryToAccelerationStructureKHR(device: VkDevice | null, deferredOperation: VkDeferredOperationKHR | null, pInfo: VkCopyMemoryToAccelerationStructureInfoKHR | null): VkResult;

  /**
   * Write acceleration structure result parameters to query results.
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param accelerationStructureCount is the count of acceleration structures for which to query the property.
   * @param pAccelerationStructures is an array of existing previously built acceleration structures.
   * @param queryType is a 'VkQueryType' value specifying the type of queries managed by the pool.
   * @param queryPool is the query pool that will manage the results of the query.
   * @param firstQuery is the first query index within the query pool that will contain the 'accelerationStructureCount' number of results.
   */
  export function vkCmdWriteAccelerationStructuresPropertiesKHR(commandBuffer: VkCommandBuffer | null, accelerationStructureCount: number, pAccelerationStructures: VkAccelerationStructureKHR[] | null, queryType: VkQueryType, queryPool: VkQueryPool | null, firstQuery: number): void;

  /**
   * Write acceleration structure result parameters to query results.
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param accelerationStructureCount is the count of acceleration structures for which to query the property.
   * @param pAccelerationStructures is an array of existing previously built acceleration structures.
   * @param queryType is a 'VkQueryType' value specifying the type of queries managed by the pool.
   * @param queryPool is the query pool that will manage the results of the query.
   * @param firstQuery is the first query index within the query pool that will contain the 'accelerationStructureCount' number of results.
   */
  export function vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer: VkCommandBuffer | null, accelerationStructureCount: number, pAccelerationStructures: VkAccelerationStructureNV[] | null, queryType: VkQueryType, queryPool: VkQueryPool | null, firstQuery: number): void;

  /**
   * Build an acceleration structure
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pInfo contains the shared information for the acceleration structure's structure.
   * @param instanceData is the buffer containing an array of 'VkAccelerationStructureInstanceKHR' structures defining acceleration structures. This parameter 'must' be <i>null</i> for bottom level acceleration structures.
   * @param instanceOffset is the offset in bytes (relative to the start of 'instanceData') at which the instance data is located.
   * @param update
   * @param dst is a reference to the target acceleration structure for the build.
   * @param src is a reference to an existing acceleration structure that is to be used to update the 'dst' acceleration structure.
   * @param scratch is the 'VkBuffer' that will be used as scratch memory for the build.
   * @param scratchOffset is the offset in bytes relative to the start of 'scratch' that will be used as a scratch memory.
   */
  export function vkCmdBuildAccelerationStructureNV(commandBuffer: VkCommandBuffer | null, pInfo: VkAccelerationStructureInfoNV | null, instanceData: VkBuffer | null, instanceOffset: bigint | number, update: boolean, dst: VkAccelerationStructureNV | null, src: VkAccelerationStructureNV | null, scratch: VkBuffer | null, scratchOffset: bigint | number): void;

  /**
   * Query acceleration structure meta-data on the host
   * @param device is the device which owns the acceleration structures in 'pAccelerationStructures'.
   * @param accelerationStructureCount is the count of acceleration structures for which to query the property.
   * @param pAccelerationStructures reference to an array of existing previously built acceleration structures.
   * @param queryType is a 'VkQueryType' value specifying the property to be queried.
   * @param dataSize is the size in bytes of the buffer pointed to by 'pData'.
   * @param pData is a reference to a user-allocated buffer where the results will be written.
   * @param stride is the stride in bytes between results for individual queries within 'pData'.
   */
  export function vkWriteAccelerationStructuresPropertiesKHR(device: VkDevice | null, accelerationStructureCount: number, pAccelerationStructures: VkAccelerationStructureKHR[] | null, queryType: VkQueryType, dataSize: bigint | number, pData: ArrayBuffer | null, stride: bigint | number): VkResult;

  /**
   * Initialize a ray tracing dispatch
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pRaygenShaderBindingTable is a 'VkStridedDeviceAddressRegionKHR' that holds the shader binding table data for the ray generation shader stage.
   * @param pMissShaderBindingTable is a 'VkStridedDeviceAddressRegionKHR' that holds the shader binding table data for the miss shader stage.
   * @param pHitShaderBindingTable is a 'VkStridedDeviceAddressRegionKHR' that holds the shader binding table data for the hit shader stage.
   * @param pCallableShaderBindingTable is a 'VkStridedDeviceAddressRegionKHR' that holds the shader binding table data for the callable shader stage.
   * @param width is the width of the ray trace query dimensions.
   * @param height is height of the ray trace query dimensions.
   * @param depth is depth of the ray trace query dimensions.
   */
  export function vkCmdTraceRaysKHR(commandBuffer: VkCommandBuffer | null, pRaygenShaderBindingTable: VkStridedDeviceAddressRegionKHR | null, pMissShaderBindingTable: VkStridedDeviceAddressRegionKHR | null, pHitShaderBindingTable: VkStridedDeviceAddressRegionKHR | null, pCallableShaderBindingTable: VkStridedDeviceAddressRegionKHR | null, width: number, height: number, depth: number): void;

  /**
   * Initialize a ray tracing dispatch
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param raygenShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the ray generation shader stage.
   * @param raygenShaderBindingOffset is the offset in bytes (relative to 'raygenShaderBindingTableBuffer') of the ray generation shader being used for the trace.
   * @param missShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the miss shader stage.
   * @param missShaderBindingOffset is the offset in bytes (relative to 'missShaderBindingTableBuffer') of the miss shader being used for the trace.
   * @param missShaderBindingStride is the size in bytes of each shader binding table record in 'missShaderBindingTableBuffer'.
   * @param hitShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the hit shader stages.
   * @param hitShaderBindingOffset is the offset in bytes (relative to 'hitShaderBindingTableBuffer') of the hit shader group being used for the trace.
   * @param hitShaderBindingStride is the size in bytes of each shader binding table record in 'hitShaderBindingTableBuffer'.
   * @param callableShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the callable shader stage.
   * @param callableShaderBindingOffset is the offset in bytes (relative to 'callableShaderBindingTableBuffer') of the callable shader being used for the trace.
   * @param callableShaderBindingStride is the size in bytes of each shader binding table record in 'callableShaderBindingTableBuffer'.
   * @param width is the width of the ray trace query dimensions.
   * @param height is height of the ray trace query dimensions.
   * @param depth is depth of the ray trace query dimensions.
   */
  export function vkCmdTraceRaysNV(commandBuffer: VkCommandBuffer | null, raygenShaderBindingTableBuffer: VkBuffer | null, raygenShaderBindingOffset: bigint | number, missShaderBindingTableBuffer: VkBuffer | null, missShaderBindingOffset: bigint | number, missShaderBindingStride: bigint | number, hitShaderBindingTableBuffer: VkBuffer | null, hitShaderBindingOffset: bigint | number, hitShaderBindingStride: bigint | number, callableShaderBindingTableBuffer: VkBuffer | null, callableShaderBindingOffset: bigint | number, callableShaderBindingStride: bigint | number, width: number, height: number, depth: number): void;

  /**
   * Query ray tracing pipeline shader group handles
   * @param device is the logical device containing the ray tracing pipeline.
   * @param pipeline is the ray tracing pipeline object containing the shaders.
   * @param firstGroup is the index of the first group to retrieve a handle for from the'VkRayTracingPipelineCreateInfoKHR'::'pGroups'
   * @param groupCount
   * @param dataSize
   * @param pData
   */
  export function vkGetRayTracingShaderGroupHandlesKHR(device: VkDevice | null, pipeline: VkPipeline | null, firstGroup: number, groupCount: number, dataSize: bigint | number, pData: ArrayBuffer | null): VkResult;

  /**
   * Query ray tracing capture replay pipeline shader group handles
   * @param device is the logical device containing the ray tracing pipeline.
   * @param pipeline is the ray tracing pipeline object containing the shaders.
   * @param firstGroup is the index of the first group to retrieve a handle for from the 'VkRayTracingPipelineCreateInfoKHR'::'pGroups' array.
   * @param groupCount is the number of shader handles to retrieve.
   * @param dataSize is the size in bytes of the buffer pointed to by 'pData'.
   * @param pData is a reference to a user-allocated buffer where the results will be written.
   */
  export function vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(device: VkDevice | null, pipeline: VkPipeline | null, firstGroup: number, groupCount: number, dataSize: bigint | number, pData: ArrayBuffer | null): VkResult;

  /**
   * Get opaque acceleration structure handle
   * @param device is the logical device that owns the acceleration structures.
   * @param accelerationStructure is the acceleration structure.
   * @param dataSize is the size in bytes of the buffer pointed to by 'pData'.
   * @param pData is a reference to a user-allocated buffer where the results will be written.
   */
  export function vkGetAccelerationStructureHandleNV(device: VkDevice | null, accelerationStructure: VkAccelerationStructureNV | null, dataSize: bigint | number, pData: ArrayBuffer | null): VkResult;

  /**
   * Creates a new ray tracing pipeline object
   * @param device is the logical device that creates the ray tracing pipelines.
   * @param pipelineCache is either 'VK_NULL_HANDLE', indicating that pipeline caching is disabled, or the handle of a valid <<pipelines-cache,pipeline cache>> object, in which case use of that cache is enabled for the duration of the command.
   * @param createInfoCount
   * @param pCreateInfos is an array of 'VkRayTracingPipelineCreateInfoNV' structures.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelines is an array in which the resulting ray tracing pipeline objects are returned.
   */
  export function vkCreateRayTracingPipelinesNV(device: VkDevice | null, pipelineCache: VkPipelineCache | null, createInfoCount: number, pCreateInfos: VkRayTracingPipelineCreateInfoNV[] | null, pAllocator: null, pPipelines: VkPipeline[] | null): VkResult;

  /**
   * Creates a new ray tracing pipeline object
   * @param device is the logical device that creates the ray tracing pipelines.
   * @param deferredOperation is an optional 'VkDeferredOperationKHR' to <<deferred-host-operations-requesting, request deferral>> for this command.
   * @param pipelineCache is either 'VK_NULL_HANDLE', indicating that pipeline caching is disabled, or the handle of a valid <<pipelines-cache,pipeline cache>> object, in which case use of that cache is enabled for the duration of the command.
   * @param createInfoCount
   * @param pCreateInfos is an array of 'VkRayTracingPipelineCreateInfoKHR' structures.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPipelines is an array in which the resulting ray tracing pipeline objects are returned.
   */
  export function vkCreateRayTracingPipelinesKHR(device: VkDevice | null, deferredOperation: VkDeferredOperationKHR | null, pipelineCache: VkPipelineCache | null, createInfoCount: number, pCreateInfos: VkRayTracingPipelineCreateInfoKHR[] | null, pAllocator: null, pPipelines: VkPipeline[] | null): VkResult;

  /**
   * Returns properties describing what cooperative matrix types are supported
   * @param physicalDevice is the physical device.
   * @param pPropertyCount is a reference to a number related to the number of cooperative matrix properties available or queried.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkCooperativeMatrixPropertiesNV' structures.
   */
  export function vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice: VkPhysicalDevice | null, pPropertyCount: VkInout | null, pProperties: VkCooperativeMatrixPropertiesNV[] | null): VkResult;

  /**
   * Initialize an indirect ray tracing dispatch
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pRaygenShaderBindingTable is a 'VkStridedDeviceAddressRegionKHR' that holds the shader binding table data for the ray generation shader stage.
   * @param pMissShaderBindingTable is a 'VkStridedDeviceAddressRegionKHR' that holds the shader binding table data for the miss shader stage.
   * @param pHitShaderBindingTable is a 'VkStridedDeviceAddressRegionKHR' that holds the shader binding table data for the hit shader stage.
   * @param pCallableShaderBindingTable is a 'VkStridedDeviceAddressRegionKHR' that holds the shader binding table data for the callable shader stage.
   * @param indirectDeviceAddress is a buffer device address which reference to a 'VkTraceRaysIndirectCommandKHR' structure which contains the trace ray parameters.
   */
  export function vkCmdTraceRaysIndirectKHR(commandBuffer: VkCommandBuffer | null, pRaygenShaderBindingTable: VkStridedDeviceAddressRegionKHR | null, pMissShaderBindingTable: VkStridedDeviceAddressRegionKHR | null, pHitShaderBindingTable: VkStridedDeviceAddressRegionKHR | null, pCallableShaderBindingTable: VkStridedDeviceAddressRegionKHR | null, indirectDeviceAddress: bigint | number): void;

  /**
   * Check if a serialized acceleration structure is compatible with the current device
   * @param device is the device to check the version against.
   * @param pVersionInfo reference to the 'VkAccelerationStructureVersionInfoKHR' version information to check against the device.
   * @param pCompatibility reference to the 'VkAccelerationStructureCompatibilityKHR' compatibility return value.
   */
  export function vkGetDeviceAccelerationStructureCompatibilityKHR(device: VkDevice | null, pVersionInfo: VkAccelerationStructureVersionInfoKHR | null, pCompatibility: VkInout | null): void;

  /**
   * Query ray tracing pipeline shader group shader stack size
   * @param device is the logical device containing the ray tracing pipeline.
   * @param pipeline is the ray tracing pipeline object containing the shaders groups.
   * @param group is the index of the shader group to query.
   * @param groupShader is the type of shader from the group to query.
   */
  export function vkGetRayTracingShaderGroupStackSizeKHR(device: VkDevice | null, pipeline: VkPipeline | null, group: number, groupShader: VkShaderGroupShaderKHR): bigint;

  /**
   * Set the dynamic stack size for a ray tracing pipeline
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pipelineStackSize is the stack size to use for subsequent ray tracing trace commands.
   */
  export function vkCmdSetRayTracingPipelineStackSizeKHR(commandBuffer: VkCommandBuffer | null, pipelineStackSize: number): void;

  /**
   * Get the handle for an image view for a specific descriptor type
   * @param device is the logical device that owns the image view.
   * @param pInfo describes the image view to query and type of handle.
   */
  export function vkGetImageViewHandleNVX(device: VkDevice | null, pInfo: VkImageViewHandleInfoNVX | null): number;

  /**
   * Get the device address of an image view
   * @param device is the logical device that owns the image view.
   * @param imageView is a handle to the image view.
   * @param pProperties contains the device address and size when the call returns.
   */
  export function vkGetImageViewAddressNVX(device: VkDevice | null, imageView: VkImageView | null, pProperties: VkImageViewAddressPropertiesNVX | null): VkResult;

  /**
   * Query supported presentation modes
   * @param physicalDevice is the physical device that will be associated with the swapchain to be created, as described for 'vkCreateSwapchainKHR'.
   * @param pSurfaceInfo is a reference to a 'VkPhysicalDeviceSurfaceInfo2KHR' structure describing the surface and other fixed parameters that would be consumed by 'vkCreateSwapchainKHR'.
   * @param pPresentModeCount is a reference to a number related to the number of presentation modes available or queried, as described below.
   * @param pPresentModes is either <i>null</i> or a reference to an array of 'VkPresentModeKHR' values, indicating the supported presentation modes.
   */
  export function vkGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice: VkPhysicalDevice | null, pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR | null, pPresentModeCount: VkInout | null, pPresentModes: Int32Array | null): VkResult;

  /**
   * Query device group present capabilities for a surface
   * @param device is the logical device.
   * @param pSurfaceInfo is a reference to a 'VkPhysicalDeviceSurfaceInfo2KHR' structure describing the surface and other fixed parameters that would be consumed by 'vkCreateSwapchainKHR'.
   * @param pModes is a reference to a 'VkDeviceGroupPresentModeFlagsKHR' in which the supported device group present modes for the surface are returned.
   */
  export function vkGetDeviceGroupSurfacePresentModes2EXT(device: VkDevice | null, pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR | null, pModes: VkInout | null): VkResult;

  /**
   * Acquire full-screen exclusive mode for a swapchain
   * @param device
   * @param swapchain is the swapchain to acquire exclusive full-screen access for.
   */
  export function vkAcquireFullScreenExclusiveModeEXT(device: VkDevice | null, swapchain: VkSwapchainKHR | null): VkResult;

  /**
   * Release full-screen exclusive mode from a swapchain
   * @param device
   * @param swapchain is the swapchain to release exclusive full-screen access from.
   */
  export function vkReleaseFullScreenExclusiveModeEXT(device: VkDevice | null, swapchain: VkSwapchainKHR | null): VkResult;

  /**
   * Reports properties of the performance query counters available on a queue family of a device
   * @param physicalDevice is the handle to the physical device whose queue family performance query counter properties will be queried.
   * @param queueFamilyIndex is the index into the queue family of the physical device we want to get properties for.
   * @param pCounterCount is a reference to a number related to the number of counters available or queried, as described below.
   * @param pCounters is either <i>null</i> or a reference to an array of 'VkPerformanceCounterKHR' structures.
   * @param pCounterDescriptions is either <i>null</i> or a reference to an array of 'VkPerformanceCounterDescriptionKHR' structures.
   */
  export function vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice: VkPhysicalDevice | null, queueFamilyIndex: number, pCounterCount: VkInout | null, pCounters: VkPerformanceCounterKHR[] | null, pCounterDescriptions: VkPerformanceCounterDescriptionKHR[] | null): VkResult;

  /**
   * Reports the number of passes require for a performance query pool type
   * @param physicalDevice is the handle to the physical device whose queue family performance query counter properties will be queried.
   * @param pPerformanceQueryCreateInfo is a reference to a 'VkQueryPoolPerformanceCreateInfoKHR' of the performance query that is to be created.
   * @param pNumPasses is a reference to a number related to the number of passes required to query the performance query pool, as described below.
   */
  export function vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice: VkPhysicalDevice | null, pPerformanceQueryCreateInfo: VkQueryPoolPerformanceCreateInfoKHR | null, pNumPasses: VkInout | null): void;

  /**
   * Acquires the profiling lock
   * @param device is the logical device to profile.
   * @param pInfo is a reference to a 'VkAcquireProfilingLockInfoKHR' structure which contains information about how the profiling is to be acquired.
   */
  export function vkAcquireProfilingLockKHR(device: VkDevice | null, pInfo: VkAcquireProfilingLockInfoKHR | null): VkResult;

  /**
   * Releases the profiling lock
   * @param device is the logical device to cease profiling on.
   */
  export function vkReleaseProfilingLockKHR(device: VkDevice | null): void;

  /**
   * Returns an image\
   * @param device is the logical device that owns the image.
   * @param image is the queried image.
   * @param pProperties will return properties of the image's _DRM format modifier_.
   */
  export function vkGetImageDrmFormatModifierPropertiesEXT(device: VkDevice | null, image: VkImage | null, pProperties: VkImageDrmFormatModifierPropertiesEXT | null): VkResult;

  /**
   * Query an opaque capture address of a buffer
   * @param device is the logical device that the buffer was created on.
   * @param pInfo is a reference to a 'VkBufferDeviceAddressInfo' structure specifying the buffer to retrieve an address for.
   */
  export function vkGetBufferOpaqueCaptureAddress(device: VkDevice | null, pInfo: VkBufferDeviceAddressInfo | null): bigint;

  /**
   * Query an address of a buffer
   * @param device is the logical device that the buffer was created on.
   * @param pInfo is a reference to a 'VkBufferDeviceAddressInfo' structure specifying the buffer to retrieve an address for.
   */
  export function vkGetBufferDeviceAddress(device: VkDevice | null, pInfo: VkBufferDeviceAddressInfo | null): bigint;

  /**
   * Create a headless {#0#} object
   * @param instance is the instance to associate the surface with.
   * @param pCreateInfo is a reference to a 'VkHeadlessSurfaceCreateInfoEXT' structure containing parameters affecting the creation of the surface object.
   * @param pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see <<memory-allocation,Memory Allocation>>).
   * @param pSurface is a reference to a 'VkSurfaceKHR' handle in which the created surface object is returned.
   */
  export function vkCreateHeadlessSurfaceEXT(instance: VkInstance | null, pCreateInfo: VkHeadlessSurfaceCreateInfoEXT | null, pAllocator: null, pSurface: VkSurfaceKHR | null): VkResult;

  /**
   * Query supported sample count combinations
   * @param physicalDevice is the physical device from which to query the set of combinations.
   * @param pCombinationCount is a reference to a number related to the number of combinations available or queried, as described below.
   * @param pCombinations is either <i>null</i> or a reference to an array of 'VkFramebufferMixedSamplesCombinationNV' values, indicating the supported combinations of coverage reduction mode, rasterization samples, and color, depth, stencil attachment sample counts.
   */
  export function vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice: VkPhysicalDevice | null, pCombinationCount: VkInout | null, pCombinations: VkFramebufferMixedSamplesCombinationNV[] | null): VkResult;

  /**
   * Initialize a device for performance queries
   * @param device is the logical device used for the queries.
   * @param pInitializeInfo is a reference to a 'VkInitializePerformanceApiInfoINTEL' structure specifying initialization parameters.
   */
  export function vkInitializePerformanceApiINTEL(device: VkDevice | null, pInitializeInfo: VkInitializePerformanceApiInfoINTEL | null): VkResult;

  /**
   * Uninitialize a device for performance queries
   * @param device is the logical device used for the queries.
   */
  export function vkUninitializePerformanceApiINTEL(device: VkDevice | null): void;

  /**
   * Markers
   * @param commandBuffer
   * @param pMarkerInfo
   */
  export function vkCmdSetPerformanceMarkerINTEL(commandBuffer: VkCommandBuffer | null, pMarkerInfo: VkPerformanceMarkerInfoINTEL | null): VkResult;

  /**
   * Markers
   * @param commandBuffer
   * @param pMarkerInfo
   */
  export function vkCmdSetPerformanceStreamMarkerINTEL(commandBuffer: VkCommandBuffer | null, pMarkerInfo: VkPerformanceStreamMarkerInfoINTEL | null): VkResult;

  /**
   * Performance override settings
   * @param commandBuffer is the command buffer where the override takes place.
   * @param pOverrideInfo is a reference to a 'VkPerformanceOverrideInfoINTEL' structure selecting the parameter to override.
   */
  export function vkCmdSetPerformanceOverrideINTEL(commandBuffer: VkCommandBuffer | null, pOverrideInfo: VkPerformanceOverrideInfoINTEL | null): VkResult;

  /**
   * Acquire the performance query capability
   * @param device is the logical device that the performance query commands will be submitted to.
   * @param pAcquireInfo is a reference to a 'VkPerformanceConfigurationAcquireInfoINTEL' structure, specifying the performance configuration to acquire.
   * @param pConfiguration is a reference to a 'VkPerformanceConfigurationINTEL' handle in which the resulting configuration object is returned.
   */
  export function vkAcquirePerformanceConfigurationINTEL(device: VkDevice | null, pAcquireInfo: VkPerformanceConfigurationAcquireInfoINTEL | null, pConfiguration: VkPerformanceConfigurationINTEL | null): VkResult;

  /**
   * Release a configuration to capture performance data
   * @param device is the device associated to the configuration object to release.
   * @param configuration is the configuration object to release.
   */
  export function vkReleasePerformanceConfigurationINTEL(device: VkDevice | null, configuration: VkPerformanceConfigurationINTEL | null): VkResult;

  /**
   * Set a performance query
   * @param queue is the queue on which the configuration will be used.
   * @param configuration is the configuration to use.
   */
  export function vkQueueSetPerformanceConfigurationINTEL(queue: VkQueue | null, configuration: VkPerformanceConfigurationINTEL | null): VkResult;

  /**
   * Query performance capabilities of the device
   * @param device is the logical device to query.
   * @param parameter is the parameter to query.
   * @param pValue is a reference to a 'VkPerformanceValueINTEL' structure in which the type and value of the parameter are returned.
   */
  export function vkGetPerformanceParameterINTEL(device: VkDevice | null, parameter: VkPerformanceParameterTypeINTEL, pValue: VkPerformanceValueINTEL | null): VkResult;

  /**
   * Query an opaque capture address of a memory object
   * @param device is the logical device that the memory object was allocated on.
   * @param pInfo is a reference to a 'VkDeviceMemoryOpaqueCaptureAddressInfo' structure specifying the memory object to retrieve an address for.
   */
  export function vkGetDeviceMemoryOpaqueCaptureAddress(device: VkDevice | null, pInfo: VkDeviceMemoryOpaqueCaptureAddressInfo | null): bigint;

  /**
   * Get the executables associated with a pipeline
   * @param device is the device that created the pipeline.
   * @param pPipelineInfo describes the pipeline being queried.
   * @param pExecutableCount is a reference to a number related to the number of pipeline executables available or queried, as described below.
   * @param pProperties is either <i>null</i> or a reference to an array of 'VkPipelineExecutablePropertiesKHR' structures.
   */
  export function vkGetPipelineExecutablePropertiesKHR(device: VkDevice | null, pPipelineInfo: VkPipelineInfoKHR | null, pExecutableCount: VkInout | null, pProperties: VkPipelineExecutablePropertiesKHR[] | null): VkResult;

  /**
   * Get compile time statistics associated with a pipeline executable
   * @param device is the device that created the pipeline.
   * @param pExecutableInfo describes the pipeline executable being queried.
   * @param pStatisticCount is a reference to a number related to the number of statistics available or queried, as described below.
   * @param pStatistics is either <i>null</i> or a reference to an array of 'VkPipelineExecutableStatisticKHR' structures.
   */
  export function vkGetPipelineExecutableStatisticsKHR(device: VkDevice | null, pExecutableInfo: VkPipelineExecutableInfoKHR | null, pStatisticCount: VkInout | null, pStatistics: VkPipelineExecutableStatisticKHR[] | null): VkResult;

  /**
   * Get internal representations of the pipeline executable
   * @param device is the device that created the pipeline.
   * @param pExecutableInfo describes the pipeline executable being queried.
   * @param pInternalRepresentationCount is a reference to a number related to the number of internal representations available or queried, as described below.
   * @param pInternalRepresentations is either <i>null</i> or a reference to an array of 'VkPipelineExecutableInternalRepresentationKHR' structures.
   */
  export function vkGetPipelineExecutableInternalRepresentationsKHR(device: VkDevice | null, pExecutableInfo: VkPipelineExecutableInfoKHR | null, pInternalRepresentationCount: VkInout | null, pInternalRepresentations: VkPipelineExecutableInternalRepresentationKHR[] | null): VkResult;

  /**
   * Set the dynamic line width state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param lineStippleFactor is the repeat factor used in stippled line rasterization.
   * @param lineStipplePattern is the bit pattern used in stippled line rasterization.
   */
  export function vkCmdSetLineStippleEXT(commandBuffer: VkCommandBuffer | null, lineStippleFactor: number, lineStipplePattern: number): void;

  /**
   * Reports properties of tools active on the specified physical device
   * @param physicalDevice is the handle to the physical device to query for active tools.
   * @param pToolCount is a reference to a number describing the number of tools active on 'physicalDevice'.
   * @param pToolProperties is either <i>null</i> or a reference to an array of 'VkPhysicalDeviceToolPropertiesEXT' structures.
   */
  export function vkGetPhysicalDeviceToolPropertiesEXT(physicalDevice: VkPhysicalDevice | null, pToolCount: VkInout | null, pToolProperties: VkPhysicalDeviceToolPropertiesEXT[] | null): VkResult;

  /**
   * Create a new acceleration structure object
   * @param device is the logical device that creates the acceleration structure object.
   * @param pCreateInfo is a reference to a 'VkAccelerationStructureCreateInfoKHR' structure containing parameters affecting creation of the acceleration structure.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pAccelerationStructure is a reference to a 'VkAccelerationStructureKHR' handle in which the resulting acceleration structure object is returned.
   */
  export function vkCreateAccelerationStructureKHR(device: VkDevice | null, pCreateInfo: VkAccelerationStructureCreateInfoKHR | null, pAllocator: null, pAccelerationStructure: VkAccelerationStructureKHR | null): VkResult;

  /**
   * Build an acceleration structure
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param infoCount references to arrays of 'VkAccelerationStructureBuildRangeInfoKHR' structures. Each 'ppBuildRangeInfos'[i] is an array of 'pInfos'[i].'geometryCount' 'VkAccelerationStructureBuildRangeInfoKHR' structures defining dynamic offsets to the addresses where geometry data is stored, as defined by 'pInfos'[i].
   * @param pInfos
   * @param ppBuildRangeInfos
   */
  export function vkCmdBuildAccelerationStructuresKHR(commandBuffer: VkCommandBuffer | null, infoCount: number, pInfos: VkAccelerationStructureBuildGeometryInfoKHR[] | null, ppBuildRangeInfos: VkAccelerationStructureBuildRangeInfoKHR[] | null): void;

  /**
   * Build an acceleration structure with some parameters provided on the device
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param infoCount arrays of 'pInfo'[i]->'geometryCount' values indicating the maximum number of primitives that will be built by this command for each geometry.
   * @param pInfos
   * @param pIndirectDeviceAddresses
   * @param pIndirectStrides
   * @param ppMaxPrimitiveCounts
   */
  export function vkCmdBuildAccelerationStructuresIndirectKHR(commandBuffer: VkCommandBuffer | null, infoCount: number, pInfos: VkAccelerationStructureBuildGeometryInfoKHR[] | null, pIndirectDeviceAddresses: BigUint64Array | null, pIndirectStrides: Uint32Array | null, ppMaxPrimitiveCounts: bigint | number): void;

  /**
   * Build an acceleration structure on the host
   * @param device is the 'VkDevice' for which the acceleration structures are being built.
   * @param deferredOperation is an optional 'VkDeferredOperationKHR' to <<deferred-host-operations-requesting, request deferral>> for this command.
   * @param infoCount references to arrays of 'VkAccelerationStructureBuildRangeInfoKHR' structures. Each 'ppBuildRangeInfos'[i] is an array of 'pInfos'[i].'geometryCount' 'VkAccelerationStructureBuildRangeInfoKHR' structures defining dynamic offsets to the addresses where geometry data is stored, as defined by 'pInfos'[i].
   * @param pInfos
   * @param ppBuildRangeInfos
   */
  export function vkBuildAccelerationStructuresKHR(device: VkDevice | null, deferredOperation: VkDeferredOperationKHR | null, infoCount: number, pInfos: VkAccelerationStructureBuildGeometryInfoKHR[] | null, ppBuildRangeInfos: VkAccelerationStructureBuildRangeInfoKHR[] | null): VkResult;

  /**
   * Query an address of a acceleration structure
   * @param device is the logical device that the accelerationStructure was created on.
   * @param pInfo is a reference to a 'VkAccelerationStructureDeviceAddressInfoKHR' structure specifying the acceleration structure to retrieve an address for.
   */
  export function vkGetAccelerationStructureDeviceAddressKHR(device: VkDevice | null, pInfo: VkAccelerationStructureDeviceAddressInfoKHR | null): bigint;

  /**
   * Create a deferred operation handle
   * @param device
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation,Memory Allocation>> chapter.
   * @param pDeferredOperation is a reference to a handle in which the created 'VkDeferredOperationKHR' is returned.
   */
  export function vkCreateDeferredOperationKHR(device: VkDevice | null, pAllocator: null, pDeferredOperation: VkDeferredOperationKHR | null): VkResult;

  /**
   * Destroy a deferred operation handle
   * @param device
   * @param operation is the completed operation to be destroyed.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation,Memory Allocation>> chapter.
   */
  export function vkDestroyDeferredOperationKHR(device: VkDevice | null, operation: VkDeferredOperationKHR | null, pAllocator: null): void;

  /**
   * Query the maximum concurrency on a deferred operation
   * @param device
   * @param operation is the deferred operation to be queried.
   */
  export function vkGetDeferredOperationMaxConcurrencyKHR(device: VkDevice | null, operation: VkDeferredOperationKHR | null): number;

  /**
   * Query the result of a deferred operation
   * @param device
   * @param operation is the operation whose deferred result is being queried.
   */
  export function vkGetDeferredOperationResultKHR(device: VkDevice | null, operation: VkDeferredOperationKHR | null): VkResult;

  /**
   * Assign a thread to a deferred operation
   * @param device
   * @param operation is the deferred operation that the calling thread should work on.
   */
  export function vkDeferredOperationJoinKHR(device: VkDevice | null, operation: VkDeferredOperationKHR | null): VkResult;

  /**
   * Set the cull mode property
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param cullMode specifies the cull mode property to use for drawing.
   */
  export function vkCmdSetCullModeEXT(commandBuffer: VkCommandBuffer | null, cullMode: VkCullModeFlagBits): void;

  /**
   * Set the front face property
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param frontFace specifies the front face property to use for drawing.
   */
  export function vkCmdSetFrontFaceEXT(commandBuffer: VkCommandBuffer | null, frontFace: VkFrontFace): void;

  /**
   * Set the primitive topology state
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param primitiveTopology
   */
  export function vkCmdSetPrimitiveTopologyEXT(commandBuffer: VkCommandBuffer | null, primitiveTopology: VkPrimitiveTopology): void;

  /**
   * Set the viewport count and viewports
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param viewportCount specifies the viewport count.
   * @param pViewports specifies the viewports to use for drawing.
   */
  export function vkCmdSetViewportWithCountEXT(commandBuffer: VkCommandBuffer | null, viewportCount: number, pViewports: VkViewport[] | null): void;

  /**
   * Set the scissor count and scissors
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param scissorCount specifies the scissor count.
   * @param pScissors specifies the scissors to use for drawing.
   */
  export function vkCmdSetScissorWithCountEXT(commandBuffer: VkCommandBuffer | null, scissorCount: number, pScissors: VkRect2D[] | null): void;

  /**
   * Bind vertex buffers to a command buffer
   * @param commandBuffer is the command buffer into which the command is recorded.
   * @param firstBinding is the index of the first vertex input binding whose state is updated by the command.
   * @param bindingCount is the number of vertex input bindings whose state is updated by the command.
   * @param pBuffers is an array of buffer handles.
   * @param pOffsets is an array of buffer offsets.
   * @param pSizes is an optional array of the size in bytes of vertex data bound from 'pBuffers'.
   * @param pStrides is optional, and when not <i>null</i> is an array of buffer strides.
   */
  export function vkCmdBindVertexBuffers2EXT(commandBuffer: VkCommandBuffer | null, firstBinding: number, bindingCount: number, pBuffers: VkBuffer[] | null, pOffsets: BigUint64Array | null, pSizes: BigUint64Array | null, pStrides: BigUint64Array | null): void;

  /**
   * Set the depth test enable for a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param depthTestEnable specifies if the depth test is enabled.
   */
  export function vkCmdSetDepthTestEnableEXT(commandBuffer: VkCommandBuffer | null, depthTestEnable: boolean): void;

  /**
   * Set the depth write enable for the command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param depthWriteEnable specifies if depth writes are enabled.
   */
  export function vkCmdSetDepthWriteEnableEXT(commandBuffer: VkCommandBuffer | null, depthWriteEnable: boolean): void;

  /**
   * Set the depth comparison operator for the command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param depthCompareOp specifies the depth comparison operator.
   */
  export function vkCmdSetDepthCompareOpEXT(commandBuffer: VkCommandBuffer | null, depthCompareOp: VkCompareOp): void;

  /**
   * Set the depth bounds test enable for a command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param depthBoundsTestEnable specifies if the depth bounds test is enabled.
   */
  export function vkCmdSetDepthBoundsTestEnableEXT(commandBuffer: VkCommandBuffer | null, depthBoundsTestEnable: boolean): void;

  /**
   * Set the stencil test enable for the command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param stencilTestEnable specifies if the stencil test is enabled.
   */
  export function vkCmdSetStencilTestEnableEXT(commandBuffer: VkCommandBuffer | null, stencilTestEnable: boolean): void;

  /**
   * Set the stencil operation for the command buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param faceMask is a bitmask of VkStencilFaceFlagBits specifying the set of stencil state for which to update the stencil operation.
   * @param failOp is a 'VkStencilOp' value specifying the action performed on samples that fail the stencil test.
   * @param passOp is a 'VkStencilOp' value specifying the action performed on samples that pass both the depth and stencil tests.
   * @param depthFailOp is a 'VkStencilOp' value specifying the action performed on samples that pass the stencil test and fail the depth test.
   * @param compareOp is a 'VkCompareOp' value specifying the comparison operator used in the stencil test.
   */
  export function vkCmdSetStencilOpEXT(commandBuffer: VkCommandBuffer | null, faceMask: VkStencilFaceFlagBits, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp): void;

  /**
   * Create a slot for private data storage
   * @param device is the logical device associated with the creation of the object(s) holding the private data slot.
   * @param pCreateInfo is a reference to a 'VkPrivateDataSlotCreateInfoEXT'
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   * @param pPrivateDataSlot is a reference to a 'VkPrivateDataSlotEXT' handle in which the resulting private data slot is returned
   */
  export function vkCreatePrivateDataSlotEXT(device: VkDevice | null, pCreateInfo: VkPrivateDataSlotCreateInfoEXT | null, pAllocator: null, pPrivateDataSlot: VkPrivateDataSlotEXT | null): VkResult;

  /**
   * Destroy a private data slot
   * @param device is the logical device associated with the creation of the object(s) holding the private data slot.
   * @param privateDataSlot is the private data slot to destroy.
   * @param pAllocator controls host memory allocation as described in the <<memory-allocation, Memory Allocation>> chapter.
   */
  export function vkDestroyPrivateDataSlotEXT(device: VkDevice | null, privateDataSlot: VkPrivateDataSlotEXT | null, pAllocator: null): void;

  /**
   * Associate data with a Vulkan object
   * @param device is the device that created the object.
   * @param objectType is a 'VkObjectType' specifying the type of object to associate data with.
   * @param objectHandle is a handle to the object to associate data with.
   * @param privateDataSlot is a handle to a 'VkPrivateDataSlotEXT' specifying location of private data storage.
   * @param data is user defined data to associate the object with. This data will be stored at 'privateDataSlot'.
   */
  export function vkSetPrivateDataEXT(device: VkDevice | null, objectType: VkObjectType, objectHandle: bigint | number, privateDataSlot: VkPrivateDataSlotEXT | null, data: bigint | number): VkResult;

  /**
   * Retrieve data associated with a Vulkan object
   * @param device is the device that created the object
   * @param objectType is a 'VkObjectType' specifying the type of object data is associated with.
   * @param objectHandle is a handle to the object data is associated with.
   * @param privateDataSlot is a handle to a 'VkPrivateDataSlotEXT' specifying location of private data reference storage.
   * @param pData is a reference to specify where user data is returned. `0` will be written in the absence of a previous call to 'vkSetPrivateDataEXT' using the object specified by 'objectHandle'.
   */
  export function vkGetPrivateDataEXT(device: VkDevice | null, objectType: VkObjectType, objectHandle: bigint | number, privateDataSlot: VkPrivateDataSlotEXT | null, pData: VkInoutAddress | null): void;

  /**
   * Copy data between buffer regions
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pCopyBufferInfo is a reference to a 'VkCopyBufferInfo2KHR' structure describing the copy parameters.
   */
  export function vkCmdCopyBuffer2KHR(commandBuffer: VkCommandBuffer | null, pCopyBufferInfo: VkCopyBufferInfo2KHR | null): void;

  /**
   * Copy data between images
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pCopyImageInfo is a reference to a 'VkCopyImageInfo2KHR' structure describing the copy parameters.
   */
  export function vkCmdCopyImage2KHR(commandBuffer: VkCommandBuffer | null, pCopyImageInfo: VkCopyImageInfo2KHR | null): void;

  /**
   * Copy regions of an image, potentially performing format conversion,
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pBlitImageInfo is a reference to a 'VkBlitImageInfo2KHR' structure describing the blit parameters.
   */
  export function vkCmdBlitImage2KHR(commandBuffer: VkCommandBuffer | null, pBlitImageInfo: VkBlitImageInfo2KHR | null): void;

  /**
   * Copy data from a buffer into an image
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pCopyBufferToImageInfo is a reference to a 'VkCopyBufferToImageInfo2KHR' structure describing the copy parameters.
   */
  export function vkCmdCopyBufferToImage2KHR(commandBuffer: VkCommandBuffer | null, pCopyBufferToImageInfo: VkCopyBufferToImageInfo2KHR | null): void;

  /**
   * Copy image data into a buffer
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pCopyImageToBufferInfo is a reference to a 'vkCmdCopyImageToBuffer2KHR' structure describing the copy parameters.
   */
  export function vkCmdCopyImageToBuffer2KHR(commandBuffer: VkCommandBuffer | null, pCopyImageToBufferInfo: VkCopyImageToBufferInfo2KHR | null): void;

  /**
   * Resolve regions of an image
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pResolveImageInfo is a reference to a 'VkResolveImageInfo2KHR' structure describing the resolve parameters.
   */
  export function vkCmdResolveImage2KHR(commandBuffer: VkCommandBuffer | null, pResolveImageInfo: VkResolveImageInfo2KHR | null): void;

  /**
   * Set pipeline fragment shading rate dynamically
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param pFragmentSize specifies the pipeline fragment shading rate for subsequent draw commands.
   * @param combinerOps specifies a 'VkFragmentShadingRateCombinerOpKHR' determining how the <<primsrast-fragment-shading-rate-pipeline,pipeline>>, <<primsrast-fragment-shading-rate-primitive,primitive>>, and <<primsrast-fragment-shading-rate-attachment,attachment shading rates>> are <<primsrast-fragment-shading-rate-combining,combined>> for fragments generated by subsequent drawing commands.
   */
  export function vkCmdSetFragmentShadingRateKHR(commandBuffer: VkCommandBuffer | null, pFragmentSize: VkExtent2D | null, combinerOps: number[] | null): void;

  /**
   * Get available shading rates for a physical device
   * @param physicalDevice is the handle to the physical device whose properties will be queried.
   * @param pFragmentShadingRateCount is a reference to a number related to the number of fragment shading rates available or queried, as described below.
   * @param pFragmentShadingRates is either <i>null</i> or a reference to an array of 'VkPhysicalDeviceFragmentShadingRateKHR' structures.
   */
  export function vkGetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice: VkPhysicalDevice | null, pFragmentShadingRateCount: VkInout | null, pFragmentShadingRates: VkPhysicalDeviceFragmentShadingRateKHR[] | null): VkResult;

  /**
   * Set pipeline fragment shading rate dynamically using enums
   * @param commandBuffer is the command buffer into which the command will be recorded.
   * @param shadingRate specifies a 'VkFragmentShadingRateNV' enum indicating the pipeline fragment shading rate for subsequent draw commands.
   * @param combinerOps specifies a 'VkFragmentShadingRateCombinerOpKHR' determining how the <<primsrast-fragment-shading-rate-pipeline,pipeline>>, <<primsrast-fragment-shading-rate-primitive,primitive>>, and <<primsrast-fragment-shading-rate-attachment,attachment shading rates>> are <<primsrast-fragment-shading-rate-combining,combined>> for fragments generated by subsequent drawing commands.
   */
  export function vkCmdSetFragmentShadingRateEnumNV(commandBuffer: VkCommandBuffer | null, shadingRate: VkFragmentShadingRateNV, combinerOps: number[] | null): void;

  /**
   * Retrieve the required size for an acceleration structure
   * @param device is the logical device that will be used for creating the acceleration structure.
   * @param buildType defines whether host or device operations (or both) are being queried for.
   * @param pBuildInfo is a reference to a 'VkAccelerationStructureBuildGeometryInfoKHR' structure describing parameters of a build operation.
   * @param pMaxPrimitiveCounts is an array of 'pBuildInfo'->geometryCount 'uint32_t' values defining the number of primitives built into each geometry.
   * @param pSizeInfo is a reference to a 'VkAccelerationStructureBuildSizesInfoKHR' structure which returns the size required for an acceleration structure and the sizes required for the scratch buffers, given the build parameters.
   */
  export function vkGetAccelerationStructureBuildSizesKHR(device: VkDevice | null, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: VkAccelerationStructureBuildGeometryInfoKHR | null, pMaxPrimitiveCounts: Uint32Array | null, pSizeInfo: VkAccelerationStructureBuildSizesInfoKHR | null): void;



  /**
   * 
   * @param pUserData
   * @param size
   * @param allocationType
   * @param allocationScope
   */
  export interface vkInternalAllocationNotification {
    (
      pUserData: null,
      size: bigint | number,
      allocationType: VkInternalAllocationType,
      allocationScope: VkSystemAllocationScope
    ) : void
  }

  /**
   * 
   * @param pUserData
   * @param size
   * @param allocationType
   * @param allocationScope
   */
  export interface vkInternalFreeNotification {
    (
      pUserData: null,
      size: bigint | number,
      allocationType: VkInternalAllocationType,
      allocationScope: VkSystemAllocationScope
    ) : void
  }

  /**
   * 
   * @param pUserData
   * @param pOriginal
   * @param size
   * @param alignment
   * @param allocationScope
   */
  export interface vkReallocationFunction {
    (
      pUserData: null,
      pOriginal: ArrayBuffer | null,
      size: bigint | number,
      alignment: bigint | number,
      allocationScope: VkSystemAllocationScope
    ) : void
  }

  /**
   * 
   * @param pUserData
   * @param size
   * @param alignment
   * @param allocationScope
   */
  export interface vkAllocationFunction {
    (
      pUserData: null,
      size: bigint | number,
      alignment: bigint | number,
      allocationScope: VkSystemAllocationScope
    ) : void
  }

  /**
   * 
   * @param pUserData
   * @param pMemory
   */
  export interface vkFreeFunction {
    (
      pUserData: null,
      pMemory: ArrayBuffer | null
    ) : void
  }

  /**
   * 
   * @param flags
   * @param objectType
   * @param object
   * @param location
   * @param messageCode
   * @param pLayerPrefix
   * @param pMessage
   * @param pUserData
   */
  export interface vkDebugReportCallbackEXT {
    (
      flags: VkDebugReportFlagBitsEXT,
      objectType: VkDebugReportObjectTypeEXT,
      object: bigint | number,
      location: bigint | number,
      messageCode: number,
      pLayerPrefix: string | null,
      pMessage: string | null,
      pUserData: null
    ) : boolean
  }

  /**
   * 
   * @param messageSeverity
   * @param messageTypes
   * @param pCallbackData
   * @param pUserData
   */
  export interface vkDebugUtilsMessengerCallbackEXT {
    (
      messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
      messageTypes: VkDebugUtilsMessageTypeFlagBitsEXT,
      pCallbackData: VkDebugUtilsMessengerCallbackDataEXT | null,
      pUserData: null
    ) : boolean
  }

  /**
   * 
   * @param pCallbackData
   * @param pUserData
   */
  export interface vkDeviceMemoryReportCallbackEXT {
    (
      pCallbackData: VkDeviceMemoryReportCallbackDataEXT | null,
      pUserData: null
    ) : void
  }


export function createV8ArrayBufferFromMemory(
  addr: bigint,
  size: number
): ArrayBuffer;

export function VK_MAKE_VERSION(
  major: number,
  minor: number,
  patch: number
): number;

export function VK_VERSION_MAJOR(
  major: number
): number;

export function VK_VERSION_MINOR(
  minor: number
): number;

export function VK_VERSION_PATCH(
  patch: number
): number;

export function vkUseDevice(
  pDevice: VkDevice
): void;

export function vkUseInstance(
  pInstance: VkInstance
): void;

export var VK_API_VERSION_1_0: number;

export interface ResizeEvent {
  width: number;
  height: number;
}
export interface FocusEvent {
  focused: boolean;
}
export interface CloseEvent {

}
export interface KeydownEvent {
  keyCode: number;
}
export interface KeyupEvent {
  keyCode: number;
}
export interface MousemoveEvent {
  x: number;
  y: number;
  movementX: number;
  movementY: number;
}
export interface MousewheelEvent {
  x: number;
  y: number;
  deltaX: number;
  deltaY: number;
}
export interface MousedownEvent {
  x: number;
  y: number;
  button: number;
}
export interface MouseupEvent {
  x: number;
  y: number;
  button: number;
}
export interface DropEvent {
  paths: string[];
}

export interface VulkanWindowInitializer {
  width: number;
  height: number;
  title?: string;
  resizable?: boolean;
}

declare var VulkanWindow: {
  prototype: VulkanWindow;
  new(param: VulkanWindowInitializer): VulkanWindow;
  width: number;
  height: number;
  frameBufferWidth: number;
  frameBufferHeight: number;
  title: string;
  pollEvents(): void;
  focus(): void;
  close(): void;
  shouldClose(): boolean;
  createSurface(instance: VkInstance | null, pAllocator: null, surface: VkSurfaceKHR | null): number;
  getRequiredInstanceExtensions(): string[];
  onresize: ((ev: ResizeEvent) => any) | null;
  onfocus: ((ev: FocusEvent) => any) | null;
  onclose: ((ev: CloseEvent) => any) | null;
  onkeydown: ((ev: KeydownEvent) => any) | null;
  onkeyup: ((ev: KeyupEvent) => any) | null;
  onmousemove: ((ev: MousemoveEvent) => any) | null;
  onmousewheel: ((ev: MousewheelEvent) => any) | null;
  onmousedown: ((ev: MousedownEvent) => any) | null;
  onmouseup: ((ev: MouseupEvent) => any) | null;
  ondrop: ((ev: DropEvent) => any) | null;
}

export interface VulkanWindow {
  width: number;
  height: number;
  frameBufferWidth: number;
  frameBufferHeight: number;
  title: string;
  pollEvents(): void;
  focus(): void;
  close(): void;
  shouldClose(): boolean;
  createSurface(instance: VkInstance | null, pAllocator: null, surface: VkSurfaceKHR | null): number;
  getRequiredInstanceExtensions(): string[];
  onresize: ((ev: ResizeEvent) => any) | null;
  onfocus: ((ev: FocusEvent) => any) | null;
  onclose: ((ev: CloseEvent) => any) | null;
  onkeydown: ((ev: KeydownEvent) => any) | null;
  onkeyup: ((ev: KeyupEvent) => any) | null;
  onmousemove: ((ev: MousemoveEvent) => any) | null;
  onmousewheel: ((ev: MousewheelEvent) => any) | null;
  onmousedown: ((ev: MousedownEvent) => any) | null;
  onmouseup: ((ev: MouseupEvent) => any) | null;
  ondrop: ((ev: DropEvent) => any) | null;
}